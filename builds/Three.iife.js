// Made by Itee (https://github.com/Itee) with ES6 Convertor script


var Three = (function (exports) {
  'use strict';

  // Polyfills

  if ( Number.EPSILON === undefined ) {

  	Number.EPSILON = Math.pow( 2, - 52 );

  }

  if ( Number.isInteger === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

  	Number.isInteger = function ( value ) {

  		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

  	};

  }

  //

  if ( Math.sign === undefined ) {

  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  	Math.sign = function ( x ) {

  		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  	};

  }

  if ( 'name' in Function.prototype === false ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  	Object.defineProperty( Function.prototype, 'name', {

  		get: function () {

  			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

  		}

  	} );

  }

  if ( Object.assign === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

  	( function () {

  		Object.assign = function ( target ) {
  			var arguments$1 = arguments;


  			if ( target === undefined || target === null ) {

  				throw new TypeError( 'Cannot convert undefined or null to object' );

  			}

  			var output = Object( target );

  			for ( var index = 1; index < arguments.length; index ++ ) {

  				var source = arguments$1[ index ];

  				if ( source !== undefined && source !== null ) {

  					for ( var nextKey in source ) {

  						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

  							output[ nextKey ] = source[ nextKey ];

  						}

  					}

  				}

  			}

  			return output;

  		};

  	} )();

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var _Math = {

  	DEG2RAD: Math.PI / 180,
  	RAD2DEG: 180 / Math.PI,

  	generateUUID: ( function () {

  		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

  		var lut = [];

  		for ( var i = 0; i < 256; i ++ ) {

  			lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

  		}

  		return function generateUUID() {

  			var d0 = Math.random() * 0xffffffff | 0;
  			var d1 = Math.random() * 0xffffffff | 0;
  			var d2 = Math.random() * 0xffffffff | 0;
  			var d3 = Math.random() * 0xffffffff | 0;
  			var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
  				lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
  				lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
  				lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

  			// .toUpperCase() here flattens concatenated strings to save heap memory space.
  			return uuid.toUpperCase();

  		};

  	} )(),

  	clamp: function ( value, min, max ) {

  		return Math.max( min, Math.min( max, value ) );

  	},

  	// compute euclidian modulo of m % n
  	// https://en.wikipedia.org/wiki/Modulo_operation

  	euclideanModulo: function ( n, m ) {

  		return ( ( n % m ) + m ) % m;

  	},

  	// Linear mapping from range <a1, a2> to range <b1, b2>

  	mapLinear: function ( x, a1, a2, b1, b2 ) {

  		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  	},

  	// https://en.wikipedia.org/wiki/Linear_interpolation

  	lerp: function ( x, y, t ) {

  		return ( 1 - t ) * x + t * y;

  	},

  	// http://en.wikipedia.org/wiki/Smoothstep

  	smoothstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * ( 3 - 2 * x );

  	},

  	smootherstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  	},

  	// Random integer from <low, high> interval

  	randInt: function ( low, high ) {

  		return low + Math.floor( Math.random() * ( high - low + 1 ) );

  	},

  	// Random float from <low, high> interval

  	randFloat: function ( low, high ) {

  		return low + Math.random() * ( high - low );

  	},

  	// Random float from <-range/2, range/2> interval

  	randFloatSpread: function ( range ) {

  		return range * ( 0.5 - Math.random() );

  	},

  	degToRad: function ( degrees ) {

  		return degrees * _Math.DEG2RAD;

  	},

  	radToDeg: function ( radians ) {

  		return radians * _Math.RAD2DEG;

  	},

  	isPowerOfTwo: function ( value ) {

  		return ( value & ( value - 1 ) ) === 0 && value !== 0;

  	},

  	ceilPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  	},

  	floorPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Matrix4() {

  	this.elements = [

  		1, 0, 0, 0,
  		0, 1, 0, 0,
  		0, 0, 1, 0,
  		0, 0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix4.prototype, {

  	isMatrix4: true,

  	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new Matrix4().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	},

  	copyPosition: function ( m ) {

  		var te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	},

  	extractBasis: function ( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	},

  	makeBasis: function ( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	},

  	extractRotation: function () {

  		var v1 = new Vector3();

  		return function extractRotation( m ) {

  			// this method does not support reflection matrices

  			var te = this.elements;
  			var me = m.elements;

  			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
  			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
  			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

  			te[ 0 ] = me[ 0 ] * scaleX;
  			te[ 1 ] = me[ 1 ] * scaleX;
  			te[ 2 ] = me[ 2 ] * scaleX;
  			te[ 3 ] = 0;

  			te[ 4 ] = me[ 4 ] * scaleY;
  			te[ 5 ] = me[ 5 ] * scaleY;
  			te[ 6 ] = me[ 6 ] * scaleY;
  			te[ 7 ] = 0;

  			te[ 8 ] = me[ 8 ] * scaleZ;
  			te[ 9 ] = me[ 9 ] * scaleZ;
  			te[ 10 ] = me[ 10 ] * scaleZ;
  			te[ 11 ] = 0;

  			te[ 12 ] = 0;
  			te[ 13 ] = 0;
  			te[ 14 ] = 0;
  			te[ 15 ] = 1;

  			return this;

  		};

  	}(),

  	makeRotationFromEuler: function ( euler ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			console.error( 'Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  		}

  		var te = this.elements;

  		var x = euler.x, y = euler.y, z = euler.z;
  		var a = Math.cos( x ), b = Math.sin( x );
  		var c = Math.cos( y ), d = Math.sin( y );
  		var e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// bottom row
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// last column
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	makeRotationFromQuaternion: function () {

  		var zero = new Vector3( 0, 0, 0 );
  		var one = new Vector3( 1, 1, 1 );

  		return function makeRotationFromQuaternion( q ) {

  			return this.compose( zero, q, one );

  		};

  	}(),

  	lookAt: function () {

  		var x = new Vector3();
  		var y = new Vector3();
  		var z = new Vector3();

  		return function lookAt( eye, target, up ) {

  			var te = this.elements;

  			z.subVectors( eye, target );

  			if ( z.lengthSq() === 0 ) {

  				// eye and target are in the same position

  				z.z = 1;

  			}

  			z.normalize();
  			x.crossVectors( up, z );

  			if ( x.lengthSq() === 0 ) {

  				// up and z are parallel

  				if ( Math.abs( up.z ) === 1 ) {

  					z.x += 0.0001;

  				} else {

  					z.z += 0.0001;

  				}

  				z.normalize();
  				x.crossVectors( up, z );

  			}

  			x.normalize();
  			y.crossVectors( z, x );

  			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
  			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
  			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

  			return this;

  		};

  	}(),

  	multiply: function ( m, n ) {

  		if ( n !== undefined ) {

  			console.warn( 'Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  			return this.multiplyMatrices( m, n );

  		}

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix4( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	determinant: function () {

  		var te = this.elements;

  		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	},

  	transpose: function () {

  		var te = this.elements;
  		var tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	},

  	setPosition: function ( v ) {

  		var te = this.elements;

  		te[ 12 ] = v.x;
  		te[ 13 ] = v.y;
  		te[ 14 ] = v.z;

  		return this;

  	},

  	getInverse: function ( m, throwOnDegenerate ) {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		var te = this.elements,
  			me = m.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
  			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
  			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
  			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) {

  			var msg = "Matrix4: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	},

  	scale: function ( v ) {

  		var te = this.elements;
  		var x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	},

  	getMaxScaleOnAxis: function () {

  		var te = this.elements;

  		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	},

  	makeTranslation: function ( x, y, z ) {

  		this.set(

  			1, 0, 0, x,
  			0, 1, 0, y,
  			0, 0, 1, z,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationX: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationY: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationZ: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationAxis: function ( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		var c = Math.cos( angle );
  		var s = Math.sin( angle );
  		var t = 1 - c;
  		var x = axis.x, y = axis.y, z = axis.z;
  		var tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		 return this;

  	},

  	makeScale: function ( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeShear: function ( x, y, z ) {

  		this.set(

  			1, y, z, 0,
  			x, 1, z, 0,
  			x, y, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	compose: function ( position, quaternion, scale ) {

  		var te = this.elements;

  		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  		var x2 = x + x,	y2 = y + y, z2 = z + z;
  		var xx = x * x2, xy = x * y2, xz = x * z2;
  		var yy = y * y2, yz = y * z2, zz = z * z2;
  		var wx = w * x2, wy = w * y2, wz = w * z2;

  		var sx = scale.x, sy = scale.y, sz = scale.z;

  	        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  	        te[ 1 ] = ( xy + wz ) * sx;
  	        te[ 2 ] = ( xz - wy ) * sx;
  	        te[ 3 ] = 0;

  	        te[ 4 ] = ( xy - wz ) * sy;
  	        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  	        te[ 6 ] = ( yz + wx ) * sy;
  	        te[ 7 ] = 0;

  	        te[ 8 ] = ( xz + wy ) * sz;
  	        te[ 9 ] = ( yz - wx ) * sz;
  	        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  	        te[ 11 ] = 0;

  	        te[ 12 ] = position.x;
  	        te[ 13 ] = position.y;
  	        te[ 14 ] = position.z;
  	        te[ 15 ] = 1;

  	        return this;

  	},

  	decompose: function () {

  		var vector = new Vector3();
  		var matrix = new Matrix4();

  		return function decompose( position, quaternion, scale ) {

  			var te = this.elements;

  			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  			// if determine is negative, we need to invert one scale
  			var det = this.determinant();
  			if ( det < 0 ) { sx = - sx; }

  			position.x = te[ 12 ];
  			position.y = te[ 13 ];
  			position.z = te[ 14 ];

  			// scale the rotation part
  			matrix.copy( this );

  			var invSX = 1 / sx;
  			var invSY = 1 / sy;
  			var invSZ = 1 / sz;

  			matrix.elements[ 0 ] *= invSX;
  			matrix.elements[ 1 ] *= invSX;
  			matrix.elements[ 2 ] *= invSX;

  			matrix.elements[ 4 ] *= invSY;
  			matrix.elements[ 5 ] *= invSY;
  			matrix.elements[ 6 ] *= invSY;

  			matrix.elements[ 8 ] *= invSZ;
  			matrix.elements[ 9 ] *= invSZ;
  			matrix.elements[ 10 ] *= invSZ;

  			quaternion.setFromRotationMatrix( matrix );

  			scale.x = sx;
  			scale.y = sy;
  			scale.z = sz;

  			return this;

  		};

  	}(),

  	makePerspective: function ( left, right, top, bottom, near, far ) {

  		if ( far === undefined ) {

  			console.warn( 'Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  		}

  		var te = this.elements;
  		var x = 2 * near / ( right - left );
  		var y = 2 * near / ( top - bottom );

  		var a = ( right + left ) / ( right - left );
  		var b = ( top + bottom ) / ( top - bottom );
  		var c = - ( far + near ) / ( far - near );
  		var d = - 2 * far * near / ( far - near );

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	},

  	makeOrthographic: function ( left, right, top, bottom, near, far ) {

  		var te = this.elements;
  		var w = 1.0 / ( right - left );
  		var h = 1.0 / ( top - bottom );
  		var p = 1.0 / ( far - near );

  		var x = ( right + left ) * w;
  		var y = ( top + bottom ) * h;
  		var z = ( far + near ) * p;

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 16; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector3( x, y, z ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;

  }

  Object.assign( Vector3.prototype, {

  	isVector3: true,

  	set: function ( x, y, z ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	},

  	multiply: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  			return this.multiplyVectors( v, w );

  		}

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	},

  	multiplyVectors: function ( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	},

  	applyEuler: function () {

  		var quaternion = new Quaternion();

  		return function applyEuler( euler ) {

  			if ( ! ( euler && euler.isEuler ) ) {

  				console.error( 'Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  			}

  			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

  		};

  	}(),

  	applyAxisAngle: function () {

  		var quaternion = new Quaternion();

  		return function applyAxisAngle( axis, angle ) {

  			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

  		};

  	}(),

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	},

  	applyQuaternion: function ( q ) {

  		var x = this.x, y = this.y, z = this.z;
  		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// calculate quat * vector

  		var ix = qw * x + qy * z - qz * y;
  		var iy = qw * y + qz * x - qx * z;
  		var iz = qw * z + qx * y - qy * x;
  		var iw = - qx * x - qy * y - qz * z;

  		// calculate result * inverse quat

  		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  		return this;

  	},

  	project: function ( camera ) {

  		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  	},

  	unproject: function () {

  		var matrix = new Matrix4();

  		return function unproject( camera ) {

  			return this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );

  		};

  	}(),

  	transformDirection: function ( m ) {

  		// input: Matrix4 affine matrix
  		// vector interpreted as a direction

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector3();
  		var max = new Vector3();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	},

  	// TODO lengthSquared?

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	},

  	manhattanLength: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	cross: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  			return this.crossVectors( v, w );

  		}

  		return this.crossVectors( this, v );

  	},

  	crossVectors: function ( a, b ) {

  		var ax = a.x, ay = a.y, az = a.z;
  		var bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	},

  	projectOnVector: function ( vector ) {

  		var scalar = vector.dot( this ) / vector.lengthSq();

  		return this.copy( vector ).multiplyScalar( scalar );

  	},

  	projectOnPlane: function () {

  		var v1 = new Vector3();

  		return function projectOnPlane( planeNormal ) {

  			v1.copy( this ).projectOnVector( planeNormal );

  			return this.sub( v1 );

  		};

  	}(),

  	reflect: function () {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		var v1 = new Vector3();

  		return function reflect( normal ) {

  			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  		};

  	}(),

  	angleTo: function ( v ) {

  		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

  		// clamp, to handle numerical problems

  		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	},

  	manhattanDistanceTo: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	},

  	setFromSpherical: function ( s ) {

  		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  	},

  	setFromSphericalCoords: function ( radius, phi, theta ) {

  		var sinPhiRadius = Math.sin( phi ) * radius;

  		this.x = sinPhiRadius * Math.sin( theta );
  		this.y = Math.cos( phi ) * radius;
  		this.z = sinPhiRadius * Math.cos( theta );

  		return this;

  	},

  	setFromCylindrical: function ( c ) {

  		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  	},

  	setFromCylindricalCoords: function ( radius, theta, y ) {

  		this.x = radius * Math.sin( theta );
  		this.y = y;
  		this.z = radius * Math.cos( theta );

  		return this;

  	},

  	setFromMatrixPosition: function ( m ) {

  		var e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	},

  	setFromMatrixScale: function ( m ) {

  		var sx = this.setFromMatrixColumn( m, 0 ).length();
  		var sy = this.setFromMatrixColumn( m, 1 ).length();
  		var sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	},

  	setFromMatrixColumn: function ( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'Vector3: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Quaternion( x, y, z, w ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Quaternion, {

  	slerp: function ( qa, qb, qm, t ) {

  		return qm.copy( qa ).slerp( qb, t );

  	},

  	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		var x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ],

  			x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			var s = 1 - t,

  				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				var sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			var tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  } );

  Object.defineProperties( Quaternion.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	w: {

  		get: function () {

  			return this._w;

  		},

  		set: function ( value ) {

  			this._w = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Quaternion.prototype, {

  	isQuaternion: true,

  	set: function ( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	},

  	copy: function ( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromEuler: function ( euler, update ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			throw new Error( 'Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		var cos = Math.cos;
  		var sin = Math.sin;

  		var c1 = cos( x / 2 );
  		var c2 = cos( y / 2 );
  		var c3 = cos( z / 2 );

  		var s1 = sin( x / 2 );
  		var s2 = sin( y / 2 );
  		var s3 = sin( z / 2 );

  		if ( order === 'XYZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'YXZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'ZXY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'ZYX' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'YZX' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'XZY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		}

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromAxisAngle: function ( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		var halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33,
  			s;

  		if ( trace > 0 ) {

  			s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	setFromUnitVectors: function () {

  		// assumes direction vectors vFrom and vTo are normalized

  		var v1 = new Vector3();
  		var r;

  		var EPS = 0.000001;

  		return function setFromUnitVectors( vFrom, vTo ) {

  			if ( v1 === undefined ) { v1 = new Vector3(); }

  			r = vFrom.dot( vTo ) + 1;

  			if ( r < EPS ) {

  				r = 0;

  				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  					v1.set( - vFrom.y, vFrom.x, 0 );

  				} else {

  					v1.set( 0, - vFrom.z, vFrom.y );

  				}

  			} else {

  				v1.crossVectors( vFrom, vTo );

  			}

  			this._x = v1.x;
  			this._y = v1.y;
  			this._z = v1.z;
  			this._w = r;

  			return this.normalize();

  		};

  	}(),

  	angleTo: function ( q ) {

  		return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

  	},

  	rotateTowards: function ( q, step ) {

  		var angle = this.angleTo( q );

  		if ( angle === 0 ) { return this; }

  		var t = Math.min( 1, step / angle );

  		this.slerp( q, t );

  		return this;

  	},

  	inverse: function () {

  		// quaternion is assumed to have unit length

  		return this.conjugate();

  	},

  	conjugate: function () {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this.onChangeCallback();

  		return this;

  	},

  	dot: function ( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	},

  	lengthSq: function () {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	},

  	length: function () {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	},

  	normalize: function () {

  		var l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	multiply: function ( q, p ) {

  		if ( p !== undefined ) {

  			console.warn( 'Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  			return this.multiplyQuaternions( q, p );

  		}

  		return this.multiplyQuaternions( this, q );

  	},

  	premultiply: function ( q ) {

  		return this.multiplyQuaternions( q, this );

  	},

  	multiplyQuaternions: function ( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this.onChangeCallback();

  		return this;

  	},

  	slerp: function ( qb, t ) {

  		if ( t === 0 ) { return this; }
  		if ( t === 1 ) { return this.copy( qb ); }

  		var x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  		if ( sqrSinHalfTheta <= Number.EPSILON ) {

  			var s = 1 - t;
  			this._w = s * w + t * this._w;
  			this._x = s * x + t * this._x;
  			this._y = s * y + t * this._y;
  			this._z = s * z + t * this._z;

  			return this.normalize();

  		}

  		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this.onChangeCallback();

  		return this;

  	},

  	equals: function ( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function EventDispatcher() {}

  Object.assign( EventDispatcher.prototype, {

  	addEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { this._listeners = {}; }

  		var listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	},

  	hasEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return false; }

  		var listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	},

  	removeEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			var index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	},

  	dispatchEvent: function ( event ) {
  		var this$1 = this;


  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			var array = listenerArray.slice( 0 );

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this$1, event );

  			}

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Euler( x, y, z, order ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._order = order || Euler.DefaultOrder;

  }

  Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  Euler.DefaultOrder = 'XYZ';

  Object.defineProperties( Euler.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	order: {

  		get: function () {

  			return this._order;

  		},

  		set: function ( value ) {

  			this._order = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Euler.prototype, {

  	isEuler: true,

  	set: function ( x, y, z, order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order || this._order;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	},

  	copy: function ( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m, order, update ) {

  		var clamp = _Math.clamp;

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements;
  		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		order = order || this._order;

  		if ( order === 'XYZ' ) {

  			this._y = Math.asin( clamp( m13, - 1, 1 ) );

  			if ( Math.abs( m13 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m33 );
  				this._z = Math.atan2( - m12, m11 );

  			} else {

  				this._x = Math.atan2( m32, m22 );
  				this._z = 0;

  			}

  		} else if ( order === 'YXZ' ) {

  			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  			if ( Math.abs( m23 ) < 0.99999 ) {

  				this._y = Math.atan2( m13, m33 );
  				this._z = Math.atan2( m21, m22 );

  			} else {

  				this._y = Math.atan2( - m31, m11 );
  				this._z = 0;

  			}

  		} else if ( order === 'ZXY' ) {

  			this._x = Math.asin( clamp( m32, - 1, 1 ) );

  			if ( Math.abs( m32 ) < 0.99999 ) {

  				this._y = Math.atan2( - m31, m33 );
  				this._z = Math.atan2( - m12, m22 );

  			} else {

  				this._y = 0;
  				this._z = Math.atan2( m21, m11 );

  			}

  		} else if ( order === 'ZYX' ) {

  			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  			if ( Math.abs( m31 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m33 );
  				this._z = Math.atan2( m21, m11 );

  			} else {

  				this._x = 0;
  				this._z = Math.atan2( - m12, m22 );

  			}

  		} else if ( order === 'YZX' ) {

  			this._z = Math.asin( clamp( m21, - 1, 1 ) );

  			if ( Math.abs( m21 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m22 );
  				this._y = Math.atan2( - m31, m11 );

  			} else {

  				this._x = 0;
  				this._y = Math.atan2( m13, m33 );

  			}

  		} else if ( order === 'XZY' ) {

  			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  			if ( Math.abs( m12 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m22 );
  				this._y = Math.atan2( m13, m11 );

  			} else {

  				this._x = Math.atan2( - m23, m33 );
  				this._y = 0;

  			}

  		} else {

  			console.warn( 'Euler: .setFromRotationMatrix() given unsupported order: ' + order );

  		}

  		this._order = order;

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromQuaternion: function () {

  		var matrix = new Matrix4();

  		return function setFromQuaternion( q, order, update ) {

  			matrix.makeRotationFromQuaternion( q );

  			return this.setFromRotationMatrix( matrix, order, update );

  		};

  	}(),

  	setFromVector3: function ( v, order ) {

  		return this.set( v.x, v.y, v.z, order || this._order );

  	},

  	reorder: function () {

  		// WARNING: this discards revolution information -bhouston

  		var q = new Quaternion();

  		return function reorder( newOrder ) {

  			q.setFromEuler( this );

  			return this.setFromQuaternion( q, newOrder );

  		};

  	}(),

  	equals: function ( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	},

  	fromArray: function ( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	},

  	toVector3: function ( optionalResult ) {

  		if ( optionalResult ) {

  			return optionalResult.set( this._x, this._y, this._z );

  		} else {

  			return new Vector3( this._x, this._y, this._z );

  		}

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Layers() {

  	this.mask = 1 | 0;

  }

  Object.assign( Layers.prototype, {

  	set: function ( channel ) {

  		this.mask = 1 << channel | 0;

  	},

  	enable: function ( channel ) {

  		this.mask |= 1 << channel | 0;

  	},

  	toggle: function ( channel ) {

  		this.mask ^= 1 << channel | 0;

  	},

  	disable: function ( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	},

  	test: function ( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Matrix3() {

  	this.elements = [

  		1, 0, 0,
  		0, 1, 0,
  		0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix3.prototype, {

  	isMatrix3: true,

  	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	},

  	setFromMatrix4: function ( m ) {

  		var me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix3( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	multiply: function ( m ) {

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	},

  	determinant: function () {

  		var te = this.elements;

  		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	},

  	getInverse: function ( matrix, throwOnDegenerate ) {

  		if ( matrix && matrix.isMatrix4 ) {

  			console.error( "Matrix3: .getInverse() no longer takes a Matrix4 argument." );

  		}

  		var me = matrix.elements,
  			te = this.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
  			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
  			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) {

  			var msg = "Matrix3: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	},

  	transpose: function () {

  		var tmp, m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	},

  	getNormalMatrix: function ( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

  	},

  	transposeIntoArray: function ( r ) {

  		var m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	},

  	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

  		var c = Math.cos( rotation );
  		var s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  	},

  	scale: function ( sx, sy ) {

  		var te = this.elements;

  		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
  		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

  		return this;

  	},

  	rotate: function ( theta ) {

  		var c = Math.cos( theta );
  		var s = Math.sin( theta );

  		var te = this.elements;

  		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
  		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

  		te[ 0 ] = c * a11 + s * a21;
  		te[ 3 ] = c * a12 + s * a22;
  		te[ 6 ] = c * a13 + s * a23;

  		te[ 1 ] = - s * a11 + c * a21;
  		te[ 4 ] = - s * a12 + c * a22;
  		te[ 7 ] = - s * a13 + c * a23;

  		return this;

  	},

  	translate: function ( tx, ty ) {

  		var te = this.elements;

  		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
  		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 9; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var REVISION = '102';
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var CullFaceFrontBack = 3;
  var FrontFaceDirectionCW = 0;
  var FrontFaceDirectionCCW = 1;
  var BasicShadowMap = 0;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var SmoothShading = 2;
  var NoColors = 0;
  var FaceColors = 1;
  var VertexColors = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var Uncharted2ToneMapping = 3;
  var CineonToneMapping = 4;
  var ACESFilmicToneMapping = 5;

  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var SphericalReflectionMapping = 305;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1000;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipMapNearestFilter = 1004;
  var NearestMipMapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipMapNearestFilter = 1007;
  var LinearMipMapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var RGBEFormat = RGBAFormat;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3000;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var object3DId = 0;

  function Object3D() {

  	Object.defineProperty( this, 'id', { value: object3DId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Object3D';

  	this.parent = null;
  	this.children = [];

  	this.up = Object3D.DefaultUp.clone();

  	var position = new Vector3();
  	var rotation = new Euler();
  	var quaternion = new Quaternion();
  	var scale = new Vector3( 1, 1, 1 );

  	function onRotationChange() {

  		quaternion.setFromEuler( rotation, false );

  	}

  	function onQuaternionChange() {

  		rotation.setFromQuaternion( quaternion, undefined, false );

  	}

  	rotation.onChange( onRotationChange );
  	quaternion.onChange( onQuaternionChange );

  	Object.defineProperties( this, {
  		position: {
  			configurable: true,
  			enumerable: true,
  			value: position
  		},
  		rotation: {
  			configurable: true,
  			enumerable: true,
  			value: rotation
  		},
  		quaternion: {
  			configurable: true,
  			enumerable: true,
  			value: quaternion
  		},
  		scale: {
  			configurable: true,
  			enumerable: true,
  			value: scale
  		},
  		modelViewMatrix: {
  			value: new Matrix4()
  		},
  		normalMatrix: {
  			value: new Matrix3()
  		}
  	} );

  	this.matrix = new Matrix4();
  	this.matrixWorld = new Matrix4();

  	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  	this.matrixWorldNeedsUpdate = false;

  	this.layers = new Layers();
  	this.visible = true;

  	this.castShadow = false;
  	this.receiveShadow = false;

  	this.frustumCulled = true;
  	this.renderOrder = 0;

  	this.userData = {};

  }

  Object3D.DefaultUp = new Vector3( 0, 1, 0 );
  Object3D.DefaultMatrixAutoUpdate = true;

  Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: Object3D,

  	isObject3D: true,

  	onBeforeRender: function () {},
  	onAfterRender: function () {},

  	applyMatrix: function ( matrix ) {

  		this.matrix.multiplyMatrices( matrix, this.matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	},

  	applyQuaternion: function ( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	},

  	setRotationFromAxisAngle: function ( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	},

  	setRotationFromEuler: function ( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	},

  	setRotationFromMatrix: function ( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	},

  	setRotationFromQuaternion: function ( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	},

  	rotateOnAxis: function () {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		var q1 = new Quaternion();

  		return function rotateOnAxis( axis, angle ) {

  			q1.setFromAxisAngle( axis, angle );

  			this.quaternion.multiply( q1 );

  			return this;

  		};

  	}(),

  	rotateOnWorldAxis: function () {

  		// rotate object on axis in world space
  		// axis is assumed to be normalized
  		// method assumes no rotated parent

  		var q1 = new Quaternion();

  		return function rotateOnWorldAxis( axis, angle ) {

  			q1.setFromAxisAngle( axis, angle );

  			this.quaternion.premultiply( q1 );

  			return this;

  		};

  	}(),

  	rotateX: function () {

  		var v1 = new Vector3( 1, 0, 0 );

  		return function rotateX( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateY: function () {

  		var v1 = new Vector3( 0, 1, 0 );

  		return function rotateY( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateZ: function () {

  		var v1 = new Vector3( 0, 0, 1 );

  		return function rotateZ( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	translateOnAxis: function () {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		var v1 = new Vector3();

  		return function translateOnAxis( axis, distance ) {

  			v1.copy( axis ).applyQuaternion( this.quaternion );

  			this.position.add( v1.multiplyScalar( distance ) );

  			return this;

  		};

  	}(),

  	translateX: function () {

  		var v1 = new Vector3( 1, 0, 0 );

  		return function translateX( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateY: function () {

  		var v1 = new Vector3( 0, 1, 0 );

  		return function translateY( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateZ: function () {

  		var v1 = new Vector3( 0, 0, 1 );

  		return function translateZ( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	localToWorld: function ( vector ) {

  		return vector.applyMatrix4( this.matrixWorld );

  	},

  	worldToLocal: function () {

  		var m1 = new Matrix4();

  		return function worldToLocal( vector ) {

  			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

  		};

  	}(),

  	lookAt: function () {

  		// This method does not support objects having non-uniformly-scaled parent(s)

  		var q1 = new Quaternion();
  		var m1 = new Matrix4();
  		var target = new Vector3();
  		var position = new Vector3();

  		return function lookAt( x, y, z ) {

  			if ( x.isVector3 ) {

  				target.copy( x );

  			} else {

  				target.set( x, y, z );

  			}

  			var parent = this.parent;

  			this.updateWorldMatrix( true, false );

  			position.setFromMatrixPosition( this.matrixWorld );

  			if ( this.isCamera || this.isLight ) {

  				m1.lookAt( position, target, this.up );

  			} else {

  				m1.lookAt( target, position, this.up );

  			}

  			this.quaternion.setFromRotationMatrix( m1 );

  			if ( parent ) {

  				m1.extractRotation( parent.matrixWorld );
  				q1.setFromRotationMatrix( m1 );
  				this.quaternion.premultiply( q1.inverse() );

  			}

  		};

  	}(),

  	add: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.add( arguments$1[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( "Object3D.add: object can't be added as a child of itself.", object );
  			return this;

  		}

  		if ( ( object && object.isObject3D ) ) {

  			if ( object.parent !== null ) {

  				object.parent.remove( object );

  			}

  			object.parent = this;
  			object.dispatchEvent( { type: 'added' } );

  			this.children.push( object );

  		} else {

  			console.error( "Object3D.add: object not an instance of Object3D.", object );

  		}

  		return this;

  	},

  	remove: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.remove( arguments$1[ i ] );

  			}

  			return this;

  		}

  		var index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;

  			object.dispatchEvent( { type: 'removed' } );

  			this.children.splice( index, 1 );

  		}

  		return this;

  	},

  	getObjectById: function ( id ) {

  		return this.getObjectByProperty( 'id', id );

  	},

  	getObjectByName: function ( name ) {

  		return this.getObjectByProperty( 'name', name );

  	},

  	getObjectByProperty: function ( name, value ) {
  		var this$1 = this;


  		if ( this[ name ] === value ) { return this; }

  		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  			var child = this$1.children[ i ];
  			var object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	},

  	getWorldPosition: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Object3D: .getWorldPosition() target is now required' );
  			target = new Vector3();

  		}

  		this.updateMatrixWorld( true );

  		return target.setFromMatrixPosition( this.matrixWorld );

  	},

  	getWorldQuaternion: function () {

  		var position = new Vector3();
  		var scale = new Vector3();

  		return function getWorldQuaternion( target ) {

  			if ( target === undefined ) {

  				console.warn( 'Object3D: .getWorldQuaternion() target is now required' );
  				target = new Quaternion();

  			}

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, target, scale );

  			return target;

  		};

  	}(),

  	getWorldScale: function () {

  		var position = new Vector3();
  		var quaternion = new Quaternion();

  		return function getWorldScale( target ) {

  			if ( target === undefined ) {

  				console.warn( 'Object3D: .getWorldScale() target is now required' );
  				target = new Vector3();

  			}

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, quaternion, target );

  			return target;

  		};

  	}(),

  	getWorldDirection: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Object3D: .getWorldDirection() target is now required' );
  			target = new Vector3();

  		}

  		this.updateMatrixWorld( true );

  		var e = this.matrixWorld.elements;

  		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  	},

  	raycast: function () {},

  	traverse: function ( callback ) {

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	},

  	traverseVisible: function ( callback ) {

  		if ( this.visible === false ) { return; }

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	},

  	traverseAncestors: function ( callback ) {

  		var parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	},

  	updateMatrix: function () {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	},

  	updateMatrixWorld: function ( force ) {

  		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].updateMatrixWorld( force );

  		}

  	},

  	updateWorldMatrix: function ( updateParents, updateChildren ) {

  		var parent = this.parent;

  		if ( updateParents === true && parent !== null ) {

  			parent.updateWorldMatrix( true, false );

  		}

  		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

  		if ( this.parent === null ) {

  			this.matrixWorld.copy( this.matrix );

  		} else {

  			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  		}

  		// update children

  		if ( updateChildren === true ) {

  			var children = this.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].updateWorldMatrix( false, true );

  			}

  		}

  	},

  	toJSON: function ( meta ) {
  		var this$1 = this;


  		// meta is a string when called from JSON.stringify
  		var isRootObject = ( meta === undefined || typeof meta === 'string' );

  		var output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {},
  				shapes: {}
  			};

  			output.metadata = {
  				version: 4.5,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		var object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) { object.name = this.name; }
  		if ( this.castShadow === true ) { object.castShadow = true; }
  		if ( this.receiveShadow === true ) { object.receiveShadow = true; }
  		if ( this.visible === false ) { object.visible = false; }
  		if ( this.frustumCulled === false ) { object.frustumCulled = false; }
  		if ( this.renderOrder !== 0 ) { object.renderOrder = this.renderOrder; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

  		object.layers = this.layers.mask;
  		object.matrix = this.matrix.toArray();

  		if ( this.matrixAutoUpdate === false ) { object.matrixAutoUpdate = false; }

  		// object specific properties

  		if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) { object.drawMode = this.drawMode; }

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.isMesh || this.isLine || this.isPoints ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  			var parameters = this.geometry.parameters;

  			if ( parameters !== undefined && parameters.shapes !== undefined ) {

  				var shapes = parameters.shapes;

  				if ( Array.isArray( shapes ) ) {

  					for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  						var shape = shapes[ i ];

  						serialize( meta.shapes, shape );

  					}

  				} else {

  					serialize( meta.shapes, shapes );

  				}

  			}

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				var uuids = [];

  				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this$1.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( var i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this$1.children[ i ].toJSON( meta ).object );

  			}

  		}

  		if ( isRootObject ) {

  			var geometries = extractFromCache( meta.geometries );
  			var materials = extractFromCache( meta.materials );
  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );
  			var shapes = extractFromCache( meta.shapes );

  			if ( geometries.length > 0 ) { output.geometries = geometries; }
  			if ( materials.length > 0 ) { output.materials = materials; }
  			if ( textures.length > 0 ) { output.textures = textures; }
  			if ( images.length > 0 ) { output.images = images; }
  			if ( shapes.length > 0 ) { output.shapes = shapes; }

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			var values = [];
  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}
  			return values;

  		}

  	},

  	clone: function ( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	},

  	copy: function ( source, recursive ) {
  		var this$1 = this;


  		if ( recursive === undefined ) { recursive = true; }

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( var i = 0; i < source.children.length; i ++ ) {

  				var child = source.children[ i ];
  				this$1.add( child.clone() );

  			}

  		}

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  function Color( r, g, b ) {

  	if ( g === undefined && b === undefined ) {

  		// r is Color, hex or string
  		return this.set( r );

  	}

  	return this.setRGB( r, g, b );

  }

  Object.assign( Color.prototype, {

  	isColor: true,

  	r: 1, g: 1, b: 1,

  	set: function ( value ) {

  		if ( value && value.isColor ) {

  			this.copy( value );

  		} else if ( typeof value === 'number' ) {

  			this.setHex( value );

  		} else if ( typeof value === 'string' ) {

  			this.setStyle( value );

  		}

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	},

  	setHex: function ( hex ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		return this;

  	},

  	setRGB: function ( r, g, b ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		return this;

  	},

  	setHSL: function () {

  		function hue2rgb( p, q, t ) {

  			if ( t < 0 ) { t += 1; }
  			if ( t > 1 ) { t -= 1; }
  			if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
  			if ( t < 1 / 2 ) { return q; }
  			if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
  			return p;

  		}

  		return function setHSL( h, s, l ) {

  			// h,s,l ranges are in 0.0 - 1.0
  			h = _Math.euclideanModulo( h, 1 );
  			s = _Math.clamp( s, 0, 1 );
  			l = _Math.clamp( l, 0, 1 );

  			if ( s === 0 ) {

  				this.r = this.g = this.b = l;

  			} else {

  				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  				var q = ( 2 * l ) - p;

  				this.r = hue2rgb( q, p, h + 1 / 3 );
  				this.g = hue2rgb( q, p, h );
  				this.b = hue2rgb( q, p, h - 1 / 3 );

  			}

  			return this;

  		};

  	}(),

  	setStyle: function ( style ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) { return; }

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}
  		var m;

  		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			var color;
  			var name = m[ 1 ];
  			var components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)
  						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  						var h = parseFloat( color[ 1 ] ) / 360;
  						var s = parseInt( color[ 2 ], 10 ) / 100;
  						var l = parseInt( color[ 3 ], 10 ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this.setHSL( h, s, l );

  					}

  					break;

  			}

  		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

  			// hex color

  			var hex = m[ 1 ];
  			var size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  				return this;

  			} else if ( size === 6 ) {

  				// #ff0000
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  				return this;

  			}

  		}

  		if ( style && style.length > 0 ) {

  			// color keywords
  			var hex = ColorKeywords[ style ];

  			if ( hex !== undefined ) {

  				// red
  				this.setHex( hex );

  			} else {

  				// unknown color
  				console.warn( 'Color: Unknown color ' + style );

  			}

  		}

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.r, this.g, this.b );

  	},

  	copy: function ( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	},

  	copyGammaToLinear: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		this.r = Math.pow( color.r, gammaFactor );
  		this.g = Math.pow( color.g, gammaFactor );
  		this.b = Math.pow( color.b, gammaFactor );

  		return this;

  	},

  	copyLinearToGamma: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  		this.r = Math.pow( color.r, safeInverse );
  		this.g = Math.pow( color.g, safeInverse );
  		this.b = Math.pow( color.b, safeInverse );

  		return this;

  	},

  	convertGammaToLinear: function ( gammaFactor ) {

  		this.copyGammaToLinear( this, gammaFactor );

  		return this;

  	},

  	convertLinearToGamma: function ( gammaFactor ) {

  		this.copyLinearToGamma( this, gammaFactor );

  		return this;

  	},

  	copySRGBToLinear: function () {

  		function SRGBToLinear( c ) {

  			return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  		}

  		return function copySRGBToLinear( color ) {

  			this.r = SRGBToLinear( color.r );
  			this.g = SRGBToLinear( color.g );
  			this.b = SRGBToLinear( color.b );

  			return this;

  		};

  	}(),

  	copyLinearToSRGB: function () {

  		function LinearToSRGB( c ) {

  			return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  		}

  		return function copyLinearToSRGB( color ) {

  			this.r = LinearToSRGB( color.r );
  			this.g = LinearToSRGB( color.g );
  			this.b = LinearToSRGB( color.b );

  			return this;

  		};

  	}(),

  	convertSRGBToLinear: function () {

  		this.copySRGBToLinear( this );

  		return this;

  	},

  	convertLinearToSRGB: function () {

  		this.copyLinearToSRGB( this );

  		return this;

  	},

  	getHex: function () {

  		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  	},

  	getHexString: function () {

  		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  	},

  	getHSL: function ( target ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		if ( target === undefined ) {

  			console.warn( 'Color: .getHSL() target is now required' );
  			target = { h: 0, s: 0, l: 0 };

  		}

  		var r = this.r, g = this.g, b = this.b;

  		var max = Math.max( r, g, b );
  		var min = Math.min( r, g, b );

  		var hue, saturation;
  		var lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			var delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		target.h = hue;
  		target.s = saturation;
  		target.l = lightness;

  		return target;

  	},

  	getStyle: function () {

  		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  	},

  	offsetHSL: function () {

  		var hsl = {};

  		return function ( h, s, l ) {

  			this.getHSL( hsl );

  			hsl.h += h; hsl.s += s; hsl.l += l;

  			this.setHSL( hsl.h, hsl.s, hsl.l );

  			return this;

  		};

  	}(),

  	add: function ( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	},

  	addColors: function ( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	},

  	sub: function ( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	},

  	multiply: function ( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	},

  	lerp: function ( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	},

  	lerpHSL: function () {

  		var hslA = { h: 0, s: 0, l: 0 };
  		var hslB = { h: 0, s: 0, l: 0 };

  		return function lerpHSL( color, alpha ) {

  			this.getHSL( hslA );
  			color.getHSL( hslB );

  			var h = _Math.lerp( hslA.h, hslB.h, alpha );
  			var s = _Math.lerp( hslA.s, hslB.s, alpha );
  			var l = _Math.lerp( hslA.l, hslB.l, alpha );

  			this.setHSL( h, s, l );

  			return this;

  		};

  	}(),

  	equals: function ( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	},

  	toJSON: function () {

  		return this.getHex();

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Face3( a, b, c, normal, color, materialIndex ) {

  	this.a = a;
  	this.b = b;
  	this.c = c;

  	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
  	this.vertexNormals = Array.isArray( normal ) ? normal : [];

  	this.color = ( color && color.isColor ) ? color : new Color();
  	this.vertexColors = Array.isArray( color ) ? color : [];

  	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign( Face3.prototype, {

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		this.a = source.a;
  		this.b = source.b;
  		this.c = source.c;

  		this.normal.copy( source.normal );
  		this.color.copy( source.color );

  		this.materialIndex = source.materialIndex;

  		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

  			this$1.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

  		}

  		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

  			this$1.vertexColors[ i ] = source.vertexColors[ i ].clone();

  		}

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Box3( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

  }

  Object.assign( Box3.prototype, {

  	isBox3: true,

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromArray: function ( array ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = array.length; i < l; i += 3 ) {

  			var x = array[ i ];
  			var y = array[ i + 1 ];
  			var z = array[ i + 2 ];

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromBufferAttribute: function ( attribute ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  			var x = attribute.getX( i );
  			var y = attribute.getY( i );
  			var z = attribute.getZ( i );

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this$1.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector3();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	setFromObject: function ( object ) {

  		this.makeEmpty();

  		return this.expandByObject( object );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	},

  	getCenter: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box3: .getCenter() target is now required' );
  			target = new Vector3();

  		}

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box3: .getSize() target is now required' );
  			target = new Vector3();

  		}

  		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	expandByObject: function () {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		var scope, i, l;

  		var v1 = new Vector3();

  		function traverse( node ) {

  			var geometry = node.geometry;

  			if ( geometry !== undefined ) {

  				if ( geometry.isGeometry ) {

  					var vertices = geometry.vertices;

  					for ( i = 0, l = vertices.length; i < l; i ++ ) {

  						v1.copy( vertices[ i ] );
  						v1.applyMatrix4( node.matrixWorld );

  						scope.expandByPoint( v1 );

  					}

  				} else if ( geometry.isBufferGeometry ) {

  					var attribute = geometry.attributes.position;

  					if ( attribute !== undefined ) {

  						for ( i = 0, l = attribute.count; i < l; i ++ ) {

  							v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  							scope.expandByPoint( v1 );

  						}

  					}

  				}

  			}

  		}

  		return function expandByObject( object ) {

  			scope = this;

  			object.updateMatrixWorld( true );

  			object.traverse( traverse );

  			return this;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ||
  			point.z < this.min.z || point.z > this.max.z ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	},

  	getParameter: function ( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		if ( target === undefined ) {

  			console.warn( 'Box3: .getParameter() target is now required' );
  			target = new Vector3();

  		}

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ||
  			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  	},

  	intersectsSphere: ( function () {

  		var closestPoint = new Vector3();

  		return function intersectsSphere( sphere ) {

  			// Find the point on the AABB closest to the sphere center.
  			this.clampPoint( sphere.center, closestPoint );

  			// If that point is inside the sphere, the AABB and sphere intersect.
  			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  		};

  	} )(),

  	intersectsPlane: function ( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		var min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= - plane.constant && max >= - plane.constant );

  	},

  	intersectsTriangle: ( function () {

  		// triangle centered vertices
  		var v0 = new Vector3();
  		var v1 = new Vector3();
  		var v2 = new Vector3();

  		// triangle edge vectors
  		var f0 = new Vector3();
  		var f1 = new Vector3();
  		var f2 = new Vector3();

  		var testAxis = new Vector3();

  		var center = new Vector3();
  		var extents = new Vector3();

  		var triangleNormal = new Vector3();

  		function satForAxes( axes ) {

  			var i, j;

  			for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  				testAxis.fromArray( axes, i );
  				// project the aabb onto the seperating axis
  				var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
  				// project all 3 vertices of the triangle onto the seperating axis
  				var p0 = v0.dot( testAxis );
  				var p1 = v1.dot( testAxis );
  				var p2 = v2.dot( testAxis );
  				// actual test, basically see if either of the most extreme of the triangle points intersects r
  				if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  					// points of the projected triangle are outside the projected half-length of the aabb
  					// the axis is seperating and we can exit
  					return false;

  				}

  			}

  			return true;

  		}

  		return function intersectsTriangle( triangle ) {

  			if ( this.isEmpty() ) {

  				return false;

  			}

  			// compute box center and extents
  			this.getCenter( center );
  			extents.subVectors( this.max, center );

  			// translate triangle to aabb origin
  			v0.subVectors( triangle.a, center );
  			v1.subVectors( triangle.b, center );
  			v2.subVectors( triangle.c, center );

  			// compute edge vectors for triangle
  			f0.subVectors( v1, v0 );
  			f1.subVectors( v2, v1 );
  			f2.subVectors( v0, v2 );

  			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  			var axes = [
  				0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
  				f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
  				- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
  			];
  			if ( ! satForAxes( axes ) ) {

  				return false;

  			}

  			// test 3 face normals from the aabb
  			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  			if ( ! satForAxes( axes ) ) {

  				return false;

  			}

  			// finally testing the face normal of the triangle
  			// use already existing triangle edge vectors here
  			triangleNormal.crossVectors( f0, f1 );
  			axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
  			return satForAxes( axes );

  		};

  	} )(),

  	clampPoint: function ( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box3: .clampPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector3();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	getBoundingSphere: function () {

  		var v1 = new Vector3();

  		return function getBoundingSphere( target ) {

  			if ( target === undefined ) {

  				console.warn( 'Box3: .getBoundingSphere() target is now required' );
  				target = new Sphere();

  			}

  			this.getCenter( target.center );

  			target.radius = this.getSize( v1 ).length() * 0.5;

  			return target;

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) { this.makeEmpty(); }

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	applyMatrix4: function () {

  		var points = [
  			new Vector3(),
  			new Vector3(),
  			new Vector3(),
  			new Vector3(),
  			new Vector3(),
  			new Vector3(),
  			new Vector3(),
  			new Vector3()
  		];

  		return function applyMatrix4( matrix ) {

  			// transform of empty box is an empty box.
  			if ( this.isEmpty() ) { return this; }

  			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  			this.setFromPoints( points );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Sphere( center, radius ) {

  	this.center = ( center !== undefined ) ? center : new Vector3();
  	this.radius = ( radius !== undefined ) ? radius : 0;

  }

  Object.assign( Sphere.prototype, {

  	set: function ( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	},

  	setFromPoints: function () {

  		var box = new Box3();

  		return function setFromPoints( points, optionalCenter ) {

  			var center = this.center;

  			if ( optionalCenter !== undefined ) {

  				center.copy( optionalCenter );

  			} else {

  				box.setFromPoints( points ).getCenter( center );

  			}

  			var maxRadiusSq = 0;

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  			}

  			this.radius = Math.sqrt( maxRadiusSq );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	},

  	empty: function () {

  		return ( this.radius <= 0 );

  	},

  	containsPoint: function ( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	},

  	distanceToPoint: function ( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	},

  	intersectsSphere: function ( sphere ) {

  		var radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsSphere( this );

  	},

  	intersectsPlane: function ( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	},

  	clampPoint: function ( point, target ) {

  		var deltaLengthSq = this.center.distanceToSquared( point );

  		if ( target === undefined ) {

  			console.warn( 'Sphere: .clampPoint() target is now required' );
  			target = new Vector3();

  		}

  		target.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			target.sub( this.center ).normalize();
  			target.multiplyScalar( this.radius ).add( this.center );

  		}

  		return target;

  	},

  	getBoundingBox: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Sphere: .getBoundingBox() target is now required' );
  			target = new Box3();

  		}

  		target.set( this.center, this.center );
  		target.expandByScalar( this.radius );

  		return target;

  	},

  	applyMatrix4: function ( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	},

  	translate: function ( offset ) {

  		this.center.add( offset );

  		return this;

  	},

  	equals: function ( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector2( x, y ) {

  	this.x = x || 0;
  	this.y = y || 0;

  }

  Object.defineProperties( Vector2.prototype, {

  	"width": {

  		get: function () {

  			return this.x;

  		},

  		set: function ( value ) {

  			this.x = value;

  		}

  	},

  	"height": {

  		get: function () {

  			return this.y;

  		},

  		set: function ( value ) {

  			this.y = value;

  		}

  	}

  } );

  Object.assign( Vector2.prototype, {

  	isVector2: true,

  	set: function ( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	},

  	multiply: function ( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector2();
  		var max = new Vector2();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal );
  			max.set( maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y;

  	},

  	cross: function ( v ) {

  		return this.x * v.y - this.y * v.x;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	},

  	manhattanLength: function () {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	angle: function () {

  		// computes the angle in radians with respect to the positive x-axis

  		var angle = Math.atan2( this.y, this.x );

  		if ( angle < 0 ) { angle += 2 * Math.PI; }

  		return angle;

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	},

  	manhattanDistanceTo: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'Vector2: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	},

  	rotateAround: function ( center, angle ) {

  		var c = Math.cos( angle ), s = Math.sin( angle );

  		var x = this.x - center.x;
  		var y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var geometryId = 0; // Geometry uses even numbers as Id

  function Geometry() {

  	Object.defineProperty( this, 'id', { value: geometryId += 2 } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Geometry';

  	this.vertices = [];
  	this.colors = [];
  	this.faces = [];
  	this.faceVertexUvs = [[]];

  	this.morphTargets = [];
  	this.morphNormals = [];

  	this.skinWeights = [];
  	this.skinIndices = [];

  	this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.elementsNeedUpdate = false;
  	this.verticesNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.lineDistancesNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: Geometry,

  	isGeometry: true,

  	applyMatrix: function ( matrix ) {
  		var this$1 = this;


  		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertex.applyMatrix4( matrix );

  		}

  		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

  			var face = this$1.faces[ i ];
  			face.normal.applyMatrix3( normalMatrix ).normalize();

  			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

  			}

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		this.verticesNeedUpdate = true;
  		this.normalsNeedUpdate = true;

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	fromBufferGeometry: function ( geometry ) {

  		var scope = this;

  		var indices = geometry.index !== null ? geometry.index.array : undefined;
  		var attributes = geometry.attributes;

  		var positions = attributes.position.array;
  		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
  		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
  		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
  		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

  		if ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }

  		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

  			scope.vertices.push( new Vector3().fromArray( positions, i ) );

  			if ( colors !== undefined ) {

  				scope.colors.push( new Color().fromArray( colors, i ) );

  			}

  		}

  		function addFace( a, b, c, materialIndex ) {

  			var vertexColors = ( colors === undefined ) ? [] : [
  				scope.colors[ a ].clone(),
  				scope.colors[ b ].clone(),
  				scope.colors[ c ].clone() ];

  			var vertexNormals = ( normals === undefined ) ? [] : [
  				new Vector3().fromArray( normals, a * 3 ),
  				new Vector3().fromArray( normals, b * 3 ),
  				new Vector3().fromArray( normals, c * 3 )
  			];

  			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

  			scope.faces.push( face );

  			if ( uvs !== undefined ) {

  				scope.faceVertexUvs[ 0 ].push( [
  					new Vector2().fromArray( uvs, a * 2 ),
  					new Vector2().fromArray( uvs, b * 2 ),
  					new Vector2().fromArray( uvs, c * 2 )
  				] );

  			}

  			if ( uvs2 !== undefined ) {

  				scope.faceVertexUvs[ 1 ].push( [
  					new Vector2().fromArray( uvs2, a * 2 ),
  					new Vector2().fromArray( uvs2, b * 2 ),
  					new Vector2().fromArray( uvs2, c * 2 )
  				] );

  			}

  		}

  		var groups = geometry.groups;

  		if ( groups.length > 0 ) {

  			for ( var i = 0; i < groups.length; i ++ ) {

  				var group = groups[ i ];

  				var start = group.start;
  				var count = group.count;

  				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  					if ( indices !== undefined ) {

  						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

  					} else {

  						addFace( j, j + 1, j + 2, group.materialIndex );

  					}

  				}

  			}

  		} else {

  			if ( indices !== undefined ) {

  				for ( var i = 0; i < indices.length; i += 3 ) {

  					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

  				}

  			} else {

  				for ( var i = 0; i < positions.length / 3; i += 3 ) {

  					addFace( i, i + 1, i + 2 );

  				}

  			}

  		}

  		this.computeFaceNormals();

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		return this;

  	},

  	center: function () {

  		var offset = new Vector3();

  		return function center() {

  			this.computeBoundingBox();

  			this.boundingBox.getCenter( offset ).negate();

  			this.translate( offset.x, offset.y, offset.z );

  			return this;

  		};

  	}(),

  	normalize: function () {

  		this.computeBoundingSphere();

  		var center = this.boundingSphere.center;
  		var radius = this.boundingSphere.radius;

  		var s = radius === 0 ? 1 : 1.0 / radius;

  		var matrix = new Matrix4();
  		matrix.set(
  			s, 0, 0, - s * center.x,
  			0, s, 0, - s * center.y,
  			0, 0, s, - s * center.z,
  			0, 0, 0, 1
  		);

  		this.applyMatrix( matrix );

  		return this;

  	},

  	computeFaceNormals: function () {
  		var this$1 = this;


  		var cb = new Vector3(), ab = new Vector3();

  		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			var face = this$1.faces[ f ];

  			var vA = this$1.vertices[ face.a ];
  			var vB = this$1.vertices[ face.b ];
  			var vC = this$1.vertices[ face.c ];

  			cb.subVectors( vC, vB );
  			ab.subVectors( vA, vB );
  			cb.cross( ab );

  			cb.normalize();

  			face.normal.copy( cb );

  		}

  	},

  	computeVertexNormals: function ( areaWeighted ) {
  		var this$1 = this;


  		if ( areaWeighted === undefined ) { areaWeighted = true; }

  		var v, vl, f, fl, face, vertices;

  		vertices = new Array( this.vertices.length );

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ] = new Vector3();

  		}

  		if ( areaWeighted ) {

  			// vertex normals weighted by triangle areas
  			// http://www.iquilezles.org/www/articles/normals/normals.htm

  			var vA, vB, vC;
  			var cb = new Vector3(), ab = new Vector3();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vA = this$1.vertices[ face.a ];
  				vB = this$1.vertices[ face.b ];
  				vC = this$1.vertices[ face.c ];

  				cb.subVectors( vC, vB );
  				ab.subVectors( vA, vB );
  				cb.cross( ab );

  				vertices[ face.a ].add( cb );
  				vertices[ face.b ].add( cb );
  				vertices[ face.c ].add( cb );

  			}

  		} else {

  			this.computeFaceNormals();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vertices[ face.a ].add( face.normal );
  				vertices[ face.b ].add( face.normal );
  				vertices[ face.c ].add( face.normal );

  			}

  		}

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ].normalize();

  		}

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( vertices[ face.a ] );
  				vertexNormals[ 1 ].copy( vertices[ face.b ] );
  				vertexNormals[ 2 ].copy( vertices[ face.c ] );

  			} else {

  				vertexNormals[ 0 ] = vertices[ face.a ].clone();
  				vertexNormals[ 1 ] = vertices[ face.b ].clone();
  				vertexNormals[ 2 ] = vertices[ face.c ].clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeFlatVertexNormals: function () {
  		var this$1 = this;


  		var f, fl, face;

  		this.computeFaceNormals();

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( face.normal );
  				vertexNormals[ 1 ].copy( face.normal );
  				vertexNormals[ 2 ].copy( face.normal );

  			} else {

  				vertexNormals[ 0 ] = face.normal.clone();
  				vertexNormals[ 1 ] = face.normal.clone();
  				vertexNormals[ 2 ] = face.normal.clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeMorphNormals: function () {
  		var this$1 = this;


  		var i, il, f, fl, face;

  		// save original normals
  		// - create temp variables on first access
  		//   otherwise just copy (for faster repeated calls)

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			if ( ! face.__originalFaceNormal ) {

  				face.__originalFaceNormal = face.normal.clone();

  			} else {

  				face.__originalFaceNormal.copy( face.normal );

  			}

  			if ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }

  			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

  				if ( ! face.__originalVertexNormals[ i ] ) {

  					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

  				} else {

  					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

  				}

  			}

  		}

  		// use temp geometry to compute face and vertex normals for each morph

  		var tmpGeo = new Geometry();
  		tmpGeo.faces = this.faces;

  		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

  			// create on first access

  			if ( ! this$1.morphNormals[ i ] ) {

  				this$1.morphNormals[ i ] = {};
  				this$1.morphNormals[ i ].faceNormals = [];
  				this$1.morphNormals[ i ].vertexNormals = [];

  				var dstNormalsFace = this$1.morphNormals[ i ].faceNormals;
  				var dstNormalsVertex = this$1.morphNormals[ i ].vertexNormals;

  				var faceNormal, vertexNormals;

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					faceNormal = new Vector3();
  					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

  					dstNormalsFace.push( faceNormal );
  					dstNormalsVertex.push( vertexNormals );

  				}

  			}

  			var morphNormals = this$1.morphNormals[ i ];

  			// set vertices to morph target

  			tmpGeo.vertices = this$1.morphTargets[ i ].vertices;

  			// compute morph normals

  			tmpGeo.computeFaceNormals();
  			tmpGeo.computeVertexNormals();

  			// store morph normals

  			var faceNormal, vertexNormals;

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				faceNormal = morphNormals.faceNormals[ f ];
  				vertexNormals = morphNormals.vertexNormals[ f ];

  				faceNormal.copy( face.normal );

  				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
  				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
  				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

  			}

  		}

  		// restore original normals

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			face.normal = face.__originalFaceNormal;
  			face.vertexNormals = face.__originalVertexNormals;

  		}

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		this.boundingBox.setFromPoints( this.vertices );

  	},

  	computeBoundingSphere: function () {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		this.boundingSphere.setFromPoints( this.vertices );

  	},

  	merge: function ( geometry, matrix, materialIndexOffset ) {

  		if ( ! ( geometry && geometry.isGeometry ) ) {

  			console.error( 'Geometry.merge(): geometry not an instance of Geometry.', geometry );
  			return;

  		}

  		var normalMatrix,
  			vertexOffset = this.vertices.length,
  			vertices1 = this.vertices,
  			vertices2 = geometry.vertices,
  			faces1 = this.faces,
  			faces2 = geometry.faces,
  			uvs1 = this.faceVertexUvs[ 0 ],
  			uvs2 = geometry.faceVertexUvs[ 0 ],
  			colors1 = this.colors,
  			colors2 = geometry.colors;

  		if ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }

  		if ( matrix !== undefined ) {

  			normalMatrix = new Matrix3().getNormalMatrix( matrix );

  		}

  		// vertices

  		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

  			var vertex = vertices2[ i ];

  			var vertexCopy = vertex.clone();

  			if ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }

  			vertices1.push( vertexCopy );

  		}

  		// colors

  		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

  			colors1.push( colors2[ i ].clone() );

  		}

  		// faces

  		for ( i = 0, il = faces2.length; i < il; i ++ ) {

  			var face = faces2[ i ], faceCopy, normal, color,
  				faceVertexNormals = face.vertexNormals,
  				faceVertexColors = face.vertexColors;

  			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
  			faceCopy.normal.copy( face.normal );

  			if ( normalMatrix !== undefined ) {

  				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

  			}

  			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

  				normal = faceVertexNormals[ j ].clone();

  				if ( normalMatrix !== undefined ) {

  					normal.applyMatrix3( normalMatrix ).normalize();

  				}

  				faceCopy.vertexNormals.push( normal );

  			}

  			faceCopy.color.copy( face.color );

  			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

  				color = faceVertexColors[ j ];
  				faceCopy.vertexColors.push( color.clone() );

  			}

  			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

  			faces1.push( faceCopy );

  		}

  		// uvs

  		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

  			var uv = uvs2[ i ], uvCopy = [];

  			if ( uv === undefined ) {

  				continue;

  			}

  			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

  				uvCopy.push( uv[ j ].clone() );

  			}

  			uvs1.push( uvCopy );

  		}

  	},

  	mergeMesh: function ( mesh ) {

  		if ( ! ( mesh && mesh.isMesh ) ) {

  			console.error( 'Geometry.mergeMesh(): mesh not an instance of Mesh.', mesh );
  			return;

  		}

  		if ( mesh.matrixAutoUpdate ) { mesh.updateMatrix(); }

  		this.merge( mesh.geometry, mesh.matrix );

  	},
  	mergeVertices: function () {
  		var this$1 = this;


  		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  		var unique = [], changes = [];

  		var v, key;
  		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  		var precision = Math.pow( 10, precisionPoints );
  		var i, il, face;
  		var indices, j, jl;

  		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

  			v = this$1.vertices[ i ];
  			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

  			if ( verticesMap[ key ] === undefined ) {

  				verticesMap[ key ] = i;
  				unique.push( this$1.vertices[ i ] );
  				changes[ i ] = unique.length - 1;

  			} else {

  				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  				changes[ i ] = changes[ verticesMap[ key ] ];

  			}

  		}
  		// if faces are completely degenerate after merging vertices, we
  		// have to remove them from the geometry.
  		var faceIndicesToRemove = [];

  		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

  			face = this$1.faces[ i ];

  			face.a = changes[ face.a ];
  			face.b = changes[ face.b ];
  			face.c = changes[ face.c ];

  			indices = [ face.a, face.b, face.c ];

  			// if any duplicate vertices are found in a Face3
  			// we have to remove the face as nothing can be saved
  			for ( var n = 0; n < 3; n ++ ) {

  				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

  					faceIndicesToRemove.push( i );
  					break;

  				}

  			}

  		}

  		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

  			var idx = faceIndicesToRemove[ i ];

  			this$1.faces.splice( idx, 1 );

  			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

  				this$1.faceVertexUvs[ j ].splice( idx, 1 );

  			}

  		}

  		// Use unique set of vertices

  		var diff = this.vertices.length - unique.length;
  		this.vertices = unique;
  		return diff;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.vertices = [];

  		for ( var i = 0, l = points.length; i < l; i ++ ) {

  			var point = points[ i ];
  			this$1.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

  		}

  		return this;

  	},

  	sortFacesByMaterialIndex: function () {

  		var faces = this.faces;
  		var length = faces.length;

  		// tag faces

  		for ( var i = 0; i < length; i ++ ) {

  			faces[ i ]._id = i;

  		}

  		// sort faces

  		function materialIndexSort( a, b ) {

  			return a.materialIndex - b.materialIndex;

  		}

  		faces.sort( materialIndexSort );

  		// sort uvs

  		var uvs1 = this.faceVertexUvs[ 0 ];
  		var uvs2 = this.faceVertexUvs[ 1 ];

  		var newUvs1, newUvs2;

  		if ( uvs1 && uvs1.length === length ) { newUvs1 = []; }
  		if ( uvs2 && uvs2.length === length ) { newUvs2 = []; }

  		for ( var i = 0; i < length; i ++ ) {

  			var id = faces[ i ]._id;

  			if ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }
  			if ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }

  		}

  		if ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }
  		if ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Geometry',
  				generator: 'Geometry.toJSON'
  			}
  		};

  		// standard Geometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		var vertices = [];

  		for ( var i = 0; i < this.vertices.length; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  		var faces = [];
  		var normals = [];
  		var normalsHash = {};
  		var colors = [];
  		var colorsHash = {};
  		var uvs = [];
  		var uvsHash = {};

  		for ( var i = 0; i < this.faces.length; i ++ ) {

  			var face = this$1.faces[ i ];

  			var hasMaterial = true;
  			var hasFaceUv = false; // deprecated
  			var hasFaceVertexUv = this$1.faceVertexUvs[ 0 ][ i ] !== undefined;
  			var hasFaceNormal = face.normal.length() > 0;
  			var hasFaceVertexNormal = face.vertexNormals.length > 0;
  			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
  			var hasFaceVertexColor = face.vertexColors.length > 0;

  			var faceType = 0;

  			faceType = setBit( faceType, 0, 0 ); // isQuad
  			faceType = setBit( faceType, 1, hasMaterial );
  			faceType = setBit( faceType, 2, hasFaceUv );
  			faceType = setBit( faceType, 3, hasFaceVertexUv );
  			faceType = setBit( faceType, 4, hasFaceNormal );
  			faceType = setBit( faceType, 5, hasFaceVertexNormal );
  			faceType = setBit( faceType, 6, hasFaceColor );
  			faceType = setBit( faceType, 7, hasFaceVertexColor );

  			faces.push( faceType );
  			faces.push( face.a, face.b, face.c );
  			faces.push( face.materialIndex );

  			if ( hasFaceVertexUv ) {

  				var faceVertexUvs = this$1.faceVertexUvs[ 0 ][ i ];

  				faces.push(
  					getUvIndex( faceVertexUvs[ 0 ] ),
  					getUvIndex( faceVertexUvs[ 1 ] ),
  					getUvIndex( faceVertexUvs[ 2 ] )
  				);

  			}

  			if ( hasFaceNormal ) {

  				faces.push( getNormalIndex( face.normal ) );

  			}

  			if ( hasFaceVertexNormal ) {

  				var vertexNormals = face.vertexNormals;

  				faces.push(
  					getNormalIndex( vertexNormals[ 0 ] ),
  					getNormalIndex( vertexNormals[ 1 ] ),
  					getNormalIndex( vertexNormals[ 2 ] )
  				);

  			}

  			if ( hasFaceColor ) {

  				faces.push( getColorIndex( face.color ) );

  			}

  			if ( hasFaceVertexColor ) {

  				var vertexColors = face.vertexColors;

  				faces.push(
  					getColorIndex( vertexColors[ 0 ] ),
  					getColorIndex( vertexColors[ 1 ] ),
  					getColorIndex( vertexColors[ 2 ] )
  				);

  			}

  		}

  		function setBit( value, position, enabled ) {

  			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

  		}

  		function getNormalIndex( normal ) {

  			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

  			if ( normalsHash[ hash ] !== undefined ) {

  				return normalsHash[ hash ];

  			}

  			normalsHash[ hash ] = normals.length / 3;
  			normals.push( normal.x, normal.y, normal.z );

  			return normalsHash[ hash ];

  		}

  		function getColorIndex( color ) {

  			var hash = color.r.toString() + color.g.toString() + color.b.toString();

  			if ( colorsHash[ hash ] !== undefined ) {

  				return colorsHash[ hash ];

  			}

  			colorsHash[ hash ] = colors.length;
  			colors.push( color.getHex() );

  			return colorsHash[ hash ];

  		}

  		function getUvIndex( uv ) {

  			var hash = uv.x.toString() + uv.y.toString();

  			if ( uvsHash[ hash ] !== undefined ) {

  				return uvsHash[ hash ];

  			}

  			uvsHash[ hash ] = uvs.length / 2;
  			uvs.push( uv.x, uv.y );

  			return uvsHash[ hash ];

  		}

  		data.data = {};

  		data.data.vertices = vertices;
  		data.data.normals = normals;
  		if ( colors.length > 0 ) { data.data.colors = colors; }
  		if ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility
  		data.data.faces = faces;

  		return data;

  	},

  	clone: function () {
  		return new Geometry().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var i, il, j, jl, k, kl;

  		// reset

  		this.vertices = [];
  		this.colors = [];
  		this.faces = [];
  		this.faceVertexUvs = [[]];
  		this.morphTargets = [];
  		this.morphNormals = [];
  		this.skinWeights = [];
  		this.skinIndices = [];
  		this.lineDistances = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// vertices

  		var vertices = source.vertices;

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			this$1.vertices.push( vertices[ i ].clone() );

  		}

  		// colors

  		var colors = source.colors;

  		for ( i = 0, il = colors.length; i < il; i ++ ) {

  			this$1.colors.push( colors[ i ].clone() );

  		}

  		// faces

  		var faces = source.faces;

  		for ( i = 0, il = faces.length; i < il; i ++ ) {

  			this$1.faces.push( faces[ i ].clone() );

  		}

  		// face vertex uvs

  		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

  			var faceVertexUvs = source.faceVertexUvs[ i ];

  			if ( this$1.faceVertexUvs[ i ] === undefined ) {

  				this$1.faceVertexUvs[ i ] = [];

  			}

  			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

  				var uvs = faceVertexUvs[ j ], uvsCopy = [];

  				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

  					var uv = uvs[ k ];

  					uvsCopy.push( uv.clone() );

  				}

  				this$1.faceVertexUvs[ i ].push( uvsCopy );

  			}

  		}

  		// morph targets

  		var morphTargets = source.morphTargets;

  		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = {};
  			morphTarget.name = morphTargets[ i ].name;

  			// vertices

  			if ( morphTargets[ i ].vertices !== undefined ) {

  				morphTarget.vertices = [];

  				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

  					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

  				}

  			}

  			// normals

  			if ( morphTargets[ i ].normals !== undefined ) {

  				morphTarget.normals = [];

  				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

  					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

  				}

  			}

  			this$1.morphTargets.push( morphTarget );

  		}

  		// morph normals

  		var morphNormals = source.morphNormals;

  		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

  			var morphNormal = {};

  			// vertex normals

  			if ( morphNormals[ i ].vertexNormals !== undefined ) {

  				morphNormal.vertexNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

  					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
  					var destVertexNormal = {};

  					destVertexNormal.a = srcVertexNormal.a.clone();
  					destVertexNormal.b = srcVertexNormal.b.clone();
  					destVertexNormal.c = srcVertexNormal.c.clone();

  					morphNormal.vertexNormals.push( destVertexNormal );

  				}

  			}

  			// face normals

  			if ( morphNormals[ i ].faceNormals !== undefined ) {

  				morphNormal.faceNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

  					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

  				}

  			}

  			this$1.morphNormals.push( morphNormal );

  		}

  		// skin weights

  		var skinWeights = source.skinWeights;

  		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

  			this$1.skinWeights.push( skinWeights[ i ].clone() );

  		}

  		// skin indices

  		var skinIndices = source.skinIndices;

  		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

  			this$1.skinIndices.push( skinIndices[ i ].clone() );

  		}

  		// line distances

  		var lineDistances = source.lineDistances;

  		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

  			this$1.lineDistances.push( lineDistances[ i ] );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// update flags

  		this.elementsNeedUpdate = source.elementsNeedUpdate;
  		this.verticesNeedUpdate = source.verticesNeedUpdate;
  		this.uvsNeedUpdate = source.uvsNeedUpdate;
  		this.normalsNeedUpdate = source.normalsNeedUpdate;
  		this.colorsNeedUpdate = source.colorsNeedUpdate;
  		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
  		this.groupsNeedUpdate = source.groupsNeedUpdate;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector4( x, y, z, w ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;
  	this.w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Vector4.prototype, {

  	isVector4: true,

  	set: function ( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setW: function ( w ) {

  		this.w = w;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z, w = this.w;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	setAxisAngleFromQuaternion: function ( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		var s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	},

  	setAxisAngleFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var angle, x, y, z,		// variables for result
  			epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			var xx = ( m11 + 1 ) / 2;
  			var yy = ( m22 + 1 ) / 2;
  			var zz = ( m33 + 1 ) / 2;
  			var xy = ( m12 + m21 ) / 4;
  			var xz = ( m13 + m31 ) / 4;
  			var yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  		                   ( m13 - m31 ) * ( m13 - m31 ) +
  		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) { s = 1; }

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min, max;

  		return function clampScalar( minVal, maxVal ) {

  			if ( min === undefined ) {

  				min = new Vector4();
  				max = new Vector4();

  			}

  			min.set( minVal, minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	},

  	manhattanLength: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'Vector4: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BufferAttribute( array, itemSize, normalized ) {

  	if ( Array.isArray( array ) ) {

  		throw new TypeError( 'BufferAttribute: array should be a Typed Array.' );

  	}

  	this.name = '';

  	this.array = array;
  	this.itemSize = itemSize;
  	this.count = array !== undefined ? array.length / itemSize : 0;
  	this.normalized = normalized === true;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.version = 0;

  }

  Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( BufferAttribute.prototype, {

  	isBufferAttribute: true,

  	onUploadCallback: function () {},

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.itemSize : 0;
  		this.array = array;

  		return this;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.name = source.name;
  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {
  		var this$1 = this;


  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

  			this$1.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	copyArray: function ( array ) {

  		this.array.set( array );

  		return this;

  	},

  	copyColorsArray: function ( colors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = colors.length; i < l; i ++ ) {

  			var color = colors[ i ];

  			if ( color === undefined ) {

  				console.warn( 'BufferAttribute.copyColorsArray(): color is undefined', i );
  				color = new Color();

  			}

  			array[ offset ++ ] = color.r;
  			array[ offset ++ ] = color.g;
  			array[ offset ++ ] = color.b;

  		}

  		return this;

  	},

  	copyVector2sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'BufferAttribute.copyVector2sArray(): vector is undefined', i );
  				vector = new Vector2();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;

  		}

  		return this;

  	},

  	copyVector3sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'BufferAttribute.copyVector3sArray(): vector is undefined', i );
  				vector = new Vector3();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;

  		}

  		return this;

  	},

  	copyVector4sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'BufferAttribute.copyVector4sArray(): vector is undefined', i );
  				vector = new Vector4();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;
  			array[ offset ++ ] = vector.w;

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.array.set( value, offset );

  		return this;

  	},

  	getX: function ( index ) {

  		return this.array[ index * this.itemSize ];

  	},

  	setX: function ( index, x ) {

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	},

  	getY: function ( index ) {

  		return this.array[ index * this.itemSize + 1 ];

  	},

  	setY: function ( index, y ) {

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	},

  	getZ: function ( index ) {

  		return this.array[ index * this.itemSize + 2 ];

  	},

  	setZ: function ( index, z ) {

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	},

  	getW: function ( index ) {

  		return this.array[ index * this.itemSize + 3 ];

  	},

  	setW: function ( index, w ) {

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	},

  	setXY: function ( index, x, y ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  } );

  //

  function Int8BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

  }

  Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
  function Uint8BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

  }

  Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
  function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

  }

  Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
  function Int16BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

  }

  Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
  function Uint16BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

  }

  Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
  function Int32BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

  }

  Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
  function Uint32BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

  }

  Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
  function Float32BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

  }

  Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
  function Float64BufferAttribute( array, itemSize, normalized ) {

  	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

  }

  Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DirectGeometry() {

  	this.vertices = [];
  	this.normals = [];
  	this.colors = [];
  	this.uvs = [];
  	this.uvs2 = [];

  	this.groups = [];

  	this.morphTargets = {};

  	this.skinWeights = [];
  	this.skinIndices = [];

  	// this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.verticesNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( DirectGeometry.prototype, {

  	computeGroups: function ( geometry ) {

  		var group;
  		var groups = [];
  		var materialIndex = undefined;

  		var faces = geometry.faces;

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			// materials

  			if ( face.materialIndex !== materialIndex ) {

  				materialIndex = face.materialIndex;

  				if ( group !== undefined ) {

  					group.count = ( i * 3 ) - group.start;
  					groups.push( group );

  				}

  				group = {
  					start: i * 3,
  					materialIndex: materialIndex
  				};

  			}

  		}

  		if ( group !== undefined ) {

  			group.count = ( i * 3 ) - group.start;
  			groups.push( group );

  		}

  		this.groups = groups;

  	},

  	fromGeometry: function ( geometry ) {
  		var this$1 = this;


  		var faces = geometry.faces;
  		var vertices = geometry.vertices;
  		var faceVertexUvs = geometry.faceVertexUvs;

  		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
  		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

  		// morphs

  		var morphTargets = geometry.morphTargets;
  		var morphTargetsLength = morphTargets.length;

  		var morphTargetsPosition;

  		if ( morphTargetsLength > 0 ) {

  			morphTargetsPosition = [];

  			for ( var i = 0; i < morphTargetsLength; i ++ ) {

  				morphTargetsPosition[ i ] = {
  					name: morphTargets[ i ].name,
  				 	data: []
  				};

  			}

  			this.morphTargets.position = morphTargetsPosition;

  		}

  		var morphNormals = geometry.morphNormals;
  		var morphNormalsLength = morphNormals.length;

  		var morphTargetsNormal;

  		if ( morphNormalsLength > 0 ) {

  			morphTargetsNormal = [];

  			for ( var i = 0; i < morphNormalsLength; i ++ ) {

  				morphTargetsNormal[ i ] = {
  					name: morphNormals[ i ].name,
  				 	data: []
  				};

  			}

  			this.morphTargets.normal = morphTargetsNormal;

  		}

  		// skins

  		var skinIndices = geometry.skinIndices;
  		var skinWeights = geometry.skinWeights;

  		var hasSkinIndices = skinIndices.length === vertices.length;
  		var hasSkinWeights = skinWeights.length === vertices.length;

  		//

  		if ( vertices.length > 0 && faces.length === 0 ) {

  			console.error( 'DirectGeometry: Faceless geometries are not supported.' );

  		}

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			this$1.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				this$1.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

  			} else {

  				var normal = face.normal;

  				this$1.normals.push( normal, normal, normal );

  			}

  			var vertexColors = face.vertexColors;

  			if ( vertexColors.length === 3 ) {

  				this$1.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

  			} else {

  				var color = face.color;

  				this$1.colors.push( color, color, color );

  			}

  			if ( hasFaceVertexUv === true ) {

  				var vertexUvs = faceVertexUvs[ 0 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

  					this$1.uvs.push( new Vector2(), new Vector2(), new Vector2() );

  				}

  			}

  			if ( hasFaceVertexUv2 === true ) {

  				var vertexUvs = faceVertexUvs[ 1 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

  					this$1.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

  				}

  			}

  			// morphs

  			for ( var j = 0; j < morphTargetsLength; j ++ ) {

  				var morphTarget = morphTargets[ j ].vertices;

  				morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

  			}

  			for ( var j = 0; j < morphNormalsLength; j ++ ) {

  				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

  				morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

  			}

  			// skins

  			if ( hasSkinIndices ) {

  				this$1.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

  			}

  			if ( hasSkinWeights ) {

  				this$1.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

  			}

  		}

  		this.computeGroups( geometry );

  		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
  		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
  		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
  		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
  		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function arrayMin( array ) {

  	if ( array.length === 0 ) { return Infinity; }

  	var min = array[ 0 ];

  	for ( var i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] < min ) { min = array[ i ]; }

  	}

  	return min;

  }

  function arrayMax( array ) {

  	if ( array.length === 0 ) { return - Infinity; }

  	var max = array[ 0 ];

  	for ( var i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] > max ) { max = array[ i ]; }

  	}

  	return max;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

  function BufferGeometry() {

  	Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'BufferGeometry';

  	this.index = null;
  	this.attributes = {};

  	this.morphAttributes = {};

  	this.groups = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	this.drawRange = { start: 0, count: Infinity };

  	this.userData = {};

  }

  BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: BufferGeometry,

  	isBufferGeometry: true,

  	getIndex: function () {

  		return this.index;

  	},

  	setIndex: function ( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  	},

  	addAttribute: function ( name, attribute ) {

  		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

  			console.warn( 'BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  			return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

  		}

  		if ( name === 'index' ) {

  			console.warn( 'BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  			this.setIndex( attribute );

  			return this;

  		}

  		this.attributes[ name ] = attribute;

  		return this;

  	},

  	getAttribute: function ( name ) {

  		return this.attributes[ name ];

  	},

  	removeAttribute: function ( name ) {

  		delete this.attributes[ name ];

  		return this;

  	},

  	addGroup: function ( start, count, materialIndex ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex !== undefined ? materialIndex : 0

  		} );

  	},

  	clearGroups: function () {

  		this.groups = [];

  	},

  	setDrawRange: function ( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	},

  	applyMatrix: function ( matrix ) {

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			matrix.applyToBufferAttribute( position );
  			position.needsUpdate = true;

  		}

  		var normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normalMatrix.applyToBufferAttribute( normal );
  			normal.needsUpdate = true;

  		}

  		var tangent = this.attributes.tangent;

  		if ( tangent !== undefined ) {

  			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			// Tangent is vec4, but the '.w' component is a sign value (+1/-1).
  			normalMatrix.applyToBufferAttribute( tangent );
  			tangent.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	center: function () {

  		var offset = new Vector3();

  		return function center() {

  			this.computeBoundingBox();

  			this.boundingBox.getCenter( offset ).negate();

  			this.translate( offset.x, offset.y, offset.z );

  			return this;

  		};

  	}(),

  	setFromObject: function ( object ) {

  		// console.log( 'BufferGeometry.setFromObject(). Converting', object, this );

  		var geometry = object.geometry;

  		if ( object.isPoints || object.isLine ) {

  			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
  			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

  			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
  			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

  			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

  				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

  				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

  			}

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  		} else if ( object.isMesh ) {

  			if ( geometry && geometry.isGeometry ) {

  				this.fromGeometry( geometry );

  			}

  		}

  		return this;

  	},

  	setFromPoints: function ( points ) {

  		var position = [];

  		for ( var i = 0, l = points.length; i < l; i ++ ) {

  			var point = points[ i ];
  			position.push( point.x, point.y, point.z || 0 );

  		}

  		this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  		return this;

  	},

  	updateFromObject: function ( object ) {

  		var geometry = object.geometry;

  		if ( object.isMesh ) {

  			var direct = geometry.__directGeometry;

  			if ( geometry.elementsNeedUpdate === true ) {

  				direct = undefined;
  				geometry.elementsNeedUpdate = false;

  			}

  			if ( direct === undefined ) {

  				return this.fromGeometry( geometry );

  			}

  			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
  			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
  			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
  			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
  			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

  			geometry.verticesNeedUpdate = false;
  			geometry.normalsNeedUpdate = false;
  			geometry.colorsNeedUpdate = false;
  			geometry.uvsNeedUpdate = false;
  			geometry.groupsNeedUpdate = false;

  			geometry = direct;

  		}

  		var attribute;

  		if ( geometry.verticesNeedUpdate === true ) {

  			attribute = this.attributes.position;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.vertices );
  				attribute.needsUpdate = true;

  			}

  			geometry.verticesNeedUpdate = false;

  		}

  		if ( geometry.normalsNeedUpdate === true ) {

  			attribute = this.attributes.normal;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.normals );
  				attribute.needsUpdate = true;

  			}

  			geometry.normalsNeedUpdate = false;

  		}

  		if ( geometry.colorsNeedUpdate === true ) {

  			attribute = this.attributes.color;

  			if ( attribute !== undefined ) {

  				attribute.copyColorsArray( geometry.colors );
  				attribute.needsUpdate = true;

  			}

  			geometry.colorsNeedUpdate = false;

  		}

  		if ( geometry.uvsNeedUpdate ) {

  			attribute = this.attributes.uv;

  			if ( attribute !== undefined ) {

  				attribute.copyVector2sArray( geometry.uvs );
  				attribute.needsUpdate = true;

  			}

  			geometry.uvsNeedUpdate = false;

  		}

  		if ( geometry.lineDistancesNeedUpdate ) {

  			attribute = this.attributes.lineDistance;

  			if ( attribute !== undefined ) {

  				attribute.copyArray( geometry.lineDistances );
  				attribute.needsUpdate = true;

  			}

  			geometry.lineDistancesNeedUpdate = false;

  		}

  		if ( geometry.groupsNeedUpdate ) {

  			geometry.computeGroups( object.geometry );
  			this.groups = geometry.groups;

  			geometry.groupsNeedUpdate = false;

  		}

  		return this;

  	},

  	fromGeometry: function ( geometry ) {

  		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

  		return this.fromDirectGeometry( geometry.__directGeometry );

  	},

  	fromDirectGeometry: function ( geometry ) {
  		var this$1 = this;


  		var positions = new Float32Array( geometry.vertices.length * 3 );
  		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

  		if ( geometry.normals.length > 0 ) {

  			var normals = new Float32Array( geometry.normals.length * 3 );
  			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

  		}

  		if ( geometry.colors.length > 0 ) {

  			var colors = new Float32Array( geometry.colors.length * 3 );
  			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

  		}

  		if ( geometry.uvs.length > 0 ) {

  			var uvs = new Float32Array( geometry.uvs.length * 2 );
  			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

  		}

  		if ( geometry.uvs2.length > 0 ) {

  			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
  			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

  		}

  		// groups

  		this.groups = geometry.groups;

  		// morphs

  		for ( var name in geometry.morphTargets ) {

  			var array = [];
  			var morphTargets = geometry.morphTargets[ name ];

  			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

  				var morphTarget = morphTargets[ i ];

  				var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
  				attribute.name = morphTarget.name;

  				array.push( attribute.copyVector3sArray( morphTarget.data ) );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// skinning

  		if ( geometry.skinIndices.length > 0 ) {

  			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
  			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

  		}

  		if ( geometry.skinWeights.length > 0 ) {

  			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
  			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

  		}

  		//

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		return this;

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	},

  	computeBoundingSphere: function () {

  		var box = new Box3();
  		var vector = new Vector3();

  		return function computeBoundingSphere() {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere();

  			}

  			var position = this.attributes.position;

  			if ( position ) {

  				var center = this.boundingSphere.center;

  				box.setFromBufferAttribute( position );
  				box.getCenter( center );

  				// hoping to find a boundingSphere with a radius smaller than the
  				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = position.count; i < il; i ++ ) {

  					vector.x = position.getX( i );
  					vector.y = position.getY( i );
  					vector.z = position.getZ( i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  				}

  				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  				if ( isNaN( this.boundingSphere.radius ) ) {

  					console.error( 'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  				}

  			}

  		};

  	}(),

  	computeFaceNormals: function () {

  		// backwards compatibility

  	},

  	computeVertexNormals: function () {

  		var index = this.index;
  		var attributes = this.attributes;

  		if ( attributes.position ) {

  			var positions = attributes.position.array;

  			if ( attributes.normal === undefined ) {

  				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

  			} else {

  				// reset existing normals to zero

  				var array = attributes.normal.array;

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					array[ i ] = 0;

  				}

  			}

  			var normals = attributes.normal.array;

  			var vA, vB, vC;
  			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  			var cb = new Vector3(), ab = new Vector3();

  			// indexed elements

  			if ( index ) {

  				var indices = index.array;

  				for ( var i = 0, il = index.count; i < il; i += 3 ) {

  					vA = indices[ i + 0 ] * 3;
  					vB = indices[ i + 1 ] * 3;
  					vC = indices[ i + 2 ] * 3;

  					pA.fromArray( positions, vA );
  					pB.fromArray( positions, vB );
  					pC.fromArray( positions, vC );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normals[ vA ] += cb.x;
  					normals[ vA + 1 ] += cb.y;
  					normals[ vA + 2 ] += cb.z;

  					normals[ vB ] += cb.x;
  					normals[ vB + 1 ] += cb.y;
  					normals[ vB + 2 ] += cb.z;

  					normals[ vC ] += cb.x;
  					normals[ vC + 1 ] += cb.y;
  					normals[ vC + 2 ] += cb.z;

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

  					pA.fromArray( positions, i );
  					pB.fromArray( positions, i + 3 );
  					pC.fromArray( positions, i + 6 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normals[ i ] = cb.x;
  					normals[ i + 1 ] = cb.y;
  					normals[ i + 2 ] = cb.z;

  					normals[ i + 3 ] = cb.x;
  					normals[ i + 4 ] = cb.y;
  					normals[ i + 5 ] = cb.z;

  					normals[ i + 6 ] = cb.x;
  					normals[ i + 7 ] = cb.y;
  					normals[ i + 8 ] = cb.z;

  				}

  			}

  			this.normalizeNormals();

  			attributes.normal.needsUpdate = true;

  		}

  	},

  	merge: function ( geometry, offset ) {

  		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

  			console.error( 'BufferGeometry.merge(): geometry not an instance of BufferGeometry.', geometry );
  			return;

  		}

  		if ( offset === undefined ) {

  			offset = 0;

  			console.warn(
  				'BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
  				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
  			);

  		}

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			if ( geometry.attributes[ key ] === undefined ) { continue; }

  			var attribute1 = attributes[ key ];
  			var attributeArray1 = attribute1.array;

  			var attribute2 = geometry.attributes[ key ];
  			var attributeArray2 = attribute2.array;

  			var attributeSize = attribute2.itemSize;

  			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

  				attributeArray1[ j ] = attributeArray2[ i ];

  			}

  		}

  		return this;

  	},

  	normalizeNormals: function () {

  		var vector = new Vector3();

  		return function normalizeNormals() {

  			var normals = this.attributes.normal;

  			for ( var i = 0, il = normals.count; i < il; i ++ ) {

  				vector.x = normals.getX( i );
  				vector.y = normals.getY( i );
  				vector.z = normals.getZ( i );

  				vector.normalize();

  				normals.setXYZ( i, vector.x, vector.y, vector.z );

  			}

  		};

  	}(),

  	toNonIndexed: function () {

  		function convertBufferAttribute( attribute, indices ) {

  			var array = attribute.array;
  			var itemSize = attribute.itemSize;

  			var array2 = new array.constructor( indices.length * itemSize );

  			var index = 0, index2 = 0;

  			for ( var i = 0, l = indices.length; i < l; i ++ ) {

  				index = indices[ i ] * itemSize;

  				for ( var j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			return new BufferAttribute( array2, itemSize );

  		}

  		//

  		if ( this.index === null ) {

  			console.warn( 'BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
  			return this;

  		}

  		var geometry2 = new BufferGeometry();

  		var indices = this.index.array;
  		var attributes = this.attributes;

  		// attributes

  		for ( var name in attributes ) {

  			var attribute = attributes[ name ];

  			var newAttribute = convertBufferAttribute( attribute, indices );

  			geometry2.addAttribute( name, newAttribute );

  		}

  		// morph attributes

  		var morphAttributes = this.morphAttributes;

  		for ( name in morphAttributes ) {

  			var morphArray = [];
  			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

  				var attribute = morphAttribute[ i ];

  				var newAttribute = convertBufferAttribute( attribute, indices );

  				morphArray.push( newAttribute );

  			}

  			geometry2.morphAttributes[ name ] = morphArray;

  		}

  		// groups

  		var groups = this.groups;

  		for ( var i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			geometry2.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return geometry2;

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }
  		if ( Object.keys( this.userData ).length > 0 ) { data.userData = this.userData; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		data.data = { attributes: {} };

  		var index = this.index;

  		if ( index !== null ) {

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: Array.prototype.slice.call( index.array )
  			};

  		}

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];

  			var attributeData = {
  				itemSize: attribute.itemSize,
  				type: attribute.array.constructor.name,
  				array: Array.prototype.slice.call( attribute.array ),
  				normalized: attribute.normalized
  			};

  			if ( attribute.name !== '' ) { attributeData.name = attribute.name; }

  			data.data.attributes[ key ] = attributeData;

  		}

  		var morphAttributes = {};
  		var hasMorphAttributes = false;

  		for ( var key in this$1.morphAttributes ) {

  			var attributeArray = this$1.morphAttributes[ key ];

  			var array = [];

  			for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

  				var attribute = attributeArray[ i ];

  				var attributeData = {
  					itemSize: attribute.itemSize,
  					type: attribute.array.constructor.name,
  					array: Array.prototype.slice.call( attribute.array ),
  					normalized: attribute.normalized
  				};

  				if ( attribute.name !== '' ) { attributeData.name = attribute.name; }

  				array.push( attributeData );

  			}

  			if ( array.length > 0 ) {

  				morphAttributes[ key ] = array;

  				hasMorphAttributes = true;

  			}

  		}

  		if ( hasMorphAttributes ) { data.data.morphAttributes = morphAttributes; }

  		var groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		var boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	},

  	clone: function () {
  		return new BufferGeometry().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var name, i, l;

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// index

  		var index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		var attributes = source.attributes;

  		for ( name in attributes ) {

  			var attribute = attributes[ name ];
  			this$1.addAttribute( name, attribute.clone() );

  		}

  		// morph attributes

  		var morphAttributes = source.morphAttributes;

  		for ( name in morphAttributes ) {

  			var array = [];
  			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone() );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// groups

  		var groups = source.groups;

  		for ( i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			this$1.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		// user data

  		this.userData = source.userData;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // SphereGeometry

  function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'SphereGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  SphereGeometry.prototype = Object.create( Geometry.prototype );
  SphereGeometry.prototype.constructor = SphereGeometry;

  // SphereBufferGeometry

  function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'SphereBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 1;

  	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  	phiStart = phiStart !== undefined ? phiStart : 0;
  	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  	var thetaEnd = thetaStart + thetaLength;

  	var ix, iy;

  	var index = 0;
  	var grid = [];

  	var vertex = new Vector3();
  	var normal = new Vector3();

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy <= heightSegments; iy ++ ) {

  		var verticesRow = [];

  		var v = iy / heightSegments;

  		for ( ix = 0; ix <= widthSegments; ix ++ ) {

  			var u = ix / widthSegments;

  			// vertex

  			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, 1 - v );

  			verticesRow.push( index ++ );

  		}

  		grid.push( verticesRow );

  	}

  	// indices

  	for ( iy = 0; iy < heightSegments; iy ++ ) {

  		for ( ix = 0; ix < widthSegments; ix ++ ) {

  			var a = grid[ iy ][ ix + 1 ];
  			var b = grid[ iy ][ ix ];
  			var c = grid[ iy + 1 ][ ix ];
  			var d = grid[ iy + 1 ][ ix + 1 ];

  			if ( iy !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }
  			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var materialId = 0;

  function Material$1() {

  	Object.defineProperty( this, 'id', { value: materialId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Material';

  	this.fog = true;
  	this.lights = true;

  	this.blending = NormalBlending;
  	this.side = FrontSide;
  	this.flatShading = false;
  	this.vertexTangents = false;
  	this.vertexColors = NoColors; // NoColors, VertexColors, FaceColors

  	this.opacity = 1;
  	this.transparent = false;

  	this.blendSrc = SrcAlphaFactor;
  	this.blendDst = OneMinusSrcAlphaFactor;
  	this.blendEquation = AddEquation;
  	this.blendSrcAlpha = null;
  	this.blendDstAlpha = null;
  	this.blendEquationAlpha = null;

  	this.depthFunc = LessEqualDepth;
  	this.depthTest = true;
  	this.depthWrite = true;

  	this.clippingPlanes = null;
  	this.clipIntersection = false;
  	this.clipShadows = false;

  	this.shadowSide = null;

  	this.colorWrite = true;

  	this.precision = null; // override the renderer's default precision for this material

  	this.polygonOffset = false;
  	this.polygonOffsetFactor = 0;
  	this.polygonOffsetUnits = 0;

  	this.dithering = false;

  	this.alphaTest = 0;
  	this.premultipliedAlpha = false;

  	this.visible = true;

  	this.userData = {};

  	this.needsUpdate = true;

  }

  Material$1.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: Material$1,

  	isMaterial: true,

  	onBeforeCompile: function () {},

  	setValues: function ( values ) {
  		var this$1 = this;


  		if ( values === undefined ) { return; }

  		for ( var key in values ) {

  			var newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( "Material: '" + key + "' parameter is undefined." );
  				continue;

  			}

  			// for backward compatability if shading is set in the constructor
  			if ( key === 'shading' ) {

  				console.warn( '' + this$1.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  				this$1.flatShading = ( newValue === FlatShading ) ? true : false;
  				continue;

  			}

  			var currentValue = this$1[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( "" + this$1.type + ": '" + key + "' is not a property of this material." );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else {

  				this$1[ key ] = newValue;

  			}

  		}

  	},

  	toJSON: function ( meta ) {

  		var isRoot = ( meta === undefined || typeof meta === 'string' );

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

  		if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
  		if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

  		if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
  		if ( this.emissiveIntensity !== 1 ) { data.emissiveIntensity = this.emissiveIntensity; }

  		if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
  		if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
  		if ( this.clearCoat !== undefined ) { data.clearCoat = this.clearCoat; }
  		if ( this.clearCoatRoughness !== undefined ) { data.clearCoatRoughness = this.clearCoatRoughness; }

  		if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
  		if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }
  		if ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }

  		if ( this.aoMap && this.aoMap.isTexture ) {

  			data.aoMap = this.aoMap.toJSON( meta ).uuid;
  			data.aoMapIntensity = this.aoMapIntensity;

  		}

  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}

  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalMapType = this.normalMapType;
  			data.normalScale = this.normalScale.toArray();

  		}

  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}

  		if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
  		if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;
  			data.reflectivity = this.reflectivity; // Scale behind envMap

  			if ( this.combine !== undefined ) { data.combine = this.combine; }
  			if ( this.envMapIntensity !== undefined ) { data.envMapIntensity = this.envMapIntensity; }

  		}

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.size !== undefined ) { data.size = this.size; }
  		if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

  		if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
  		if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
  		if ( this.side !== FrontSide ) { data.side = this.side; }
  		if ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }

  		if ( this.opacity < 1 ) { data.opacity = this.opacity; }
  		if ( this.transparent === true ) { data.transparent = this.transparent; }

  		data.depthFunc = this.depthFunc;
  		data.depthTest = this.depthTest;
  		data.depthWrite = this.depthWrite;

  		// rotation (SpriteMaterial)
  		if ( this.rotation !== 0 ) { data.rotation = this.rotation; }

  		if ( this.polygonOffset === true ) { data.polygonOffset = true; }
  		if ( this.polygonOffsetFactor !== 0 ) { data.polygonOffsetFactor = this.polygonOffsetFactor; }
  		if ( this.polygonOffsetUnits !== 0 ) { data.polygonOffsetUnits = this.polygonOffsetUnits; }

  		if ( this.linewidth !== 1 ) { data.linewidth = this.linewidth; }
  		if ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }
  		if ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }
  		if ( this.scale !== undefined ) { data.scale = this.scale; }

  		if ( this.dithering === true ) { data.dithering = true; }

  		if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
  		if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

  		if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
  		if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
  		if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
  		if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

  		if ( this.morphTargets === true ) { data.morphTargets = true; }
  		if ( this.skinning === true ) { data.skinning = true; }

  		if ( this.visible === false ) { data.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			var values = [];

  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) { data.textures = textures; }
  			if ( images.length > 0 ) { data.images = images; }

  		}

  		return data;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.fog = source.fog;
  		this.lights = source.lights;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.flatShading = source.flatShading;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.premultipliedAlpha = source.premultipliedAlpha;

  		this.visible = source.visible;
  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.clipShadows = source.clipShadows;
  		this.clipIntersection = source.clipIntersection;

  		var srcPlanes = source.clippingPlanes,
  			dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			var n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( var i = 0; i !== n; ++ i )
  				{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }

  		}

  		this.clippingPlanes = dstPlanes;

  		this.shadowSide = source.shadowSide;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshBasicMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshBasicMaterial';

  	this.color = new Color( 0xffffff ); // emissive

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshBasicMaterial.prototype = Object.create( Material$1.prototype );
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineBasicMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'LineBasicMaterial';

  	this.color = new Color( 0xffffff );

  	this.linewidth = 1;
  	this.linecap = 'round';
  	this.linejoin = 'round';

  	this.lights = false;

  	this.setValues( parameters );

  }

  LineBasicMaterial.prototype = Object.create( Material$1.prototype );
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;

  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  LineBasicMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;
  	this.linecap = source.linecap;
  	this.linejoin = source.linejoin;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Ray( origin, direction ) {

  	this.origin = ( origin !== undefined ) ? origin : new Vector3();
  	this.direction = ( direction !== undefined ) ? direction : new Vector3();

  }

  Object.assign( Ray.prototype, {

  	set: function ( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	},

  	at: function ( t, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Ray: .at() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  	},

  	lookAt: function ( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	},

  	recast: function () {

  		var v1 = new Vector3();

  		return function recast( t ) {

  			this.origin.copy( this.at( t, v1 ) );

  			return this;

  		};

  	}(),

  	closestPointToPoint: function ( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Ray: .closestPointToPoint() target is now required' );
  			target = new Vector3();

  		}

  		target.subVectors( point, this.origin );

  		var directionDistance = target.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return target.copy( this.origin );

  		}

  		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  	},

  	distanceToPoint: function ( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	},

  	distanceSqToPoint: function () {

  		var v1 = new Vector3();

  		return function distanceSqToPoint( point ) {

  			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

  			// point behind the ray

  			if ( directionDistance < 0 ) {

  				return this.origin.distanceToSquared( point );

  			}

  			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  			return v1.distanceToSquared( point );

  		};

  	}(),

  	distanceSqToSegment: function () {

  		var segCenter = new Vector3();
  		var segDir = new Vector3();
  		var diff = new Vector3();

  		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  			// It returns the min distance between the ray and the segment
  			// defined by v0 and v1
  			// It can also set two optional targets :
  			// - The closest point on the ray
  			// - The closest point on the segment

  			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  			segDir.copy( v1 ).sub( v0 ).normalize();
  			diff.copy( this.origin ).sub( segCenter );

  			var segExtent = v0.distanceTo( v1 ) * 0.5;
  			var a01 = - this.direction.dot( segDir );
  			var b0 = diff.dot( this.direction );
  			var b1 = - diff.dot( segDir );
  			var c = diff.lengthSq();
  			var det = Math.abs( 1 - a01 * a01 );
  			var s0, s1, sqrDist, extDet;

  			if ( det > 0 ) {

  				// The ray and segment are not parallel.

  				s0 = a01 * b1 - b0;
  				s1 = a01 * b0 - b1;
  				extDet = segExtent * det;

  				if ( s0 >= 0 ) {

  					if ( s1 >= - extDet ) {

  						if ( s1 <= extDet ) {

  							// region 0
  							// Minimum at interior points of ray and segment.

  							var invDet = 1 / det;
  							s0 *= invDet;
  							s1 *= invDet;
  							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  						} else {

  							// region 1

  							s1 = segExtent;
  							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					} else {

  						// region 5

  						s1 = - segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					if ( s1 <= - extDet ) {

  						// region 4

  						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					} else if ( s1 <= extDet ) {

  						// region 3

  						s0 = 0;
  						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  					} else {

  						// region 2

  						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				}

  			} else {

  				// Ray and segment are parallel.

  				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  			}

  			if ( optionalPointOnRay ) {

  				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  			}

  			if ( optionalPointOnSegment ) {

  				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

  			}

  			return sqrDist;

  		};

  	}(),

  	intersectSphere: function () {

  		var v1 = new Vector3();

  		return function intersectSphere( sphere, target ) {

  			v1.subVectors( sphere.center, this.origin );
  			var tca = v1.dot( this.direction );
  			var d2 = v1.dot( v1 ) - tca * tca;
  			var radius2 = sphere.radius * sphere.radius;

  			if ( d2 > radius2 ) { return null; }

  			var thc = Math.sqrt( radius2 - d2 );

  			// t0 = first intersect point - entrance on front of sphere
  			var t0 = tca - thc;

  			// t1 = second intersect point - exit point on back of sphere
  			var t1 = tca + thc;

  			// test to see if both t0 and t1 are behind the ray - if so, return null
  			if ( t0 < 0 && t1 < 0 ) { return null; }

  			// test to see if t0 is behind the ray:
  			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  			// in order to always return an intersect point that is in front of the ray.
  			if ( t0 < 0 ) { return this.at( t1, target ); }

  			// else t0 is in front of the ray, so return the first collision point scaled by t0
  			return this.at( t0, target );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  	},

  	distanceToPlane: function ( plane ) {

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	},

  	intersectPlane: function ( plane, target ) {

  		var t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, target );

  	},

  	intersectsPlane: function ( plane ) {

  		// check if the ray lies on the plane first

  		var distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	},

  	intersectBox: function ( box, target ) {

  		var tmin, tmax, tymin, tymax, tzmin, tzmax;

  		var invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		var origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

  		// These lines also handle the case where tmin or tmax is NaN
  		// (result of 0 * Infinity). x !== x returns true if x is NaN

  		if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

  		if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

  		if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

  		if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) { return null; }

  		return this.at( tmin >= 0 ? tmin : tmax, target );

  	},

  	intersectsBox: ( function () {

  		var v = new Vector3();

  		return function intersectsBox( box ) {

  			return this.intersectBox( box, v ) !== null;

  		};

  	} )(),

  	intersectTriangle: function () {

  		// Compute the offset origin, edges, and normal.
  		var diff = new Vector3();
  		var edge1 = new Vector3();
  		var edge2 = new Vector3();
  		var normal = new Vector3();

  		return function intersectTriangle( a, b, c, backfaceCulling, target ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  			edge1.subVectors( b, a );
  			edge2.subVectors( c, a );
  			normal.crossVectors( edge1, edge2 );

  			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  			var DdN = this.direction.dot( normal );
  			var sign;

  			if ( DdN > 0 ) {

  				if ( backfaceCulling ) { return null; }
  				sign = 1;

  			} else if ( DdN < 0 ) {

  				sign = - 1;
  				DdN = - DdN;

  			} else {

  				return null;

  			}

  			diff.subVectors( this.origin, a );
  			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

  			// b1 < 0, no intersection
  			if ( DdQxE2 < 0 ) {

  				return null;

  			}

  			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

  			// b2 < 0, no intersection
  			if ( DdE1xQ < 0 ) {

  				return null;

  			}

  			// b1+b2 > 1, no intersection
  			if ( DdQxE2 + DdE1xQ > DdN ) {

  				return null;

  			}

  			// Line intersects triangle, check if ray does.
  			var QdN = - sign * diff.dot( normal );

  			// t < 0, no intersection
  			if ( QdN < 0 ) {

  				return null;

  			}

  			// Ray intersects triangle.
  			return this.at( QdN / DdN, target );

  		};

  	}(),

  	applyMatrix4: function ( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	},

  	equals: function ( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Triangle( a, b, c ) {

  	this.a = ( a !== undefined ) ? a : new Vector3();
  	this.b = ( b !== undefined ) ? b : new Vector3();
  	this.c = ( c !== undefined ) ? c : new Vector3();

  }

  Object.assign( Triangle, {

  	getNormal: function () {

  		var v0 = new Vector3();

  		return function getNormal( a, b, c, target ) {

  			if ( target === undefined ) {

  				console.warn( 'Triangle: .getNormal() target is now required' );
  				target = new Vector3();

  			}

  			target.subVectors( c, b );
  			v0.subVectors( a, b );
  			target.cross( v0 );

  			var targetLengthSq = target.lengthSq();
  			if ( targetLengthSq > 0 ) {

  				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  			}

  			return target.set( 0, 0, 0 );

  		};

  	}(),

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	getBarycoord: function () {

  		var v0 = new Vector3();
  		var v1 = new Vector3();
  		var v2 = new Vector3();

  		return function getBarycoord( point, a, b, c, target ) {

  			v0.subVectors( c, a );
  			v1.subVectors( b, a );
  			v2.subVectors( point, a );

  			var dot00 = v0.dot( v0 );
  			var dot01 = v0.dot( v1 );
  			var dot02 = v0.dot( v2 );
  			var dot11 = v1.dot( v1 );
  			var dot12 = v1.dot( v2 );

  			var denom = ( dot00 * dot11 - dot01 * dot01 );

  			if ( target === undefined ) {

  				console.warn( 'Triangle: .getBarycoord() target is now required' );
  				target = new Vector3();

  			}

  			// collinear or singular triangle
  			if ( denom === 0 ) {

  				// arbitrary location outside of triangle?
  				// not sure if this is the best idea, maybe should be returning undefined
  				return target.set( - 2, - 1, - 1 );

  			}

  			var invDenom = 1 / denom;
  			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  			// barycentric coordinates must always sum to 1
  			return target.set( 1 - u - v, v, u );

  		};

  	}(),

  	containsPoint: function () {

  		var v1 = new Vector3();

  		return function containsPoint( point, a, b, c ) {

  			Triangle.getBarycoord( point, a, b, c, v1 );

  			return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

  		};

  	}(),

  	getUV: function () {

  		var barycoord = new Vector3();

  		return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

  			this.getBarycoord( point, p1, p2, p3, barycoord );

  			target.set( 0, 0 );
  			target.addScaledVector( uv1, barycoord.x );
  			target.addScaledVector( uv2, barycoord.y );
  			target.addScaledVector( uv3, barycoord.z );

  			return target;

  		};

  	}()

  } );

  Object.assign( Triangle.prototype, {

  	set: function ( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	},

  	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	},

  	getArea: function () {

  		var v0 = new Vector3();
  		var v1 = new Vector3();

  		return function getArea() {

  			v0.subVectors( this.c, this.b );
  			v1.subVectors( this.a, this.b );

  			return v0.cross( v1 ).length() * 0.5;

  		};

  	}(),

  	getMidpoint: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Triangle: .getMidpoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	},

  	getNormal: function ( target ) {

  		return Triangle.getNormal( this.a, this.b, this.c, target );

  	},

  	getPlane: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Triangle: .getPlane() target is now required' );
  			target = new Vector3();

  		}

  		return target.setFromCoplanarPoints( this.a, this.b, this.c );

  	},

  	getBarycoord: function ( point, target ) {

  		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  	},

  	containsPoint: function ( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	},

  	getUV: function ( point, uv1, uv2, uv3, result ) {

  		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsTriangle( this );

  	},

  	closestPointToPoint: function () {

  		var vab = new Vector3();
  		var vac = new Vector3();
  		var vbc = new Vector3();
  		var vap = new Vector3();
  		var vbp = new Vector3();
  		var vcp = new Vector3();

  		return function closestPointToPoint( p, target ) {

  			if ( target === undefined ) {

  				console.warn( 'Triangle: .closestPointToPoint() target is now required' );
  				target = new Vector3();

  			}

  			var a = this.a, b = this.b, c = this.c;
  			var v, w;

  			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  			// basically, we're distinguishing which of the voronoi regions of the triangle
  			// the point lies in with the minimum amount of redundant computation.

  			vab.subVectors( b, a );
  			vac.subVectors( c, a );
  			vap.subVectors( p, a );
  			var d1 = vab.dot( vap );
  			var d2 = vac.dot( vap );
  			if ( d1 <= 0 && d2 <= 0 ) {

  				// vertex region of A; barycentric coords (1, 0, 0)
  				return target.copy( a );

  			}

  			vbp.subVectors( p, b );
  			var d3 = vab.dot( vbp );
  			var d4 = vac.dot( vbp );
  			if ( d3 >= 0 && d4 <= d3 ) {

  				// vertex region of B; barycentric coords (0, 1, 0)
  				return target.copy( b );

  			}

  			var vc = d1 * d4 - d3 * d2;
  			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  				v = d1 / ( d1 - d3 );
  				// edge region of AB; barycentric coords (1-v, v, 0)
  				return target.copy( a ).addScaledVector( vab, v );

  			}

  			vcp.subVectors( p, c );
  			var d5 = vab.dot( vcp );
  			var d6 = vac.dot( vcp );
  			if ( d6 >= 0 && d5 <= d6 ) {

  				// vertex region of C; barycentric coords (0, 0, 1)
  				return target.copy( c );

  			}

  			var vb = d5 * d2 - d1 * d6;
  			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  				w = d2 / ( d2 - d6 );
  				// edge region of AC; barycentric coords (1-w, 0, w)
  				return target.copy( a ).addScaledVector( vac, w );

  			}

  			var va = d3 * d6 - d5 * d4;
  			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  				vbc.subVectors( c, b );
  				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  				// edge region of BC; barycentric coords (0, 1-w, w)
  				return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

  			}

  			// face region
  			var denom = 1 / ( va + vb + vc );
  			// u = va * denom
  			v = vb * denom;
  			w = vc * denom;
  			return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

  		};

  	}(),

  	equals: function ( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Mesh( geometry, material ) {

  	Object3D.call( this );

  	this.type = 'Mesh';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  	this.drawMode = TrianglesDrawMode;

  	this.updateMorphTargets();

  }

  Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Mesh,

  	isMesh: true,

  	setDrawMode: function ( value ) {

  		this.drawMode = value;

  	},

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		this.drawMode = source.drawMode;

  		if ( source.morphTargetInfluences !== undefined ) {

  			this.morphTargetInfluences = source.morphTargetInfluences.slice();

  		}

  		if ( source.morphTargetDictionary !== undefined ) {

  			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  		}

  		return this;

  	},

  	updateMorphTargets: function () {
  		var this$1 = this;


  		var geometry = this.geometry;
  		var m, ml, name;

  		if ( geometry.isBufferGeometry ) {

  			var morphAttributes = geometry.morphAttributes;
  			var keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				var morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						name = morphAttribute[ m ].name || String( m );

  						this$1.morphTargetInfluences.push( 0 );
  						this$1.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			var morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				console.error( 'Mesh.updateMorphTargets() no longer supports Geometry. Use BufferGeometry instead.' );

  			}

  		}

  	},

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		var vA = new Vector3();
  		var vB = new Vector3();
  		var vC = new Vector3();

  		var tempA = new Vector3();
  		var tempB = new Vector3();
  		var tempC = new Vector3();

  		var uvA = new Vector2();
  		var uvB = new Vector2();
  		var uvC = new Vector2();

  		var intersectionPoint = new Vector3();
  		var intersectionPointWorld = new Vector3();

  		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

  			var intersect;

  			if ( material.side === BackSide ) {

  				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  			} else {

  				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

  			}

  			if ( intersect === null ) { return null; }

  			intersectionPointWorld.copy( point );
  			intersectionPointWorld.applyMatrix4( object.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

  			return {
  				distance: distance,
  				point: intersectionPointWorld.clone(),
  				object: object
  			};

  		}

  		function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {

  			vA.fromBufferAttribute( position, a );
  			vB.fromBufferAttribute( position, b );
  			vC.fromBufferAttribute( position, c );

  			var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

  			if ( intersection ) {

  				if ( uv ) {

  					uvA.fromBufferAttribute( uv, a );
  					uvB.fromBufferAttribute( uv, b );
  					uvC.fromBufferAttribute( uv, c );

  					intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );

  				}

  				var face = new Face3( a, b, c );
  				Triangle.getNormal( vA, vB, vC, face.normal );

  				intersection.face = face;

  			}

  			return intersection;

  		}

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var geometry = this.geometry;
  			var material = this.material;
  			var matrixWorld = this.matrixWorld;

  			if ( material === undefined ) { return; }

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			// Check boundingBox before continuing

  			if ( geometry.boundingBox !== null ) {

  				if ( ray.intersectsBox( geometry.boundingBox ) === false ) { return; }

  			}

  			var intersection;

  			if ( geometry.isBufferGeometry ) {

  				var a, b, c;
  				var index = geometry.index;
  				var position = geometry.attributes.position;
  				var uv = geometry.attributes.uv;
  				var groups = geometry.groups;
  				var drawRange = geometry.drawRange;
  				var i, j, il, jl;
  				var group, groupMaterial;
  				var start, end;

  				if ( index !== null ) {

  					// indexed buffer geometry

  					if ( Array.isArray( material ) ) {

  						for ( i = 0, il = groups.length; i < il; i ++ ) {

  							group = groups[ i ];
  							groupMaterial = material[ group.materialIndex ];

  							start = Math.max( group.start, drawRange.start );
  							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  							for ( j = start, jl = end; j < jl; j += 3 ) {

  								a = index.getX( j );
  								b = index.getX( j + 1 );
  								c = index.getX( j + 2 );

  								intersection = checkBufferGeometryIntersection( this$1, groupMaterial, raycaster, ray, position, uv, a, b, c );

  								if ( intersection ) {

  									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  									intersection.face.materialIndex = group.materialIndex;
  									intersects.push( intersection );

  								}

  							}

  						}

  					} else {

  						start = Math.max( 0, drawRange.start );
  						end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  						for ( i = start, il = end; i < il; i += 3 ) {

  							a = index.getX( i );
  							b = index.getX( i + 1 );
  							c = index.getX( i + 2 );

  							intersection = checkBufferGeometryIntersection( this$1, material, raycaster, ray, position, uv, a, b, c );

  							if ( intersection ) {

  								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  								intersects.push( intersection );

  							}

  						}

  					}

  				} else if ( position !== undefined ) {

  					// non-indexed buffer geometry

  					if ( Array.isArray( material ) ) {

  						for ( i = 0, il = groups.length; i < il; i ++ ) {

  							group = groups[ i ];
  							groupMaterial = material[ group.materialIndex ];

  							start = Math.max( group.start, drawRange.start );
  							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  							for ( j = start, jl = end; j < jl; j += 3 ) {

  								a = j;
  								b = j + 1;
  								c = j + 2;

  								intersection = checkBufferGeometryIntersection( this$1, groupMaterial, raycaster, ray, position, uv, a, b, c );

  								if ( intersection ) {

  									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  									intersection.face.materialIndex = group.materialIndex;
  									intersects.push( intersection );

  								}

  							}

  						}

  					} else {

  						start = Math.max( 0, drawRange.start );
  						end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  						for ( i = start, il = end; i < il; i += 3 ) {

  							a = i;
  							b = i + 1;
  							c = i + 2;

  							intersection = checkBufferGeometryIntersection( this$1, material, raycaster, ray, position, uv, a, b, c );

  							if ( intersection ) {

  								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  								intersects.push( intersection );

  							}

  						}

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var fvA, fvB, fvC;
  				var isMultiMaterial = Array.isArray( material );

  				var vertices = geometry.vertices;
  				var faces = geometry.faces;
  				var uvs;

  				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  				if ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }

  				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  					var face = faces[ f ];
  					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

  					if ( faceMaterial === undefined ) { continue; }

  					fvA = vertices[ face.a ];
  					fvB = vertices[ face.b ];
  					fvC = vertices[ face.c ];

  					if ( faceMaterial.morphTargets === true ) {

  						var morphTargets = geometry.morphTargets;
  						var morphInfluences = this$1.morphTargetInfluences;

  						vA.set( 0, 0, 0 );
  						vB.set( 0, 0, 0 );
  						vC.set( 0, 0, 0 );

  						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  							var influence = morphInfluences[ t ];

  							if ( influence === 0 ) { continue; }

  							var targets = morphTargets[ t ].vertices;

  							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
  							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
  							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

  						}

  						vA.add( fvA );
  						vB.add( fvB );
  						vC.add( fvC );

  						fvA = vA;
  						fvB = vB;
  						fvC = vC;

  					}

  					intersection = checkIntersection( this$1, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

  					if ( intersection ) {

  						if ( uvs && uvs[ f ] ) {

  							var uvs_f = uvs[ f ];
  							uvA.copy( uvs_f[ 0 ] );
  							uvB.copy( uvs_f[ 1 ] );
  							uvC.copy( uvs_f[ 2 ] );

  							intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );

  						}

  						intersection.face = face;
  						intersection.faceIndex = f;
  						intersects.push( intersection );

  					}

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Line( geometry, material, mode ) {

  	if ( mode === 1 ) {

  		console.error( 'Line: parameter LinePieces no longer supported. Use LineSegments instead.' );

  	}

  	Object3D.call( this );

  	this.type = 'Line';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

  }

  Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Line,

  	isLine: true,

  	computeLineDistances: ( function () {

  		var start = new Vector3();
  		var end = new Vector3();

  		return function computeLineDistances() {

  			var geometry = this.geometry;

  			if ( geometry.isBufferGeometry ) {

  				// we assume non-indexed geometry

  				if ( geometry.index === null ) {

  					var positionAttribute = geometry.attributes.position;
  					var lineDistances = [ 0 ];

  					for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

  						start.fromBufferAttribute( positionAttribute, i - 1 );
  						end.fromBufferAttribute( positionAttribute, i );

  						lineDistances[ i ] = lineDistances[ i - 1 ];
  						lineDistances[ i ] += start.distanceTo( end );

  					}

  					geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  				} else {

  					console.warn( 'Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var lineDistances = geometry.lineDistances;

  				lineDistances[ 0 ] = 0;

  				for ( var i = 1, l = vertices.length; i < l; i ++ ) {

  					lineDistances[ i ] = lineDistances[ i - 1 ];
  					lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

  				}

  			}

  			return this;

  		};

  	}() ),

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var precision = raycaster.linePrecision;

  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );
  			sphere.radius += precision;

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  			var localPrecisionSq = localPrecision * localPrecision;

  			var vStart = new Vector3();
  			var vEnd = new Vector3();
  			var interSegment = new Vector3();
  			var interRay = new Vector3();
  			var step = ( this && this.isLineSegments ) ? 2 : 1;

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

  						var a = indices[ i ];
  						var b = indices[ i + 1 ];

  						vStart.fromArray( positions, a * 3 );
  						vEnd.fromArray( positions, b * 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > localPrecisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

  						vStart.fromArray( positions, 3 * i );
  						vEnd.fromArray( positions, 3 * i + 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > localPrecisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var nbVertices = vertices.length;

  				for ( var i = 0; i < nbVertices - 1; i += step ) {

  					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

  					if ( distSq > localPrecisionSq ) { continue; }

  					interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  					var distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this$1

  					} );

  				}

  			}

  		};

  	}() ),

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		this.geometry.copy( source.geometry );
  		this.material.copy( source.material );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CCDIKSolver = ( function () {
  	function CCDIKSolver( mesh, iks ) {

  		this.mesh = mesh;
  		this.iks = iks || [];

  		this._valid();

  	}

  	CCDIKSolver.prototype = {

  		constructor: CCDIKSolver,
  		update: function () {

  			var q = new Quaternion();
  			var targetPos = new Vector3();
  			var targetVec = new Vector3();
  			var effectorPos = new Vector3();
  			var effectorVec = new Vector3();
  			var linkPos = new Vector3();
  			var invLinkQ = new Quaternion();
  			var linkScale = new Vector3();
  			var axis = new Vector3();
  			var vector = new Vector3();

  			return function update() {

  				var bones = this.mesh.skeleton.bones;
  				var iks = this.iks;

  				// for reference overhead reduction in loop
  				var math = Math;

  				for ( var i = 0, il = iks.length; i < il; i++ ) {

  					var ik = iks[ i ];
  					var effector = bones[ ik.effector ];
  					var target = bones[ ik.target ];

  					// don't use getWorldPosition() here for the performance
  					// because it calls updateMatrixWorld( true ) inside.
  					targetPos.setFromMatrixPosition( target.matrixWorld );

  					var links = ik.links;
  					var iteration = ik.iteration !== undefined ? ik.iteration : 1;

  					for ( var j = 0; j < iteration; j++ ) {

  						var rotated = false;

  						for ( var k = 0, kl = links.length; k < kl; k++ ) {

  							var link = bones[ links[ k ].index ];

  							// skip this link and following links.
  							// this skip is used for MMD performance optimization.
  							if ( links[ k ].enabled === false ) { break; }

  							var limitation = links[ k ].limitation;
  							var rotationMin = links[ k ].rotationMin;
  							var rotationMax = links[ k ].rotationMax;

  							// don't use getWorldPosition/Quaternion() here for the performance
  							// because they call updateMatrixWorld( true ) inside.
  							link.matrixWorld.decompose( linkPos, invLinkQ, linkScale );
  							invLinkQ.inverse();
  							effectorPos.setFromMatrixPosition( effector.matrixWorld );

  							// work in link world
  							effectorVec.subVectors( effectorPos, linkPos );
  							effectorVec.applyQuaternion( invLinkQ );
  							effectorVec.normalize();

  							targetVec.subVectors( targetPos, linkPos );
  							targetVec.applyQuaternion( invLinkQ );
  							targetVec.normalize();

  							var angle = targetVec.dot( effectorVec );

  							if ( angle > 1.0 ) {

  								angle = 1.0;

  							} else if ( angle < -1.0 ) {

  								angle = -1.0;

  							}

  							angle = math.acos( angle );

  							// skip if changing angle is too small to prevent vibration of bone
  							// Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js
  							if ( angle < 1e-5 ) { continue; }

  							if ( ik.minAngle !== undefined && angle < ik.minAngle ) {

  								angle = ik.minAngle;

  							}

  							if ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {

  								angle = ik.maxAngle;

  							}

  							axis.crossVectors( effectorVec, targetVec );
  							axis.normalize();

  							q.setFromAxisAngle( axis, angle );
  							link.quaternion.multiply( q );

  							// TODO: re-consider the limitation specification
  							if ( limitation !== undefined ) {

  								var c = link.quaternion.w;

  								if ( c > 1.0 ) { c = 1.0; }

  								var c2 = math.sqrt( 1 - c * c );
  								link.quaternion.set( limitation.x * c2,
  								                     limitation.y * c2,
  								                     limitation.z * c2,
  								                     c );

  							}

  							if ( rotationMin !== undefined ) {

  								link.rotation.setFromVector3(
  									link.rotation
  										.toVector3( vector )
  										.max( rotationMin ) );

  							}

  							if ( rotationMax !== undefined ) {

  								link.rotation.setFromVector3(
  									link.rotation
  										.toVector3( vector )
  										.min( rotationMax ) );

  							}

  							link.updateMatrixWorld( true );

  							rotated = true;

  						}

  						if ( ! rotated ) { break; }

  					}

  				}

  				return this;

  			};

  		}(),
  		createHelper: function () {

  			return new CCDIKHelper( this.mesh, this.mesh.geometry.userData.MMD.iks );

  		},

  		// private methods

  		_valid: function () {

  			var iks = this.iks;
  			var bones = this.mesh.skeleton.bones;

  			for ( var i = 0, il = iks.length; i < il; i ++ ) {

  				var ik = iks[ i ];
  				var effector = bones[ ik.effector ];
  				var links = ik.links;
  				var link0, link1;

  				link0 = effector;

  				for ( var j = 0, jl = links.length; j < jl; j ++ ) {

  					link1 = bones[ links[ j ].index ];

  					if ( link0.parent !== link1 ) {

  						console.warn( 'CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name );

  					}

  					link0 = link1;

  				}

  			}

  		}

  	};
  	function CCDIKHelper( mesh, iks ) {

  		Object3D.call( this );

  		this.root = mesh;
  		this.iks = iks || [];

  		this.matrix.copy( mesh.matrixWorld );
  		this.matrixAutoUpdate = false;

  		this.sphereGeometry = new SphereBufferGeometry( 0.25, 16, 8 );

  		this.targetSphereMaterial = new MeshBasicMaterial( {
  			color: new Color( 0xff8888 ),
  			depthTest: false,
  			depthWrite: false,
  			transparent: true
  		} );

  		this.effectorSphereMaterial = new MeshBasicMaterial( {
  			color: new Color( 0x88ff88 ),
  			depthTest: false,
  			depthWrite: false,
  			transparent: true
  		} );

  		this.linkSphereMaterial = new MeshBasicMaterial( {
  			color: new Color( 0x8888ff ),
  			depthTest: false,
  			depthWrite: false,
  			transparent: true
  		} );

  		this.lineMaterial = new LineBasicMaterial( {
  			color: new Color( 0xff0000 ),
  			depthTest: false,
  			depthWrite: false,
  			transparent: true
  		} );

  		this._init();

  	}

  	CCDIKHelper.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: CCDIKHelper,
  		updateMatrixWorld: function () {

  			var matrix = new Matrix4();
  			var vector = new Vector3();

  			function getPosition( bone, matrixWorldInv ) {

  				return vector
  					.setFromMatrixPosition( bone.matrixWorld )
  					.applyMatrix4( matrixWorldInv );

  			}

  			function setPositionOfBoneToAttributeArray( array, index, bone, matrixWorldInv ) {

  				var v = getPosition( bone, matrixWorldInv );

  				array[ index * 3 + 0 ] = v.x;
  				array[ index * 3 + 1 ] = v.y;
  				array[ index * 3 + 2 ] = v.z;

  			}

  			return function updateMatrixWorld( force ) {
  				var this$1 = this;


  				var mesh = this.root;

  				if ( this.visible ) {

  					var offset = 0;

  					var iks = this.iks;
  					var bones = mesh.skeleton.bones;

  					matrix.getInverse( mesh.matrixWorld );

  					for ( var i = 0, il = iks.length; i < il; i ++ ) {

  						var ik = iks[ i ];

  						var targetBone = bones[ ik.target ];
  						var effectorBone = bones[ ik.effector ];

  						var targetMesh = this$1.children[ offset ++ ];
  						var effectorMesh = this$1.children[ offset ++ ];

  						targetMesh.position.copy( getPosition( targetBone, matrix ) );
  						effectorMesh.position.copy( getPosition( effectorBone, matrix ) );

  						for ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {

  							var link = ik.links[ j ];
  							var linkBone = bones[ link.index ];

  							var linkMesh = this$1.children[ offset ++ ];

  							linkMesh.position.copy( getPosition( linkBone, matrix ) );

  						}

  						var line = this$1.children[ offset ++ ];
  						var array = line.geometry.attributes.position.array;

  						setPositionOfBoneToAttributeArray( array, 0, targetBone, matrix );
  						setPositionOfBoneToAttributeArray( array, 1, effectorBone, matrix );

  						for ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {

  							var link = ik.links[ j ];
  							var linkBone = bones[ link.index ];
  							setPositionOfBoneToAttributeArray( array, j + 2, linkBone, matrix );

  						}

  						line.geometry.attributes.position.needsUpdate = true;

  					}

  				}

  				this.matrix.copy( mesh.matrixWorld );

  				Object3D.prototype.updateMatrixWorld.call( this, force );

  			};

  		}(),

  		// private method

  		_init: function () {
  			var this$1 = this;


  			var self = this;
  			var iks = this.iks;

  			function createLineGeometry( ik ) {

  				var geometry = new BufferGeometry();
  				var vertices = new Float32Array( ( 2 + ik.links.length ) * 3 );
  				geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );

  				return geometry;

  			}

  			function createTargetMesh() {

  				return new Mesh( self.sphereGeometry, self.targetSphereMaterial );

  			}

  			function createEffectorMesh() {

  				return new Mesh( self.sphereGeometry, self.effectorSphereMaterial );

  			}

  			function createLinkMesh() {

  				return new Mesh( self.sphereGeometry, self.linkSphereMaterial );

  			}

  			function createLine( ik ) {

  				return new Line( createLineGeometry( ik ), self.lineMaterial );

  			}

  			for ( var i = 0, il = iks.length; i < il; i ++ ) {

  				var ik = iks[ i ];

  				this$1.add( createTargetMesh() );
  				this$1.add( createEffectorMesh() );

  				for ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {

  					this$1.add( createLinkMesh() );

  				}

  				this$1.add( createLine( ik ) );

  			}

  		}

  	} );

  	return CCDIKSolver;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AnimationAction( mixer, clip, localRoot ) {

  	this._mixer = mixer;
  	this._clip = clip;
  	this._localRoot = localRoot || null;

  	var tracks = clip.tracks,
  		nTracks = tracks.length,
  		interpolants = new Array( nTracks );

  	var interpolantSettings = {
  		endingStart: ZeroCurvatureEnding,
  		endingEnd: ZeroCurvatureEnding
  	};

  	for ( var i = 0; i !== nTracks; ++ i ) {

  		var interpolant = tracks[ i ].createInterpolant( null );
  		interpolants[ i ] = interpolant;
  		interpolant.settings = interpolantSettings;

  	}

  	this._interpolantSettings = interpolantSettings;

  	this._interpolants = interpolants; // bound by the mixer

  	// inside: PropertyMixer (managed by the mixer)
  	this._propertyBindings = new Array( nTracks );

  	this._cacheIndex = null; // for the memory manager
  	this._byClipCacheIndex = null; // for the memory manager

  	this._timeScaleInterpolant = null;
  	this._weightInterpolant = null;

  	this.loop = LoopRepeat;
  	this._loopCount = - 1;

  	// global mixer time when the action is to be started
  	// it's set back to 'null' upon start of the action
  	this._startTime = null;

  	// scaled local time of the action
  	// gets clamped or wrapped to 0..clip.duration according to loop
  	this.time = 0;

  	this.timeScale = 1;
  	this._effectiveTimeScale = 1;

  	this.weight = 1;
  	this._effectiveWeight = 1;

  	this.repetitions = Infinity; // no. of repetitions when looping

  	this.paused = false; // true -> zero effective time scale
  	this.enabled = true; // false -> zero effective weight

  	this.clampWhenFinished = false;// keep feeding the last frame?

  	this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
  	this.zeroSlopeAtEnd = true;// clips for start, loop and end

  }

  Object.assign( AnimationAction.prototype, {

  	// State & Scheduling

  	play: function () {

  		this._mixer._activateAction( this );

  		return this;

  	},

  	stop: function () {

  		this._mixer._deactivateAction( this );

  		return this.reset();

  	},

  	reset: function () {

  		this.paused = false;
  		this.enabled = true;

  		this.time = 0; // restart clip
  		this._loopCount = - 1;// forget previous loops
  		this._startTime = null;// forget scheduling

  		return this.stopFading().stopWarping();

  	},

  	isRunning: function () {

  		return this.enabled && ! this.paused && this.timeScale !== 0 &&
  			this._startTime === null && this._mixer._isActiveAction( this );

  	},

  	// return true when play has been called
  	isScheduled: function () {

  		return this._mixer._isActiveAction( this );

  	},

  	startAt: function ( time ) {

  		this._startTime = time;

  		return this;

  	},

  	setLoop: function ( mode, repetitions ) {

  		this.loop = mode;
  		this.repetitions = repetitions;

  		return this;

  	},

  	// Weight

  	// set the weight stopping any scheduled fading
  	// although .enabled = false yields an effective weight of zero, this
  	// method does *not* change .enabled, because it would be confusing
  	setEffectiveWeight: function ( weight ) {

  		this.weight = weight;

  		// note: same logic as when updated at runtime
  		this._effectiveWeight = this.enabled ? weight : 0;

  		return this.stopFading();

  	},

  	// return the weight considering fading and .enabled
  	getEffectiveWeight: function () {

  		return this._effectiveWeight;

  	},

  	fadeIn: function ( duration ) {

  		return this._scheduleFading( duration, 0, 1 );

  	},

  	fadeOut: function ( duration ) {

  		return this._scheduleFading( duration, 1, 0 );

  	},

  	crossFadeFrom: function ( fadeOutAction, duration, warp ) {

  		fadeOutAction.fadeOut( duration );
  		this.fadeIn( duration );

  		if ( warp ) {

  			var fadeInDuration = this._clip.duration,
  				fadeOutDuration = fadeOutAction._clip.duration,

  				startEndRatio = fadeOutDuration / fadeInDuration,
  				endStartRatio = fadeInDuration / fadeOutDuration;

  			fadeOutAction.warp( 1.0, startEndRatio, duration );
  			this.warp( endStartRatio, 1.0, duration );

  		}

  		return this;

  	},

  	crossFadeTo: function ( fadeInAction, duration, warp ) {

  		return fadeInAction.crossFadeFrom( this, duration, warp );

  	},

  	stopFading: function () {

  		var weightInterpolant = this._weightInterpolant;

  		if ( weightInterpolant !== null ) {

  			this._weightInterpolant = null;
  			this._mixer._takeBackControlInterpolant( weightInterpolant );

  		}

  		return this;

  	},

  	// Time Scale Control

  	// set the time scale stopping any scheduled warping
  	// although .paused = true yields an effective time scale of zero, this
  	// method does *not* change .paused, because it would be confusing
  	setEffectiveTimeScale: function ( timeScale ) {

  		this.timeScale = timeScale;
  		this._effectiveTimeScale = this.paused ? 0 : timeScale;

  		return this.stopWarping();

  	},

  	// return the time scale considering warping and .paused
  	getEffectiveTimeScale: function () {

  		return this._effectiveTimeScale;

  	},

  	setDuration: function ( duration ) {

  		this.timeScale = this._clip.duration / duration;

  		return this.stopWarping();

  	},

  	syncWith: function ( action ) {

  		this.time = action.time;
  		this.timeScale = action.timeScale;

  		return this.stopWarping();

  	},

  	halt: function ( duration ) {

  		return this.warp( this._effectiveTimeScale, 0, duration );

  	},

  	warp: function ( startTimeScale, endTimeScale, duration ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._timeScaleInterpolant,

  			timeScale = this.timeScale;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._timeScaleInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		times[ 1 ] = now + duration;

  		values[ 0 ] = startTimeScale / timeScale;
  		values[ 1 ] = endTimeScale / timeScale;

  		return this;

  	},

  	stopWarping: function () {

  		var timeScaleInterpolant = this._timeScaleInterpolant;

  		if ( timeScaleInterpolant !== null ) {

  			this._timeScaleInterpolant = null;
  			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  		}

  		return this;

  	},

  	// Object Accessors

  	getMixer: function () {

  		return this._mixer;

  	},

  	getClip: function () {

  		return this._clip;

  	},

  	getRoot: function () {

  		return this._localRoot || this._mixer._root;

  	},

  	// Interna

  	_update: function ( time, deltaTime, timeDirection, accuIndex ) {

  		// called by the mixer

  		if ( ! this.enabled ) {

  			// call ._updateWeight() to update ._effectiveWeight

  			this._updateWeight( time );
  			return;

  		}

  		var startTime = this._startTime;

  		if ( startTime !== null ) {

  			// check for scheduled start of action

  			var timeRunning = ( time - startTime ) * timeDirection;
  			if ( timeRunning < 0 || timeDirection === 0 ) {

  				return; // yet to come / don't decide when delta = 0

  			}

  			// start

  			this._startTime = null; // unschedule
  			deltaTime = timeDirection * timeRunning;

  		}

  		// apply time scale and advance time

  		deltaTime *= this._updateTimeScale( time );
  		var clipTime = this._updateTime( deltaTime );

  		// note: _updateTime may disable the action resulting in
  		// an effective weight of 0

  		var weight = this._updateWeight( time );

  		if ( weight > 0 ) {

  			var interpolants = this._interpolants;
  			var propertyMixers = this._propertyBindings;

  			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

  				interpolants[ j ].evaluate( clipTime );
  				propertyMixers[ j ].accumulate( accuIndex, weight );

  			}

  		}

  	},

  	_updateWeight: function ( time ) {

  		var weight = 0;

  		if ( this.enabled ) {

  			weight = this.weight;
  			var interpolant = this._weightInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				weight *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopFading();

  					if ( interpolantValue === 0 ) {

  						// faded out, disable
  						this.enabled = false;

  					}

  				}

  			}

  		}

  		this._effectiveWeight = weight;
  		return weight;

  	},

  	_updateTimeScale: function ( time ) {

  		var timeScale = 0;

  		if ( ! this.paused ) {

  			timeScale = this.timeScale;

  			var interpolant = this._timeScaleInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				timeScale *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopWarping();

  					if ( timeScale === 0 ) {

  						// motion has halted, pause
  						this.paused = true;

  					} else {

  						// warp done - apply final time scale
  						this.timeScale = timeScale;

  					}

  				}

  			}

  		}

  		this._effectiveTimeScale = timeScale;
  		return timeScale;

  	},

  	_updateTime: function ( deltaTime ) {

  		var time = this.time + deltaTime;
  		var duration = this._clip.duration;
  		var loop = this.loop;
  		var loopCount = this._loopCount;

  		var pingPong = ( loop === LoopPingPong );

  		if ( deltaTime === 0 ) {

  			if ( loopCount === - 1 ) { return time; }

  			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

  		}

  		if ( loop === LoopOnce ) {

  			if ( loopCount === - 1 ) {

  				// just started

  				this._loopCount = 0;
  				this._setEndings( true, true, false );

  			}

  			handle_stop: {

  				if ( time >= duration ) {

  					time = duration;

  				} else if ( time < 0 ) {

  					time = 0;

  				} else { break handle_stop; }

  				if ( this.clampWhenFinished ) { this.paused = true; }
  				else { this.enabled = false; }

  				this._mixer.dispatchEvent( {
  					type: 'finished', action: this,
  					direction: deltaTime < 0 ? - 1 : 1
  				} );

  			}

  		} else { // repetitive Repeat or PingPong

  			if ( loopCount === - 1 ) {

  				// just started

  				if ( deltaTime >= 0 ) {

  					loopCount = 0;

  					this._setEndings( true, this.repetitions === 0, pingPong );

  				} else {

  					// when looping in reverse direction, the initial
  					// transition through zero counts as a repetition,
  					// so leave loopCount at -1

  					this._setEndings( this.repetitions === 0, true, pingPong );

  				}

  			}

  			if ( time >= duration || time < 0 ) {

  				// wrap around

  				var loopDelta = Math.floor( time / duration ); // signed
  				time -= duration * loopDelta;

  				loopCount += Math.abs( loopDelta );

  				var pending = this.repetitions - loopCount;

  				if ( pending <= 0 ) {

  					// have to stop (switch state, clamp time, fire event)

  					if ( this.clampWhenFinished ) { this.paused = true; }
  					else { this.enabled = false; }

  					time = deltaTime > 0 ? duration : 0;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime > 0 ? 1 : - 1
  					} );

  				} else {

  					// keep running

  					if ( pending === 1 ) {

  						// entering the last round

  						var atStart = deltaTime < 0;
  						this._setEndings( atStart, ! atStart, pingPong );

  					} else {

  						this._setEndings( false, false, pingPong );

  					}

  					this._loopCount = loopCount;

  					this._mixer.dispatchEvent( {
  						type: 'loop', action: this, loopDelta: loopDelta
  					} );

  				}

  			}

  			if ( pingPong && ( loopCount & 1 ) === 1 ) {

  				// invert time for the "pong round"

  				this.time = time;
  				return duration - time;

  			}

  		}

  		this.time = time;
  		return time;

  	},

  	_setEndings: function ( atStart, atEnd, pingPong ) {

  		var settings = this._interpolantSettings;

  		if ( pingPong ) {

  			settings.endingStart = ZeroSlopeEnding;
  			settings.endingEnd = ZeroSlopeEnding;

  		} else {

  			// assuming for LoopOnce atStart == atEnd == true

  			if ( atStart ) {

  				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingStart = WrapAroundEnding;

  			}

  			if ( atEnd ) {

  				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingEnd 	 = WrapAroundEnding;

  			}

  		}

  	},

  	_scheduleFading: function ( duration, weightNow, weightThen ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._weightInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._weightInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		values[ 0 ] = weightNow;
  		times[ 1 ] = now + duration;
  		values[ 1 ] = weightThen;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	this.parameterPositions = parameterPositions;
  	this._cachedIndex = 0;

  	this.resultBuffer = resultBuffer !== undefined ?
  		resultBuffer : new sampleValues.constructor( sampleSize );
  	this.sampleValues = sampleValues;
  	this.valueSize = sampleSize;

  }

  Object.assign( Interpolant.prototype, {

  	evaluate: function ( t ) {
  		var this$1 = this;


  		var pp = this.parameterPositions,
  			i1 = this._cachedIndex,

  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				var right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( var giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) { break forward_scan; }

  								// after end

  								i1 = pp.length;
  								this$1._cachedIndex = i1;
  								return this$1.afterEnd_( i1 - 1, t, t0 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						var t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( var giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this$1._cachedIndex = 0;
  								return this$1.beforeStart_( 0, t, t1 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					var mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.beforeStart_( 0, t, t1 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.afterEnd_( i1 - 1, t0, t );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	},

  	settings: null, // optional, subclass-specific settings structure
  	// Note: The indirection allows central control of many interpolants.

  	// --- Protected interface

  	DefaultSettings_: {},

  	getSettings_: function () {

  		return this.settings || this.DefaultSettings_;

  	},

  	copySampleValue_: function ( index ) {

  		// copies a sample value to the result buffer

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	},

  	// Template methods for derived classes:

  	interpolate_: function (  ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	},

  	intervalChanged_: function (  ) {

  		// empty

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( Interpolant.prototype, {

  	//( 0, t, t0 ), returns this.resultBuffer
  	beforeStart_: Interpolant.prototype.copySampleValue_,

  	//( N-1, tN-1, t ), returns this.resultBuffer
  	afterEnd_: Interpolant.prototype.copySampleValue_,

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: LinearInterpolant,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Characters [].:/ are reserved for track binding syntax.
  var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

  function Composite( targetGroup, path, optionalParsedPath ) {

  	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  	this._targetGroup = targetGroup;
  	this._bindings = targetGroup.subscribe_( path, parsedPath );

  }

  Object.assign( Composite.prototype, {

  	getValue: function ( array, offset ) {

  		this.bind(); // bind all binding

  		var firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) { binding.getValue( array, offset ); }

  	},

  	setValue: function ( array, offset ) {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	},

  	bind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	},

  	unbind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  } );
  function PropertyBinding( rootNode, path, parsedPath ) {

  	this.path = path;
  	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  	this.rootNode = rootNode;

  }

  Object.assign( PropertyBinding, {

  	Composite: Composite,

  	create: function ( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding( root, path, parsedPath );

  		} else {

  			return new PropertyBinding.Composite( root, path, parsedPath );

  		}

  	},
  	sanitizeNodeName: ( function () {

  		var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

  		return function sanitizeNodeName( name ) {

  			return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

  		};

  	}() ),

  	parseTrackName: function () {

  		// Attempts to allow node names from any language. ES5's `\w` regexp matches
  		// only latin characters, and the unicode \p{L} is not yet supported. So
  		// instead, we exclude reserved characters and match everything else.
  		var wordChar = '[^' + RESERVED_CHARS_RE + ']';
  		var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

  		// Parent directories, delimited by '/' or ':'. Currently unused, but must
  		// be matched to parse the rest of the track name.
  		var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

  		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  		var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

  		// Object on target node, and accessor. May not contain reserved
  		// characters. Accessor may contain any character except closing bracket.
  		var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

  		// Property and accessor. May not contain reserved characters. Accessor may
  		// contain any non-bracket characters.
  		var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

  		var trackRe = new RegExp( ''
  			+ '^'
  			+ directoryRe
  			+ nodeRe
  			+ objectRe
  			+ propertyRe
  			+ '$'
  		);

  		var supportedObjectNames = [ 'material', 'materials', 'bones' ];

  		return function parseTrackName( trackName ) {

  			var matches = trackRe.exec( trackName );

  			if ( ! matches ) {

  				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  			}

  			var results = {
  				// directoryName: matches[ 1 ], // (tschw) currently unused
  				nodeName: matches[ 2 ],
  				objectName: matches[ 3 ],
  				objectIndex: matches[ 4 ],
  				propertyName: matches[ 5 ], // required
  				propertyIndex: matches[ 6 ]
  			};

  			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  			if ( lastDot !== undefined && lastDot !== - 1 ) {

  				var objectName = results.nodeName.substring( lastDot + 1 );

  				// Object names must be checked against a whitelist. Otherwise, there
  				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  				// 'bar' could be the objectName, or part of a nodeName (which can
  				// include '.' characters).
  				if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  					results.nodeName = results.nodeName.substring( 0, lastDot );
  					results.objectName = objectName;

  				}

  			}

  			if ( results.propertyName === null || results.propertyName.length === 0 ) {

  				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  			}

  			return results;

  		};

  	}(),

  	findNode: function ( root, nodeName ) {

  		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			var bone = root.skeleton.getBoneByName( nodeName );

  			if ( bone !== undefined ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			var searchNodeSubtree = function ( children ) {

  				for ( var i = 0; i < children.length; i ++ ) {

  					var childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					var result = searchNodeSubtree( childNode.children );

  					if ( result ) { return result; }

  				}

  				return null;

  			};

  			var subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  } );

  Object.assign( PropertyBinding.prototype, { // prototype, continued

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable: function () {},
  	_setValue_unavailable: function () {},

  	BindingType: {
  		Direct: 0,
  		EntireArray: 1,
  		ArrayElement: 2,
  		HasFromToArray: 3
  	},

  	Versioning: {
  		None: 0,
  		NeedsUpdate: 1,
  		MatrixWorldNeedsUpdate: 2
  	},

  	GetterByBindingType: [

  		function getValue_direct( buffer, offset ) {

  			buffer[ offset ] = this.node[ this.propertyName ];

  		},

  		function getValue_array( buffer, offset ) {

  			var source = this.resolvedProperty;

  			for ( var i = 0, n = source.length; i !== n; ++ i ) {

  				buffer[ offset ++ ] = source[ i ];

  			}

  		},

  		function getValue_arrayElement( buffer, offset ) {

  			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  		},

  		function getValue_toArray( buffer, offset ) {

  			this.resolvedProperty.toArray( buffer, offset );

  		}

  	],

  	SetterByBindingTypeAndVersioning: [

  		[
  			// Direct

  			function setValue_direct( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];

  			},

  			function setValue_direct_setNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// EntireArray

  			function setValue_array( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  			},

  			function setValue_array_setNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// ArrayElement

  			function setValue_arrayElement( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  			},

  			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// HasToFromArray

  			function setValue_fromArray( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );

  			},

  			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		]

  	],

  	getValue: function getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  		// Note: This class uses a State pattern on a per-method basis:
  		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
  		// prototype version of these methods with one that represents
  		// the bound state. When the property is not found, the methods
  		// become no-ops.

  	},

  	setValue: function getValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	},

  	// create getter / setter pair for a property in the scene graph
  	bind: function () {

  		var targetObject = this.node,
  			parsedPath = this.parsedPath,

  			objectName = parsedPath.objectName,
  			propertyName = parsedPath.propertyName,
  			propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.error( 'PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
  			return;

  		}

  		if ( objectName ) {

  			var objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( var i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}
  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		var nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			var nodeName = parsedPath.nodeName;

  			console.error( 'PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		var versioning = this.Versioning.None;

  		this.targetObject = targetObject;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;

  		}

  		// determine how the property gets bound
  		var bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === "morphTargetInfluences" ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( targetObject.geometry.isBufferGeometry ) {

  					if ( ! targetObject.geometry.morphAttributes ) {

  						console.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

  						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}
  				} else {

  					if ( ! targetObject.geometry.morphTargets ) {

  						console.error( 'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

  						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	},

  	unbind: function () {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( PropertyBinding.prototype, {

  	// initial state of these methods that calls 'bind'
  	_getValue_unbound: PropertyBinding.prototype.getValue,
  	_setValue_unbound: PropertyBinding.prototype.setValue,

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PropertyMixer( binding, typeName, valueSize ) {

  	this.binding = binding;
  	this.valueSize = valueSize;

  	var bufferType = Float64Array,
  		mixFunction;

  	switch ( typeName ) {

  		case 'quaternion':
  			mixFunction = this._slerp;
  			break;

  		case 'string':
  		case 'bool':
  			bufferType = Array;
  			mixFunction = this._select;
  			break;

  		default:
  			mixFunction = this._lerp;

  	}

  	this.buffer = new bufferType( valueSize * 4 );
  	// layout: [ incoming | accu0 | accu1 | orig ]
  	//
  	// interpolators can use .buffer as their .result
  	// the data then goes to 'incoming'
  	//
  	// 'accu0' and 'accu1' are used frame-interleaved for
  	// the cumulative result and are compared to detect
  	// changes
  	//
  	// 'orig' stores the original state of the property

  	this._mixBufferRegion = mixFunction;

  	this.cumulativeWeight = 0;

  	this.useCount = 0;
  	this.referenceCount = 0;

  }

  Object.assign( PropertyMixer.prototype, {

  	// accumulate data in the 'incoming' region into 'accu<i>'
  	accumulate: function ( accuIndex, weight ) {

  		// note: happily accumulating nothing when weight = 0, the caller knows
  		// the weight and shouldn't have made the call in the first place

  		var buffer = this.buffer,
  			stride = this.valueSize,
  			offset = accuIndex * stride + stride,

  			currentWeight = this.cumulativeWeight;

  		if ( currentWeight === 0 ) {

  			// accuN := incoming * weight

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ offset + i ] = buffer[ i ];

  			}

  			currentWeight = weight;

  		} else {

  			// accuN := accuN + incoming * weight

  			currentWeight += weight;
  			var mix = weight / currentWeight;
  			this._mixBufferRegion( buffer, offset, 0, mix, stride );

  		}

  		this.cumulativeWeight = currentWeight;

  	},

  	// apply the state of 'accu<i>' to the binding when accus differ
  	apply: function ( accuIndex ) {

  		var stride = this.valueSize,
  			buffer = this.buffer,
  			offset = accuIndex * stride + stride,

  			weight = this.cumulativeWeight,

  			binding = this.binding;

  		this.cumulativeWeight = 0;

  		if ( weight < 1 ) {

  			// accuN := accuN + original * ( 1 - cumulativeWeight )

  			var originalValueOffset = stride * 3;

  			this._mixBufferRegion(
  				buffer, offset, originalValueOffset, 1 - weight, stride );

  		}

  		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

  			if ( buffer[ i ] !== buffer[ i + stride ] ) {

  				// value has changed -> update scene graph

  				binding.setValue( buffer, offset );
  				break;

  			}

  		}

  	},

  	// remember the state of the bound property and copy it to both accus
  	saveOriginalState: function () {

  		var binding = this.binding;

  		var buffer = this.buffer,
  			stride = this.valueSize,

  			originalValueOffset = stride * 3;

  		binding.getValue( buffer, originalValueOffset );

  		// accu[0..1] := orig -- initially detect changes against the original
  		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

  			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  		}

  		this.cumulativeWeight = 0;

  	},

  	// apply the state previously taken via 'saveOriginalState' to the binding
  	restoreOriginalState: function () {

  		var originalValueOffset = this.valueSize * 3;
  		this.binding.setValue( this.buffer, originalValueOffset );

  	},
  	// mix functions

  	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		if ( t >= 0.5 ) {

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  			}

  		}

  	},

  	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

  		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  	},

  	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		var s = 1 - t;

  		for ( var i = 0; i !== stride; ++ i ) {

  			var j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AnimationUtils = {

  	// same as Array.prototype.slice, but also works on typed arrays
  	arraySlice: function ( array, from, to ) {

  		if ( AnimationUtils.isTypedArray( array ) ) {

  			// in ios9 array.subarray(from, undefined) will return empty array
  			// but array.subarray(from) or array.subarray(from, len) is correct
  			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  		}

  		return array.slice( from, to );

  	},

  	// converts an array to a specific type
  	convertArray: function ( array, type, forceClone ) {

  		if ( ! array || // let 'undefined' and 'null' pass
  			! forceClone && array.constructor === type ) { return array; }

  		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  			return new type( array ); // create typed array

  		}

  		return Array.prototype.slice.call( array ); // create Array

  	},

  	isTypedArray: function ( object ) {

  		return ArrayBuffer.isView( object ) &&
  			! ( object instanceof DataView );

  	},

  	// returns an array by which times and values can be sorted
  	getKeyframeOrder: function ( times ) {

  		function compareTime( i, j ) {

  			return times[ i ] - times[ j ];

  		}

  		var n = times.length;
  		var result = new Array( n );
  		for ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }

  		result.sort( compareTime );

  		return result;

  	},

  	// uses the array previously returned by 'getKeyframeOrder' to sort data
  	sortedArray: function ( values, stride, order ) {

  		var nValues = values.length;
  		var result = new values.constructor( nValues );

  		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  			var srcOffset = order[ i ] * stride;

  			for ( var j = 0; j !== stride; ++ j ) {

  				result[ dstOffset ++ ] = values[ srcOffset + j ];

  			}

  		}

  		return result;

  	},

  	// function for parsing AOS keyframe formats
  	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  		var i = 1, key = jsonKeys[ 0 ];

  		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  			key = jsonKeys[ i ++ ];

  		}

  		if ( key === undefined ) { return; } // no data

  		var value = key[ valuePropertyName ];
  		if ( value === undefined ) { return; } // no data

  		if ( Array.isArray( value ) ) {

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push.apply( values, value ); // push all elements

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else if ( value.toArray !== undefined ) {

  			// ...assume Math-ish

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					value.toArray( values, values.length );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else {

  			// otherwise push as-is

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push( value );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	this._weightPrev = - 0;
  	this._offsetPrev = - 0;
  	this._weightNext = - 0;
  	this._offsetNext = - 0;

  }

  CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: CubicInterpolant,

  	DefaultSettings_: {

  		endingStart: ZeroCurvatureEnding,
  		endingEnd: ZeroCurvatureEnding

  	},

  	intervalChanged_: function ( i1, t0, t1 ) {

  		var pp = this.parameterPositions,
  			iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		var halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	},

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		var sP = - wP * ppp + 2 * wP * pp - wP * p;
  		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		var sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: DiscreteInterpolant,

  	interpolate_: function ( i1  ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function KeyframeTrack( name, times, values, interpolation ) {

  	if ( name === undefined ) { throw new Error( 'KeyframeTrack: track name is undefined' ); }
  	if ( times === undefined || times.length === 0 ) { throw new Error( 'KeyframeTrack: no keyframes in track named ' + name ); }

  	this.name = name;

  	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
  	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

  	this.setInterpolation( interpolation || this.DefaultInterpolation );

  }

  // Static methods

  Object.assign( KeyframeTrack, {

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	toJSON: function ( track ) {

  		var trackType = track.constructor;

  		var json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== undefined ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': AnimationUtils.convertArray( track.times, Array ),
  				'values': AnimationUtils.convertArray( track.values, Array )

  			};

  			var interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	}

  } );

  Object.assign( KeyframeTrack.prototype, {

  	constructor: KeyframeTrack,

  	TimeBufferType: Float32Array,

  	ValueBufferType: Float32Array,

  	DefaultInterpolation: InterpolateLinear,

  	InterpolantFactoryMethodDiscrete: function ( result ) {

  		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: function ( result ) {

  		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	setInterpolation: function ( interpolation ) {

  		var factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			var message = "unsupported interpolation for " +
  				this.ValueTypeName + " keyframe track named " + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'KeyframeTrack:', message );
  			return this;

  		}

  		this.createInterpolant = factoryMethod;

  		return this;

  	},

  	getInterpolation: function () {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth;

  		}

  	},

  	getValueSize: function () {

  		return this.values.length / this.times.length;

  	},

  	// move all keyframes either forwards or backwards in time
  	shift: function ( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	},

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale: function ( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	},

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim: function ( startTime, endTime ) {

  		var times = this.times,
  			nKeys = times.length,
  			from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) {

  			++ from;

  		}

  		while ( to !== - 1 && times[ to ] > endTime ) {

  			-- to;

  		}

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) { to = Math.max( to, 1 ), from = to - 1; }

  			var stride = this.getValueSize();
  			this.times = AnimationUtils.arraySlice( times, from, to );
  			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

  		}

  		return this;

  	},

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate: function () {
  		var this$1 = this;


  		var valid = true;

  		var valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'KeyframeTrack: Invalid value size in track.', this );
  			valid = false;

  		}

  		var times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'KeyframeTrack: Track is empty.', this );
  			valid = false;

  		}

  		var prevTime = null;

  		for ( var i = 0; i !== nKeys; i ++ ) {

  			var currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'KeyframeTrack: Time is not a valid number.', this$1, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'KeyframeTrack: Out of order keys.', this$1, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( AnimationUtils.isTypedArray( values ) ) {

  				for ( var i = 0, n = values.length; i !== n; ++ i ) {

  					var value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'KeyframeTrack: Value is not a valid number.', this$1, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	},

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize: function () {

  		var times = this.times,
  			values = this.values,
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  			writeIndex = 1,
  			lastIndex = times.length - 1;

  		for ( var i = 1; i < lastIndex; ++ i ) {

  			var keep = false;

  			var time = times[ i ];
  			var timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					var offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( var j = 0; j !== stride; ++ j ) {

  						var value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  							value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else {

  					keep = true;

  				}

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					var readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( var j = 0; j !== stride; ++ j ) {

  						values[ writeOffset + j ] = values[ readOffset + j ];

  					}

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

  				values[ writeOffset + j ] = values[ readOffset + j ];

  			}

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
  			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

  		}

  		return this;

  	},

  	clone: function () {

  		var times = AnimationUtils.arraySlice( this.times, 0 );
  		var values = AnimationUtils.arraySlice( this.values, 0 );

  		var TypedKeyframeTrack = this.constructor;
  		var track = new TypedKeyframeTrack( this.name, times, values );

  		// Interpolant argument to constructor is not saved, so copy the factory method directly.
  		track.createInterpolant = this.createInterpolant;

  		return track;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BooleanKeyframeTrack( name, times, values ) {

  	KeyframeTrack.call( this, name, times, values );

  }

  BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: BooleanKeyframeTrack,

  	ValueTypeName: 'bool',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete,

  	InterpolantFactoryMethodLinear: undefined,
  	InterpolantFactoryMethodSmooth: undefined

  	// Note: Actually this track could have a optimized / compressed
  	// representation of a single value and a custom interpolant that
  	// computes "firstValue ^ isOdd( index )".

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ColorKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrack.call( this, name, times, values, interpolation );

  }

  ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: ColorKeyframeTrack,

  	ValueTypeName: 'color'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  	// Note: Very basic implementation and nothing special yet.
  	// However, this is the place for color space parameterization.

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NumberKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrack.call( this, name, times, values, interpolation );

  }

  NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: NumberKeyframeTrack,

  	ValueTypeName: 'number'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: QuaternionLinearInterpolant,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset = i1 * stride,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		for ( var end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function QuaternionKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrack.call( this, name, times, values, interpolation );

  }

  QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: QuaternionKeyframeTrack,

  	ValueTypeName: 'quaternion',

  	// ValueBufferType is inherited

  	DefaultInterpolation: InterpolateLinear,

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: undefined // not yet implemented

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function StringKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrack.call( this, name, times, values, interpolation );

  }

  StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: StringKeyframeTrack,

  	ValueTypeName: 'string',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete,

  	InterpolantFactoryMethodLinear: undefined,

  	InterpolantFactoryMethodSmooth: undefined

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function VectorKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrack.call( this, name, times, values, interpolation );

  }

  VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  	constructor: VectorKeyframeTrack,

  	ValueTypeName: 'vector'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AnimationClip( name, duration, tracks ) {

  	this.name = name;
  	this.tracks = tracks;
  	this.duration = ( duration !== undefined ) ? duration : - 1;

  	this.uuid = _Math.generateUUID();

  	// this means it should figure out its duration by scanning the tracks
  	if ( this.duration < 0 ) {

  		this.resetDuration();

  	}

  }

  function getTrackTypeForValueTypeName( typeName ) {

  	switch ( typeName.toLowerCase() ) {

  		case 'scalar':
  		case 'double':
  		case 'float':
  		case 'number':
  		case 'integer':

  			return NumberKeyframeTrack;

  		case 'vector':
  		case 'vector2':
  		case 'vector3':
  		case 'vector4':

  			return VectorKeyframeTrack;

  		case 'color':

  			return ColorKeyframeTrack;

  		case 'quaternion':

  			return QuaternionKeyframeTrack;

  		case 'bool':
  		case 'boolean':

  			return BooleanKeyframeTrack;

  		case 'string':

  			return StringKeyframeTrack;

  	}

  	throw new Error( 'KeyframeTrack: Unsupported typeName: ' + typeName );

  }

  function parseKeyframeTrack( json ) {

  	if ( json.type === undefined ) {

  		throw new Error( 'KeyframeTrack: track type undefined, can not parse' );

  	}

  	var trackType = getTrackTypeForValueTypeName( json.type );

  	if ( json.times === undefined ) {

  		var times = [], values = [];

  		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

  		json.times = times;
  		json.values = values;

  	}

  	// derived classes can define a static parse method
  	if ( trackType.parse !== undefined ) {

  		return trackType.parse( json );

  	} else {

  		// by default, we assume a constructor compatible with the base
  		return new trackType( json.name, json.times, json.values, json.interpolation );

  	}

  }

  Object.assign( AnimationClip, {

  	parse: function ( json ) {

  		var tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		return new AnimationClip( json.name, json.duration, tracks );

  	},

  	toJSON: function ( clip ) {

  		var tracks = [],
  			clipTracks = clip.tracks;

  		var json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks,
  			'uuid': clip.uuid

  		};

  		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	},

  	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

  		var numMorphTargets = morphTargetSequence.length;
  		var tracks = [];

  		for ( var i = 0; i < numMorphTargets; i ++ ) {

  			var times = [];
  			var values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			var order = AnimationUtils.getKeyframeOrder( times );
  			times = AnimationUtils.sortedArray( times, 1, order );
  			values = AnimationUtils.sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new AnimationClip( name, - 1, tracks );

  	},

  	findByName: function ( objectOrClipArray, name ) {

  		var clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			var o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( var i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	},

  	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

  		var animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		var pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = morphTargets[ i ];
  			var parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				var name = parts[ 1 ];

  				var animationMorphTargets = animationToMorphTargets[ name ];
  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		var clips = [];

  		for ( var name in animationToMorphTargets ) {

  			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	},

  	// parse the animation.hierarchy format
  	parseAnimation: function ( animation, bones ) {

  		if ( ! animation ) {

  			console.error( 'AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				var times = [];
  				var values = [];

  				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		var tracks = [];

  		var clipName = animation.name || 'default';
  		// automatic length determination in AnimationClip.
  		var duration = animation.length || - 1;
  		var fps = animation.fps || 30;

  		var hierarchyTracks = animation.hierarchy || [];

  		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

  			var animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) { continue; }

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				var morphTargetNames = {};

  				for ( var k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( var morphTargetName in morphTargetNames ) {

  					var times = [];
  					var values = [];

  					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						var animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * ( fps || 1.0 );

  			} else {

  				// ...assume skeletal animation

  				var boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		var clip = new AnimationClip( clipName, duration, tracks );

  		return clip;

  	}

  } );

  Object.assign( AnimationClip.prototype, {

  	resetDuration: function () {
  		var this$1 = this;


  		var tracks = this.tracks, duration = 0;

  		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

  			var track = this$1.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  		return this;

  	},

  	trim: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].trim( 0, this$1.duration );

  		}

  		return this;

  	},

  	validate: function () {
  		var this$1 = this;


  		var valid = true;

  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			valid = valid && this$1.tracks[ i ].validate();

  		}

  		return valid;

  	},

  	optimize: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].optimize();

  		}

  		return this;

  	},
  	clone: function () {
  		var this$1 = this;


  		var tracks = [];

  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			tracks.push( this$1.tracks[ i ].clone() );

  		}

  		return new AnimationClip( this.name, this.duration, tracks );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AnimationMixer( root ) {

  	this._root = root;
  	this._initMemoryManager();
  	this._accuIndex = 0;

  	this.time = 0;

  	this.timeScale = 1.0;

  }

  AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: AnimationMixer,

  	_bindAction: function ( action, prototypeAction ) {
  		var this$1 = this;


  		var root = action._localRoot || this._root,
  			tracks = action._clip.tracks,
  			nTracks = tracks.length,
  			bindings = action._propertyBindings,
  			interpolants = action._interpolants,
  			rootUuid = root.uuid,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingsByName = bindingsByRoot[ rootUuid ];

  		if ( bindingsByName === undefined ) {

  			bindingsByName = {};
  			bindingsByRoot[ rootUuid ] = bindingsByName;

  		}

  		for ( var i = 0; i !== nTracks; ++ i ) {

  			var track = tracks[ i ],
  				trackName = track.name,
  				binding = bindingsByName[ trackName ];

  			if ( binding !== undefined ) {

  				bindings[ i ] = binding;

  			} else {

  				binding = bindings[ i ];

  				if ( binding !== undefined ) {

  					// existing binding, make sure the cache knows

  					if ( binding._cacheIndex === null ) {

  						++ binding.referenceCount;
  						this$1._addInactiveBinding( binding, rootUuid, trackName );

  					}

  					continue;

  				}

  				var path = prototypeAction && prototypeAction.
  					_propertyBindings[ i ].binding.parsedPath;

  				binding = new PropertyMixer(
  					PropertyBinding.create( root, trackName, path ),
  					track.ValueTypeName, track.getValueSize() );

  				++ binding.referenceCount;
  				this$1._addInactiveBinding( binding, rootUuid, trackName );

  				bindings[ i ] = binding;

  			}

  			interpolants[ i ].resultBuffer = binding.buffer;

  		}

  	},

  	_activateAction: function ( action ) {
  		var this$1 = this;


  		if ( ! this._isActiveAction( action ) ) {

  			if ( action._cacheIndex === null ) {

  				// this action has been forgotten by the cache, but the user
  				// appears to be still using it -> rebind

  				var rootUuid = ( action._localRoot || this._root ).uuid,
  					clipUuid = action._clip.uuid,
  					actionsForClip = this._actionsByClip[ clipUuid ];

  				this._bindAction( action,
  					actionsForClip && actionsForClip.knownActions[ 0 ] );

  				this._addInactiveAction( action, clipUuid, rootUuid );

  			}

  			var bindings = action._propertyBindings;

  			// increment reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( binding.useCount ++ === 0 ) {

  					this$1._lendBinding( binding );
  					binding.saveOriginalState();

  				}

  			}

  			this._lendAction( action );

  		}

  	},

  	_deactivateAction: function ( action ) {
  		var this$1 = this;


  		if ( this._isActiveAction( action ) ) {

  			var bindings = action._propertyBindings;

  			// decrement reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( -- binding.useCount === 0 ) {

  					binding.restoreOriginalState();
  					this$1._takeBackBinding( binding );

  				}

  			}

  			this._takeBackAction( action );

  		}

  	},

  	// Memory manager

  	_initMemoryManager: function () {

  		this._actions = []; // 'nActiveActions' followed by inactive ones
  		this._nActiveActions = 0;

  		this._actionsByClip = {};
  		// inside:
  		// {
  		// 	knownActions: Array< AnimationAction > - used as prototypes
  		// 	actionByRoot: AnimationAction - lookup
  		// }
  		this._bindings = []; // 'nActiveBindings' followed by inactive ones
  		this._nActiveBindings = 0;

  		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
  		this._controlInterpolants = []; // same game as above
  		this._nActiveControlInterpolants = 0;

  		var scope = this;

  		this.stats = {

  			actions: {
  				get total() {

  					return scope._actions.length;

  				},
  				get inUse() {

  					return scope._nActiveActions;

  				}
  			},
  			bindings: {
  				get total() {

  					return scope._bindings.length;

  				},
  				get inUse() {

  					return scope._nActiveBindings;

  				}
  			},
  			controlInterpolants: {
  				get total() {

  					return scope._controlInterpolants.length;

  				},
  				get inUse() {

  					return scope._nActiveControlInterpolants;

  				}
  			}

  		};

  	},

  	// Memory management for AnimationAction objects

  	_isActiveAction: function ( action ) {

  		var index = action._cacheIndex;
  		return index !== null && index < this._nActiveActions;

  	},

  	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

  		var actions = this._actions,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip === undefined ) {

  			actionsForClip = {

  				knownActions: [ action ],
  				actionByRoot: {}

  			};

  			action._byClipCacheIndex = 0;

  			actionsByClip[ clipUuid ] = actionsForClip;

  		} else {

  			var knownActions = actionsForClip.knownActions;

  			action._byClipCacheIndex = knownActions.length;
  			knownActions.push( action );

  		}

  		action._cacheIndex = actions.length;
  		actions.push( action );

  		actionsForClip.actionByRoot[ rootUuid ] = action;

  	},

  	_removeInactiveAction: function ( action ) {

  		var actions = this._actions,
  			lastInactiveAction = actions[ actions.length - 1 ],
  			cacheIndex = action._cacheIndex;

  		lastInactiveAction._cacheIndex = cacheIndex;
  		actions[ cacheIndex ] = lastInactiveAction;
  		actions.pop();

  		action._cacheIndex = null;
  		var clipUuid = action._clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ],
  			knownActionsForClip = actionsForClip.knownActions,

  			lastKnownAction =
  				knownActionsForClip[ knownActionsForClip.length - 1 ],

  			byClipCacheIndex = action._byClipCacheIndex;

  		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  		knownActionsForClip.pop();

  		action._byClipCacheIndex = null;
  		var actionByRoot = actionsForClip.actionByRoot,
  			rootUuid = ( action._localRoot || this._root ).uuid;

  		delete actionByRoot[ rootUuid ];

  		if ( knownActionsForClip.length === 0 ) {

  			delete actionsByClip[ clipUuid ];

  		}

  		this._removeInactiveBindingsForAction( action );

  	},

  	_removeInactiveBindingsForAction: function ( action ) {
  		var this$1 = this;


  		var bindings = action._propertyBindings;
  		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  			var binding = bindings[ i ];

  			if ( -- binding.referenceCount === 0 ) {

  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	_lendAction: function ( action ) {

  		// [ active actions |  inactive actions  ]
  		// [  active actions >| inactive actions ]
  		//                 s        a
  		//                  <-swap->
  		//                 a        s

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			lastActiveIndex = this._nActiveActions ++,

  			firstInactiveAction = actions[ lastActiveIndex ];

  		action._cacheIndex = lastActiveIndex;
  		actions[ lastActiveIndex ] = action;

  		firstInactiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = firstInactiveAction;

  	},

  	_takeBackAction: function ( action ) {

  		// [  active actions  | inactive actions ]
  		// [ active actions |< inactive actions  ]
  		//        a        s
  		//         <-swap->
  		//        s        a

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			firstInactiveIndex = -- this._nActiveActions,

  			lastActiveAction = actions[ firstInactiveIndex ];

  		action._cacheIndex = firstInactiveIndex;
  		actions[ firstInactiveIndex ] = action;

  		lastActiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = lastActiveAction;

  	},

  	// Memory management for PropertyMixer objects

  	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			bindings = this._bindings;

  		if ( bindingByName === undefined ) {

  			bindingByName = {};
  			bindingsByRoot[ rootUuid ] = bindingByName;

  		}

  		bindingByName[ trackName ] = binding;

  		binding._cacheIndex = bindings.length;
  		bindings.push( binding );

  	},

  	_removeInactiveBinding: function ( binding ) {

  		var bindings = this._bindings,
  			propBinding = binding.binding,
  			rootUuid = propBinding.rootNode.uuid,
  			trackName = propBinding.path,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			lastInactiveBinding = bindings[ bindings.length - 1 ],
  			cacheIndex = binding._cacheIndex;

  		lastInactiveBinding._cacheIndex = cacheIndex;
  		bindings[ cacheIndex ] = lastInactiveBinding;
  		bindings.pop();

  		delete bindingByName[ trackName ];

  		remove_empty_map: {

  			for ( var _ in bindingByName ) { break remove_empty_map; } // eslint-disable-line no-unused-vars

  			delete bindingsByRoot[ rootUuid ];

  		}

  	},

  	_lendBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			lastActiveIndex = this._nActiveBindings ++,

  			firstInactiveBinding = bindings[ lastActiveIndex ];

  		binding._cacheIndex = lastActiveIndex;
  		bindings[ lastActiveIndex ] = binding;

  		firstInactiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = firstInactiveBinding;

  	},

  	_takeBackBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			firstInactiveIndex = -- this._nActiveBindings,

  			lastActiveBinding = bindings[ firstInactiveIndex ];

  		binding._cacheIndex = firstInactiveIndex;
  		bindings[ firstInactiveIndex ] = binding;

  		lastActiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = lastActiveBinding;

  	},
  	// Memory management of Interpolants for weight and time scale

  	_lendControlInterpolant: function () {

  		var interpolants = this._controlInterpolants,
  			lastActiveIndex = this._nActiveControlInterpolants ++,
  			interpolant = interpolants[ lastActiveIndex ];

  		if ( interpolant === undefined ) {

  			interpolant = new LinearInterpolant(
  				new Float32Array( 2 ), new Float32Array( 2 ),
  				1, this._controlInterpolantsResultBuffer );

  			interpolant.__cacheIndex = lastActiveIndex;
  			interpolants[ lastActiveIndex ] = interpolant;

  		}

  		return interpolant;

  	},

  	_takeBackControlInterpolant: function ( interpolant ) {

  		var interpolants = this._controlInterpolants,
  			prevIndex = interpolant.__cacheIndex,

  			firstInactiveIndex = -- this._nActiveControlInterpolants,

  			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  		interpolant.__cacheIndex = firstInactiveIndex;
  		interpolants[ firstInactiveIndex ] = interpolant;

  		lastActiveInterpolant.__cacheIndex = prevIndex;
  		interpolants[ prevIndex ] = lastActiveInterpolant;

  	},

  	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

  	// return an action for a clip optionally using a custom root target
  	// object (this method allocates a lot of dynamic memory in case a
  	// previously unknown clip/root combination is specified)
  	clipAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip.findByName( root, clip ) : clip,

  			clipUuid = clipObject !== null ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ],
  			prototypeAction = null;

  		if ( actionsForClip !== undefined ) {

  			var existingAction =
  					actionsForClip.actionByRoot[ rootUuid ];

  			if ( existingAction !== undefined ) {

  				return existingAction;

  			}

  			// we know the clip, so we don't have to parse all
  			// the bindings again but can just copy
  			prototypeAction = actionsForClip.knownActions[ 0 ];

  			// also, take the clip from the prototype action
  			if ( clipObject === null )
  				{ clipObject = prototypeAction._clip; }

  		}

  		// clip must be known when specified via string
  		if ( clipObject === null ) { return null; }

  		// allocate all resources required to run it
  		var newAction = new AnimationAction( this, clipObject, optionalRoot );

  		this._bindAction( newAction, prototypeAction );

  		// and make the action known to the memory manager
  		this._addInactiveAction( newAction, clipUuid, rootUuid );

  		return newAction;

  	},

  	// get an existing action
  	existingAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip.findByName( root, clip ) : clip,

  			clipUuid = clipObject ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			return actionsForClip.actionByRoot[ rootUuid ] || null;

  		}

  		return null;

  	},

  	// deactivates all previously scheduled actions
  	stopAllAction: function () {

  		var actions = this._actions,
  			nActions = this._nActiveActions,
  			bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		this._nActiveActions = 0;
  		this._nActiveBindings = 0;

  		for ( var i = 0; i !== nActions; ++ i ) {

  			actions[ i ].reset();

  		}

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].useCount = 0;

  		}

  		return this;

  	},

  	// advance the time and update apply the animation
  	update: function ( deltaTime ) {

  		deltaTime *= this.timeScale;

  		var actions = this._actions,
  			nActions = this._nActiveActions,

  			time = this.time += deltaTime,
  			timeDirection = Math.sign( deltaTime ),

  			accuIndex = this._accuIndex ^= 1;

  		// run active actions

  		for ( var i = 0; i !== nActions; ++ i ) {

  			var action = actions[ i ];

  			action._update( time, deltaTime, timeDirection, accuIndex );

  		}

  		// update scene graph

  		var bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].apply( accuIndex );

  		}

  		return this;

  	},

  	// return this mixer's root target object
  	getRoot: function () {

  		return this._root;

  	},

  	// free all resources specific to a particular clip
  	uncacheClip: function ( clip ) {
  		var this$1 = this;


  		var actions = this._actions,
  			clipUuid = clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			// note: just calling _removeInactiveAction would mess up the
  			// iteration state and also require updating the state we can
  			// just throw away

  			var actionsToRemove = actionsForClip.knownActions;

  			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  				var action = actionsToRemove[ i ];

  				this$1._deactivateAction( action );

  				var cacheIndex = action._cacheIndex,
  					lastInactiveAction = actions[ actions.length - 1 ];

  				action._cacheIndex = null;
  				action._byClipCacheIndex = null;

  				lastInactiveAction._cacheIndex = cacheIndex;
  				actions[ cacheIndex ] = lastInactiveAction;
  				actions.pop();

  				this$1._removeInactiveBindingsForAction( action );

  			}

  			delete actionsByClip[ clipUuid ];

  		}

  	},

  	// free all resources specific to a particular root target object
  	uncacheRoot: function ( root ) {
  		var this$1 = this;


  		var rootUuid = root.uuid,
  			actionsByClip = this._actionsByClip;

  		for ( var clipUuid in actionsByClip ) {

  			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  				action = actionByRoot[ rootUuid ];

  			if ( action !== undefined ) {

  				this$1._deactivateAction( action );
  				this$1._removeInactiveAction( action );

  			}

  		}

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName !== undefined ) {

  			for ( var trackName in bindingByName ) {

  				var binding = bindingByName[ trackName ];
  				binding.restoreOriginalState();
  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	// remove a targeted clip from the cache
  	uncacheAction: function ( clip, optionalRoot ) {

  		var action = this.existingAction( clip, optionalRoot );

  		if ( action !== null ) {

  			this._deactivateAction( action );
  			this._removeInactiveAction( action );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Bone() {

  	Object3D.call( this );

  	this.type = 'Bone';

  }

  Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Bone,

  	isBone: true

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // BoxGeometry

  function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	Geometry.call( this );

  	this.type = 'BoxGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
  	this.mergeVertices();

  }

  BoxGeometry.prototype = Object.create( Geometry.prototype );
  BoxGeometry.prototype.constructor = BoxGeometry;

  // BoxBufferGeometry

  function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	BufferGeometry.call( this );

  	this.type = 'BoxBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	var scope = this;

  	width = width || 1;
  	height = height || 1;
  	depth = depth || 1;

  	// segments

  	widthSegments = Math.floor( widthSegments ) || 1;
  	heightSegments = Math.floor( heightSegments ) || 1;
  	depthSegments = Math.floor( depthSegments ) || 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var numberOfVertices = 0;
  	var groupStart = 0;

  	// build each side of the box geometry

  	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  	buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  	buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  	buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  	buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  		var segmentWidth = width / gridX;
  		var segmentHeight = height / gridY;

  		var widthHalf = width / 2;
  		var heightHalf = height / 2;
  		var depthHalf = depth / 2;

  		var gridX1 = gridX + 1;
  		var gridY1 = gridY + 1;

  		var vertexCounter = 0;
  		var groupCount = 0;

  		var ix, iy;

  		var vector = new Vector3();

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy < gridY1; iy ++ ) {

  			var y = iy * segmentHeight - heightHalf;

  			for ( ix = 0; ix < gridX1; ix ++ ) {

  				var x = ix * segmentWidth - widthHalf;

  				// set values to correct vector component

  				vector[ u ] = x * udir;
  				vector[ v ] = y * vdir;
  				vector[ w ] = depthHalf;

  				// now apply vector to vertex buffer

  				vertices.push( vector.x, vector.y, vector.z );

  				// set values to correct vector component

  				vector[ u ] = 0;
  				vector[ v ] = 0;
  				vector[ w ] = depth > 0 ? 1 : - 1;

  				// now apply vector to normal buffer

  				normals.push( vector.x, vector.y, vector.z );

  				// uvs

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  				// counters

  				vertexCounter += 1;

  			}

  		}

  		// indices

  		// 1. you need three indices to draw a single face
  		// 2. a single segment consists of two faces
  		// 3. so we need to generate six (2*3) indices per segment

  		for ( iy = 0; iy < gridY; iy ++ ) {

  			for ( ix = 0; ix < gridX; ix ++ ) {

  				var a = numberOfVertices + ix + gridX1 * iy;
  				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// increase counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, materialIndex );

  		// calculate new start value for groups

  		groupStart += groupCount;

  		// update total number of vertices

  		numberOfVertices += vertexCounter;

  	}

  }

  BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // CylinderGeometry

  function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'CylinderGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CylinderGeometry.prototype = Object.create( Geometry.prototype );
  CylinderGeometry.prototype.constructor = CylinderGeometry;

  // CylinderBufferGeometry

  function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'CylinderBufferGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	var scope = this;

  	radiusTop = radiusTop !== undefined ? radiusTop : 1;
  	radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  	height = height || 1;

  	radialSegments = Math.floor( radialSegments ) || 8;
  	heightSegments = Math.floor( heightSegments ) || 1;

  	openEnded = openEnded !== undefined ? openEnded : false;
  	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var index = 0;
  	var indexArray = [];
  	var halfHeight = height / 2;
  	var groupStart = 0;

  	// generate geometry

  	generateTorso();

  	if ( openEnded === false ) {

  		if ( radiusTop > 0 ) { generateCap( true ); }
  		if ( radiusBottom > 0 ) { generateCap( false ); }

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	function generateTorso() {

  		var x, y;
  		var normal = new Vector3();
  		var vertex = new Vector3();

  		var groupCount = 0;

  		// this will be used to calculate the normal
  		var slope = ( radiusBottom - radiusTop ) / height;

  		// generate vertices, normals and uvs

  		for ( y = 0; y <= heightSegments; y ++ ) {

  			var indexRow = [];

  			var v = y / heightSegments;

  			// calculate the radius of the current row

  			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  			for ( x = 0; x <= radialSegments; x ++ ) {

  				var u = x / radialSegments;

  				var theta = u * thetaLength + thetaStart;

  				var sinTheta = Math.sin( theta );
  				var cosTheta = Math.cos( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = - v * height + halfHeight;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.set( sinTheta, slope, cosTheta ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, 1 - v );

  				// save index of vertex in respective row

  				indexRow.push( index ++ );

  			}

  			// now save vertices of the row in our index array

  			indexArray.push( indexRow );

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			for ( y = 0; y < heightSegments; y ++ ) {

  				// we use the index array to access the correct indices

  				var a = indexArray[ y ][ x ];
  				var b = indexArray[ y + 1 ][ x ];
  				var c = indexArray[ y + 1 ][ x + 1 ];
  				var d = indexArray[ y ][ x + 1 ];

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// update group counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, 0 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  	function generateCap( top ) {

  		var x, centerIndexStart, centerIndexEnd;

  		var uv = new Vector2();
  		var vertex = new Vector3();

  		var groupCount = 0;

  		var radius = ( top === true ) ? radiusTop : radiusBottom;
  		var sign = ( top === true ) ? 1 : - 1;

  		// save the index of the first center vertex
  		centerIndexStart = index;

  		// first we generate the center vertex data of the cap.
  		// because the geometry needs one set of uvs per face,
  		// we must generate a center vertex per face/segment

  		for ( x = 1; x <= radialSegments; x ++ ) {

  			// vertex

  			vertices.push( 0, halfHeight * sign, 0 );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uvs.push( 0.5, 0.5 );

  			// increase index

  			index ++;

  		}

  		// save the index of the last center vertex

  		centerIndexEnd = index;

  		// now we generate the surrounding vertices, normals and uvs

  		for ( x = 0; x <= radialSegments; x ++ ) {

  			var u = x / radialSegments;
  			var theta = u * thetaLength + thetaStart;

  			var cosTheta = Math.cos( theta );
  			var sinTheta = Math.sin( theta );

  			// vertex

  			vertex.x = radius * sinTheta;
  			vertex.y = halfHeight * sign;
  			vertex.z = radius * cosTheta;
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uv.x = ( cosTheta * 0.5 ) + 0.5;
  			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  			uvs.push( uv.x, uv.y );

  			// increase index

  			index ++;

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			var c = centerIndexStart + x;
  			var i = centerIndexEnd + x;

  			if ( top === true ) {

  				// face top

  				indices.push( i, i + 1, c );

  			} else {

  				// face bottom

  				indices.push( i + 1, i, c );

  			}

  			groupCount += 3;

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  }

  CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MMDPhysics = ( function () {
  	function MMDPhysics( mesh, rigidBodyParams, constraintParams, params ) {

  		if ( typeof Ammo === 'undefined' ) {

  			throw new Error( 'MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js' );

  		}

  		constraintParams = constraintParams || [];
  		params = params || {};

  		this.manager = new ResourceManager();

  		this.mesh = mesh;
  		this.unitStep = ( params.unitStep !== undefined ) ? params.unitStep : 1 / 65;
  		this.maxStepNum = ( params.maxStepNum !== undefined ) ? params.maxStepNum : 3;
  		this.gravity = new Vector3( 0, - 9.8 * 10, 0 );

  		if ( params.gravity !== undefined ) { this.gravity.copy( params.gravity ); }

  		this.world = params.world !== undefined ? params.world : null; // experimental

  		this.bodies = [];
  		this.constraints = [];

  		this._init( mesh, rigidBodyParams, constraintParams );

  	}

  	MMDPhysics.prototype = {

  		constructor: MMDPhysics,
  		update: function ( delta ) {

  			var manager = this.manager;
  			var mesh = this.mesh;

  			// rigid bodies and constrains are for
  			// mesh's world scale (1, 1, 1).
  			// Convert to (1, 1, 1) if it isn't.

  			var isNonDefaultScale = false;

  			var position = manager.allocThreeVector3();
  			var quaternion = manager.allocThreeQuaternion();
  			var scale = manager.allocThreeVector3();

  			mesh.matrixWorld.decompose( position, quaternion, scale );

  			if ( scale.x !== 1 || scale.y !== 1 || scale.z !== 1 ) {

  				isNonDefaultScale = true;

  			}

  			var parent;

  			if ( isNonDefaultScale ) {

  				parent = mesh.parent;

  				if ( parent !== null ) { mesh.parent = null; }

  				scale.copy( this.mesh.scale );

  				mesh.scale.set( 1, 1, 1 );
  				mesh.updateMatrixWorld( true );

  			}

  			// calculate physics and update bones

  			this._updateRigidBodies();
  			this._stepSimulation( delta );
  			this._updateBones();

  			// restore mesh if converted above

  			if ( isNonDefaultScale ) {

  				if ( parent !== null ) { mesh.parent = parent; }

  				mesh.scale.copy( scale );

  			}

  			manager.freeThreeVector3( scale );
  			manager.freeThreeQuaternion( quaternion );
  			manager.freeThreeVector3( position );

  			return this;

  		},
  		reset: function () {
  			var this$1 = this;


  			for ( var i = 0, il = this.bodies.length; i < il; i++ ) {

  				this$1.bodies[ i ].reset();

  			}

  			return this;

  		},
  		warmup: function ( cycles ) {
  			var this$1 = this;


  			for ( var i = 0; i < cycles; i++ ) {

  				this$1.update( 1 / 60 );

  			}

  			return this;

  		},
  		setGravity: function ( gravity ) {

  			this.world.setGravity( new Ammo.btVector3( gravity.x, gravity.y, gravity.z ) );
  			this.gravity.copy( gravity );

  			return this;

  		},
  		createHelper: function () {

  			return new MMDPhysicsHelper( this.mesh, this );

  		},

  		// private methods

  		_init: function ( mesh, rigidBodyParams, constraintParams ) {

  			var manager = this.manager;

  			// rigid body/constraint parameters are for
  			// mesh's default world transform as position(0, 0, 0),
  			// quaternion(0, 0, 0, 1) and scale(0, 0, 0)

  			var parent = mesh.parent;

  			if ( parent !== null ) { parent = null; }

  			var currentPosition = manager.allocThreeVector3();
  			var currentQuaternion = manager.allocThreeQuaternion();
  			var currentScale = manager.allocThreeVector3();

  			currentPosition.copy( mesh.position );
  			currentQuaternion.copy( mesh.quaternion );
  			currentScale.copy( mesh.scale );

  			mesh.position.set( 0, 0, 0 );
  			mesh.quaternion.set( 0, 0, 0, 1 );
  			mesh.scale.set( 1, 1, 1 );

  			mesh.updateMatrixWorld( true );

  			if ( this.world === null ) {

  				this.world = this._createWorld();
  				this.setGravity( this.gravity );

  			}

  			this._initRigidBodies( rigidBodyParams );
  			this._initConstraints( constraintParams );

  			if ( parent !== null ) { mesh.parent = parent; }

  			mesh.position.copy( currentPosition );
  			mesh.quaternion.copy( currentQuaternion );
  			mesh.scale.copy( currentScale );

  			mesh.updateMatrixWorld( true );

  			this.reset();

  			manager.freeThreeVector3( currentPosition );
  			manager.freeThreeQuaternion( currentQuaternion );
  			manager.freeThreeVector3( currentScale );

  		},

  		_createWorld: function () {

  			var config = new Ammo.btDefaultCollisionConfiguration();
  			var dispatcher = new Ammo.btCollisionDispatcher( config );
  			var cache = new Ammo.btDbvtBroadphase();
  			var solver = new Ammo.btSequentialImpulseConstraintSolver();
  			var world = new Ammo.btDiscreteDynamicsWorld( dispatcher, cache, solver, config );
  			return world;

  		},

  		_initRigidBodies: function ( rigidBodies ) {
  			var this$1 = this;


  			for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {

  				this$1.bodies.push( new RigidBody(
  					this$1.mesh, this$1.world, rigidBodies[ i ], this$1.manager ) );

  			}

  		},

  		_initConstraints: function ( constraints ) {
  			var this$1 = this;


  			for ( var i = 0, il = constraints.length; i < il; i++ ) {

  				var params = constraints[ i ];
  				var bodyA = this$1.bodies[ params.rigidBodyIndex1 ];
  				var bodyB = this$1.bodies[ params.rigidBodyIndex2 ];
  				this$1.constraints.push( new Constraint(
  					this$1.mesh, this$1.world, bodyA, bodyB, params, this$1.manager ) );

  			}
  		},

  		_stepSimulation: function ( delta ) {

  			var unitStep = this.unitStep;
  			var stepTime = delta;
  			var maxStepNum = ( ( delta / unitStep ) | 0 ) + 1;

  			if ( stepTime < unitStep ) {

  				stepTime = unitStep;
  				maxStepNum = 1;

  			}

  			if ( maxStepNum > this.maxStepNum ) {

  				maxStepNum = this.maxStepNum;

  			}

  			this.world.stepSimulation( stepTime, maxStepNum, unitStep );

  		},

  		_updateRigidBodies: function () {
  			var this$1 = this;


  			for ( var i = 0, il = this.bodies.length; i < il; i++ ) {

  				this$1.bodies[ i ].updateFromBone();

  			}

  		},

  		_updateBones: function () {
  			var this$1 = this;


  			for ( var i = 0, il = this.bodies.length; i < il; i++ ) {

  				this$1.bodies[ i ].updateBone();

  			}

  		}

  	};
  	function ResourceManager() {

  		// for Three.js
  		this.threeVector3s = [];
  		this.threeMatrix4s = [];
  		this.threeQuaternions = [];
  		this.threeEulers = [];

  		// for Ammo.js
  		this.transforms = [];
  		this.quaternions = [];
  		this.vector3s = [];

  	}

  	ResourceManager.prototype = {

  		constructor: ResourceManager,

  		allocThreeVector3: function () {

  			return ( this.threeVector3s.length > 0 )
  				? this.threeVector3s.pop()
  				: new Vector3();

  		},

  		freeThreeVector3: function ( v ) {

  			this.threeVector3s.push( v );

  		},

  		allocThreeMatrix4: function () {

  			return ( this.threeMatrix4s.length > 0 )
  				? this.threeMatrix4s.pop()
  				: new Matrix4();

  		},

  		freeThreeMatrix4: function ( m ) {

  			this.threeMatrix4s.push( m );

  		},

  		allocThreeQuaternion: function () {

  			return ( this.threeQuaternions.length > 0 )
  				? this.threeQuaternions.pop()
  				: new Quaternion();

  		},

  		freeThreeQuaternion: function ( q ) {

  			this.threeQuaternions.push( q );

  		},

  		allocThreeEuler: function () {

  			return ( this.threeEulers.length > 0 )
  				? this.threeEulers.pop()
  				: new Euler();

  		},

  		freeThreeEuler: function ( e ) {

  			this.threeEulers.push( e );

  		},

  		allocTransform: function () {

  			return ( this.transforms.length > 0 )
  				? this.transforms.pop()
  				: new Ammo.btTransform();

  		},

  		freeTransform: function ( t ) {

  			this.transforms.push( t );

  		},

  		allocQuaternion: function () {

  			return ( this.quaternions.length > 0 )
  				? this.quaternions.pop()
  				: new Ammo.btQuaternion();

  		},

  		freeQuaternion: function ( q ) {

  			this.quaternions.push( q );

  		},

  		allocVector3: function () {

  			return ( this.vector3s.length > 0 )
  				? this.vector3s.pop()
  				: new Ammo.btVector3();

  		},

  		freeVector3: function ( v ) {

  			this.vector3s.push( v );

  		},

  		setIdentity: function ( t ) {

  			t.setIdentity();

  		},

  		getBasis: function ( t ) {

  			var q = this.allocQuaternion();
  			t.getBasis().getRotation( q );
  			return q;

  		},

  		getBasisAsMatrix3: function ( t ) {

  			var q = this.getBasis( t );
  			var m = this.quaternionToMatrix3( q );
  			this.freeQuaternion( q );
  			return m;

  		},

  		getOrigin: function( t ) {

  			return t.getOrigin();

  		},

  		setOrigin: function( t, v ) {

  			t.getOrigin().setValue( v.x(), v.y(), v.z() );

  		},

  		copyOrigin: function( t1, t2 ) {

  			var o = t2.getOrigin();
  			this.setOrigin( t1, o );

  		},

  		setBasis: function( t, q ) {

  			t.setRotation( q );

  		},

  		setBasisFromMatrix3: function( t, m ) {

  			var q = this.matrix3ToQuaternion( m );
  			this.setBasis( t, q );
  			this.freeQuaternion( q );

  		},

  		setOriginFromArray3: function ( t, a ) {

  			t.getOrigin().setValue( a[ 0 ], a[ 1 ], a[ 2 ] );

  		},

  		setOriginFromThreeVector3: function ( t, v ) {

  			t.getOrigin().setValue( v.x, v.y, v.z );

  		},

  		setBasisFromArray3: function ( t, a ) {

  			var thQ = this.allocThreeQuaternion();
  			var thE = this.allocThreeEuler();
  			thE.set( a[ 0 ], a[ 1 ], a[ 2 ] );
  			this.setBasisFromThreeQuaternion( t, thQ.setFromEuler( thE ) );

  			this.freeThreeEuler( thE );
  			this.freeThreeQuaternion( thQ );

  		},

  		setBasisFromThreeQuaternion: function ( t, a ) {

  			var q = this.allocQuaternion();

  			q.setX( a.x );
  			q.setY( a.y );
  			q.setZ( a.z );
  			q.setW( a.w );
  			this.setBasis( t, q );

  			this.freeQuaternion( q );

  		},

  		multiplyTransforms: function ( t1, t2 ) {

  			var t = this.allocTransform();
  			this.setIdentity( t );

  			var m1 = this.getBasisAsMatrix3( t1 );
  			var m2 = this.getBasisAsMatrix3( t2 );

  			var o1 = this.getOrigin( t1 );
  			var o2 = this.getOrigin( t2 );

  			var v1 = this.multiplyMatrix3ByVector3( m1, o2 );
  			var v2 = this.addVector3( v1, o1 );
  			this.setOrigin( t, v2 );

  			var m3 = this.multiplyMatrices3( m1, m2 );
  			this.setBasisFromMatrix3( t, m3 );

  			this.freeVector3( v1 );
  			this.freeVector3( v2 );

  			return t;

  		},

  		inverseTransform: function ( t ) {

  			var t2 = this.allocTransform();

  			var m1 = this.getBasisAsMatrix3( t );
  			var o = this.getOrigin( t );

  			var m2 = this.transposeMatrix3( m1 );
  			var v1 = this.negativeVector3( o );
  			var v2 = this.multiplyMatrix3ByVector3( m2, v1 );

  			this.setOrigin( t2, v2 );
  			this.setBasisFromMatrix3( t2, m2 );

  			this.freeVector3( v1 );
  			this.freeVector3( v2 );

  			return t2;

  		},

  		multiplyMatrices3: function ( m1, m2 ) {

  			var m3 = [];

  			var v10 = this.rowOfMatrix3( m1, 0 );
  			var v11 = this.rowOfMatrix3( m1, 1 );
  			var v12 = this.rowOfMatrix3( m1, 2 );

  			var v20 = this.columnOfMatrix3( m2, 0 );
  			var v21 = this.columnOfMatrix3( m2, 1 );
  			var v22 = this.columnOfMatrix3( m2, 2 );

  			m3[ 0 ] = this.dotVectors3( v10, v20 );
  			m3[ 1 ] = this.dotVectors3( v10, v21 );
  			m3[ 2 ] = this.dotVectors3( v10, v22 );
  			m3[ 3 ] = this.dotVectors3( v11, v20 );
  			m3[ 4 ] = this.dotVectors3( v11, v21 );
  			m3[ 5 ] = this.dotVectors3( v11, v22 );
  			m3[ 6 ] = this.dotVectors3( v12, v20 );
  			m3[ 7 ] = this.dotVectors3( v12, v21 );
  			m3[ 8 ] = this.dotVectors3( v12, v22 );

  			this.freeVector3( v10 );
  			this.freeVector3( v11 );
  			this.freeVector3( v12 );
  			this.freeVector3( v20 );
  			this.freeVector3( v21 );
  			this.freeVector3( v22 );

  			return m3;

  		},

  		addVector3: function( v1, v2 ) {

  			var v = this.allocVector3();
  			v.setValue( v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z() );
  			return v;

  		},

  		dotVectors3: function( v1, v2 ) {

  			return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();

  		},

  		rowOfMatrix3: function( m, i ) {

  			var v = this.allocVector3();
  			v.setValue( m[ i * 3 + 0 ], m[ i * 3 + 1 ], m[ i * 3 + 2 ] );
  			return v;

  		},

  		columnOfMatrix3: function( m, i ) {

  			var v = this.allocVector3();
  			v.setValue( m[ i + 0 ], m[ i + 3 ], m[ i + 6 ] );
  			return v;

  		},

  		negativeVector3: function( v ) {

  			var v2 = this.allocVector3();
  			v2.setValue( -v.x(), -v.y(), -v.z() );
  			return v2;

  		},

  		multiplyMatrix3ByVector3: function ( m, v ) {

  			var v4 = this.allocVector3();

  			var v0 = this.rowOfMatrix3( m, 0 );
  			var v1 = this.rowOfMatrix3( m, 1 );
  			var v2 = this.rowOfMatrix3( m, 2 );
  			var x = this.dotVectors3( v0, v );
  			var y = this.dotVectors3( v1, v );
  			var z = this.dotVectors3( v2, v );

  			v4.setValue( x, y, z );

  			this.freeVector3( v0 );
  			this.freeVector3( v1 );
  			this.freeVector3( v2 );

  			return v4;

  		},

  		transposeMatrix3: function( m ) {

  			var m2 = [];
  			m2[ 0 ] = m[ 0 ];
  			m2[ 1 ] = m[ 3 ];
  			m2[ 2 ] = m[ 6 ];
  			m2[ 3 ] = m[ 1 ];
  			m2[ 4 ] = m[ 4 ];
  			m2[ 5 ] = m[ 7 ];
  			m2[ 6 ] = m[ 2 ];
  			m2[ 7 ] = m[ 5 ];
  			m2[ 8 ] = m[ 8 ];
  			return m2;

  		},

  		quaternionToMatrix3: function ( q ) {

  			var m = [];

  			var x = q.x();
  			var y = q.y();
  			var z = q.z();
  			var w = q.w();

  			var xx = x * x;
  			var yy = y * y;
  			var zz = z * z;

  			var xy = x * y;
  			var yz = y * z;
  			var zx = z * x;

  			var xw = x * w;
  			var yw = y * w;
  			var zw = z * w;

  			m[ 0 ] = 1 - 2 * ( yy + zz );
  			m[ 1 ] = 2 * ( xy - zw );
  			m[ 2 ] = 2 * ( zx + yw );
  			m[ 3 ] = 2 * ( xy + zw );
  			m[ 4 ] = 1 - 2 * ( zz + xx );
  			m[ 5 ] = 2 * ( yz - xw );
  			m[ 6 ] = 2 * ( zx - yw );
  			m[ 7 ] = 2 * ( yz + xw );
  			m[ 8 ] = 1 - 2 * ( xx + yy );

  			return m;

  		},

  		matrix3ToQuaternion: function( m ) {

  			var t = m[ 0 ] + m[ 4 ] + m[ 8 ];
  			var s, x, y, z, w;

  			if( t > 0 ) {

  				s = Math.sqrt( t + 1.0 ) * 2;
  				w = 0.25 * s;
  				x = ( m[ 7 ] - m[ 5 ] ) / s;
  				y = ( m[ 2 ] - m[ 6 ] ) / s;
  				z = ( m[ 3 ] - m[ 1 ] ) / s;

  			} else if( ( m[ 0 ] > m[ 4 ] ) && ( m[ 0 ] > m[ 8 ] ) ) {

  				s = Math.sqrt( 1.0 + m[ 0 ] - m[ 4 ] - m[ 8 ] ) * 2;
  				w = ( m[ 7 ] - m[ 5 ] ) / s;
  				x = 0.25 * s;
  				y = ( m[ 1 ] + m[ 3 ] ) / s;
  				z = ( m[ 2 ] + m[ 6 ] ) / s;

  			} else if( m[ 4 ] > m[ 8 ] ) {

  				s = Math.sqrt( 1.0 + m[ 4 ] - m[ 0 ] - m[ 8 ] ) * 2;
  				w = ( m[ 2 ] - m[ 6 ] ) / s;
  				x = ( m[ 1 ] + m[ 3 ] ) / s;
  				y = 0.25 * s;
  				z = ( m[ 5 ] + m[ 7 ] ) / s;

  			} else {

  				s = Math.sqrt( 1.0 + m[ 8 ] - m[ 0 ] - m[ 4 ] ) * 2;
  				w = ( m[ 3 ] - m[ 1 ] ) / s;
  				x = ( m[ 2 ] + m[ 6 ] ) / s;
  				y = ( m[ 5 ] + m[ 7 ] ) / s;
  				z = 0.25 * s;

  			}

  			var q = this.allocQuaternion();
  			q.setX( x );
  			q.setY( y );
  			q.setZ( z );
  			q.setW( w );
  			return q;

  		}

  	};
  	function RigidBody( mesh, world, params, manager ) {

  		this.mesh  = mesh;
  		this.world = world;
  		this.params = params;
  		this.manager = manager;

  		this.body = null;
  		this.bone = null;
  		this.boneOffsetForm = null;
  		this.boneOffsetFormInverse = null;

  		this._init();

  	}

  	RigidBody.prototype = {

  		constructor: MMDPhysics.RigidBody,
  		reset: function () {

  			this._setTransformFromBone();
  			return this;

  		},
  		updateFromBone: function () {

  			if ( this.params.boneIndex !== - 1 &&
  				this.params.type === 0 ) {

  				this._setTransformFromBone();

  			}

  			return this;

  		},
  		updateBone: function () {

  			if ( this.params.type === 0 ||
  				this.params.boneIndex === - 1 ) {

  				return this;

  			}

  			this._updateBoneRotation();

  			if ( this.params.type === 1 ) {

  				this._updateBonePosition();

  			}

  			this.bone.updateMatrixWorld( true );

  			if ( this.params.type === 2 ) {

  				this._setPositionFromBone();

  			}

  			return this;

  		},

  		// private methods

  		_init: function () {

  			function generateShape( p ) {

  				switch( p.shapeType ) {

  					case 0:
  						return new Ammo.btSphereShape( p.width );

  					case 1:
  						return new Ammo.btBoxShape( new Ammo.btVector3( p.width, p.height, p.depth ) );

  					case 2:
  						return new Ammo.btCapsuleShape( p.width, p.height );

  					default:
  						throw 'unknown shape type ' + p.shapeType;

  				}

  			}

  			var manager = this.manager;
  			var params = this.params;
  			var bones = this.mesh.skeleton.bones;
  			var bone = ( params.boneIndex === - 1 )
  				? new Bone()
  				: bones[ params.boneIndex ];

  			var shape = generateShape( params );
  			var weight = ( params.type === 0 ) ? 0 : params.weight;
  			var localInertia = manager.allocVector3();
  			localInertia.setValue( 0, 0, 0 );

  			if( weight !== 0 ) {

  				shape.calculateLocalInertia( weight, localInertia );

  			}

  			var boneOffsetForm = manager.allocTransform();
  			manager.setIdentity( boneOffsetForm );
  			manager.setOriginFromArray3( boneOffsetForm, params.position );
  			manager.setBasisFromArray3( boneOffsetForm, params.rotation );

  			var vector = manager.allocThreeVector3();
  			var boneForm = manager.allocTransform();
  			manager.setIdentity( boneForm );
  			manager.setOriginFromThreeVector3( boneForm, bone.getWorldPosition( vector ) );

  			var form = manager.multiplyTransforms( boneForm, boneOffsetForm );
  			var state = new Ammo.btDefaultMotionState( form );

  			var info = new Ammo.btRigidBodyConstructionInfo( weight, state, shape, localInertia );
  			info.set_m_friction( params.friction );
  			info.set_m_restitution( params.restitution );

  			var body = new Ammo.btRigidBody( info );

  			if ( params.type === 0 ) {

  				body.setCollisionFlags( body.getCollisionFlags() | 2 );
  				body.setActivationState( 4 );

  			}

  			body.setDamping( params.positionDamping, params.rotationDamping );
  			body.setSleepingThresholds( 0, 0 );

  			this.world.addRigidBody( body, 1 << params.groupIndex, params.groupTarget );

  			this.body = body;
  			this.bone = bone;
  			this.boneOffsetForm = boneOffsetForm;
  			this.boneOffsetFormInverse = manager.inverseTransform( boneOffsetForm );

  			manager.freeVector3( localInertia );
  			manager.freeTransform( form );
  			manager.freeTransform( boneForm );
  			manager.freeThreeVector3( vector );

  		},

  		_getBoneTransform: function () {

  			var manager = this.manager;
  			var p = manager.allocThreeVector3();
  			var q = manager.allocThreeQuaternion();
  			var s = manager.allocThreeVector3();

  			this.bone.matrixWorld.decompose( p, q, s );

  			var tr = manager.allocTransform();
  			manager.setOriginFromThreeVector3( tr, p );
  			manager.setBasisFromThreeQuaternion( tr, q );

  			var form = manager.multiplyTransforms( tr, this.boneOffsetForm );

  			manager.freeTransform( tr );
  			manager.freeThreeVector3( s );
  			manager.freeThreeQuaternion( q );
  			manager.freeThreeVector3( p );

  			return form;

  		},

  		_getWorldTransformForBone: function () {

  			var manager = this.manager;

  			var tr = manager.allocTransform();
  			this.body.getMotionState().getWorldTransform( tr );
  			var tr2 = manager.multiplyTransforms( tr, this.boneOffsetFormInverse );

  			manager.freeTransform( tr );

  			return tr2;

  		},

  		_setTransformFromBone: function () {

  			var manager = this.manager;
  			var form = this._getBoneTransform();

  			// TODO: check the most appropriate way to set
  			//this.body.setWorldTransform( form );
  			this.body.setCenterOfMassTransform( form );
  			this.body.getMotionState().setWorldTransform( form );

  			manager.freeTransform( form );

  		},

  		_setPositionFromBone: function () {

  			var manager = this.manager;
  			var form = this._getBoneTransform();

  			var tr = manager.allocTransform();
  			this.body.getMotionState().getWorldTransform( tr );
  			manager.copyOrigin( tr, form );

  			// TODO: check the most appropriate way to set
  			//this.body.setWorldTransform( tr );
  			this.body.setCenterOfMassTransform( tr );
  			this.body.getMotionState().setWorldTransform( tr );

  			manager.freeTransform( tr );
  			manager.freeTransform( form );

  		},

  		_updateBoneRotation: function () {

  			var manager = this.manager;

  			var tr = this._getWorldTransformForBone();
  			var q = manager.getBasis( tr );

  			var thQ = manager.allocThreeQuaternion();
  			var thQ2 = manager.allocThreeQuaternion();
  			var thQ3 = manager.allocThreeQuaternion();

  			thQ.set( q.x(), q.y(), q.z(), q.w() );
  			thQ2.setFromRotationMatrix( this.bone.matrixWorld );
  			thQ2.conjugate();
  			thQ2.multiply( thQ );

  			//this.bone.quaternion.multiply( thQ2 );

  			thQ3.setFromRotationMatrix( this.bone.matrix );
  			this.bone.quaternion.copy( thQ2.multiply( thQ3 ) );

  			manager.freeThreeQuaternion( thQ );
  			manager.freeThreeQuaternion( thQ2 );
  			manager.freeThreeQuaternion( thQ3 );

  			manager.freeQuaternion( q );
  			manager.freeTransform( tr );

  		},

  		_updateBonePosition: function () {

  			var manager = this.manager;

  			var tr = this.body.getCenterOfMassTransform();
  			var origin = tr.getOrigin();
  			
  			var matrixInv = manager.allocThreeMatrix4();
  			matrixInv.copy( this.bone.parent.matrixWorld ).getInverse( matrixInv );
  			
  			var pos = manager.allocThreeVector3();
  			pos.set( origin.x(), origin.y(), origin.z() ).applyMatrix4( matrixInv );

  			this.bone.position.copy( pos );

  			manager.freeThreeVector3( pos );
  			manager.freeThreeMatrix4( matrixInv );

  		}

  	};
  	function Constraint( mesh, world, bodyA, bodyB, params, manager ) {

  		this.mesh  = mesh;
  		this.world = world;
  		this.bodyA = bodyA;
  		this.bodyB = bodyB;
  		this.params = params;
  		this.manager = manager;

  		this.constraint = null;

  		this._init();

  	}

  	Constraint.prototype = {

  		constructor: Constraint,

  		// private method

  		_init: function () {

  			var manager = this.manager;
  			var params = this.params;
  			var bodyA = this.bodyA;
  			var bodyB = this.bodyB;

  			var form = manager.allocTransform();
  			manager.setIdentity( form );
  			manager.setOriginFromArray3( form, params.position );
  			manager.setBasisFromArray3( form, params.rotation );

  			var formA = manager.allocTransform();
  			var formB = manager.allocTransform();

  			bodyA.body.getMotionState().getWorldTransform( formA );
  			bodyB.body.getMotionState().getWorldTransform( formB );

  			var formInverseA = manager.inverseTransform( formA );
  			var formInverseB = manager.inverseTransform( formB );

  			var formA2 = manager.multiplyTransforms( formInverseA, form );
  			var formB2 = manager.multiplyTransforms( formInverseB, form );

  			var constraint = new Ammo.btGeneric6DofSpringConstraint( bodyA.body, bodyB.body, formA2, formB2, true );

  			var lll = manager.allocVector3();
  			var lul = manager.allocVector3();
  			var all = manager.allocVector3();
  			var aul = manager.allocVector3();

  			lll.setValue( params.translationLimitation1[ 0 ],
  			              params.translationLimitation1[ 1 ],
  			              params.translationLimitation1[ 2 ] );
  			lul.setValue( params.translationLimitation2[ 0 ],
  			              params.translationLimitation2[ 1 ],
  			              params.translationLimitation2[ 2 ] );
  			all.setValue( params.rotationLimitation1[ 0 ],
  			              params.rotationLimitation1[ 1 ],
  			              params.rotationLimitation1[ 2 ] );
  			aul.setValue( params.rotationLimitation2[ 0 ],
  			              params.rotationLimitation2[ 1 ],
  			              params.rotationLimitation2[ 2 ] );

  			constraint.setLinearLowerLimit( lll );
  			constraint.setLinearUpperLimit( lul );
  			constraint.setAngularLowerLimit( all );
  			constraint.setAngularUpperLimit( aul );

  			for ( var i = 0; i < 3; i++ ) {

  				if( params.springPosition[ i ] !== 0 ) {

  					constraint.enableSpring( i, true );
  					constraint.setStiffness( i, params.springPosition[ i ] );

  				}

  			}

  			for ( var i = 0; i < 3; i++ ) {

  				if( params.springRotation[ i ] !== 0 ) {

  					constraint.enableSpring( i + 3, true );
  					constraint.setStiffness( i + 3, params.springRotation[ i ] );

  				}

  			}
  			if ( constraint.setParam !== undefined ) {

  				for ( var i = 0; i < 6; i ++ ) {

  					// this parameter is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js
  					constraint.setParam( 2, 0.475, i );

  				}

  			}

  			this.world.addConstraint( constraint, true );
  			this.constraint = constraint;

  			manager.freeTransform( form );
  			manager.freeTransform( formA );
  			manager.freeTransform( formB );
  			manager.freeTransform( formInverseA );
  			manager.freeTransform( formInverseB );
  			manager.freeTransform( formA2 );
  			manager.freeTransform( formB2 );
  			manager.freeVector3( lll );
  			manager.freeVector3( lul );
  			manager.freeVector3( all );
  			manager.freeVector3( aul );

  		}

  	};
  	function MMDPhysicsHelper( mesh, physics ) {

  		Object3D.call( this );

  		this.root = mesh;
  		this.physics = physics;

  		this.matrix.copy( mesh.matrixWorld );
  		this.matrixAutoUpdate = false;

  		this.materials = [];

  		this.materials.push(
  			new MeshBasicMaterial( {
  				color: new Color( 0xff8888 ),
  				wireframe: true,
  				depthTest: false,
  				depthWrite: false,
  				opacity: 0.25,
  				transparent: true
  			} )
  		);

  		this.materials.push(
  			new MeshBasicMaterial( {
  				color: new Color( 0x88ff88 ),
  				wireframe: true,
  				depthTest: false,
  				depthWrite: false,
  				opacity: 0.25,
  				transparent: true
  			} )
  		);

  		this.materials.push(
  			new MeshBasicMaterial( {
  				color: new Color( 0x8888ff ),
  				wireframe: true,
  				depthTest: false,
  				depthWrite: false,
  				opacity: 0.25,
  				transparent: true
  			} )
  		);

  		this._init();

  	}

  	MMDPhysicsHelper.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: MMDPhysicsHelper,
  		updateMatrixWorld: function () {

  			var position = new Vector3();
  			var quaternion = new Quaternion();
  			var scale = new Vector3();
  			var matrixWorldInv = new Matrix4();

  			return function updateMatrixWorld( force ) {
  				var this$1 = this;


  				var mesh = this.root;

  				if ( this.visible ) {

  					var bodies = this.physics.bodies;

  					matrixWorldInv
  						.copy( mesh.matrixWorld )
  						.decompose( position, quaternion, scale )
  						.compose( position, quaternion, scale.set( 1, 1, 1 ) )
  						.getInverse( matrixWorldInv );

  					for ( var i = 0, il = bodies.length; i < il; i ++ ) {

  						var body = bodies[ i ].body;
  						var child = this$1.children[ i ];

  						var tr = body.getCenterOfMassTransform();
  						var origin = tr.getOrigin();
  						var rotation = tr.getRotation();

  						child.position
  							.set( origin.x(), origin.y(), origin.z() )
  							.applyMatrix4( matrixWorldInv );

  						child.quaternion
  							.setFromRotationMatrix( matrixWorldInv )
  							.multiply(
  								quaternion.set(
  									rotation.x(), rotation.y(), rotation.z(), rotation.w() )
  							);

  					}

  				}

  				this.matrix
  					.copy( mesh.matrixWorld )
  					.decompose( position, quaternion, scale )
  					.compose( position, quaternion, scale.set( 1, 1, 1 ) );

  				Object3D.prototype.updateMatrixWorld.call( this, force );

  			};

  		}(),

  		// private method

  		_init: function () {
  			var this$1 = this;


  			var bodies = this.physics.bodies;

  			function createGeometry( param ) {

  				switch ( param.shapeType ) {

  					case 0:
  						return new SphereBufferGeometry( param.width, 16, 8 );

  					case 1:
  						return new BoxBufferGeometry( param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8 );

  					case 2:
  						return new createCapsuleGeometry( param.width, param.height, 16, 8 );

  					default:
  						return null;

  				}

  			}

  			// copy from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mytest37.js?ver=20160815
  			function createCapsuleGeometry( radius, cylinderHeight, segmentsRadius, segmentsHeight ) {

  				var geometry = new CylinderBufferGeometry( radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true );
  				var upperSphere = new Mesh( new SphereBufferGeometry( radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2 ) );
  				var lowerSphere = new Mesh( new SphereBufferGeometry( radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2 ) );

  				upperSphere.position.set( 0, cylinderHeight / 2, 0 );
  				lowerSphere.position.set( 0, - cylinderHeight / 2, 0 );

  				upperSphere.updateMatrix();
  				lowerSphere.updateMatrix();

  				geometry.merge( upperSphere.geometry, upperSphere.matrix );
  				geometry.merge( lowerSphere.geometry, lowerSphere.matrix );

  				return geometry;

  			}

  			for ( var i = 0, il = bodies.length; i < il; i ++ ) {

  				var param = bodies[ i ].params;
  				this$1.add( new Mesh( createGeometry( param ), this$1.materials[ param.type ] ) );

  			}

  		}

  	} );

  	return MMDPhysics;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MMDAnimationHelper = ( function () {
  	function MMDAnimationHelper( params ) {

  		params = params || {};

  		this.meshes = [];

  		this.camera = null;
  		this.cameraTarget = new Object3D();
  		this.cameraTarget.name = 'target';

  		this.audio = null;
  		this.audioManager = null;

  		this.objects = new WeakMap();

  		this.configuration = {
  			sync: params.sync !== undefined
  				? params.sync : true,
  			afterglow: params.afterglow !== undefined
  				? params.afterglow : 0.0,
  			resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined
  				? params.resetPhysicsOnLoop : true
  		};

  		this.enabled = {
  			animation: true,
  			ik: true,
  			grant: true,
  			physics: true,
  			cameraAnimation: true
  		};

  		this.onBeforePhysics = function ( mesh ) {};

  		// experimental
  		this.sharedPhysics = false;
  		this.masterPhysics = null;

  	}

  	MMDAnimationHelper.prototype = {

  		constructor: MMDAnimationHelper,
  		add: function ( object, params ) {

  			params = params || {};

  			if ( object.isSkinnedMesh ) {

  				this._addMesh( object, params );

  			} else if ( object.isCamera ) {

  				this._setupCamera( object, params );

  			} else if ( object.type === 'Audio' ) {

  				this._setupAudio( object, params );

  			} else {

  				throw new Error( 'MMDAnimationHelper.add: '
  					+ 'accepts only '
  					+ 'SkinnedMesh or '
  					+ 'Camera or '
  					+ 'Audio instance.' );

  			}

  			if ( this.configuration.sync ) { this._syncDuration(); }

  			return this;

  		},
  		remove: function ( object ) {

  			if ( object.isSkinnedMesh ) {

  				this._removeMesh( object );

  			} else if ( object.isCamera ) {

  				this._clearCamera( object );

  			} else if ( object.type === 'Audio' ) {

  				this._clearAudio( object );

  			} else {

  				throw new Error( 'MMDAnimationHelper.remove: '
  					+ 'accepts only '
  					+ 'SkinnedMesh or '
  					+ 'Camera or '
  					+ 'Audio instance.' );

  			}

  			if ( this.configuration.sync ) { this._syncDuration(); }

  			return this;

  		},
  		update: function ( delta ) {
  			var this$1 = this;


  			if ( this.audioManager !== null ) { this.audioManager.control( delta ); }

  			for ( var i = 0; i < this.meshes.length; i ++ ) {

  				this$1._animateMesh( this$1.meshes[ i ], delta );

  			}

  			if ( this.sharedPhysics ) { this._updateSharedPhysics( delta ); }

  			if ( this.camera !== null ) { this._animateCamera( this.camera, delta ); }

  			return this;

  		},
  		pose: function ( mesh, vpd, params ) {

  			params = params || {};

  			if ( params.resetPose !== false ) { mesh.pose(); }

  			var bones = mesh.skeleton.bones;
  			var boneParams = vpd.bones;

  			var boneNameDictionary = {};

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				boneNameDictionary[ bones[ i ].name ] = i;

  			}

  			var vector = new Vector3();
  			var quaternion = new Quaternion();

  			for ( var i = 0, il = boneParams.length; i < il; i ++ ) {

  				var boneParam = boneParams[ i ];
  				var boneIndex = boneNameDictionary[ boneParam.name ];

  				if ( boneIndex === undefined ) { continue; }

  				var bone = bones[ boneIndex ];
  				bone.position.add( vector.fromArray( boneParam.translation ) );
  				bone.quaternion.multiply( quaternion.fromArray( boneParam.quaternion ) );

  			}

  			mesh.updateMatrixWorld( true );

  			if ( params.ik !== false ) {

  				this._createCCDIKSolver( mesh ).update( params.saveOriginalBonesBeforeIK ); // this param is experimental

  			}

  			if ( params.grant !== false ) {

  				this.createGrantSolver( mesh ).update();

  			}

  			return this;

  		},
  		enable: function ( key, enabled ) {
  			var this$1 = this;


  			if ( this.enabled[ key ] === undefined ) {

  				throw new Error( 'MMDAnimationHelper.enable: '
  					+ 'unknown key ' + key );

  			}

  			this.enabled[ key ] = enabled;

  			if ( key === 'physics' ) {

  				for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  					this$1._optimizeIK( this$1.meshes[ i ], enabled );

  				}

  			}

  			return this;

  		},
  		createGrantSolver: function ( mesh ) {

  			return new GrantSolver( mesh, mesh.geometry.userData.MMD.grants );

  		},

  		// private methods

  		_addMesh: function ( mesh, params ) {

  			if ( this.meshes.indexOf( mesh ) >= 0 ) {

  				throw new Error( 'MMDAnimationHelper._addMesh: '
  					+ 'SkinnedMesh \'' + mesh.name + '\' has already been added.' );

  			}

  			this.meshes.push( mesh );
  			this.objects.set( mesh, { looped: false } );

  			this._setupMeshAnimation( mesh, params.animation );

  			if ( params.physics !== false ) {

  				this._setupMeshPhysics( mesh, params );

  			}

  			return this;

  		},

  		_setupCamera: function ( camera, params ) {

  			if ( this.camera === camera ) {

  				throw new Error( 'MMDAnimationHelper._setupCamera: '
  					+ 'Camera \'' + camera.name + '\' has already been set.' );

  			}

  			if ( this.camera ) { this.clearCamera( this.camera ); }

  			this.camera = camera;

  			camera.add( this.cameraTarget );

  			this.objects.set( camera, {} );

  			if ( params.animation !== undefined ) {

  				this._setupCameraAnimation( camera, params.animation );

  			}

  			return this;

  		},

  		_setupAudio: function ( audio, params ) {

  			if ( this.audio === audio ) {

  				throw new Error( 'MMDAnimationHelper._setupAudio: '
  					+ 'Audio \'' + audio.name + '\' has already been set.' );

  			}

  			if ( this.audio ) { this.clearAudio( this.audio ); }

  			this.audio = audio;
  			this.audioManager = new AudioManager( audio, params );

  			this.objects.set( this.audioManager, {
  				duration: this.audioManager.duration
  			} );

  			return this;

  		},

  		_removeMesh: function ( mesh ) {
  			var this$1 = this;


  			var found = false;
  			var writeIndex = 0;

  			for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  				if ( this$1.meshes[ i ] === mesh ) {

  					this$1.objects.delete( mesh );
  					found = true;

  					continue;

  				}

  				this$1.meshes[ writeIndex ++ ] = this$1.meshes[ i ];

  			}

  			if ( ! found ) {

  				throw new Error( 'MMDAnimationHelper._removeMesh: '
  					+ 'SkinnedMesh \'' + mesh.name + '\' has not been added yet.' );

  			}

  			this.meshes.length = writeIndex;

  			return this;

  		},

  		_clearCamera: function ( camera ) {

  			if ( camera !== this.camera ) {

  				throw new Error( 'MMDAnimationHelper._clearCamera: '
  					+ 'Camera \'' + camera.name + '\' has not been set yet.' );

  			}

  			this.camera.remove( this.cameraTarget );

  			this.objects.delete( this.camera );
  			this.camera = null;

  			return this;

  		},

  		_clearAudio: function ( audio ) {

  			if ( audio !== this.audio ) {

  				throw new Error( 'MMDAnimationHelper._clearAudio: '
  					+ 'Audio \'' + audio.name + '\' has not been set yet.' );

  			}

  			this.objects.delete( this.audioManager );

  			this.audio = null;
  			this.audioManager = null;

  			return this;

  		},

  		_setupMeshAnimation: function ( mesh, animation ) {

  			var objects = this.objects.get( mesh );

  			if ( animation !== undefined ) {

  				var animations = Array.isArray( animation )
  					? animation : [ animation ];

  				objects.mixer = new AnimationMixer( mesh );

  				for ( var i = 0, il = animations.length; i < il; i ++ ) {

  					objects.mixer.clipAction( animations[ i ] ).play();

  				}

  				// TODO: find a workaround not to access ._clip looking like a private property
  				objects.mixer.addEventListener( 'loop', function ( event ) {

  					var tracks = event.action._clip.tracks;

  					if ( tracks.length > 0 &&
  					     tracks[ 0 ].name.slice( 0, 6 ) !== '.bones' ) { return; }

  					objects.looped = true;

  				} );

  			}

  			objects.ikSolver = this._createCCDIKSolver( mesh );
  			objects.grantSolver = this.createGrantSolver( mesh );

  			return this;

  		},

  		_setupCameraAnimation: function ( camera, animation ) {

  			var animations = Array.isArray( animation )
  				? animation : [ animation ];

  			var objects = this.objects.get( camera );

  			objects.mixer = new AnimationMixer( camera );

  			for ( var i = 0, il = animations.length; i < il; i ++ ) {

  				objects.mixer.clipAction( animations[ i ] ).play();

  			}

  		},

  		_setupMeshPhysics: function ( mesh, params ) {

  			var objects = this.objects.get( mesh );

  			// shared physics is experimental

  			if ( params.world === undefined && this.sharedPhysics ) {

  				var masterPhysics = this._getMasterPhysics();

  				if ( masterPhysics !== null ) { world = masterPhysics.world; }

  			}

  			objects.physics = this._createMMDPhysics( mesh, params );

  			if ( objects.mixer && params.animationWarmup !== false ) {

  				this._animateMesh( mesh, 0 );
  				objects.physics.reset();

  			}

  			objects.physics.warmup( params.warmup !== undefined ? params.warmup : 60 );

  			this._optimizeIK( mesh, true );

  		},

  		_animateMesh: function ( mesh, delta ) {

  			var objects = this.objects.get( mesh );

  			var mixer = objects.mixer;
  			var ikSolver = objects.ikSolver;
  			var grantSolver = objects.grantSolver;
  			var physics = objects.physics;
  			var looped = objects.looped;

  			// alternate solution to save/restore bones but less performant?
  			//mesh.pose();
  			//this._updatePropertyMixersBuffer( mesh );

  			if ( mixer && this.enabled.animation ) {

  				this._restoreBones( mesh );

  				mixer.update( delta );

  				this._saveBones( mesh );

  				if ( ikSolver && this.enabled.ik ) {

  					mesh.updateMatrixWorld( true );
  					ikSolver.update();

  				}

  				if ( grantSolver && this.enabled.grant ) {

  					grantSolver.update();

  				}

  			}

  			if ( looped === true && this.enabled.physics ) {

  				if ( physics && this.configuration.resetPhysicsOnLoop ) { physics.reset(); }

  				objects.looped = false;

  			}

  			if ( physics && this.enabled.physics && ! this.sharedPhysics ) {

  				this.onBeforePhysics( mesh );
  				physics.update( delta );

  			}

  		},

  		_animateCamera: function ( camera, delta ) {

  			var mixer = this.objects.get( camera ).mixer;

  			if ( mixer && this.enabled.cameraAnimation ) {

  				mixer.update( delta );

  				camera.updateProjectionMatrix();

  				camera.up.set( 0, 1, 0 );
  				camera.up.applyQuaternion( camera.quaternion );
  				camera.lookAt( this.cameraTarget.position );

  			}

  		},

  		_optimizeIK: function ( mesh, physicsEnabled ) {

  			var iks = mesh.geometry.userData.MMD.iks;
  			var bones = mesh.geometry.userData.MMD.bones;

  			for ( var i = 0, il = iks.length; i < il; i ++ ) {

  				var ik = iks[ i ];
  				var links = ik.links;

  				for ( var j = 0, jl = links.length; j < jl; j ++ ) {

  					var link = links[ j ];

  					if ( physicsEnabled === true ) {

  						// disable IK of the bone the corresponding rigidBody type of which is 1 or 2
  						// because its rotation will be overriden by physics
  						link.enabled = bones[ link.index ].rigidBodyType > 0 ? false : true;

  					} else {

  						link.enabled = true;

  					}

  				}

  			}

  		},

  		_createCCDIKSolver: function ( mesh ) {

  			if ( CCDIKSolver === undefined ) {

  				throw new Error( 'MMDAnimationHelper: Import CCDIKSolver.' );

  			}

  			return new CCDIKSolver( mesh, mesh.geometry.userData.MMD.iks );

  		},

  		_createMMDPhysics: function ( mesh, params ) {

  			if ( MMDPhysics === undefined ) {

  				throw new Error( 'MMDPhysics: Import MMDPhysics.' );

  			}

  			return new MMDPhysics(
  				mesh,
  				mesh.geometry.userData.MMD.rigidBodies,
  				mesh.geometry.userData.MMD.constraints,
  				params );

  		},
  		_syncDuration: function () {
  			var this$1 = this;


  			var max = 0.0;

  			var objects = this.objects;
  			var meshes = this.meshes;
  			var camera = this.camera;
  			var audioManager = this.audioManager;

  			// get the longest duration

  			for ( var i = 0, il = meshes.length; i < il; i ++ ) {

  				var mixer = this$1.objects.get( meshes[ i ] ).mixer;

  				if ( mixer === undefined ) { continue; }

  				for ( var j = 0; j < mixer._actions.length; j ++ ) {

  					var clip = mixer._actions[ j ]._clip;

  					if ( ! objects.has( clip ) ) {

  						objects.set( clip, {
  							duration: clip.duration
  						} );

  					}

  					max = Math.max( max, objects.get( clip ).duration );

  				}

  			}

  			if ( camera !== null ) {

  				var mixer = this.objects.get( camera ).mixer;

  				if ( mixer !== undefined ) {

  					for ( var i = 0, il = mixer._actions.length; i < il; i ++ ) {

  						var clip = mixer._actions[ i ]._clip;

  						if ( ! objects.has( clip ) ) {

  							objects.set( clip, {
  								duration: clip.duration
  							} );

  						}

  						max = Math.max( max, objects.get( clip ).duration );

  					}

  				}

  			}

  			if ( audioManager !== null ) {

  				max = Math.max( max, objects.get( audioManager ).duration );

  			}

  			max += this.configuration.afterglow;

  			// update the duration

  			for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  				var mixer = this$1.objects.get( this$1.meshes[ i ] ).mixer;

  				if ( mixer === undefined ) { continue; }

  				for ( var j = 0, jl = mixer._actions.length; j < jl; j ++ ) {

  					mixer._actions[ j ]._clip.duration = max;

  				}

  			}

  			if ( camera !== null ) {

  				var mixer = this.objects.get( camera ).mixer;

  				if ( mixer !== undefined ) {

  					for ( var i = 0, il = mixer._actions.length; i < il; i ++ ) {

  						mixer._actions[ i ]._clip.duration = max;

  					}

  				}

  			}

  			if ( audioManager !== null ) {

  				audioManager.duration = max;

  			}

  		},

  		// workaround

  		_updatePropertyMixersBuffer: function ( mesh ) {

  			var mixer = this.objects.get( mesh ).mixer;

  			var propertyMixers = mixer._bindings;
  			var accuIndex = mixer._accuIndex;

  			for ( var i = 0, il = propertyMixers.length; i < il; i ++ ) {

  				var propertyMixer = propertyMixers[ i ];
  				var buffer = propertyMixer.buffer;
  				var stride = propertyMixer.valueSize;
  				var offset = ( accuIndex + 1 ) * stride;

  				propertyMixer.binding.getValue( buffer, offset );

  			}

  		},
  		_saveBones: function ( mesh ) {

  			var objects = this.objects.get( mesh );

  			var bones = mesh.skeleton.bones;

  			var backupBones = objects.backupBones;

  			if ( backupBones === undefined ) {

  				backupBones = new Float32Array( bones.length * 7 );
  				objects.backupBones = backupBones;

  			}

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				var bone = bones[ i ];
  				bone.position.toArray( backupBones, i * 7 );
  				bone.quaternion.toArray( backupBones, i * 7 + 3 );

  			}

  		},

  		_restoreBones: function ( mesh ) {

  			var objects = this.objects.get( mesh );

  			var backupBones = objects.backupBones;

  			if ( backupBones === undefined ) { return; }

  			var bones = mesh.skeleton.bones;

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				var bone = bones[ i ];
  				bone.position.fromArray( backupBones, i * 7 );
  				bone.quaternion.fromArray( backupBones, i * 7 + 3 );

  			}

  		},

  		// experimental

  		_getMasterPhysics: function () {
  			var this$1 = this;


  			if ( this.masterPhysics !== null ) { return this.masterPhysics; }

  			for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  				var physics = this$1.meshes[ i ].physics;

  				if ( physics !== undefined && physics !== null ) {

  					this$1.masterPhysics = physics;
  					return this$1.masterPhysics;

  				}

  			}

  			return null;

  		},

  		_updateSharedPhysics: function ( delta ) {
  			var this$1 = this;


  			if ( this.meshes.length === 0 || ! this.enabled.physics || ! this.sharedPhysics ) { return; }

  			var physics = this._getMasterPhysics();

  			if ( physics === null ) { return; }

  			for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  				var p = this$1.meshes[ i ].physics;

  				if ( p !== null && p !== undefined ) {

  					p.updateRigidBodies();

  				}

  			}

  			physics.stepSimulation( delta );

  			for ( var i = 0, il = this.meshes.length; i < il; i ++ ) {

  				var p = this$1.meshes[ i ].physics;

  				if ( p !== null && p !== undefined ) {

  					p.updateBones();

  				}

  			}

  		}

  	};

  	//
  	function AudioManager( audio, params ) {

  		params = params || {};

  		this.audio = audio;

  		this.elapsedTime = 0.0;
  		this.currentTime = 0.0;
  		this.delayTime = params.delayTime !== undefined
  			? params.delayTime : 0.0;

  		this.audioDuration = this.audio.buffer.duration;
  		this.duration = this.audioDuration + this.delayTime;

  	}

  	AudioManager.prototype = {

  		constructor: AudioManager,
  		control: function ( delta ) {

  			this.elapsed += delta;
  			this.currentTime += delta;

  			if ( this._shouldStopAudio() ) { this.audio.stop(); }
  			if ( this._shouldStartAudio() ) { this.audio.play(); }

  			return this;

  		},

  		// private methods

  		_shouldStartAudio: function () {
  			var this$1 = this;


  			if ( this.audio.isPlaying ) { return false; }

  			while ( this.currentTime >= this.duration ) {

  				this$1.currentTime -= this$1.duration;

  			}

  			if ( this.currentTime < this.delayTime ) { return false; }
  			
  			// 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration
  			if ( ( this.currentTime - this.delayTime ) > this.audioDuration ) { return false; }

  			this.audio.startTime = this.currentTime - this.delayTime;

  			return true;

  		},

  		_shouldStopAudio: function () {

  			return this.audio.isPlaying &&
  				this.currentTime >= this.duration;

  		}

  	};
  	function GrantSolver( mesh, grants ) {

  		this.mesh = mesh;
  		this.grants = grants || [];

  	}

  	GrantSolver.prototype = {

  		constructor: GrantSolver,
  		update: function () {

  			var quaternion = new Quaternion();

  			return function () {

  				var bones = this.mesh.skeleton.bones;
  				var grants = this.grants;

  				for ( var i = 0, il = grants.length; i < il; i ++ ) {

  					var grant = grants[ i ];
  					var bone = bones[ grant.index ];
  					var parentBone = bones[ grant.parentIndex ];

  					if ( grant.isLocal ) {

  						// TODO: implement
  						if ( grant.affectPosition ) ;

  						// TODO: implement
  						if ( grant.affectRotation ) ;

  					} else {

  						// TODO: implement
  						if ( grant.affectPosition ) ;

  						if ( grant.affectRotation ) {

  							quaternion.set( 0, 0, 0, 1 );
  							quaternion.slerp( parentBone.quaternion, grant.ratio );
  							bone.quaternion.multiply( quaternion );

  						}

  					}

  				}

  				return this;

  			};

  		}()

  	};

  	return MMDAnimationHelper;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AnimationClipCreator = function () {};

  AnimationClipCreator.CreateRotationAnimation = function ( period, axis ) {

  	var times = [ 0, period ], values = [ 0, 360 ];

  	axis = axis || 'x';
  	var trackName = '.rotation[' + axis + ']';

  	var track = new NumberKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, period, [ track ] );

  };

  AnimationClipCreator.CreateScaleAxisAnimation = function ( period, axis ) {

  	var times = [ 0, period ], values = [ 0, 1 ];

  	axis = axis || 'x';
  	var trackName = '.scale[' + axis + ']';

  	var track = new NumberKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, period, [ track ] );

  };

  AnimationClipCreator.CreateShakeAnimation = function ( duration, shakeScale ) {

  	var times = [], values = [], tmp = new Vector3();

  	for ( var i = 0; i < duration * 10; i ++ ) {

  		times.push( i / 10 );

  		tmp.set( Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0 ).
  			multiply( shakeScale ).
  			toArray( values, values.length );

  	}

  	var trackName = '.position';

  	var track = new VectorKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, duration, [ track ] );

  };
  AnimationClipCreator.CreatePulsationAnimation = function ( duration, pulseScale ) {

  	var times = [], values = [], tmp = new Vector3();

  	for ( var i = 0; i < duration * 10; i ++ ) {

  		times.push( i / 10 );

  		var scaleFactor = Math.random() * pulseScale;
  		tmp.set( scaleFactor, scaleFactor, scaleFactor ).
  			toArray( values, values.length );

  	}

  	var trackName = '.scale';

  	var track = new VectorKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, duration, [ track ] );

  };
  AnimationClipCreator.CreateVisibilityAnimation = function ( duration ) {

  	var times = [ 0, duration / 2, duration ], values = [ true, false, true ];

  	var trackName = '.visible';

  	var track = new BooleanKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, duration, [ track ] );

  };
  AnimationClipCreator.CreateMaterialColorAnimation = function ( duration, colors ) {

  	var times = [], values = [],
  		timeStep = duration / colors.length;

  	for ( var i = 0; i <= colors.length; i ++ ) {

  		times.push( i * timeStep );
  		values.push( colors[ i % colors.length ] );

  	}

  	var trackName = '.material[0].color';

  	var track = new ColorKeyframeTrack( trackName, times, values );

  	return new AnimationClip( null, duration, [ track ] );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Camera() {

  	Object3D.call( this );

  	this.type = 'Camera';

  	this.matrixWorldInverse = new Matrix4();

  	this.projectionMatrix = new Matrix4();
  	this.projectionMatrixInverse = new Matrix4();

  }

  Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Camera,

  	isCamera: true,

  	copy: function ( source, recursive ) {

  		Object3D.prototype.copy.call( this, source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );

  		this.projectionMatrix.copy( source.projectionMatrix );
  		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  		return this;

  	},

  	getWorldDirection: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Camera: .getWorldDirection() target is now required' );
  			target = new Vector3();

  		}

  		this.updateMatrixWorld( true );

  		var e = this.matrixWorld.elements;

  		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

  	},

  	updateMatrixWorld: function ( force ) {

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  		this.matrixWorldInverse.getInverse( this.matrixWorld );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PerspectiveCamera( fov, aspect, near, far ) {

  	Camera.call( this );

  	this.type = 'PerspectiveCamera';

  	this.fov = fov !== undefined ? fov : 50;
  	this.zoom = 1;

  	this.near = near !== undefined ? near : 0.1;
  	this.far = far !== undefined ? far : 2000;
  	this.focus = 10;

  	this.aspect = aspect !== undefined ? aspect : 1;
  	this.view = null;

  	this.filmGauge = 35;	// width of the film (default in millimeters)
  	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  	this.updateProjectionMatrix();

  }

  PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  	constructor: PerspectiveCamera,

  	isPerspectiveCamera: true,

  	copy: function ( source, recursive ) {

  		Camera.prototype.copy.call( this, source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	},
  	setFocalLength: function ( focalLength ) {

  		// see http://www.bobatkins.com/photography/technical/field_of_view.html
  		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	},
  	getFocalLength: function () {

  		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	},

  	getEffectiveFOV: function () {

  		return _Math.RAD2DEG * 2 * Math.atan(
  			Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	},

  	getFilmWidth: function () {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	},

  	getFilmHeight: function () {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	},
  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var near = this.near,
  			top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
  			height = 2 * top,
  			width = this.aspect * height,
  			left = - 0.5 * width,
  			view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			var fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		var skew = this.filmOffset;
  		if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function cloneUniforms( src ) {

  	var dst = {};

  	for ( var u in src ) {

  		dst[ u ] = {};

  		for ( var p in src[ u ] ) {

  			var property = src[ u ][ p ];

  			if ( property && ( property.isColor ||
  				property.isMatrix3 || property.isMatrix4 ||
  				property.isVector2 || property.isVector3 || property.isVector4 ||
  				property.isTexture ) ) {

  				dst[ u ][ p ] = property.clone();

  			} else if ( Array.isArray( property ) ) {

  				dst[ u ][ p ] = property.slice();

  			} else {

  				dst[ u ][ p ] = property;

  			}

  		}

  	}

  	return dst;

  }

  function mergeUniforms( uniforms ) {

  	var merged = {};

  	for ( var u = 0; u < uniforms.length; u ++ ) {

  		var tmp = cloneUniforms( uniforms[ u ] );

  		for ( var p in tmp ) {

  			merged[ p ] = tmp[ p ];

  		}

  	}

  	return merged;

  }

  // Legacy

  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var default_vertex = "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var default_fragment = "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ShaderMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'ShaderMaterial';

  	this.defines = {};
  	this.uniforms = {};

  	this.vertexShader = default_vertex;
  	this.fragmentShader = default_fragment;

  	this.linewidth = 1;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false; // set to use scene fog
  	this.lights = false; // set to use scene lights
  	this.clipping = false; // set to use user-defined clipping planes

  	this.skinning = false; // set to use skinning attribute streams
  	this.morphTargets = false; // set to use morph targets
  	this.morphNormals = false; // set to use morph normals

  	this.extensions = {
  		derivatives: false, // set to use derivatives
  		fragDepth: false, // set to use fragment depth values
  		drawBuffers: false, // set to use draw buffers
  		shaderTextureLOD: false // set to use shader texture LOD
  	};

  	// When rendered geometry doesn't include these attributes but the material does,
  	// use these default values in WebGL. This avoids errors when buffer data is missing.
  	this.defaultAttributeValues = {
  		'color': [ 1, 1, 1 ],
  		'uv': [ 0, 0 ],
  		'uv2': [ 0, 0 ]
  	};

  	this.index0AttributeName = undefined;
  	this.uniformsNeedUpdate = false;

  	if ( parameters !== undefined ) {

  		if ( parameters.attributes !== undefined ) {

  			console.error( 'ShaderMaterial: attributes should now be defined in BufferGeometry instead.' );

  		}

  		this.setValues( parameters );

  	}

  }

  ShaderMaterial.prototype = Object.create( Material$1.prototype );
  ShaderMaterial.prototype.constructor = ShaderMaterial;

  ShaderMaterial.prototype.isShaderMaterial = true;

  ShaderMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.fragmentShader = source.fragmentShader;
  	this.vertexShader = source.vertexShader;

  	this.uniforms = cloneUniforms( source.uniforms );

  	this.defines = Object.assign( {}, source.defines );

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.lights = source.lights;
  	this.clipping = source.clipping;

  	this.skinning = source.skinning;

  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	this.extensions = source.extensions;

  	return this;

  };

  ShaderMaterial.prototype.toJSON = function ( meta ) {
  	var this$1 = this;


  	var data = Material$1.prototype.toJSON.call( this, meta );

  	data.uniforms = {};

  	for ( var name in this$1.uniforms ) {

  		var uniform = this$1.uniforms[ name ];
  		var value = uniform.value;

  		if ( value && value.isTexture ) {

  			data.uniforms[ name ] = {
  				type: 't',
  				value: value.toJSON( meta ).uuid
  			};

  		} else if ( value && value.isColor ) {

  			data.uniforms[ name ] = {
  				type: 'c',
  				value: value.getHex()
  			};

  		} else if ( value && value.isVector2 ) {

  			data.uniforms[ name ] = {
  				type: 'v2',
  				value: value.toArray()
  			};

  		} else if ( value && value.isVector3 ) {

  			data.uniforms[ name ] = {
  				type: 'v3',
  				value: value.toArray()
  			};

  		} else if ( value && value.isVector4 ) {

  			data.uniforms[ name ] = {
  				type: 'v4',
  				value: value.toArray()
  			};

  		} else if ( value && value.isMatrix3 ) {

  			data.uniforms[ name ] = {
  				type: 'm3',
  				value: value.toArray()
  			};

  		} else if ( value && value.isMatrix4 ) {

  			data.uniforms[ name ] = {
  				type: 'm4',
  				value: value.toArray()
  			};

  		} else {

  			data.uniforms[ name ] = {
  				value: value
  			};

  			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  		}

  	}

  	if ( Object.keys( this.defines ).length > 0 ) { data.defines = this.defines; }

  	data.vertexShader = this.vertexShader;
  	data.fragmentShader = this.fragmentShader;

  	var extensions = {};

  	for ( var key in this$1.extensions ) {

  		if ( this$1.extensions[ key ] === true ) { extensions[ key ] = true; }

  	}

  	if ( Object.keys( extensions ).length > 0 ) { data.extensions = extensions; }

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Scene() {

  	Object3D.call( this );

  	this.type = 'Scene';

  	this.background = null;
  	this.fog = null;
  	this.overrideMaterial = null;

  	this.autoUpdate = true; // checked by the renderer

  }

  Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Scene,

  	isScene: true,

  	copy: function ( source, recursive ) {

  		Object3D.prototype.copy.call( this, source, recursive );

  		if ( source.background !== null ) { this.background = source.background.clone(); }
  		if ( source.fog !== null ) { this.fog = source.fog.clone(); }
  		if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

  		this.autoUpdate = source.autoUpdate;
  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
  		if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

  		return data;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function OrthographicCamera( left, right, top, bottom, near, far ) {

  	Camera.call( this );

  	this.type = 'OrthographicCamera';

  	this.zoom = 1;
  	this.view = null;

  	this.left = ( left !== undefined ) ? left : - 1;
  	this.right = ( right !== undefined ) ? right : 1;
  	this.top = ( top !== undefined ) ? top : 1;
  	this.bottom = ( bottom !== undefined ) ? bottom : - 1;

  	this.near = ( near !== undefined ) ? near : 0.1;
  	this.far = ( far !== undefined ) ? far : 2000;

  	this.updateProjectionMatrix();

  }

  OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  	constructor: OrthographicCamera,

  	isOrthographicCamera: true,

  	copy: function ( source, recursive ) {

  		Camera.prototype.copy.call( this, source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	},

  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		var cx = ( this.right + this.left ) / 2;
  		var cy = ( this.top + this.bottom ) / 2;

  		var left = cx - dx;
  		var right = cx + dx;
  		var top = cy + dy;
  		var bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
  			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
  			var scaleW = ( this.right - this.left ) / this.view.width;
  			var scaleH = ( this.top - this.bottom ) / this.view.height;

  			left += scaleW * ( this.view.offsetX / zoomW );
  			right = left + scaleW * ( this.view.width / zoomW );
  			top -= scaleH * ( this.view.offsetY / zoomH );
  			bottom = top - scaleH * ( this.view.height / zoomH );

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  		this.projectionMatrixInverse.getInverse( this.projectionMatrix );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		return data;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var _canvas;

  var ImageUtils = {

  	getDataURL: function ( image ) {

  		var canvas;

  		if ( typeof HTMLCanvasElement == 'undefined' ) {

  			return image.src;

  		} else if ( image instanceof HTMLCanvasElement ) {

  			canvas = image;

  		} else {

  			if ( _canvas === undefined ) { _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ); }

  			_canvas.width = image.width;
  			_canvas.height = image.height;

  			var context = _canvas.getContext( '2d' );

  			if ( image instanceof ImageData ) {

  				context.putImageData( image, 0, 0 );

  			} else {

  				context.drawImage( image, 0, 0, image.width, image.height );

  			}

  			canvas = _canvas;

  		}

  		if ( canvas.width > 2048 || canvas.height > 2048 ) {

  			return canvas.toDataURL( 'image/jpeg', 0.6 );

  		} else {

  			return canvas.toDataURL( 'image/png' );

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var textureId = 0;

  function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	Object.defineProperty( this, 'id', { value: textureId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';

  	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  	this.mipmaps = [];

  	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

  	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

  	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

  	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  	this.format = format !== undefined ? format : RGBAFormat;
  	this.type = type !== undefined ? type : UnsignedByteType;

  	this.offset = new Vector2( 0, 0 );
  	this.repeat = new Vector2( 1, 1 );
  	this.center = new Vector2( 0, 0 );
  	this.rotation = 0;

  	this.matrixAutoUpdate = true;
  	this.matrix = new Matrix3();

  	this.generateMipmaps = true;
  	this.premultiplyAlpha = false;
  	this.flipY = true;
  	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  	// Values of encoding !== LinearEncoding only supported on map, envMap and emissiveMap.
  	//
  	// Also changing the encoding after already used by a Material will not automatically make the Material
  	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

  	this.version = 0;
  	this.onUpdate = null;

  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;

  Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: Texture,

  	isTexture: true,

  	updateMatrix: function () {

  		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.image = source.image;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.encoding = source.encoding;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		var output = {

  			metadata: {
  				version: 4.5,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			mapping: this.mapping,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			format: this.format,
  			type: this.type,
  			encoding: this.encoding,

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY,

  			premultiplyAlpha: this.premultiplyAlpha,
  			unpackAlignment: this.unpackAlignment

  		};

  		if ( this.image !== undefined ) {

  			// TODO: Move to Image

  			var image = this.image;

  			if ( image.uuid === undefined ) {

  				image.uuid = _Math.generateUUID(); // UGH

  			}

  			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

  				var url;

  				if ( Array.isArray( image ) ) {

  					// process array of images e.g. CubeTexture

  					url = [];

  					for ( var i = 0, l = image.length; i < l; i ++ ) {

  						url.push( ImageUtils.getDataURL( image[ i ] ) );

  					}

  				} else {

  					// process single image

  					url = ImageUtils.getDataURL( image );

  				}

  				meta.images[ image.uuid ] = {
  					uuid: image.uuid,
  					url: url
  				};

  			}

  			output.image = image.uuid;

  		}

  		if ( ! isRootObject ) {

  			meta.textures[ this.uuid ] = output;

  		}

  		return output;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	},

  	transformUv: function ( uv ) {

  		if ( this.mapping !== UVMapping ) { return uv; }

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}
  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}
  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  		return uv;

  	}

  } );

  Object.defineProperty( Texture.prototype, "needsUpdate", {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLRenderTarget( width, height, options ) {

  	this.width = width;
  	this.height = height;

  	this.scissor = new Vector4( 0, 0, width, height );
  	this.scissorTest = false;

  	this.viewport = new Vector4( 0, 0, width, height );

  	options = options || {};

  	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  	this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  	this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  	constructor: WebGLRenderTarget,

  	isWebGLRenderTarget: true,

  	setSize: function ( width, height ) {

  		if ( this.width !== width || this.height !== height ) {

  			this.width = width;
  			this.height = height;

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.width = source.width;
  		this.height = source.height;

  		this.viewport.copy( source.viewport );

  		this.texture = source.texture.clone();

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // PlaneGeometry

  function PlaneGeometry( width, height, widthSegments, heightSegments ) {

  	Geometry.call( this );

  	this.type = 'PlaneGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
  	this.mergeVertices();

  }

  PlaneGeometry.prototype = Object.create( Geometry.prototype );
  PlaneGeometry.prototype.constructor = PlaneGeometry;

  // PlaneBufferGeometry

  function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

  	BufferGeometry.call( this );

  	this.type = 'PlaneBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	width = width || 1;
  	height = height || 1;

  	var width_half = width / 2;
  	var height_half = height / 2;

  	var gridX = Math.floor( widthSegments ) || 1;
  	var gridY = Math.floor( heightSegments ) || 1;

  	var gridX1 = gridX + 1;
  	var gridY1 = gridY + 1;

  	var segment_width = width / gridX;
  	var segment_height = height / gridY;

  	var ix, iy;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy < gridY1; iy ++ ) {

  		var y = iy * segment_height - height_half;

  		for ( ix = 0; ix < gridX1; ix ++ ) {

  			var x = ix * segment_width - width_half;

  			vertices.push( x, - y, 0 );

  			normals.push( 0, 0, 1 );

  			uvs.push( ix / gridX );
  			uvs.push( 1 - ( iy / gridY ) );

  		}

  	}

  	// indices

  	for ( iy = 0; iy < gridY; iy ++ ) {

  		for ( ix = 0; ix < gridX; ix ++ ) {

  			var a = ix + gridX1 * iy;
  			var b = ix + gridX1 * ( iy + 1 );
  			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  			var d = ( ix + 1 ) + gridX1 * iy;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BokehShader = {

  	defines: {
  		"DEPTH_PACKING": 1,
  		"PERSPECTIVE_CAMERA": 1,
  	},

  	uniforms: {

  		"tColor":   { value: null },
  		"tDepth":   { value: null },
  		"focus":    { value: 1.0 },
  		"aspect":   { value: 1.0 },
  		"aperture": { value: 0.025 },
  		"maxblur":  { value: 1.0 },
  		"nearClip":  { value: 1.0 },
  		"farClip":  { value: 1000.0 },

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [
  		"#include <common>",

  		"varying vec2 vUv;",

  		"uniform sampler2D tColor;",
  		"uniform sampler2D tDepth;",

  		"uniform float maxblur;",  // max blur amount
  		"uniform float aperture;", // aperture - bigger values for shallower depth of field

  		"uniform float nearClip;",
  		"uniform float farClip;",

  		"uniform float focus;",
  		"uniform float aspect;",

  		"#include <packing>",

  		"float getDepth( const in vec2 screenPosition ) {",
  		"	#if DEPTH_PACKING == 1",
  		"	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
  		"	#else",
  		"	return texture2D( tDepth, screenPosition ).x;",
  		"	#endif",
  		"}",

  		"float getViewZ( const in float depth ) {",
  		"	#if PERSPECTIVE_CAMERA == 1",
  		"	return perspectiveDepthToViewZ( depth, nearClip, farClip );",
  		"	#else",
  		"	return orthographicDepthToViewZ( depth, nearClip, farClip );",
  		"	#endif",
  		"}",
  		"void main() {",

  			"vec2 aspectcorrect = vec2( 1.0, aspect );",
  	
  			"float viewZ = getViewZ( getDepth( vUv ) );",

  			"float factor = ( focus + viewZ );",  // viewZ is <= 0, so this is a difference equation

  			"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",

  			"vec2 dofblur9 = dofblur * 0.9;",
  			"vec2 dofblur7 = dofblur * 0.7;",
  			"vec2 dofblur4 = dofblur * 0.4;",

  			"vec4 col = vec4( 0.0 );",

  			"col += texture2D( tColor, vUv.xy );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",

  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",

  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",

  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
  			"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",

  			"gl_FragColor = col / 41.0;",
  			"gl_FragColor.a = 1.0;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BokehShader2 = {

  	uniforms: {

  		"textureWidth":  { value: 1.0 },
  		"textureHeight":  { value: 1.0 },

  		"focalDepth":   { value: 1.0 },
  		"focalLength":   { value: 24.0 },
  		"fstop": { value: 0.9 },

  		"tColor":   { value: null },
  		"tDepth":   { value: null },

  		"maxblur":  { value: 1.0 },

  		"showFocus":   { value: 0 },
  		"manualdof":   { value: 0 },
  		"vignetting":   { value: 0 },
  		"depthblur":   { value: 0 },

  		"threshold":  { value: 0.5 },
  		"gain":  { value: 2.0 },
  		"bias":  { value: 0.5 },
  		"fringe":  { value: 0.7 },

  		"znear":  { value: 0.1 },
  		"zfar":  { value: 100 },

  		"noise":  { value: 1 },
  		"dithering":  { value: 0.0001 },
  		"pentagon": { value: 0 },

  		"shaderFocus":  { value: 1 },
  		"focusCoords":  { value: new Vector2() }
  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#include <common>",

  		"varying vec2 vUv;",

  		"uniform sampler2D tColor;",
  		"uniform sampler2D tDepth;",
  		"uniform float textureWidth;",
  		"uniform float textureHeight;",

  		"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below",
  		"uniform float focalLength; //focal length in mm",
  		"uniform float fstop; //f-stop value",
  		"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)",

  		"",

  		"uniform float znear; // camera clipping start",
  		"uniform float zfar; // camera clipping end",

  		"//------------------------------------------",
  		"//user variables",

  		"const int samples = SAMPLES; //samples on the first ring",
  		"const int rings = RINGS; //ring count",

  		"const int maxringsamples = rings * samples;",

  		"uniform bool manualdof; // manual dof calculation",
  		"float ndofstart = 1.0; // near dof blur start",
  		"float ndofdist = 2.0; // near dof blur falloff distance",
  		"float fdofstart = 1.0; // far dof blur start",
  		"float fdofdist = 3.0; // far dof blur falloff distance",

  		"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)",

  		"uniform bool vignetting; // use optical lens vignetting",

  		"float vignout = 1.3; // vignetting outer border",
  		"float vignin = 0.0; // vignetting inner border",
  		"float vignfade = 22.0; // f-stops till vignete fades",

  		"uniform bool shaderFocus;",
  		"// disable if you use external focalDepth value",

  		"uniform vec2 focusCoords;",
  		"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)",
  		"// if center of screen use vec2(0.5, 0.5);",

  		"uniform float maxblur;",
  		"//clamp value of max blur (0.0 = no blur, 1.0 default)",

  		"uniform float threshold; // highlight threshold;",
  		"uniform float gain; // highlight gain;",

  		"uniform float bias; // bokeh edge bias",
  		"uniform float fringe; // bokeh chromatic aberration / fringing",

  		"uniform bool noise; //use noise instead of pattern for sample dithering",

  		"uniform float dithering;",

  		"uniform bool depthblur; // blur the depth buffer",
  		"float dbsize = 1.25; // depth blur size",

  		"",

  		"uniform bool pentagon; //use pentagon as bokeh shape?",
  		"float feather = 0.4; //pentagon shape feather",

  		"//------------------------------------------",

  		"float penta(vec2 coords) {",
  			"//pentagonal shape",
  			"float scale = float(rings) - 1.3;",
  			"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);",
  			"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);",
  			"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);",
  			"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);",
  			"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);",
  			"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);",

  			"vec4  one = vec4( 1.0 );",

  			"vec4 P = vec4((coords),vec2(scale, scale));",

  			"vec4 dist = vec4(0.0);",
  			"float inorout = -4.0;",

  			"dist.x = dot( P, HS0 );",
  			"dist.y = dot( P, HS1 );",
  			"dist.z = dot( P, HS2 );",
  			"dist.w = dot( P, HS3 );",

  			"dist = smoothstep( -feather, feather, dist );",

  			"inorout += dot( dist, one );",

  			"dist.x = dot( P, HS4 );",
  			"dist.y = HS5.w - abs( P.z );",

  			"dist = smoothstep( -feather, feather, dist );",
  			"inorout += dist.x;",

  			"return clamp( inorout, 0.0, 1.0 );",
  		"}",

  		"float bdepth(vec2 coords) {",
  			"// Depth buffer blur",
  			"float d = 0.0;",
  			"float kernel[9];",
  			"vec2 offset[9];",

  			"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;",

  			"offset[0] = vec2(-wh.x,-wh.y);",
  			"offset[1] = vec2( 0.0, -wh.y);",
  			"offset[2] = vec2( wh.x -wh.y);",

  			"offset[3] = vec2(-wh.x,  0.0);",
  			"offset[4] = vec2( 0.0,   0.0);",
  			"offset[5] = vec2( wh.x,  0.0);",

  			"offset[6] = vec2(-wh.x, wh.y);",
  			"offset[7] = vec2( 0.0,  wh.y);",
  			"offset[8] = vec2( wh.x, wh.y);",

  			"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;",
  			"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;",
  			"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;",
  			"for( int i=0; i<9; i++ ) {",
  				"float tmp = texture2D(tDepth, coords + offset[i]).r;",
  				"d += tmp * kernel[i];",
  			"}",

  			"return d;",
  		"}",
  		"vec3 color(vec2 coords,float blur) {",
  			"//processing the sample",

  			"vec3 col = vec3(0.0);",
  			"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);",

  			"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;",
  			"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;",
  			"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;",

  			"vec3 lumcoeff = vec3(0.299,0.587,0.114);",
  			"float lum = dot(col.rgb, lumcoeff);",
  			"float thresh = max((lum-threshold)*gain, 0.0);",
  			"return col+mix(vec3(0.0),col,thresh*blur);",
  		"}",

  		"vec3 debugFocus(vec3 col, float blur, float depth) {",
  			"float edge = 0.002*depth; //distance based edge smoothing",
  			"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);",
  			"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);",

  			"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);",
  			"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);",

  			"return col;",
  		"}",

  		"float linearize(float depth) {",
  			"return -zfar * znear / (depth * (zfar - znear) - zfar);",
  		"}",
  		"float vignette() {",
  			"float dist = distance(vUv.xy, vec2(0.5,0.5));",
  			"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);",
  			"return clamp(dist,0.0,1.0);",
  		"}",

  		"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {",
  			"float rings2 = float(rings);",
  			"float step = PI*2.0 / float(ringsamples);",
  			"float pw = cos(j*step)*i;",
  			"float ph = sin(j*step)*i;",
  			"float p = 1.0;",
  			"if (pentagon) {",
  				"p = penta(vec2(pw,ph));",
  			"}",
  			"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;",
  			"return 1.0 * mix(1.0, i /rings2, bias) * p;",
  		"}",

  		"void main() {",
  			"//scene depth calculation",

  			"float depth = linearize(texture2D(tDepth,vUv.xy).x);",

  			"// Blur depth?",
  			"if ( depthblur ) {",
  				"depth = linearize(bdepth(vUv.xy));",
  			"}",

  			"//focal plane calculation",

  			"float fDepth = focalDepth;",

  			"if (shaderFocus) {",

  				"fDepth = linearize(texture2D(tDepth,focusCoords).x);",

  			"}",

  			"// dof blur factor calculation",

  			"float blur = 0.0;",

  			"if (manualdof) {",
  				"float a = depth-fDepth; // Focal plane",
  				"float b = (a-fdofstart)/fdofdist; // Far DoF",
  				"float c = (-a-ndofstart)/ndofdist; // Near Dof",
  				"blur = (a>0.0) ? b : c;",
  			"} else {",
  				"float f = focalLength; // focal length in mm",
  				"float d = fDepth*1000.0; // focal plane in mm",
  				"float o = depth*1000.0; // depth in mm",

  				"float a = (o*f)/(o-f);",
  				"float b = (d*f)/(d-f);",
  				"float c = (d-f)/(d*fstop*CoC);",

  				"blur = abs(a-b)*c;",
  			"}",

  			"blur = clamp(blur,0.0,1.0);",

  			"// calculation of pattern for dithering",

  			"vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;",

  			"// getting blur x and y step factor",

  			"float w = (1.0/textureWidth)*blur*maxblur+noise.x;",
  			"float h = (1.0/textureHeight)*blur*maxblur+noise.y;",

  			"// calculation of final color",

  			"vec3 col = vec3(0.0);",

  			"if(blur < 0.05) {",
  				"//some optimization thingy",
  				"col = texture2D(tColor, vUv.xy).rgb;",
  			"} else {",
  				"col = texture2D(tColor, vUv.xy).rgb;",
  				"float s = 1.0;",
  				"int ringsamples;",

  				"for (int i = 1; i <= rings; i++) {",
  					"",
  					"ringsamples = i * samples;",

  					"for (int j = 0 ; j < maxringsamples ; j++) {",
  						"if (j >= ringsamples) break;",
  						"s += gather(float(i), float(j), ringsamples, col, w, h, blur);",
  					"}",
  					"",
  				"}",

  				"col /= s; //divide by sample count",
  			"}",

  			"if (showFocus) {",
  				"col = debugFocus(col, blur, depth);",
  			"}",

  			"if (vignetting) {",
  				"col *= vignette();",
  			"}",

  			"gl_FragColor.rgb = col;",
  			"gl_FragColor.a = 1.0;",
  		"} "

  	].join( "\n" )

  };

  var BokehDepthShader = {

  	uniforms: {

  		"mNear": { value: 1.0 },
  		"mFar": { value: 1000.0 },

  	},

  	vertexShader: [

  		"varying float vViewZDepth;",

  		"void main() {",

  		"	#include <begin_vertex>",
  		"	#include <project_vertex>",

  		"	vViewZDepth = - mvPosition.z;",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float mNear;",
  		"uniform float mFar;",

  		"varying float vViewZDepth;",

  		"void main() {",

  		"	float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );",
  		"	gl_FragColor = vec4( vec3( color ), 1.0 );",

  		"} "

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CinematicCamera = function ( fov, aspect, near, far ) {

  	PerspectiveCamera.call( this, fov, aspect, near, far );

  	this.type = 'CinematicCamera';

  	this.postprocessing = { enabled: true };
  	this.shaderSettings = {
  		rings: 3,
  		samples: 4
  	};

  	var depthShader = BokehDepthShader;

  	this.materialDepth = new ShaderMaterial( {
  		uniforms: depthShader.uniforms,
  		vertexShader: depthShader.vertexShader,
  		fragmentShader: depthShader.fragmentShader
  	} );

  	this.materialDepth.uniforms[ 'mNear' ].value = near;
  	this.materialDepth.uniforms[ 'mFar' ].value = far;

  	// In case of cinematicCamera, having a default lens set is important
  	this.setLens();

  	this.initPostProcessing();

  };

  CinematicCamera.prototype = Object.create( PerspectiveCamera.prototype );
  CinematicCamera.prototype.constructor = CinematicCamera;
  // providing fnumber and coc(Circle of Confusion) as extra arguments
  CinematicCamera.prototype.setLens = function ( focalLength, filmGauge, fNumber, coc ) {

  	// In case of cinematicCamera, having a default lens set is important
  	if ( focalLength === undefined ) { focalLength = 35; }
  	if ( filmGauge !== undefined ) { this.filmGauge = filmGauge; }

  	this.setFocalLength( focalLength );

  	// if fnumber and coc are not provided, cinematicCamera tries to act as a basic PerspectiveCamera
  	if ( fNumber === undefined ) { fNumber = 8; }
  	if ( coc === undefined ) { coc = 0.019; }

  	this.fNumber = fNumber;
  	this.coc = coc;

  	// fNumber is focalLength by aperture
  	this.aperture = focalLength / this.fNumber;

  	// hyperFocal is required to calculate depthOfField when a lens tries to focus at a distance with given fNumber and focalLength
  	this.hyperFocal = ( focalLength * focalLength ) / ( this.aperture * this.coc );

  };

  CinematicCamera.prototype.linearize = function ( depth ) {

  	var zfar = this.far;
  	var znear = this.near;
  	return - zfar * znear / ( depth * ( zfar - znear ) - zfar );

  };

  CinematicCamera.prototype.smoothstep = function ( near, far, depth ) {

  	var x = this.saturate( ( depth - near ) / ( far - near ) );
  	return x * x * ( 3 - 2 * x );

  };

  CinematicCamera.prototype.saturate = function ( x ) {

  	return Math.max( 0, Math.min( 1, x ) );

  };

  // function for focusing at a distance from the camera
  CinematicCamera.prototype.focusAt = function ( focusDistance ) {

  	if ( focusDistance === undefined ) { focusDistance = 20; }

  	var focalLength = this.getFocalLength();

  	// distance from the camera (normal to frustrum) to focus on
  	this.focus = focusDistance;

  	// the nearest point from the camera which is in focus (unused)
  	this.nearPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal + ( this.focus - focalLength ) );

  	// the farthest point from the camera which is in focus (unused)
  	this.farPoint = ( this.hyperFocal * this.focus ) / ( this.hyperFocal - ( this.focus - focalLength ) );

  	// the gap or width of the space in which is everything is in focus (unused)
  	this.depthOfField = this.farPoint - this.nearPoint;

  	// Considering minimum distance of focus for a standard lens (unused)
  	if ( this.depthOfField < 0 ) { this.depthOfField = 0; }

  	this.sdistance = this.smoothstep( this.near, this.far, this.focus );

  	this.ldistance = this.linearize( 1 -	this.sdistance );

  	this.postprocessing.bokeh_uniforms[ 'focalDepth' ].value = this.ldistance;

  };

  CinematicCamera.prototype.initPostProcessing = function () {

  	if ( this.postprocessing.enabled ) {

  		this.postprocessing.scene = new Scene();

  		this.postprocessing.camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2,	window.innerHeight / 2, window.innerHeight / - 2, - 10000, 10000 );

  		this.postprocessing.scene.add( this.postprocessing.camera );

  		var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat };
  		this.postprocessing.rtTextureDepth = new WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );
  		this.postprocessing.rtTextureColor = new WebGLRenderTarget( window.innerWidth, window.innerHeight, pars );

  		var bokeh_shader = BokehShader;

  		this.postprocessing.bokeh_uniforms = UniformsUtils.clone( bokeh_shader.uniforms );

  		this.postprocessing.bokeh_uniforms[ "tColor" ].value = this.postprocessing.rtTextureColor.texture;
  		this.postprocessing.bokeh_uniforms[ "tDepth" ].value = this.postprocessing.rtTextureDepth.texture;

  		this.postprocessing.bokeh_uniforms[ "manualdof" ].value = 0;
  		this.postprocessing.bokeh_uniforms[ "shaderFocus" ].value = 0;

  		this.postprocessing.bokeh_uniforms[ "fstop" ].value = 2.8;

  		this.postprocessing.bokeh_uniforms[ "showFocus" ].value = 1;

  		this.postprocessing.bokeh_uniforms[ "focalDepth" ].value = 0.1;

  		//console.log( this.postprocessing.bokeh_uniforms[ "focalDepth" ].value );

  		this.postprocessing.bokeh_uniforms[ "znear" ].value = this.near;
  		this.postprocessing.bokeh_uniforms[ "zfar" ].value = this.near;
  		this.postprocessing.bokeh_uniforms[ "textureWidth" ].value = window.innerWidth;

  		this.postprocessing.bokeh_uniforms[ "textureHeight" ].value = window.innerHeight;

  		this.postprocessing.materialBokeh = new ShaderMaterial( {
  			uniforms: this.postprocessing.bokeh_uniforms,
  			vertexShader: bokeh_shader.vertexShader,
  			fragmentShader: bokeh_shader.fragmentShader,
  			defines: {
  				RINGS: this.shaderSettings.rings,
  				SAMPLES: this.shaderSettings.samples,
  				DEPTH_PACKING: 1
  			}
  		} );

  		this.postprocessing.quad = new Mesh( new PlaneBufferGeometry( window.innerWidth, window.innerHeight ), this.postprocessing.materialBokeh );
  		this.postprocessing.quad.position.z = - 500;
  		this.postprocessing.scene.add( this.postprocessing.quad );

  	}

  };

  CinematicCamera.prototype.renderCinematic = function ( scene, renderer ) {

  	if ( this.postprocessing.enabled ) {

  		var currentRenderTarget = renderer.getRenderTarget();

  		renderer.clear();

  		// Render scene into texture

  		scene.overrideMaterial = null;
  		renderer.setRenderTarget( this.postprocessing.rtTextureColor );
  		renderer.clear();
  		renderer.render( scene, camera );

  		// Render depth into texture

  		scene.overrideMaterial = this.materialDepth;
  		renderer.setRenderTarget( this.postprocessing.rtTextureDepth );
  		renderer.clear();
  		renderer.render( scene, camera );

  		// Render bokeh composite

  		renderer.setRenderTarget( null );
  		renderer.render( this.postprocessing.scene, this.postprocessing.camera );

  		renderer.setRenderTarget( currentRenderTarget );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Group() {

  	Object3D.call( this );

  	this.type = 'Group';

  }

  Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Group,

  	isGroup: true

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Car = ( function ( ) {

  	// private variables
  	var steeringWheelSpeed = 1.5;
  	var maxSteeringRotation = 0.6;

  	var acceleration = 0;

  	var maxSpeedReverse, accelerationReverse, deceleration;

  	var controlKeys = { LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, BRAKE: 32 };

  	var wheelOrientation = 0;
  	var carOrientation = 0;

  	var root = null;

  	var frontLeftWheelRoot = null;
  	var frontRightWheelRoot = null;

  	var frontLeftWheel = new Group();
  	var frontRightWheel = new Group();
  	var backLeftWheel = null;
  	var backRightWheel = null;

  	var steeringWheel = null;

  	var wheelDiameter = 1;
  	var length = 1;

  	var loaded = false;

  	var controls = {

  		brake: false,
  		moveForward: false,
  		moveBackward: false,
  		moveLeft: false,
  		moveRight: false

  	};

  	function Car( maxSpeed, acceleration, brakePower, turningRadius, keys ) {

  		this.enabled = true;

  		this.elemNames = {
  			flWheel: 'wheel_fl',
  			frWheel: 'wheel_fr',
  			rlWheel: 'wheel_rl',
  			rrWheel: 'wheel_rr',
  			steeringWheel: 'steering_wheel', // set to null to disable
  		};

  		// km/hr
  		this.maxSpeed = maxSpeed || 180;
  		maxSpeedReverse = - this.maxSpeed * 0.25;

  		// m/s
  		this.acceleration = acceleration || 10;
  		accelerationReverse = this.acceleration * 0.5;

  		// metres
  		this.turningRadius = turningRadius || 6;

  		// m/s
  		deceleration = this.acceleration * 2;

  		// multiplied with deceleration, so breaking deceleration = ( acceleration * 2 * brakePower ) m/s
  		this.brakePower = brakePower || 10;

  		// exposed so that a user can use this for various effect, e.g blur
  		this.speed = 0;

  		// keys used to control car - by default the arrow keys and space to brake
  		controlKeys = keys || controlKeys;

  		// local axes of rotation - these are likely to vary between models
  		this.wheelRotationAxis = 'x';
  		this.wheelTurnAxis = 'z';
  		this.steeringWheelTurnAxis = 'y';

  		document.addEventListener( 'keydown', this.onKeyDown, false );
  		document.addEventListener( 'keyup', this.onKeyUp, false );

  	}

  	Car.prototype = {

  		constructor: Car,

  		onKeyDown: function ( event ) {

  			switch ( event.keyCode ) {

  				case controlKeys.BRAKE:
  					controls.brake = true;
  					controls.moveForward = false;
  					controls.moveBackward = false;
  					break;

  				case controlKeys.UP: controls.moveForward = true; break;

  				case controlKeys.DOWN: controls.moveBackward = true; break;

  				case controlKeys.LEFT: controls.moveLeft = true; break;

  				case controlKeys.RIGHT: controls.moveRight = true; break;

  			}

  		},

  		onKeyUp: function ( event ) {

  			switch ( event.keyCode ) {

  				case controlKeys.BRAKE: controls.brake = false; break;

  				case controlKeys.UP: controls.moveForward = false; break;

  				case controlKeys.DOWN: controls.moveBackward = false; break;

  				case controlKeys.LEFT: controls.moveLeft = false; break;

  				case controlKeys.RIGHT: controls.moveRight = false; break;

  			}

  		},

  		dispose: function () {

  			document.removeEventListener( 'keydown', this.onKeyDown, false );
  			document.removeEventListener( 'keyup', this.onKeyUp, false );

  		},

  		update: function ( delta ) {

  			if ( ! loaded || ! this.enabled ) { return; }

  			var brakingDeceleration = 1;

  			if ( controls.brake ) { brakingDeceleration = this.brakePower; }

  			if ( controls.moveForward ) {

  				this.speed = _Math.clamp( this.speed + delta * this.acceleration, maxSpeedReverse, this.maxSpeed );
  				acceleration = _Math.clamp( acceleration + delta, - 1, 1 );

  			}

  			if ( controls.moveBackward ) {

  				this.speed = _Math.clamp( this.speed - delta * accelerationReverse, maxSpeedReverse, this.maxSpeed );
  				acceleration = _Math.clamp( acceleration - delta, - 1, 1 );

  			}

  			if ( controls.moveLeft ) {

  				wheelOrientation = _Math.clamp( wheelOrientation + delta * steeringWheelSpeed, - maxSteeringRotation, maxSteeringRotation );

  			}

  			if ( controls.moveRight ) {

  				wheelOrientation = _Math.clamp( wheelOrientation - delta * steeringWheelSpeed, - maxSteeringRotation, maxSteeringRotation );

  			}

  			// this.speed decay
  			if ( ! ( controls.moveForward || controls.moveBackward ) ) {

  				if ( this.speed > 0 ) {

  					var k = exponentialEaseOut( this.speed / this.maxSpeed );

  					this.speed = _Math.clamp( this.speed - k * delta * deceleration * brakingDeceleration, 0, this.maxSpeed );
  					acceleration = _Math.clamp( acceleration - k * delta, 0, 1 );

  				} else {

  					var k = exponentialEaseOut( this.speed / maxSpeedReverse );

  					this.speed = _Math.clamp( this.speed + k * delta * accelerationReverse * brakingDeceleration, maxSpeedReverse, 0 );
  					acceleration = _Math.clamp( acceleration + k * delta, - 1, 0 );

  				}

  			}

  			// steering decay
  			if ( ! ( controls.moveLeft || controls.moveRight ) ) {

  				if ( wheelOrientation > 0 ) {

  					wheelOrientation = _Math.clamp( wheelOrientation - delta * steeringWheelSpeed, 0, maxSteeringRotation );

  				} else {

  					wheelOrientation = _Math.clamp( wheelOrientation + delta * steeringWheelSpeed, - maxSteeringRotation, 0 );

  				}

  			}

  			var forwardDelta = - this.speed * delta;

  			carOrientation -= ( forwardDelta * this.turningRadius * 0.02 ) * wheelOrientation;

  			// movement of car
  			root.position.x += Math.sin( carOrientation ) * forwardDelta * length;
  			root.position.z += Math.cos( carOrientation ) * forwardDelta * length;

  			// angle of car
  			root.rotation.y = carOrientation;

  			// wheels rolling
  			var angularSpeedRatio = - 2 / wheelDiameter;

  			var wheelDelta = forwardDelta * angularSpeedRatio * length;

  			frontLeftWheel.rotation[ this.wheelRotationAxis ] -= wheelDelta;
  			frontRightWheel.rotation[ this.wheelRotationAxis ] -= wheelDelta;
  			backLeftWheel.rotation[ this.wheelRotationAxis ] -= wheelDelta;
  			backRightWheel.rotation[ this.wheelRotationAxis ] -= wheelDelta;

  			// rotation while steering
  			frontLeftWheelRoot.rotation[ this.wheelTurnAxis ] = wheelOrientation;
  			frontRightWheelRoot.rotation[ this.wheelTurnAxis ] = wheelOrientation;

  			steeringWheel.rotation[ this.steeringWheelTurnAxis ] = -wheelOrientation * 6;

  		},

  		setModel: function ( model, elemNames ) {

  			if ( elemNames ) { this.elemNames = elemNames; }

  			root = model;

  			this.setupWheels();
  			this.computeDimensions();

  			loaded = true;

  		},

  		setupWheels: function () {

  			frontLeftWheelRoot = root.getObjectByName( this.elemNames.flWheel );
  			frontRightWheelRoot = root.getObjectByName( this.elemNames.frWheel );
  			backLeftWheel = root.getObjectByName( this.elemNames.rlWheel );
  			backRightWheel = root.getObjectByName( this.elemNames.rrWheel );

  			if ( this.elemNames.steeringWheel !== null ) { steeringWheel = root.getObjectByName( this.elemNames.steeringWheel ); }

  			while ( frontLeftWheelRoot.children.length > 0 ) { frontLeftWheel.add( frontLeftWheelRoot.children[ 0 ] ); }
  			while ( frontRightWheelRoot.children.length > 0 ) { frontRightWheel.add( frontRightWheelRoot.children[ 0 ] ); }

  			frontLeftWheelRoot.add( frontLeftWheel );
  			frontRightWheelRoot.add( frontRightWheel );

  		},

  		computeDimensions: function () {

  			var bb = new Box3().setFromObject( frontLeftWheelRoot );

  			var size = new Vector3();
  			bb.getSize( size );

  			wheelDiameter = Math.max( size.x, size.y, size.z );

  			bb.setFromObject( root );

  			size = bb.getSize( size );
  			length = Math.max( size.x, size.y, size.z );

  		}

  	};

  	function exponentialEaseOut( k ) {

  		return k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1;

  	}

  	return Car;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DeviceOrientationControls = function ( object ) {

  	var scope = this;

  	this.object = object;
  	this.object.rotation.reorder( 'YXZ' );

  	this.enabled = true;

  	this.deviceOrientation = {};
  	this.screenOrientation = 0;

  	this.alphaOffset = 0; // radians

  	var onDeviceOrientationChangeEvent = function ( event ) {

  		scope.deviceOrientation = event;

  	};

  	var onScreenOrientationChangeEvent = function () {

  		scope.screenOrientation = window.orientation || 0;

  	};

  	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

  	var setObjectQuaternion = function () {

  		var zee = new Vector3( 0, 0, 1 );

  		var euler = new Euler();

  		var q0 = new Quaternion();

  		var q1 = new Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

  		return function ( quaternion, alpha, beta, gamma, orient ) {

  			euler.set( beta, alpha, - gamma, 'YXZ' ); // 'ZXY' for the device, but 'YXZ' for us

  			quaternion.setFromEuler( euler ); // orient the device

  			quaternion.multiply( q1 ); // camera looks out the back of the device, not the top

  			quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) ); // adjust for screen orientation

  		};

  	}();

  	this.connect = function () {

  		onScreenOrientationChangeEvent(); // run once on load

  		window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
  		window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

  		scope.enabled = true;

  	};

  	this.disconnect = function () {

  		window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
  		window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

  		scope.enabled = false;

  	};

  	this.update = function () {

  		if ( scope.enabled === false ) { return; }

  		var device = scope.deviceOrientation;

  		if ( device ) {

  			var alpha = device.alpha ? _Math.degToRad( device.alpha ) + scope.alphaOffset : 0; // Z

  			var beta = device.beta ? _Math.degToRad( device.beta ) : 0; // X'

  			var gamma = device.gamma ? _Math.degToRad( device.gamma ) : 0; // Y''

  			var orient = scope.screenOrientation ? _Math.degToRad( scope.screenOrientation ) : 0; // O

  			setObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );

  		}
  	};

  	this.dispose = function () {

  		scope.disconnect();

  	};

  	this.connect();

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Plane( normal, constant ) {

  	// normal is assumed to be normalized

  	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
  	this.constant = ( constant !== undefined ) ? constant : 0;

  }

  Object.assign( Plane.prototype, {

  	set: function ( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	},

  	setComponents: function ( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	},

  	setFromNormalAndCoplanarPoint: function ( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	},

  	setFromCoplanarPoints: function () {

  		var v1 = new Vector3();
  		var v2 = new Vector3();

  		return function setFromCoplanarPoints( a, b, c ) {

  			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

  			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  			this.setFromNormalAndCoplanarPoint( normal, a );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	},

  	normalize: function () {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		var inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	},

  	negate: function () {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	},

  	distanceToPoint: function ( point ) {

  		return this.normal.dot( point ) + this.constant;

  	},

  	distanceToSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	},

  	projectPoint: function ( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Plane: .projectPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

  	},

  	intersectLine: function () {

  		var v1 = new Vector3();

  		return function intersectLine( line, target ) {

  			if ( target === undefined ) {

  				console.warn( 'Plane: .intersectLine() target is now required' );
  				target = new Vector3();

  			}

  			var direction = line.delta( v1 );

  			var denominator = this.normal.dot( direction );

  			if ( denominator === 0 ) {

  				// line is coplanar, return origin
  				if ( this.distanceToPoint( line.start ) === 0 ) {

  					return target.copy( line.start );

  				}

  				// Unsure if this is the correct method to handle this case.
  				return undefined;

  			}

  			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  			if ( t < 0 || t > 1 ) {

  				return undefined;

  			}

  			return target.copy( direction ).multiplyScalar( t ).add( line.start );

  		};

  	}(),

  	intersectsLine: function ( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		var startSign = this.distanceToPoint( line.start );
  		var endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsPlane( this );

  	},

  	intersectsSphere: function ( sphere ) {

  		return sphere.intersectsPlane( this );

  	},

  	coplanarPoint: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Plane: .coplanarPoint() target is now required' );
  			target = new Vector3();

  		}

  		return target.copy( this.normal ).multiplyScalar( - this.constant );

  	},

  	applyMatrix4: function () {

  		var v1 = new Vector3();
  		var m1 = new Matrix3();

  		return function applyMatrix4( matrix, optionalNormalMatrix ) {

  			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

  			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

  			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  			this.constant = - referencePoint.dot( normal );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	},

  	equals: function ( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Raycaster( origin, direction, near, far ) {

  	this.ray = new Ray( origin, direction );
  	// direction is assumed to be normalized (for accurate distance calculations)

  	this.near = near || 0;
  	this.far = far || Infinity;

  	this.params = {
  		Mesh: {},
  		Line: {},
  		LOD: {},
  		Points: { threshold: 1 },
  		Sprite: {}
  	};

  	Object.defineProperties( this.params, {
  		PointCloud: {
  			get: function () {

  				console.warn( 'Raycaster: params.PointCloud has been renamed to params.Points.' );
  				return this.Points;

  			}
  		}
  	} );

  }

  function ascSort( a, b ) {

  	return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

  	if ( object.visible === false ) { return; }

  	object.raycast( raycaster, intersects );

  	if ( recursive === true ) {

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			intersectObject( children[ i ], raycaster, intersects, true );

  		}

  	}

  }

  Object.assign( Raycaster.prototype, {

  	linePrecision: 1,

  	set: function ( origin, direction ) {

  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.ray.set( origin, direction );

  	},

  	setFromCamera: function ( coords, camera ) {

  		if ( ( camera && camera.isPerspectiveCamera ) ) {

  			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
  			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

  		} else if ( ( camera && camera.isOrthographicCamera ) ) {

  			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
  			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

  		} else {

  			console.error( 'Raycaster: Unsupported camera type.' );

  		}

  	},

  	intersectObject: function ( object, recursive, optionalTarget ) {

  		var intersects = optionalTarget || [];

  		intersectObject( object, this, intersects, recursive );

  		intersects.sort( ascSort );

  		return intersects;

  	},

  	intersectObjects: function ( objects, recursive, optionalTarget ) {
  		var this$1 = this;


  		var intersects = optionalTarget || [];

  		if ( Array.isArray( objects ) === false ) {

  			console.warn( 'Raycaster.intersectObjects: objects is not an Array.' );
  			return intersects;

  		}

  		for ( var i = 0, l = objects.length; i < l; i ++ ) {

  			intersectObject( objects[ i ], this$1, intersects, recursive );

  		}

  		intersects.sort( ascSort );

  		return intersects;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DragControls = function ( _objects, _camera, _domElement ) {

  	if ( _objects instanceof Camera ) {

  		console.warn( 'DragControls: Constructor now expects ( objects, camera, domElement )' );
  		var temp = _objects; _objects = _camera; _camera = temp;

  	}

  	var _plane = new Plane();
  	var _raycaster = new Raycaster();

  	var _mouse = new Vector2();
  	var _offset = new Vector3();
  	var _intersection = new Vector3();
  	var _worldPosition = new Vector3();
  	var _inverseMatrix = new Matrix4();
  	
  	var _selected = null, _hovered = null;

  	//

  	var scope = this;

  	function activate() {

  		_domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
  		_domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
  		_domElement.addEventListener( 'mouseup', onDocumentMouseCancel, false );
  		_domElement.addEventListener( 'mouseleave', onDocumentMouseCancel, false );
  		_domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
  		_domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
  		_domElement.addEventListener( 'touchend', onDocumentTouchEnd, false );

  	}

  	function deactivate() {

  		_domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
  		_domElement.removeEventListener( 'mousedown', onDocumentMouseDown, false );
  		_domElement.removeEventListener( 'mouseup', onDocumentMouseCancel, false );
  		_domElement.removeEventListener( 'mouseleave', onDocumentMouseCancel, false );
  		_domElement.removeEventListener( 'touchmove', onDocumentTouchMove, false );
  		_domElement.removeEventListener( 'touchstart', onDocumentTouchStart, false );
  		_domElement.removeEventListener( 'touchend', onDocumentTouchEnd, false );

  	}

  	function dispose() {

  		deactivate();

  	}

  	function onDocumentMouseMove( event ) {

  		event.preventDefault();

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_raycaster.setFromCamera( _mouse, _camera );

  		if ( _selected && scope.enabled ) {

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );

  			}

  			scope.dispatchEvent( { type: 'drag', object: _selected } );

  			return;

  		}

  		_raycaster.setFromCamera( _mouse, _camera );

  		var intersects = _raycaster.intersectObjects( _objects );

  		if ( intersects.length > 0 ) {

  			var object = intersects[ 0 ].object;

  			_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( object.matrixWorld ) );

  			if ( _hovered !== object ) {

  				scope.dispatchEvent( { type: 'hoveron', object: object } );

  				_domElement.style.cursor = 'pointer';
  				_hovered = object;

  			}

  		} else {

  			if ( _hovered !== null ) {

  				scope.dispatchEvent( { type: 'hoveroff', object: _hovered } );

  				_domElement.style.cursor = 'auto';
  				_hovered = null;

  			}

  		}

  	}

  	function onDocumentMouseDown( event ) {

  		event.preventDefault();

  		_raycaster.setFromCamera( _mouse, _camera );

  		var intersects = _raycaster.intersectObjects( _objects );

  		if ( intersects.length > 0 ) {

  			_selected = intersects[ 0 ].object;

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_inverseMatrix.getInverse( _selected.parent.matrixWorld );
  				_offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			}

  			_domElement.style.cursor = 'move';

  			scope.dispatchEvent( { type: 'dragstart', object: _selected } );

  		}
  	}

  	function onDocumentMouseCancel( event ) {

  		event.preventDefault();

  		if ( _selected ) {

  			scope.dispatchEvent( { type: 'dragend', object: _selected } );

  			_selected = null;

  		}

  		_domElement.style.cursor = _hovered ? 'pointer' : 'auto';

  	}

  	function onDocumentTouchMove( event ) {

  		event.preventDefault();
  		event = event.changedTouches[ 0 ];

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_raycaster.setFromCamera( _mouse, _camera );

  		if ( _selected && scope.enabled ) {

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );

  			}

  			scope.dispatchEvent( { type: 'drag', object: _selected } );

  			return;

  		}

  	}

  	function onDocumentTouchStart( event ) {

  		event.preventDefault();
  		event = event.changedTouches[ 0 ];

  		var rect = _domElement.getBoundingClientRect();

  		_mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
  		_mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

  		_raycaster.setFromCamera( _mouse, _camera );

  		var intersects = _raycaster.intersectObjects( _objects );

  		if ( intersects.length > 0 ) {

  			_selected = intersects[ 0 ].object;

  			_plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

  				_inverseMatrix.getInverse( _selected.parent.matrixWorld );
  				_offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );

  			}

  			_domElement.style.cursor = 'move';

  			scope.dispatchEvent( { type: 'dragstart', object: _selected } );

  		}
  	}

  	function onDocumentTouchEnd( event ) {

  		event.preventDefault();

  		if ( _selected ) {

  			scope.dispatchEvent( { type: 'dragend', object: _selected } );

  			_selected = null;

  		}

  		_domElement.style.cursor = 'auto';

  	}

  	activate();

  	// API

  	this.enabled = true;

  	this.activate = activate;
  	this.deactivate = deactivate;
  	this.dispose = dispose;

  	// Backward compatibility

  	this.setObjects = function () {

  		console.error( 'DragControls: setObjects() has been removed.' );

  	};

  	this.on = function ( type, listener ) {

  		console.warn( 'DragControls: on() has been deprecated. Use addEventListener() instead.' );
  		scope.addEventListener( type, listener );

  	};

  	this.off = function ( type, listener ) {

  		console.warn( 'DragControls: off() has been deprecated. Use removeEventListener() instead.' );
  		scope.removeEventListener( type, listener );

  	};

  	this.notify = function ( type ) {

  		console.error( 'DragControls: notify() has been deprecated. Use dispatchEvent() instead.' );
  		scope.dispatchEvent( { type: type } );

  	};

  };

  DragControls.prototype = Object.create( EventDispatcher.prototype );
  DragControls.prototype.constructor = DragControls;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Spherical( radius, phi, theta ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0;
  	this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
  	this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

  	return this;

  }

  Object.assign( Spherical.prototype, {

  	set: function ( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	},

  	// restrict phi to be betwee EPS and PI-EPS
  	makeSafe: function () {

  		var EPS = 0.000001;
  		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  		return this;

  	},

  	setFromVector3: function ( v ) {

  		return this.setFromCartesianCoords( v.x, v.y, v.z );

  	},

  	setFromCartesianCoords: function ( x, y, z ) {

  		this.radius = Math.sqrt( x * x + y * y + z * z );

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( x, z );
  			this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );

  		}

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var EditorControls = function ( object, domElement ) {

  	domElement = ( domElement !== undefined ) ? domElement : document;

  	// API

  	this.enabled = true;
  	this.center = new Vector3();
  	this.panSpeed = 0.001;
  	this.zoomSpeed = 0.1;
  	this.rotationSpeed = 0.005;

  	// internals

  	var scope = this;
  	var vector = new Vector3();
  	var delta = new Vector3();
  	var box = new Box3();

  	var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2 };
  	var state = STATE.NONE;

  	var center = this.center;
  	var normalMatrix = new Matrix3();
  	var pointer = new Vector2();
  	var pointerOld = new Vector2();
  	var spherical = new Spherical();
  	var sphere = new Sphere();

  	// events

  	var changeEvent = { type: 'change' };

  	this.focus = function ( target ) {

  		var distance;

  		box.setFromObject( target );

  		if ( box.isEmpty() === false ) {

  			box.getCenter( center );
  			distance = box.getBoundingSphere( sphere ).radius;

  		} else {

  			// Focusing on an Group, AmbientLight, etc

  			center.setFromMatrixPosition( target.matrixWorld );
  			distance = 0.1;

  		}

  		delta.set( 0, 0, 1 );
  		delta.applyQuaternion( object.quaternion );
  		delta.multiplyScalar( distance * 4 );

  		object.position.copy( center ).add( delta );

  		scope.dispatchEvent( changeEvent );

  	};

  	this.pan = function ( delta ) {

  		var distance = object.position.distanceTo( center );

  		delta.multiplyScalar( distance * scope.panSpeed );
  		delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );

  		object.position.add( delta );
  		center.add( delta );

  		scope.dispatchEvent( changeEvent );

  	};

  	this.zoom = function ( delta ) {

  		var distance = object.position.distanceTo( center );

  		delta.multiplyScalar( distance * scope.zoomSpeed );

  		if ( delta.length() > distance ) { return; }

  		delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) );

  		object.position.add( delta );

  		scope.dispatchEvent( changeEvent );

  	};

  	this.rotate = function ( delta ) {

  		vector.copy( object.position ).sub( center );

  		spherical.setFromVector3( vector );

  		spherical.theta += delta.x;
  		spherical.phi += delta.y;

  		spherical.makeSafe();

  		vector.setFromSpherical( spherical );

  		object.position.copy( center ).add( vector );

  		object.lookAt( center );

  		scope.dispatchEvent( changeEvent );

  	};

  	// mouse

  	function onMouseDown( event ) {

  		if ( scope.enabled === false ) { return; }

  		if ( event.button === 0 ) {

  			state = STATE.ROTATE;

  		} else if ( event.button === 1 ) {

  			state = STATE.ZOOM;

  		} else if ( event.button === 2 ) {

  			state = STATE.PAN;

  		}

  		pointerOld.set( event.clientX, event.clientY );

  		domElement.addEventListener( 'mousemove', onMouseMove, false );
  		domElement.addEventListener( 'mouseup', onMouseUp, false );
  		domElement.addEventListener( 'mouseout', onMouseUp, false );
  		domElement.addEventListener( 'dblclick', onMouseUp, false );

  	}

  	function onMouseMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		pointer.set( event.clientX, event.clientY );

  		var movementX = pointer.x - pointerOld.x;
  		var movementY = pointer.y - pointerOld.y;

  		if ( state === STATE.ROTATE ) {

  			scope.rotate( delta.set( - movementX * scope.rotationSpeed, - movementY * scope.rotationSpeed, 0 ) );

  		} else if ( state === STATE.ZOOM ) {

  			scope.zoom( delta.set( 0, 0, movementY ) );

  		} else if ( state === STATE.PAN ) {

  			scope.pan( delta.set( - movementX, movementY, 0 ) );

  		}

  		pointerOld.set( event.clientX, event.clientY );

  	}

  	function onMouseUp( event ) {

  		domElement.removeEventListener( 'mousemove', onMouseMove, false );
  		domElement.removeEventListener( 'mouseup', onMouseUp, false );
  		domElement.removeEventListener( 'mouseout', onMouseUp, false );
  		domElement.removeEventListener( 'dblclick', onMouseUp, false );

  		state = STATE.NONE;

  	}

  	function onMouseWheel( event ) {

  		event.preventDefault();

  		// Normalize deltaY due to https://bugzilla.mozilla.org/show_bug.cgi?id=1392460
  		scope.zoom( delta.set( 0, 0, event.deltaY > 0 ? 1 : - 1 ) );

  	}

  	function contextmenu( event ) {

  		event.preventDefault();

  	}

  	this.dispose = function () {

  		domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		domElement.removeEventListener( 'mousedown', onMouseDown, false );
  		domElement.removeEventListener( 'wheel', onMouseWheel, false );

  		domElement.removeEventListener( 'mousemove', onMouseMove, false );
  		domElement.removeEventListener( 'mouseup', onMouseUp, false );
  		domElement.removeEventListener( 'mouseout', onMouseUp, false );
  		domElement.removeEventListener( 'dblclick', onMouseUp, false );

  		domElement.removeEventListener( 'touchstart', touchStart, false );
  		domElement.removeEventListener( 'touchmove', touchMove, false );

  	};

  	domElement.addEventListener( 'contextmenu', contextmenu, false );
  	domElement.addEventListener( 'mousedown', onMouseDown, false );
  	domElement.addEventListener( 'wheel', onMouseWheel, false );

  	// touch

  	var touches = [ new Vector3(), new Vector3(), new Vector3() ];
  	var prevTouches = [ new Vector3(), new Vector3(), new Vector3() ];

  	var prevDistance = null;

  	function touchStart( event ) {

  		if ( scope.enabled === false ) { return; }

  		switch ( event.touches.length ) {

  			case 1:
  				touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				touches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				break;

  			case 2:
  				touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				touches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );
  				prevDistance = touches[ 0 ].distanceTo( touches[ 1 ] );
  				break;

  		}

  		prevTouches[ 0 ].copy( touches[ 0 ] );
  		prevTouches[ 1 ].copy( touches[ 1 ] );

  	}
  	function touchMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		function getClosest( touch, touches ) {

  			var closest = touches[ 0 ];

  			for ( var i in touches ) {

  				if ( closest.distanceTo( touch ) > touches[ i ].distanceTo( touch ) ) { closest = touches[ i ]; }

  			}

  			return closest;

  		}

  		switch ( event.touches.length ) {

  			case 1:
  				touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				touches[ 1 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				scope.rotate( touches[ 0 ].sub( getClosest( touches[ 0 ], prevTouches ) ).multiplyScalar( - scope.rotationSpeed ) );
  				break;

  			case 2:
  				touches[ 0 ].set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, 0 );
  				touches[ 1 ].set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY, 0 );
  				var distance = touches[ 0 ].distanceTo( touches[ 1 ] );
  				scope.zoom( delta.set( 0, 0, prevDistance - distance ) );
  				prevDistance = distance;
  				var offset0 = touches[ 0 ].clone().sub( getClosest( touches[ 0 ], prevTouches ) );
  				var offset1 = touches[ 1 ].clone().sub( getClosest( touches[ 1 ], prevTouches ) );
  				offset0.x = - offset0.x;
  				offset1.x = - offset1.x;

  				scope.pan( offset0.add( offset1 ).multiplyScalar( 0.5 ) );

  				break;

  		}

  		prevTouches[ 0 ].copy( touches[ 0 ] );
  		prevTouches[ 1 ].copy( touches[ 1 ] );

  	}

  	domElement.addEventListener( 'touchstart', touchStart, false );
  	domElement.addEventListener( 'touchmove', touchMove, false );

  };

  EditorControls.prototype = Object.create( EventDispatcher.prototype );
  EditorControls.prototype.constructor = EditorControls;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FirstPersonControls = function ( object, domElement ) {

  	this.object = object;

  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	this.enabled = true;

  	this.movementSpeed = 1.0;
  	this.lookSpeed = 0.005;

  	this.lookVertical = true;
  	this.autoForward = false;

  	this.activeLook = true;

  	this.heightSpeed = false;
  	this.heightCoef = 1.0;
  	this.heightMin = 0.0;
  	this.heightMax = 1.0;

  	this.constrainVertical = false;
  	this.verticalMin = 0;
  	this.verticalMax = Math.PI;

  	this.autoSpeedFactor = 0.0;

  	this.mouseX = 0;
  	this.mouseY = 0;

  	this.moveForward = false;
  	this.moveBackward = false;
  	this.moveLeft = false;
  	this.moveRight = false;

  	this.mouseDragOn = false;

  	this.viewHalfX = 0;
  	this.viewHalfY = 0;

  	// private variables

  	var lat = 0;
  	var lon = 0;

  	var lookDirection = new Vector3();
  	var spherical = new Spherical();
  	var target = new Vector3();

  	//

  	if ( this.domElement !== document ) {

  		this.domElement.setAttribute( 'tabindex', - 1 );

  	}

  	//

  	this.handleResize = function () {

  		if ( this.domElement === document ) {

  			this.viewHalfX = window.innerWidth / 2;
  			this.viewHalfY = window.innerHeight / 2;

  		} else {

  			this.viewHalfX = this.domElement.offsetWidth / 2;
  			this.viewHalfY = this.domElement.offsetHeight / 2;

  		}

  	};

  	this.onMouseDown = function ( event ) {

  		if ( this.domElement !== document ) {

  			this.domElement.focus();

  		}

  		event.preventDefault();
  		event.stopPropagation();

  		if ( this.activeLook ) {

  			switch ( event.button ) {

  				case 0: this.moveForward = true; break;
  				case 2: this.moveBackward = true; break;

  			}

  		}

  		this.mouseDragOn = true;

  	};

  	this.onMouseUp = function ( event ) {

  		event.preventDefault();
  		event.stopPropagation();

  		if ( this.activeLook ) {

  			switch ( event.button ) {

  				case 0: this.moveForward = false; break;
  				case 2: this.moveBackward = false; break;

  			}

  		}

  		this.mouseDragOn = false;

  	};

  	this.onMouseMove = function ( event ) {

  		if ( this.domElement === document ) {

  			this.mouseX = event.pageX - this.viewHalfX;
  			this.mouseY = event.pageY - this.viewHalfY;

  		} else {

  			this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
  			this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;

  		}

  	};

  	this.onKeyDown = function ( event ) {

  		//event.preventDefault();

  		switch ( event.keyCode ) {

  			case 38: 
  			case 87:  this.moveForward = true; break;

  			case 37: 
  			case 65:  this.moveLeft = true; break;

  			case 40: 
  			case 83:  this.moveBackward = true; break;

  			case 39: 
  			case 68:  this.moveRight = true; break;

  			case 82:  this.moveUp = true; break;
  			case 70:  this.moveDown = true; break;

  		}

  	};

  	this.onKeyUp = function ( event ) {

  		switch ( event.keyCode ) {

  			case 38: 
  			case 87:  this.moveForward = false; break;

  			case 37: 
  			case 65:  this.moveLeft = false; break;

  			case 40: 
  			case 83:  this.moveBackward = false; break;

  			case 39: 
  			case 68:  this.moveRight = false; break;

  			case 82:  this.moveUp = false; break;
  			case 70:  this.moveDown = false; break;

  		}

  	};

  	this.lookAt = function ( x, y, z ) {

  		if ( x.isVector3 ) {

  			target.copy( x );

  		} else {

  			target.set( x, y, z );

  		}

  		this.object.lookAt( target );

  		setOrientation( this );

  		return this;

  	};

  	this.update = function () {

  		var targetPosition = new Vector3();

  		return function update( delta ) {

  			if ( this.enabled === false ) { return; }

  			if ( this.heightSpeed ) {

  				var y = _Math.clamp( this.object.position.y, this.heightMin, this.heightMax );
  				var heightDelta = y - this.heightMin;

  				this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );

  			} else {

  				this.autoSpeedFactor = 0.0;

  			}

  			var actualMoveSpeed = delta * this.movementSpeed;

  			if ( this.moveForward || ( this.autoForward && ! this.moveBackward ) ) { this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) ); }
  			if ( this.moveBackward ) { this.object.translateZ( actualMoveSpeed ); }

  			if ( this.moveLeft ) { this.object.translateX( - actualMoveSpeed ); }
  			if ( this.moveRight ) { this.object.translateX( actualMoveSpeed ); }

  			if ( this.moveUp ) { this.object.translateY( actualMoveSpeed ); }
  			if ( this.moveDown ) { this.object.translateY( - actualMoveSpeed ); }

  			var actualLookSpeed = delta * this.lookSpeed;

  			if ( ! this.activeLook ) {

  				actualLookSpeed = 0;

  			}

  			var verticalLookRatio = 1;

  			if ( this.constrainVertical ) {

  				verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );

  			}

  			lon -= this.mouseX * actualLookSpeed;
  			if ( this.lookVertical ) { lat -= this.mouseY * actualLookSpeed * verticalLookRatio; }

  			lat = Math.max( - 85, Math.min( 85, lat ) );

  			var phi = _Math.degToRad( 90 - lat );
  			var theta = _Math.degToRad( lon );

  			if ( this.constrainVertical ) {

  				phi = _Math.mapLinear( phi, 0, Math.PI, this.verticalMin, this.verticalMax );

  			}

  			var position = this.object.position;

  			targetPosition.setFromSphericalCoords( 1, phi, theta ).add( position );

  			this.object.lookAt( targetPosition );

  		};

  	}();

  	function contextmenu( event ) {

  		event.preventDefault();

  	}

  	this.dispose = function () {

  		this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		this.domElement.removeEventListener( 'mousedown', _onMouseDown, false );
  		this.domElement.removeEventListener( 'mousemove', _onMouseMove, false );
  		this.domElement.removeEventListener( 'mouseup', _onMouseUp, false );

  		window.removeEventListener( 'keydown', _onKeyDown, false );
  		window.removeEventListener( 'keyup', _onKeyUp, false );

  	};

  	var _onMouseMove = bind( this, this.onMouseMove );
  	var _onMouseDown = bind( this, this.onMouseDown );
  	var _onMouseUp = bind( this, this.onMouseUp );
  	var _onKeyDown = bind( this, this.onKeyDown );
  	var _onKeyUp = bind( this, this.onKeyUp );

  	this.domElement.addEventListener( 'contextmenu', contextmenu, false );
  	this.domElement.addEventListener( 'mousemove', _onMouseMove, false );
  	this.domElement.addEventListener( 'mousedown', _onMouseDown, false );
  	this.domElement.addEventListener( 'mouseup', _onMouseUp, false );

  	window.addEventListener( 'keydown', _onKeyDown, false );
  	window.addEventListener( 'keyup', _onKeyUp, false );

  	function bind( scope, fn ) {

  		return function () {

  			fn.apply( scope, arguments );

  		};

  	}

  	function setOrientation( controls ) {

  		var quaternion = controls.object.quaternion;

  		lookDirection.set( 0, 0, - 1 ).applyQuaternion( quaternion );
  		spherical.setFromVector3( lookDirection );

  		lat = 90 - _Math.radToDeg( spherical.phi );
  		lon = _Math.radToDeg( spherical.theta );

  	}

  	this.handleResize();

  	setOrientation( this );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FlyControls = function ( object, domElement ) {

  	this.object = object;

  	this.domElement = ( domElement !== undefined ) ? domElement : document;
  	if ( domElement ) { this.domElement.setAttribute( 'tabindex', - 1 ); }

  	// API

  	this.movementSpeed = 1.0;
  	this.rollSpeed = 0.005;

  	this.dragToLook = false;
  	this.autoForward = false;

  	// disable default target object behavior

  	// internals

  	this.tmpQuaternion = new Quaternion();

  	this.mouseStatus = 0;

  	this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
  	this.moveVector = new Vector3( 0, 0, 0 );
  	this.rotationVector = new Vector3( 0, 0, 0 );

  	this.keydown = function ( event ) {

  		if ( event.altKey ) {

  			return;

  		}

  		//event.preventDefault();

  		switch ( event.keyCode ) {

  			case 16:  this.movementSpeedMultiplier = .1; break;

  			case 87:  this.moveState.forward = 1; break;
  			case 83:  this.moveState.back = 1; break;

  			case 65:  this.moveState.left = 1; break;
  			case 68:  this.moveState.right = 1; break;

  			case 82:  this.moveState.up = 1; break;
  			case 70:  this.moveState.down = 1; break;

  			case 38:  this.moveState.pitchUp = 1; break;
  			case 40:  this.moveState.pitchDown = 1; break;

  			case 37:  this.moveState.yawLeft = 1; break;
  			case 39:  this.moveState.yawRight = 1; break;

  			case 81:  this.moveState.rollLeft = 1; break;
  			case 69:  this.moveState.rollRight = 1; break;

  		}

  		this.updateMovementVector();
  		this.updateRotationVector();

  	};

  	this.keyup = function ( event ) {

  		switch ( event.keyCode ) {

  			case 16:  this.movementSpeedMultiplier = 1; break;

  			case 87:  this.moveState.forward = 0; break;
  			case 83:  this.moveState.back = 0; break;

  			case 65:  this.moveState.left = 0; break;
  			case 68:  this.moveState.right = 0; break;

  			case 82:  this.moveState.up = 0; break;
  			case 70:  this.moveState.down = 0; break;

  			case 38:  this.moveState.pitchUp = 0; break;
  			case 40:  this.moveState.pitchDown = 0; break;

  			case 37:  this.moveState.yawLeft = 0; break;
  			case 39:  this.moveState.yawRight = 0; break;

  			case 81:  this.moveState.rollLeft = 0; break;
  			case 69:  this.moveState.rollRight = 0; break;

  		}

  		this.updateMovementVector();
  		this.updateRotationVector();

  	};

  	this.mousedown = function ( event ) {

  		if ( this.domElement !== document ) {

  			this.domElement.focus();

  		}

  		event.preventDefault();
  		event.stopPropagation();

  		if ( this.dragToLook ) {

  			this.mouseStatus ++;

  		} else {

  			switch ( event.button ) {

  				case 0: this.moveState.forward = 1; break;
  				case 2: this.moveState.back = 1; break;

  			}

  			this.updateMovementVector();

  		}

  	};

  	this.mousemove = function ( event ) {

  		if ( ! this.dragToLook || this.mouseStatus > 0 ) {

  			var container = this.getContainerDimensions();
  			var halfWidth = container.size[ 0 ] / 2;
  			var halfHeight = container.size[ 1 ] / 2;

  			this.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;
  			this.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

  			this.updateRotationVector();

  		}

  	};

  	this.mouseup = function ( event ) {

  		event.preventDefault();
  		event.stopPropagation();

  		if ( this.dragToLook ) {

  			this.mouseStatus --;

  			this.moveState.yawLeft = this.moveState.pitchDown = 0;

  		} else {

  			switch ( event.button ) {

  				case 0: this.moveState.forward = 0; break;
  				case 2: this.moveState.back = 0; break;

  			}

  			this.updateMovementVector();

  		}

  		this.updateRotationVector();

  	};

  	this.update = function ( delta ) {

  		var moveMult = delta * this.movementSpeed;
  		var rotMult = delta * this.rollSpeed;

  		this.object.translateX( this.moveVector.x * moveMult );
  		this.object.translateY( this.moveVector.y * moveMult );
  		this.object.translateZ( this.moveVector.z * moveMult );

  		this.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();
  		this.object.quaternion.multiply( this.tmpQuaternion );

  		// expose the rotation vector for convenience
  		this.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );
  	};

  	this.updateMovementVector = function () {

  		var forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0;

  		this.moveVector.x = ( - this.moveState.left + this.moveState.right );
  		this.moveVector.y = ( - this.moveState.down + this.moveState.up );
  		this.moveVector.z = ( - forward + this.moveState.back );

  		//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

  	};

  	this.updateRotationVector = function () {

  		this.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp );
  		this.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft );
  		this.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft );

  		//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

  	};

  	this.getContainerDimensions = function () {

  		if ( this.domElement != document ) {

  			return {
  				size: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
  				offset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]
  			};

  		} else {

  			return {
  				size: [ window.innerWidth, window.innerHeight ],
  				offset: [ 0, 0 ]
  			};

  		}

  	};

  	function bind( scope, fn ) {

  		return function () {

  			fn.apply( scope, arguments );

  		};

  	}

  	function contextmenu( event ) {

  		event.preventDefault();

  	}

  	this.dispose = function () {

  		this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		this.domElement.removeEventListener( 'mousedown', _mousedown, false );
  		this.domElement.removeEventListener( 'mousemove', _mousemove, false );
  		this.domElement.removeEventListener( 'mouseup', _mouseup, false );

  		window.removeEventListener( 'keydown', _keydown, false );
  		window.removeEventListener( 'keyup', _keyup, false );

  	};

  	var _mousemove = bind( this, this.mousemove );
  	var _mousedown = bind( this, this.mousedown );
  	var _mouseup = bind( this, this.mouseup );
  	var _keydown = bind( this, this.keydown );
  	var _keyup = bind( this, this.keyup );

  	this.domElement.addEventListener( 'contextmenu', contextmenu, false );

  	this.domElement.addEventListener( 'mousemove', _mousemove, false );
  	this.domElement.addEventListener( 'mousedown', _mousedown, false );
  	this.domElement.addEventListener( 'mouseup', _mouseup, false );

  	window.addEventListener( 'keydown', _keydown, false );
  	window.addEventListener( 'keyup', _keyup, false );

  	this.updateMovementVector();
  	this.updateRotationVector();

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  // This is very similar to OrbitControls, another set of touch behavior
  //
  //    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - left mouse, or arrow keys / touch: one-finger move

  var MapControls = function ( object, domElement ) {

  	this.object = object;

  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// Set to false to disable this control
  	this.enabled = true;

  	// "target" sets the location of focus, where the object orbits around
  	this.target = new Vector3();

  	// How far you can dolly in and out ( PerspectiveCamera only )
  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	// How far you can zoom in and out ( OrthographicCamera only )
  	this.minZoom = 0;
  	this.maxZoom = Infinity;

  	// How far you can orbit vertically, upper and lower limits.
  	// Range is 0 to Math.PI radians.
  	this.minPolarAngle = 0; // radians
  	this.maxPolarAngle = Math.PI; // radians

  	// How far you can orbit horizontally, upper and lower limits.
  	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  	this.minAzimuthAngle = - Infinity; // radians
  	this.maxAzimuthAngle = Infinity; // radians

  	// Set to true to enable damping (inertia)
  	// If damping is enabled, you must call controls.update() in your animation loop
  	this.enableDamping = false;
  	this.dampingFactor = 0.25;

  	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  	// Set to false to disable zooming
  	this.enableZoom = true;
  	this.zoomSpeed = 1.0;

  	// Set to false to disable rotating
  	this.enableRotate = true;
  	this.rotateSpeed = 1.0;

  	// Set to false to disable panning
  	this.enablePan = true;
  	this.panSpeed = 1.0;
  	this.screenSpacePanning = false; // if true, pan in screen-space
  	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  	// Set to true to automatically rotate around the target
  	// If auto-rotate is enabled, you must call controls.update() in your animation loop
  	this.autoRotate = false;
  	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  	// Set to false to disable use of the keys
  	this.enableKeys = true;

  	// The four arrow keys
  	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  	// Mouse buttons
  	this.mouseButtons = { LEFT: MOUSE.LEFT, MIDDLE: MOUSE.MIDDLE, RIGHT: MOUSE.RIGHT };

  	// for reset
  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.zoom0 = this.object.zoom;

  	//
  	// public methods
  	//

  	this.getPolarAngle = function () {

  		return spherical.phi;

  	};

  	this.getAzimuthalAngle = function () {

  		return spherical.theta;

  	};

  	this.saveState = function () {

  		scope.target0.copy( scope.target );
  		scope.position0.copy( scope.object.position );
  		scope.zoom0 = scope.object.zoom;

  	};

  	this.reset = function () {

  		scope.target.copy( scope.target0 );
  		scope.object.position.copy( scope.position0 );
  		scope.object.zoom = scope.zoom0;

  		scope.object.updateProjectionMatrix();
  		scope.dispatchEvent( changeEvent );

  		scope.update();

  		state = STATE.NONE;

  	};

  	// this method is exposed, but perhaps it would be better if we can make it private...
  	this.update = function () {

  		var offset = new Vector3();

  		// so camera.up is the orbit axis
  		var quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
  		var quatInverse = quat.clone().inverse();

  		var lastPosition = new Vector3();
  		var lastQuaternion = new Quaternion();

  		return function update() {

  			var position = scope.object.position;

  			offset.copy( position ).sub( scope.target );

  			// rotate offset to "y-axis-is-up" space
  			offset.applyQuaternion( quat );

  			// angle from z-axis around y-axis
  			spherical.setFromVector3( offset );

  			if ( scope.autoRotate && state === STATE.NONE ) {

  				rotateLeft( getAutoRotationAngle() );

  			}

  			spherical.theta += sphericalDelta.theta;
  			spherical.phi += sphericalDelta.phi;

  			// restrict theta to be between desired limits
  			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

  			// restrict phi to be between desired limits
  			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

  			spherical.makeSafe();
  			spherical.radius *= scale;

  			// restrict radius to be between desired limits
  			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

  			// move target to panned location
  			scope.target.add( panOffset );

  			offset.setFromSpherical( spherical );

  			// rotate offset back to "camera-up-vector-is-up" space
  			offset.applyQuaternion( quatInverse );

  			position.copy( scope.target ).add( offset );

  			scope.object.lookAt( scope.target );

  			if ( scope.enableDamping === true ) {

  				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
  				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

  				panOffset.multiplyScalar( 1 - scope.dampingFactor );

  			} else {

  				sphericalDelta.set( 0, 0, 0 );

  				panOffset.set( 0, 0, 0 );

  			}

  			scale = 1;

  			// update condition is:
  			// min(camera displacement, camera rotation in radians)^2 > EPS
  			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  			if ( zoomChanged ||
  				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
  				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

  				scope.dispatchEvent( changeEvent );

  				lastPosition.copy( scope.object.position );
  				lastQuaternion.copy( scope.object.quaternion );
  				zoomChanged = false;

  				return true;

  			}

  			return false;

  		};

  	}();

  	this.dispose = function () {

  		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
  		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
  		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

  		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
  		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
  		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		window.removeEventListener( 'keydown', onKeyDown, false );

  		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  	};

  	//
  	// internals
  	//

  	var scope = this;

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };

  	var STATE = {
  		NONE: 0,
  		ROTATE_UP: 1,
  		ROTATE_LEFT: 2,
  		ROTATE: 3, // ROTATE_UP | ROTATE_LEFT
  		DOLLY: 4,
  		DOLLY_ROTATE: 7, // ROTATE | DOLLY
  		PAN: 8,
  		DOLLY_PAN: 12, // DOLLY | PAN
  	};

  	var state = STATE.NONE;

  	var EPS = 0.000001;

  	// current position in spherical coordinates
  	var spherical = new Spherical();
  	var sphericalDelta = new Spherical();

  	var scale = 1;
  	var panOffset = new Vector3();
  	var zoomChanged = false;

  	var rotateStart = new Vector2();
  	var rotateStart2 = new Vector2();
  	var rotateEnd = new Vector2();
  	var rotateEnd2 = new Vector2();
  	var rotateDelta = new Vector2();
  	var rotateDelta2 = new Vector2();
  	var rotateDeltaStartFingers = new Vector2();
  	var rotateDeltaEndFingers = new Vector2();

  	var panStart = new Vector2();
  	var panEnd = new Vector2();
  	var panDelta = new Vector2();

  	var dollyStart = new Vector2();
  	var dollyEnd = new Vector2();
  	var dollyDelta = new Vector2();

  	function getAutoRotationAngle() {

  		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  	}

  	function getZoomScale() {

  		return Math.pow( 0.95, scope.zoomSpeed );

  	}

  	function rotateLeft( angle ) {

  		sphericalDelta.theta -= angle;

  	}

  	function rotateUp( angle ) {

  		sphericalDelta.phi -= angle;

  	}

  	var panLeft = function () {

  		var v = new Vector3();

  		return function panLeft( distance, objectMatrix ) {

  			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  			v.multiplyScalar( - distance );

  			panOffset.add( v );

  		};

  	}();

  	var panUp = function () {

  		var v = new Vector3();

  		return function panUp( distance, objectMatrix ) {

  			if ( scope.screenSpacePanning === true ) {

  				v.setFromMatrixColumn( objectMatrix, 1 );

  			} else {

  				v.setFromMatrixColumn( objectMatrix, 0 );
  				v.crossVectors( scope.object.up, v );

  			}

  			v.multiplyScalar( distance );

  			panOffset.add( v );

  		};

  	}();

  	// deltaX and deltaY are in pixels; right and down are positive
  	var pan = function () {

  		var offset = new Vector3();

  		return function pan( deltaX, deltaY ) {

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			if ( scope.object.isPerspectiveCamera ) {

  				// perspective
  				var position = scope.object.position;
  				offset.copy( position ).sub( scope.target );
  				var targetDistance = offset.length();

  				// half of the fov is center to top of screen
  				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

  				// we use only clientHeight here so aspect ratio does not distort speed
  				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
  				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

  			} else if ( scope.object.isOrthographicCamera ) {

  				// orthographic
  				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
  				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

  			} else {

  				// camera neither orthographic nor perspective
  				console.warn( 'WARNING: MapControls.js encountered an unknown camera type - pan disabled.' );
  				scope.enablePan = false;

  			}

  		};

  	}();

  	function dollyIn( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale /= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	function dollyOut( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale *= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	//
  	// event callbacks - update the object state
  	//

  	function handleMouseDownRotate( event ) {

  		//console.log( 'handleMouseDownRotate' );

  		rotateStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownDolly( event ) {

  		//console.log( 'handleMouseDownDolly' );

  		dollyStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownPan( event ) {

  		//console.log( 'handleMouseDownPan' );

  		panStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseMoveRotate( event ) {

  		//console.log( 'handleMouseMoveRotate' );

  		rotateEnd.set( event.clientX, event.clientY );

  		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

  		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  		rotateStart.copy( rotateEnd );

  		scope.update();

  	}

  	function handleMouseMoveDolly( event ) {

  		//console.log( 'handleMouseMoveDolly' );

  		dollyEnd.set( event.clientX, event.clientY );

  		dollyDelta.subVectors( dollyEnd, dollyStart );

  		if ( dollyDelta.y > 0 ) {

  			dollyIn( getZoomScale() );

  		} else if ( dollyDelta.y < 0 ) {

  			dollyOut( getZoomScale() );

  		}

  		dollyStart.copy( dollyEnd );

  		scope.update();

  	}

  	function handleMouseMovePan( event ) {

  		//console.log( 'handleMouseMovePan' );

  		panEnd.set( event.clientX, event.clientY );

  		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );

  		scope.update();

  	}

  	function handleMouseWheel( event ) {

  		// console.log( 'handleMouseWheel' );

  		if ( event.deltaY < 0 ) {

  			dollyOut( getZoomScale() );

  		} else if ( event.deltaY > 0 ) {

  			dollyIn( getZoomScale() );

  		}

  		scope.update();

  	}

  	function handleKeyDown( event ) {

  		//console.log( 'handleKeyDown' );

  		switch ( event.keyCode ) {

  			case scope.keys.UP:
  				pan( 0, scope.keyPanSpeed );
  				scope.update();
  				break;

  			case scope.keys.BOTTOM:
  				pan( 0, - scope.keyPanSpeed );
  				scope.update();
  				break;

  			case scope.keys.LEFT:
  				pan( scope.keyPanSpeed, 0 );
  				scope.update();
  				break;

  			case scope.keys.RIGHT:
  				pan( - scope.keyPanSpeed, 0 );
  				scope.update();
  				break;

  		}

  	}

  	function handleTouchStartRotate( event ) {

  		// console.log( 'handleTouchStartRotate' );

  		// First finger
  		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		// Second finger
  		rotateStart2.set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY );

  	}

  	function handleTouchStartDolly( event ) {

  		if ( scope.enableZoom ) {

  			// console.log( 'handleTouchStartDolly' );

  			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  			var distance = Math.sqrt( dx * dx + dy * dy );

  			dollyStart.set( 0, distance );

  		}

  	}

  	function handleTouchStartPan( event ) {

  		if ( scope.enablePan ) {

  			// console.log( 'handleTouchStartPan' );

  			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		}

  	}

  	function handleTouchMoveRotate( event ) {

  		if ( scope.enableRotate === false ) { return; }
  		if ( ( state & STATE.ROTATE ) === 0 ) { return; }

  		// First finger
  		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		// Second finger
  		rotateEnd2.set( event.touches[ 1 ].pageX, event.touches[ 1 ].pageY );

  		rotateDelta.subVectors( rotateEnd, rotateStart );
  		rotateDelta2.subVectors( rotateEnd2, rotateStart2 );
  		rotateDeltaStartFingers.subVectors( rotateStart2, rotateStart );
  		rotateDeltaEndFingers.subVectors( rotateEnd2, rotateEnd );

  		if ( isRotateUp() ) {

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			// rotating up and down along whole screen attempts to go 360, but limited to 180
  			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  			// Start rotateUp ==> disable all movement to prevent flickering
  			state = STATE.ROTATE_UP;

  		} else if ( ( state & STATE.ROTATE_LEFT ) !== 0 ) {

  			rotateLeft( ( rotateDeltaStartFingers.angle() - rotateDeltaEndFingers.angle() ) * scope.rotateSpeed );

  		}

  		rotateStart.copy( rotateEnd );
  		rotateStart2.copy( rotateEnd2 );

  	}

  	function isRotateUp() {

  		// At start, does the two fingers are aligned horizontally
  		if ( ! isHorizontal( rotateDeltaStartFingers ) ) {

  			return false;

  		}

  		// At end, does the two fingers are aligned horizontally
  		if ( ! isHorizontal( rotateDeltaEndFingers ) ) {

  			return false;

  		}

  		// does the first finger moved vertically between start and end
  		if ( ! isVertical( rotateDelta ) ) {

  			return false;

  		}

  		// does the second finger moved vertically between start and end
  		if ( ! isVertical( rotateDelta2 ) ) {

  			return false;

  		}

  		// Does the two finger moved in the same direction (prevent moving one finger vertically up while the other goes down)
  		return rotateDelta.dot( rotateDelta2 ) > 0;

  	}

  	var isHorizontal = function () {

  		var precision = Math.sin( Math.PI / 6 );

  		return function isHorizontal( vector ) {

  			return Math.abs( Math.sin( vector.angle() ) ) < precision;

  		};

  	}();

  	var isVertical = function () {

  		var precision = Math.cos( Math.PI / 2 - Math.PI / 6 );

  		return function isVertical( vector ) {

  			return Math.abs( Math.cos( vector.angle() ) ) < precision;

  		};

  	}();

  	function handleTouchMoveDolly( event ) {

  		if ( scope.enableZoom === false ) { return; }
  		if ( ( state & STATE.DOLLY ) === 0 ) { return; }

  		// console.log( 'handleTouchMoveDolly' );

  		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  		var distance = Math.sqrt( dx * dx + dy * dy );

  		dollyEnd.set( 0, distance );

  		dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

  		dollyIn( dollyDelta.y );

  		dollyStart.copy( dollyEnd );

  	}

  	function handleTouchMovePan( event ) {

  		if ( scope.enablePan === false ) { return; }
  		if ( ( state & STATE.PAN ) === 0 ) { return; }

  		// console.log( 'handleTouchMovePan' );

  		panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );

  	}

  	//
  	// event handlers - FSM: listen for events and reset state
  	//

  	function onMouseDown( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( event.button ) {

  			case scope.mouseButtons.LEFT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( scope.enableRotate === false ) { return; }

  					handleMouseDownRotate( event );

  					state = STATE.ROTATE;

  				} else {

  					if ( scope.enablePan === false ) { return; }

  					handleMouseDownPan( event );

  					state = STATE.PAN;

  				}

  				break;

  			case scope.mouseButtons.MIDDLE:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseDownDolly( event );

  				state = STATE.DOLLY;

  				break;

  			case scope.mouseButtons.RIGHT:

  				if ( scope.enableRotate === false ) { return; }

  				handleMouseDownRotate( event );

  				state = STATE.ROTATE;

  				break;

  		}

  		if ( state !== STATE.NONE ) {

  			document.addEventListener( 'mousemove', onMouseMove, false );
  			document.addEventListener( 'mouseup', onMouseUp, false );

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onMouseMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( state ) {

  			case STATE.ROTATE:

  				if ( scope.enableRotate === false ) { return; }

  				handleMouseMoveRotate( event );

  				break;

  			case STATE.DOLLY:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseMoveDolly( event );

  				break;

  			case STATE.PAN:

  				if ( scope.enablePan === false ) { return; }

  				handleMouseMovePan( event );

  				break;

  		}

  	}

  	function onMouseUp( event ) {

  		if ( scope.enabled === false ) { return; }

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onMouseWheel( event ) {

  		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		scope.dispatchEvent( startEvent );

  		handleMouseWheel( event );

  		scope.dispatchEvent( endEvent );

  	}

  	function onKeyDown( event ) {

  		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) { return; }

  		handleKeyDown( event );

  	}

  	function onTouchStart( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( event.touches.length ) {

  			case 1:	// one-fingered touch: pan

  				if ( scope.enablePan === false ) { return; }

  				handleTouchStartPan( event );

  				state = STATE.PAN;

  				break;

  			case 2:	// two-fingered touch: rotate-dolly

  				if ( scope.enableZoom === false && scope.enableRotate === false ) { return; }

  				handleTouchStartRotate( event );
  				handleTouchStartDolly( event );

  				state = STATE.DOLLY_ROTATE;

  				break;

  			default:

  				state = STATE.NONE;

  		}

  		if ( state !== STATE.NONE ) {

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onTouchMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1: // one-fingered touch: pan

  				if ( scope.enablePan === false ) { return; }
  				if ( state !== STATE.PAN ) { return; } // is this needed?

  				handleTouchMovePan( event );

  				scope.update();

  				break;

  			case 2: // two-fingered touch: rotate-dolly

  				if ( scope.enableZoom === false && scope.enableRotate === false ) { return; }
  				if ( ( state & STATE.DOLLY_ROTATE ) === 0 ) { return; } // is this needed?

  				handleTouchMoveRotate( event );
  				handleTouchMoveDolly( event );

  				scope.update();

  				break;

  			default:

  				state = STATE.NONE;

  		}

  	}

  	function onTouchEnd( event ) {

  		if ( scope.enabled === false ) { return; }

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onContextMenu( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  	}

  	//

  	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

  	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
  	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

  	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
  	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
  	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

  	window.addEventListener( 'keydown', onKeyDown, false );

  	// force an update at start

  	this.update();

  };

  MapControls.prototype = Object.create( EventDispatcher.prototype );
  MapControls.prototype.constructor = MapControls;

  Object.defineProperties( MapControls.prototype, {

  	center: {

  		get: function () {

  			console.warn( 'MapControls: .center has been renamed to .target' );
  			return this.target;

  		}

  	},

  	// backward compatibility

  	noZoom: {

  		get: function () {

  			console.warn( 'MapControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			return ! this.enableZoom;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			this.enableZoom = ! value;

  		}

  	},

  	noRotate: {

  		get: function () {

  			console.warn( 'MapControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			return ! this.enableRotate;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			this.enableRotate = ! value;

  		}

  	},

  	noPan: {

  		get: function () {

  			console.warn( 'MapControls: .noPan has been deprecated. Use .enablePan instead.' );
  			return ! this.enablePan;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .noPan has been deprecated. Use .enablePan instead.' );
  			this.enablePan = ! value;

  		}

  	},

  	noKeys: {

  		get: function () {

  			console.warn( 'MapControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			return ! this.enableKeys;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			this.enableKeys = ! value;

  		}

  	},

  	staticMoving: {

  		get: function () {

  			console.warn( 'MapControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			return ! this.enableDamping;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			this.enableDamping = ! value;

  		}

  	},

  	dynamicDampingFactor: {

  		get: function () {

  			console.warn( 'MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			return this.dampingFactor;

  		},

  		set: function ( value ) {

  			console.warn( 'MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			this.dampingFactor = value;

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one-finger move
  //    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
  //    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

  var OrbitControls = function ( object, domElement ) {

  	this.object = object;

  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// Set to false to disable this control
  	this.enabled = true;

  	// "target" sets the location of focus, where the object orbits around
  	this.target = new Vector3();

  	// How far you can dolly in and out ( PerspectiveCamera only )
  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	// How far you can zoom in and out ( OrthographicCamera only )
  	this.minZoom = 0;
  	this.maxZoom = Infinity;

  	// How far you can orbit vertically, upper and lower limits.
  	// Range is 0 to Math.PI radians.
  	this.minPolarAngle = 0; // radians
  	this.maxPolarAngle = Math.PI; // radians

  	// How far you can orbit horizontally, upper and lower limits.
  	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  	this.minAzimuthAngle = - Infinity; // radians
  	this.maxAzimuthAngle = Infinity; // radians

  	// Set to true to enable damping (inertia)
  	// If damping is enabled, you must call controls.update() in your animation loop
  	this.enableDamping = false;
  	this.dampingFactor = 0.25;

  	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  	// Set to false to disable zooming
  	this.enableZoom = true;
  	this.zoomSpeed = 1.0;

  	// Set to false to disable rotating
  	this.enableRotate = true;
  	this.rotateSpeed = 1.0;

  	// Set to false to disable panning
  	this.enablePan = true;
  	this.panSpeed = 1.0;
  	this.screenSpacePanning = false; // if true, pan in screen-space
  	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  	// Set to true to automatically rotate around the target
  	// If auto-rotate is enabled, you must call controls.update() in your animation loop
  	this.autoRotate = false;
  	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  	// Set to false to disable use of the keys
  	this.enableKeys = true;

  	// The four arrow keys
  	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  	// Mouse buttons
  	this.mouseButtons = { LEFT: MOUSE.LEFT, MIDDLE: MOUSE.MIDDLE, RIGHT: MOUSE.RIGHT };

  	// for reset
  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.zoom0 = this.object.zoom;

  	//
  	// public methods
  	//

  	this.getPolarAngle = function () {

  		return spherical.phi;

  	};

  	this.getAzimuthalAngle = function () {

  		return spherical.theta;

  	};

  	this.saveState = function () {

  		scope.target0.copy( scope.target );
  		scope.position0.copy( scope.object.position );
  		scope.zoom0 = scope.object.zoom;

  	};

  	this.reset = function () {

  		scope.target.copy( scope.target0 );
  		scope.object.position.copy( scope.position0 );
  		scope.object.zoom = scope.zoom0;

  		scope.object.updateProjectionMatrix();
  		scope.dispatchEvent( changeEvent );

  		scope.update();

  		state = STATE.NONE;

  	};

  	// this method is exposed, but perhaps it would be better if we can make it private...
  	this.update = function () {

  		var offset = new Vector3();

  		// so camera.up is the orbit axis
  		var quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
  		var quatInverse = quat.clone().inverse();

  		var lastPosition = new Vector3();
  		var lastQuaternion = new Quaternion();

  		return function update() {

  			var position = scope.object.position;

  			offset.copy( position ).sub( scope.target );

  			// rotate offset to "y-axis-is-up" space
  			offset.applyQuaternion( quat );

  			// angle from z-axis around y-axis
  			spherical.setFromVector3( offset );

  			if ( scope.autoRotate && state === STATE.NONE ) {

  				rotateLeft( getAutoRotationAngle() );

  			}

  			spherical.theta += sphericalDelta.theta;
  			spherical.phi += sphericalDelta.phi;

  			// restrict theta to be between desired limits
  			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

  			// restrict phi to be between desired limits
  			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

  			spherical.makeSafe();
  			spherical.radius *= scale;

  			// restrict radius to be between desired limits
  			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

  			// move target to panned location
  			scope.target.add( panOffset );

  			offset.setFromSpherical( spherical );

  			// rotate offset back to "camera-up-vector-is-up" space
  			offset.applyQuaternion( quatInverse );

  			position.copy( scope.target ).add( offset );

  			scope.object.lookAt( scope.target );

  			if ( scope.enableDamping === true ) {

  				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
  				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

  				panOffset.multiplyScalar( 1 - scope.dampingFactor );

  			} else {

  				sphericalDelta.set( 0, 0, 0 );

  				panOffset.set( 0, 0, 0 );

  			}

  			scale = 1;

  			// update condition is:
  			// min(camera displacement, camera rotation in radians)^2 > EPS
  			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  			if ( zoomChanged ||
  				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
  				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

  				scope.dispatchEvent( changeEvent );

  				lastPosition.copy( scope.object.position );
  				lastQuaternion.copy( scope.object.quaternion );
  				zoomChanged = false;

  				return true;

  			}

  			return false;

  		};

  	}();

  	this.dispose = function () {

  		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
  		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
  		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

  		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
  		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
  		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		window.removeEventListener( 'keydown', onKeyDown, false );

  		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  	};

  	//
  	// internals
  	//

  	var scope = this;

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };

  	var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

  	var state = STATE.NONE;

  	var EPS = 0.000001;

  	// current position in spherical coordinates
  	var spherical = new Spherical();
  	var sphericalDelta = new Spherical();

  	var scale = 1;
  	var panOffset = new Vector3();
  	var zoomChanged = false;

  	var rotateStart = new Vector2();
  	var rotateEnd = new Vector2();
  	var rotateDelta = new Vector2();

  	var panStart = new Vector2();
  	var panEnd = new Vector2();
  	var panDelta = new Vector2();

  	var dollyStart = new Vector2();
  	var dollyEnd = new Vector2();
  	var dollyDelta = new Vector2();

  	function getAutoRotationAngle() {

  		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  	}

  	function getZoomScale() {

  		return Math.pow( 0.95, scope.zoomSpeed );

  	}

  	function rotateLeft( angle ) {

  		sphericalDelta.theta -= angle;

  	}

  	function rotateUp( angle ) {

  		sphericalDelta.phi -= angle;

  	}

  	var panLeft = function () {

  		var v = new Vector3();

  		return function panLeft( distance, objectMatrix ) {

  			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  			v.multiplyScalar( - distance );

  			panOffset.add( v );

  		};

  	}();

  	var panUp = function () {

  		var v = new Vector3();

  		return function panUp( distance, objectMatrix ) {

  			if ( scope.screenSpacePanning === true ) {

  				v.setFromMatrixColumn( objectMatrix, 1 );

  			} else {

  				v.setFromMatrixColumn( objectMatrix, 0 );
  				v.crossVectors( scope.object.up, v );

  			}

  			v.multiplyScalar( distance );

  			panOffset.add( v );

  		};

  	}();

  	// deltaX and deltaY are in pixels; right and down are positive
  	var pan = function () {

  		var offset = new Vector3();

  		return function pan( deltaX, deltaY ) {

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			if ( scope.object.isPerspectiveCamera ) {

  				// perspective
  				var position = scope.object.position;
  				offset.copy( position ).sub( scope.target );
  				var targetDistance = offset.length();

  				// half of the fov is center to top of screen
  				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

  				// we use only clientHeight here so aspect ratio does not distort speed
  				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
  				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

  			} else if ( scope.object.isOrthographicCamera ) {

  				// orthographic
  				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
  				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

  			} else {

  				// camera neither orthographic nor perspective
  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  				scope.enablePan = false;

  			}

  		};

  	}();

  	function dollyIn( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale /= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	function dollyOut( dollyScale ) {

  		if ( scope.object.isPerspectiveCamera ) {

  			scale *= dollyScale;

  		} else if ( scope.object.isOrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	//
  	// event callbacks - update the object state
  	//

  	function handleMouseDownRotate( event ) {

  		//console.log( 'handleMouseDownRotate' );

  		rotateStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownDolly( event ) {

  		//console.log( 'handleMouseDownDolly' );

  		dollyStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownPan( event ) {

  		//console.log( 'handleMouseDownPan' );

  		panStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseMoveRotate( event ) {

  		//console.log( 'handleMouseMoveRotate' );

  		rotateEnd.set( event.clientX, event.clientY );

  		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

  		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  		rotateStart.copy( rotateEnd );

  		scope.update();

  	}

  	function handleMouseMoveDolly( event ) {

  		//console.log( 'handleMouseMoveDolly' );

  		dollyEnd.set( event.clientX, event.clientY );

  		dollyDelta.subVectors( dollyEnd, dollyStart );

  		if ( dollyDelta.y > 0 ) {

  			dollyIn( getZoomScale() );

  		} else if ( dollyDelta.y < 0 ) {

  			dollyOut( getZoomScale() );

  		}

  		dollyStart.copy( dollyEnd );

  		scope.update();

  	}

  	function handleMouseMovePan( event ) {

  		//console.log( 'handleMouseMovePan' );

  		panEnd.set( event.clientX, event.clientY );

  		panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );

  		scope.update();

  	}

  	function handleMouseWheel( event ) {

  		// console.log( 'handleMouseWheel' );

  		if ( event.deltaY < 0 ) {

  			dollyOut( getZoomScale() );

  		} else if ( event.deltaY > 0 ) {

  			dollyIn( getZoomScale() );

  		}

  		scope.update();

  	}

  	function handleKeyDown( event ) {

  		// console.log( 'handleKeyDown' );

  		var needsUpdate = false;

  		switch ( event.keyCode ) {

  			case scope.keys.UP:
  				pan( 0, scope.keyPanSpeed );
  				needsUpdate = true;
  				break;

  			case scope.keys.BOTTOM:
  				pan( 0, - scope.keyPanSpeed );
  				needsUpdate = true;
  				break;

  			case scope.keys.LEFT:
  				pan( scope.keyPanSpeed, 0 );
  				needsUpdate = true;
  				break;

  			case scope.keys.RIGHT:
  				pan( - scope.keyPanSpeed, 0 );
  				needsUpdate = true;
  				break;

  		}

  		if ( needsUpdate ) {

  			// prevent the browser from scrolling on cursor keys
  			event.preventDefault();

  			scope.update();

  		}
  	}

  	function handleTouchStartRotate( event ) {

  		//console.log( 'handleTouchStartRotate' );

  		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  	}

  	function handleTouchStartDollyPan( event ) {

  		//console.log( 'handleTouchStartDollyPan' );

  		if ( scope.enableZoom ) {

  			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  			var distance = Math.sqrt( dx * dx + dy * dy );

  			dollyStart.set( 0, distance );

  		}

  		if ( scope.enablePan ) {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			panStart.set( x, y );

  		}

  	}

  	function handleTouchMoveRotate( event ) {

  		//console.log( 'handleTouchMoveRotate' );

  		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

  		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

  		rotateStart.copy( rotateEnd );

  		scope.update();

  	}

  	function handleTouchMoveDollyPan( event ) {

  		//console.log( 'handleTouchMoveDollyPan' );

  		if ( scope.enableZoom ) {

  			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  			var distance = Math.sqrt( dx * dx + dy * dy );

  			dollyEnd.set( 0, distance );

  			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

  			dollyIn( dollyDelta.y );

  			dollyStart.copy( dollyEnd );

  		}

  		if ( scope.enablePan ) {

  			var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
  			var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

  			panEnd.set( x, y );

  			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

  			pan( panDelta.x, panDelta.y );

  			panStart.copy( panEnd );

  		}

  		scope.update();

  	}

  	//
  	// event handlers - FSM: listen for events and reset state
  	//

  	function onMouseDown( event ) {

  		if ( scope.enabled === false ) { return; }

  		// Prevent the browser from scrolling.

  		event.preventDefault();

  		// Manually set the focus since calling preventDefault above
  		// prevents the browser from setting it automatically.

  		scope.domElement.focus ? scope.domElement.focus() : window.focus();

  		switch ( event.button ) {

  			case scope.mouseButtons.LEFT:

  				if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

  					if ( scope.enablePan === false ) { return; }

  					handleMouseDownPan( event );

  					state = STATE.PAN;

  				} else {

  					if ( scope.enableRotate === false ) { return; }

  					handleMouseDownRotate( event );

  					state = STATE.ROTATE;

  				}

  				break;

  			case scope.mouseButtons.MIDDLE:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseDownDolly( event );

  				state = STATE.DOLLY;

  				break;

  			case scope.mouseButtons.RIGHT:

  				if ( scope.enablePan === false ) { return; }

  				handleMouseDownPan( event );

  				state = STATE.PAN;

  				break;

  		}

  		if ( state !== STATE.NONE ) {

  			document.addEventListener( 'mousemove', onMouseMove, false );
  			document.addEventListener( 'mouseup', onMouseUp, false );

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onMouseMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( state ) {

  			case STATE.ROTATE:

  				if ( scope.enableRotate === false ) { return; }

  				handleMouseMoveRotate( event );

  				break;

  			case STATE.DOLLY:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseMoveDolly( event );

  				break;

  			case STATE.PAN:

  				if ( scope.enablePan === false ) { return; }

  				handleMouseMovePan( event );

  				break;

  		}

  	}

  	function onMouseUp( event ) {

  		if ( scope.enabled === false ) { return; }

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onMouseWheel( event ) {

  		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		scope.dispatchEvent( startEvent );

  		handleMouseWheel( event );

  		scope.dispatchEvent( endEvent );

  	}

  	function onKeyDown( event ) {

  		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) { return; }

  		handleKeyDown( event );

  	}

  	function onTouchStart( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( event.touches.length ) {

  			case 1:	// one-fingered touch: rotate

  				if ( scope.enableRotate === false ) { return; }

  				handleTouchStartRotate( event );

  				state = STATE.TOUCH_ROTATE;

  				break;

  			case 2:	// two-fingered touch: dolly-pan

  				if ( scope.enableZoom === false && scope.enablePan === false ) { return; }

  				handleTouchStartDollyPan( event );

  				state = STATE.TOUCH_DOLLY_PAN;

  				break;

  			default:

  				state = STATE.NONE;

  		}

  		if ( state !== STATE.NONE ) {

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onTouchMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1: // one-fingered touch: rotate

  				if ( scope.enableRotate === false ) { return; }
  				if ( state !== STATE.TOUCH_ROTATE ) { return; } // is this needed?

  				handleTouchMoveRotate( event );

  				break;

  			case 2: // two-fingered touch: dolly-pan

  				if ( scope.enableZoom === false && scope.enablePan === false ) { return; }
  				if ( state !== STATE.TOUCH_DOLLY_PAN ) { return; } // is this needed?

  				handleTouchMoveDollyPan( event );

  				break;

  			default:

  				state = STATE.NONE;

  		}

  	}

  	function onTouchEnd( event ) {

  		if ( scope.enabled === false ) { return; }

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onContextMenu( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  	}

  	//

  	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

  	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
  	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

  	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
  	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
  	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

  	window.addEventListener( 'keydown', onKeyDown, false );

  	// force an update at start

  	this.update();

  };

  OrbitControls.prototype = Object.create( EventDispatcher.prototype );
  OrbitControls.prototype.constructor = OrbitControls;

  Object.defineProperties( OrbitControls.prototype, {

  	center: {

  		get: function () {

  			console.warn( 'OrbitControls: .center has been renamed to .target' );
  			return this.target;

  		}

  	},

  	// backward compatibility

  	noZoom: {

  		get: function () {

  			console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			return ! this.enableZoom;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			this.enableZoom = ! value;

  		}

  	},

  	noRotate: {

  		get: function () {

  			console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			return ! this.enableRotate;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			this.enableRotate = ! value;

  		}

  	},

  	noPan: {

  		get: function () {

  			console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  			return ! this.enablePan;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  			this.enablePan = ! value;

  		}

  	},

  	noKeys: {

  		get: function () {

  			console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			return ! this.enableKeys;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			this.enableKeys = ! value;

  		}

  	},

  	staticMoving: {

  		get: function () {

  			console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			return ! this.enableDamping;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			this.enableDamping = ! value;

  		}

  	},

  	dynamicDampingFactor: {

  		get: function () {

  			console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			return this.dampingFactor;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			this.dampingFactor = value;

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var OrthographicTrackballControls = function ( object, domElement ) {

  	var _this = this;
  	var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  	this.object = object;
  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// API

  	this.enabled = true;

  	this.screen = { left: 0, top: 0, width: 0, height: 0 };

  	this.radius = 0;

  	this.rotateSpeed = 1.0;
  	this.zoomSpeed = 1.2;

  	this.noRotate = false;
  	this.noZoom = false;
  	this.noPan = false;
  	this.noRoll = false;

  	this.staticMoving = false;
  	this.dynamicDampingFactor = 0.2;

  	this.keys = [ 65 , 83 , 68  ];

  	// internals

  	this.target = new Vector3();

  	var EPS = 0.000001;

  	var _changed = true;

  	var _state = STATE.NONE,
  		_prevState = STATE.NONE,

  		_eye = new Vector3(),

  		_rotateStart = new Vector3(),
  		_rotateEnd = new Vector3(),

  		_zoomStart = new Vector2(),
  		_zoomEnd = new Vector2(),

  		_touchZoomDistanceStart = 0,
  		_touchZoomDistanceEnd = 0,

  		_panStart = new Vector2(),
  		_panEnd = new Vector2();

  	// for reset

  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.up0 = this.object.up.clone();

  	this.left0 = this.object.left;
  	this.right0 = this.object.right;
  	this.top0 = this.object.top;
  	this.bottom0 = this.object.bottom;

  	// events

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };
  	// methods

  	this.handleResize = function () {

  		if ( this.domElement === document ) {

  			this.screen.left = 0;
  			this.screen.top = 0;
  			this.screen.width = window.innerWidth;
  			this.screen.height = window.innerHeight;

  		} else {

  			var box = this.domElement.getBoundingClientRect();
  			// adjustments come from similar code in the jquery offset() function
  			var d = this.domElement.ownerDocument.documentElement;
  			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
  			this.screen.top = box.top + window.pageYOffset - d.clientTop;
  			this.screen.width = box.width;
  			this.screen.height = box.height;

  		}

  		this.radius = 0.5 * Math.min( this.screen.width, this.screen.height );

  		this.left0 = this.object.left;
  		this.right0 = this.object.right;
  		this.top0 = this.object.top;
  		this.bottom0 = this.object.bottom;

  	};

  	var getMouseOnScreen = ( function () {

  		var vector = new Vector2();

  		return function getMouseOnScreen( pageX, pageY ) {

  			vector.set(
  				( pageX - _this.screen.left ) / _this.screen.width,
  				( pageY - _this.screen.top ) / _this.screen.height
  			);

  			return vector;

  		};

  	}() );

  	var getMouseProjectionOnBall = ( function () {

  		var vector = new Vector3();
  		var objectUp = new Vector3();
  		var mouseOnBall = new Vector3();

  		return function getMouseProjectionOnBall( pageX, pageY ) {

  			mouseOnBall.set(
  				( pageX - _this.screen.width * 0.5 - _this.screen.left ) / _this.radius,
  				( _this.screen.height * 0.5 + _this.screen.top - pageY ) / _this.radius,
  				0.0
  			);

  			var length = mouseOnBall.length();

  			if ( _this.noRoll ) {

  				if ( length < Math.SQRT1_2 ) {

  					mouseOnBall.z = Math.sqrt( 1.0 - length * length );

  				} else {

  					mouseOnBall.z = .5 / length;

  				}

  			} else if ( length > 1.0 ) {

  				mouseOnBall.normalize();

  			} else {

  				mouseOnBall.z = Math.sqrt( 1.0 - length * length );

  			}

  			_eye.copy( _this.object.position ).sub( _this.target );

  			vector.copy( _this.object.up ).setLength( mouseOnBall.y );
  			vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
  			vector.add( _eye.setLength( mouseOnBall.z ) );

  			return vector;

  		};

  	}() );

  	this.rotateCamera = ( function () {

  		var axis = new Vector3(),
  			quaternion = new Quaternion();
  		return function rotateCamera() {

  			var angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );

  			if ( angle ) {

  				axis.crossVectors( _rotateStart, _rotateEnd ).normalize();

  				angle *= _this.rotateSpeed;

  				quaternion.setFromAxisAngle( axis, - angle );

  				_eye.applyQuaternion( quaternion );
  				_this.object.up.applyQuaternion( quaternion );

  				_rotateEnd.applyQuaternion( quaternion );

  				if ( _this.staticMoving ) {

  					_rotateStart.copy( _rotateEnd );

  				} else {

  					quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
  					_rotateStart.applyQuaternion( quaternion );

  				}

  				_changed = true;

  			}

  		};

  	}() );

  	this.zoomCamera = function () {

  		if ( _state === STATE.TOUCH_ZOOM_PAN ) {

  			var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
  			_touchZoomDistanceStart = _touchZoomDistanceEnd;

  			_this.object.zoom *= factor;

  			_changed = true;

  		} else {

  			var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

  			if ( Math.abs( factor - 1.0 ) > EPS && factor > 0.0 ) {

  				_this.object.zoom /= factor;

  				if ( _this.staticMoving ) {

  					_zoomStart.copy( _zoomEnd );

  				} else {

  					_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

  				}

  				_changed = true;

  			}

  		}

  	};

  	this.panCamera = ( function () {

  		var mouseChange = new Vector2(),
  			objectUp = new Vector3(),
  			pan = new Vector3();

  		return function panCamera() {

  			mouseChange.copy( _panEnd ).sub( _panStart );

  			if ( mouseChange.lengthSq() ) {

  				// Scale movement to keep clicked/dragged position under cursor
  				var scale_x = ( _this.object.right - _this.object.left ) / _this.object.zoom;
  				var scale_y = ( _this.object.top - _this.object.bottom ) / _this.object.zoom;
  				mouseChange.x *= scale_x;
  				mouseChange.y *= scale_y;

  				pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
  				pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

  				_this.object.position.add( pan );
  				_this.target.add( pan );

  				if ( _this.staticMoving ) {

  					_panStart.copy( _panEnd );

  				} else {

  					_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

  				}

  				_changed = true;

  			}

  		};

  	}() );

  	this.update = function () {

  		_eye.subVectors( _this.object.position, _this.target );

  		if ( ! _this.noRotate ) {

  			_this.rotateCamera();

  		}

  		if ( ! _this.noZoom ) {

  			_this.zoomCamera();

  			if ( _changed ) {

  				_this.object.updateProjectionMatrix();

  			}

  		}

  		if ( ! _this.noPan ) {

  			_this.panCamera();

  		}

  		_this.object.position.addVectors( _this.target, _eye );

  		_this.object.lookAt( _this.target );

  		if ( _changed ) {

  			_this.dispatchEvent( changeEvent );

  			_changed = false;

  		}

  	};

  	this.reset = function () {

  		_state = STATE.NONE;
  		_prevState = STATE.NONE;

  		_this.target.copy( _this.target0 );
  		_this.object.position.copy( _this.position0 );
  		_this.object.up.copy( _this.up0 );

  		_eye.subVectors( _this.object.position, _this.target );

  		_this.object.left = _this.left0;
  		_this.object.right = _this.right0;
  		_this.object.top = _this.top0;
  		_this.object.bottom = _this.bottom0;

  		_this.object.lookAt( _this.target );

  		_this.dispatchEvent( changeEvent );

  		_changed = false;

  	};

  	// listeners

  	function keydown( event ) {

  		if ( _this.enabled === false ) { return; }

  		window.removeEventListener( 'keydown', keydown );

  		_prevState = _state;

  		if ( _state !== STATE.NONE ) {

  			return;

  		} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && ! _this.noRotate ) {

  			_state = STATE.ROTATE;

  		} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && ! _this.noZoom ) {

  			_state = STATE.ZOOM;

  		} else if ( event.keyCode === _this.keys[ STATE.PAN ] && ! _this.noPan ) {

  			_state = STATE.PAN;

  		}

  	}

  	function keyup( event ) {

  		if ( _this.enabled === false ) { return; }

  		_state = _prevState;

  		window.addEventListener( 'keydown', keydown, false );

  	}

  	function mousedown( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.NONE ) {

  			_state = event.button;

  		}

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
  			_rotateEnd.copy( _rotateStart );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_zoomEnd.copy( _zoomStart );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_panEnd.copy( _panStart );

  		}

  		document.addEventListener( 'mousemove', mousemove, false );
  		document.addEventListener( 'mouseup', mouseup, false );

  		_this.dispatchEvent( startEvent );

  	}

  	function mousemove( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		}

  	}

  	function mouseup( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		_state = STATE.NONE;

  		document.removeEventListener( 'mousemove', mousemove );
  		document.removeEventListener( 'mouseup', mouseup );
  		_this.dispatchEvent( endEvent );

  	}

  	function mousewheel( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		_zoomStart.y += event.deltaY * 0.01;
  		_this.dispatchEvent( startEvent );
  		_this.dispatchEvent( endEvent );

  	}

  	function touchstart( event ) {

  		if ( _this.enabled === false ) { return; }

  		switch ( event.touches.length ) {

  			case 1:
  				_state = STATE.TOUCH_ROTATE;
  				_rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_rotateEnd.copy( _rotateStart );
  				break;

  			case 2:
  				_state = STATE.TOUCH_ZOOM_PAN;
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panStart.copy( getMouseOnScreen( x, y ) );
  				_panEnd.copy( _panStart );
  				break;

  			default:
  				_state = STATE.NONE;

  		}
  		_this.dispatchEvent( startEvent );

  	}

  	function touchmove( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1:
  				_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				break;

  			case 2:
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panEnd.copy( getMouseOnScreen( x, y ) );
  				break;

  			default:
  				_state = STATE.NONE;

  		}

  	}

  	function touchend( event ) {

  		if ( _this.enabled === false ) { return; }

  		switch ( event.touches.length ) {

  			case 1:
  				_rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_rotateStart.copy( _rotateEnd );
  				break;

  			case 2:
  				_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panEnd.copy( getMouseOnScreen( x, y ) );
  				_panStart.copy( _panEnd );
  				break;

  		}

  		_state = STATE.NONE;
  		_this.dispatchEvent( endEvent );

  	}

  	function contextmenu( event ) {

  		event.preventDefault();

  	}

  	this.dispose = function () {

  		this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		this.domElement.removeEventListener( 'mousedown', mousedown, false );
  		this.domElement.removeEventListener( 'wheel', mousewheel, false );

  		this.domElement.removeEventListener( 'touchstart', touchstart, false );
  		this.domElement.removeEventListener( 'touchend', touchend, false );
  		this.domElement.removeEventListener( 'touchmove', touchmove, false );

  		document.removeEventListener( 'mousemove', mousemove, false );
  		document.removeEventListener( 'mouseup', mouseup, false );

  		window.removeEventListener( 'keydown', keydown, false );
  		window.removeEventListener( 'keyup', keyup, false );

  	};

  	this.domElement.addEventListener( 'contextmenu', contextmenu, false );
  	this.domElement.addEventListener( 'mousedown', mousedown, false );
  	this.domElement.addEventListener( 'wheel', mousewheel, false );

  	this.domElement.addEventListener( 'touchstart', touchstart, false );
  	this.domElement.addEventListener( 'touchend', touchend, false );
  	this.domElement.addEventListener( 'touchmove', touchmove, false );

  	window.addEventListener( 'keydown', keydown, false );
  	window.addEventListener( 'keyup', keyup, false );

  	this.handleResize();

  	// force an update at start
  	this.update();

  };

  OrthographicTrackballControls.prototype = Object.create( EventDispatcher.prototype );
  OrthographicTrackballControls.prototype.constructor = OrthographicTrackballControls;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PointerLockControls = function ( camera, domElement ) {

  	var scope = this;

  	this.domElement = domElement || document.body;
  	this.isLocked = false;

  	camera.rotation.set( 0, 0, 0 );

  	var pitchObject = new Object3D();
  	pitchObject.add( camera );

  	var yawObject = new Object3D();
  	yawObject.position.y = 10;
  	yawObject.add( pitchObject );

  	var PI_2 = Math.PI / 2;

  	function onMouseMove( event ) {

  		if ( scope.isLocked === false ) { return; }

  		var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
  		var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

  		yawObject.rotation.y -= movementX * 0.002;
  		pitchObject.rotation.x -= movementY * 0.002;

  		pitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, pitchObject.rotation.x ) );

  	}

  	function onPointerlockChange() {

  		if ( document.pointerLockElement === scope.domElement ) {

  			scope.dispatchEvent( { type: 'lock' } );

  			scope.isLocked = true;

  		} else {

  			scope.dispatchEvent( { type: 'unlock' } );

  			scope.isLocked = false;

  		}

  	}

  	function onPointerlockError() {

  		console.error( 'PointerLockControls: Unable to use Pointer Lock API' );

  	}

  	this.connect = function () {

  		document.addEventListener( 'mousemove', onMouseMove, false );
  		document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
  		document.addEventListener( 'pointerlockerror', onPointerlockError, false );

  	};

  	this.disconnect = function () {

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
  		document.removeEventListener( 'pointerlockerror', onPointerlockError, false );

  	};

  	this.dispose = function () {

  		this.disconnect();

  	};

  	this.getObject = function () {

  		return yawObject;

  	};

  	this.getDirection = function () {

  		// assumes the camera itself is not rotated

  		var direction = new Vector3( 0, 0, - 1 );
  		var rotation = new Euler( 0, 0, 0, 'YXZ' );

  		return function ( v ) {

  			rotation.set( pitchObject.rotation.x, yawObject.rotation.y, 0 );

  			v.copy( direction ).applyEuler( rotation );

  			return v;

  		};

  	}();

  	this.lock = function () {

  		this.domElement.requestPointerLock();

  	};

  	this.unlock = function () {

  		document.exitPointerLock();

  	};

  	this.connect();

  };

  PointerLockControls.prototype = Object.create( EventDispatcher.prototype );
  PointerLockControls.prototype.constructor = PointerLockControls;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TrackballControls = function ( object, domElement ) {

  	var _this = this;
  	var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

  	this.object = object;
  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// API

  	this.enabled = true;

  	this.screen = { left: 0, top: 0, width: 0, height: 0 };

  	this.rotateSpeed = 1.0;
  	this.zoomSpeed = 1.2;
  	this.panSpeed = 0.3;

  	this.noRotate = false;
  	this.noZoom = false;
  	this.noPan = false;

  	this.staticMoving = false;
  	this.dynamicDampingFactor = 0.2;

  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	this.keys = [ 65 , 83 , 68  ];

  	// internals

  	this.target = new Vector3();

  	var EPS = 0.000001;

  	var lastPosition = new Vector3();

  	var _state = STATE.NONE,
  		_prevState = STATE.NONE,

  		_eye = new Vector3(),

  		_movePrev = new Vector2(),
  		_moveCurr = new Vector2(),

  		_lastAxis = new Vector3(),
  		_lastAngle = 0,

  		_zoomStart = new Vector2(),
  		_zoomEnd = new Vector2(),

  		_touchZoomDistanceStart = 0,
  		_touchZoomDistanceEnd = 0,

  		_panStart = new Vector2(),
  		_panEnd = new Vector2();

  	// for reset

  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.up0 = this.object.up.clone();

  	// events

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };
  	// methods

  	this.handleResize = function () {

  		if ( this.domElement === document ) {

  			this.screen.left = 0;
  			this.screen.top = 0;
  			this.screen.width = window.innerWidth;
  			this.screen.height = window.innerHeight;

  		} else {

  			var box = this.domElement.getBoundingClientRect();
  			// adjustments come from similar code in the jquery offset() function
  			var d = this.domElement.ownerDocument.documentElement;
  			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
  			this.screen.top = box.top + window.pageYOffset - d.clientTop;
  			this.screen.width = box.width;
  			this.screen.height = box.height;

  		}

  	};

  	var getMouseOnScreen = ( function () {

  		var vector = new Vector2();

  		return function getMouseOnScreen( pageX, pageY ) {

  			vector.set(
  				( pageX - _this.screen.left ) / _this.screen.width,
  				( pageY - _this.screen.top ) / _this.screen.height
  			);

  			return vector;

  		};

  	}() );

  	var getMouseOnCircle = ( function () {

  		var vector = new Vector2();

  		return function getMouseOnCircle( pageX, pageY ) {

  			vector.set(
  				( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),
  				( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width ) // screen.width intentional
  			);

  			return vector;

  		};

  	}() );

  	this.rotateCamera = ( function () {

  		var axis = new Vector3(),
  			quaternion = new Quaternion(),
  			eyeDirection = new Vector3(),
  			objectUpDirection = new Vector3(),
  			objectSidewaysDirection = new Vector3(),
  			moveDirection = new Vector3(),
  			angle;

  		return function rotateCamera() {

  			moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
  			angle = moveDirection.length();

  			if ( angle ) {

  				_eye.copy( _this.object.position ).sub( _this.target );

  				eyeDirection.copy( _eye ).normalize();
  				objectUpDirection.copy( _this.object.up ).normalize();
  				objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();

  				objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
  				objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );

  				moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );

  				axis.crossVectors( moveDirection, _eye ).normalize();

  				angle *= _this.rotateSpeed;
  				quaternion.setFromAxisAngle( axis, angle );

  				_eye.applyQuaternion( quaternion );
  				_this.object.up.applyQuaternion( quaternion );

  				_lastAxis.copy( axis );
  				_lastAngle = angle;

  			} else if ( ! _this.staticMoving && _lastAngle ) {

  				_lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );
  				_eye.copy( _this.object.position ).sub( _this.target );
  				quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
  				_eye.applyQuaternion( quaternion );
  				_this.object.up.applyQuaternion( quaternion );

  			}

  			_movePrev.copy( _moveCurr );

  		};

  	}() );
  	this.zoomCamera = function () {

  		var factor;

  		if ( _state === STATE.TOUCH_ZOOM_PAN ) {

  			factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
  			_touchZoomDistanceStart = _touchZoomDistanceEnd;
  			_eye.multiplyScalar( factor );

  		} else {

  			factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

  			if ( factor !== 1.0 && factor > 0.0 ) {

  				_eye.multiplyScalar( factor );

  			}

  			if ( _this.staticMoving ) {

  				_zoomStart.copy( _zoomEnd );

  			} else {

  				_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

  			}

  		}

  	};

  	this.panCamera = ( function () {

  		var mouseChange = new Vector2(),
  			objectUp = new Vector3(),
  			pan = new Vector3();

  		return function panCamera() {

  			mouseChange.copy( _panEnd ).sub( _panStart );

  			if ( mouseChange.lengthSq() ) {

  				mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

  				pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
  				pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

  				_this.object.position.add( pan );
  				_this.target.add( pan );

  				if ( _this.staticMoving ) {

  					_panStart.copy( _panEnd );

  				} else {

  					_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

  				}

  			}

  		};

  	}() );

  	this.checkDistances = function () {

  		if ( ! _this.noZoom || ! _this.noPan ) {

  			if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

  				_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );
  				_zoomStart.copy( _zoomEnd );

  			}

  			if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

  				_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );
  				_zoomStart.copy( _zoomEnd );

  			}

  		}

  	};

  	this.update = function () {

  		_eye.subVectors( _this.object.position, _this.target );

  		if ( ! _this.noRotate ) {

  			_this.rotateCamera();

  		}

  		if ( ! _this.noZoom ) {

  			_this.zoomCamera();

  		}

  		if ( ! _this.noPan ) {

  			_this.panCamera();

  		}

  		_this.object.position.addVectors( _this.target, _eye );

  		_this.checkDistances();

  		_this.object.lookAt( _this.target );

  		if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

  			_this.dispatchEvent( changeEvent );

  			lastPosition.copy( _this.object.position );

  		}

  	};

  	this.reset = function () {

  		_state = STATE.NONE;
  		_prevState = STATE.NONE;

  		_this.target.copy( _this.target0 );
  		_this.object.position.copy( _this.position0 );
  		_this.object.up.copy( _this.up0 );

  		_eye.subVectors( _this.object.position, _this.target );

  		_this.object.lookAt( _this.target );

  		_this.dispatchEvent( changeEvent );

  		lastPosition.copy( _this.object.position );

  	};

  	// listeners

  	function keydown( event ) {

  		if ( _this.enabled === false ) { return; }

  		window.removeEventListener( 'keydown', keydown );

  		_prevState = _state;

  		if ( _state !== STATE.NONE ) {

  			return;

  		} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && ! _this.noRotate ) {

  			_state = STATE.ROTATE;

  		} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && ! _this.noZoom ) {

  			_state = STATE.ZOOM;

  		} else if ( event.keyCode === _this.keys[ STATE.PAN ] && ! _this.noPan ) {

  			_state = STATE.PAN;

  		}

  	}

  	function keyup( event ) {

  		if ( _this.enabled === false ) { return; }

  		_state = _prevState;

  		window.addEventListener( 'keydown', keydown, false );

  	}

  	function mousedown( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.NONE ) {

  			_state = event.button;

  		}

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
  			_movePrev.copy( _moveCurr );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_zoomEnd.copy( _zoomStart );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
  			_panEnd.copy( _panStart );

  		}

  		document.addEventListener( 'mousemove', mousemove, false );
  		document.addEventListener( 'mouseup', mouseup, false );

  		_this.dispatchEvent( startEvent );

  	}

  	function mousemove( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		if ( _state === STATE.ROTATE && ! _this.noRotate ) {

  			_movePrev.copy( _moveCurr );
  			_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.ZOOM && ! _this.noZoom ) {

  			_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		} else if ( _state === STATE.PAN && ! _this.noPan ) {

  			_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

  		}

  	}

  	function mouseup( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		_state = STATE.NONE;

  		document.removeEventListener( 'mousemove', mousemove );
  		document.removeEventListener( 'mouseup', mouseup );
  		_this.dispatchEvent( endEvent );

  	}

  	function mousewheel( event ) {

  		if ( _this.enabled === false ) { return; }

  		if ( _this.noZoom === true ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.deltaMode ) {

  			case 2:
  				// Zoom in pages
  				_zoomStart.y -= event.deltaY * 0.025;
  				break;

  			case 1:
  				// Zoom in lines
  				_zoomStart.y -= event.deltaY * 0.01;
  				break;

  			default:
  				// undefined, 0, assume pixels
  				_zoomStart.y -= event.deltaY * 0.00025;
  				break;

  		}

  		_this.dispatchEvent( startEvent );
  		_this.dispatchEvent( endEvent );

  	}

  	function touchstart( event ) {

  		if ( _this.enabled === false ) { return; }
  		
  		event.preventDefault();

  		switch ( event.touches.length ) {

  			case 1:
  				_state = STATE.TOUCH_ROTATE;
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_movePrev.copy( _moveCurr );
  				break;

  			default: // 2 or more
  				_state = STATE.TOUCH_ZOOM_PAN;
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panStart.copy( getMouseOnScreen( x, y ) );
  				_panEnd.copy( _panStart );
  				break;

  		}

  		_this.dispatchEvent( startEvent );

  	}

  	function touchmove( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1:
  				_movePrev.copy( _moveCurr );
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				break;

  			default: // 2 or more
  				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
  				_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

  				var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
  				var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
  				_panEnd.copy( getMouseOnScreen( x, y ) );
  				break;

  		}

  	}

  	function touchend( event ) {

  		if ( _this.enabled === false ) { return; }

  		switch ( event.touches.length ) {

  			case 0:
  				_state = STATE.NONE;
  				break;

  			case 1:
  				_state = STATE.TOUCH_ROTATE;
  				_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
  				_movePrev.copy( _moveCurr );
  				break;

  		}

  		_this.dispatchEvent( endEvent );

  	}

  	function contextmenu( event ) {

  		if ( _this.enabled === false ) { return; }

  		event.preventDefault();

  	}

  	this.dispose = function () {

  		this.domElement.removeEventListener( 'contextmenu', contextmenu, false );
  		this.domElement.removeEventListener( 'mousedown', mousedown, false );
  		this.domElement.removeEventListener( 'wheel', mousewheel, false );

  		this.domElement.removeEventListener( 'touchstart', touchstart, false );
  		this.domElement.removeEventListener( 'touchend', touchend, false );
  		this.domElement.removeEventListener( 'touchmove', touchmove, false );

  		document.removeEventListener( 'mousemove', mousemove, false );
  		document.removeEventListener( 'mouseup', mouseup, false );

  		window.removeEventListener( 'keydown', keydown, false );
  		window.removeEventListener( 'keyup', keyup, false );

  	};

  	this.domElement.addEventListener( 'contextmenu', contextmenu, false );
  	this.domElement.addEventListener( 'mousedown', mousedown, false );
  	this.domElement.addEventListener( 'wheel', mousewheel, false );

  	this.domElement.addEventListener( 'touchstart', touchstart, false );
  	this.domElement.addEventListener( 'touchend', touchend, false );
  	this.domElement.addEventListener( 'touchmove', touchmove, false );

  	window.addEventListener( 'keydown', keydown, false );
  	window.addEventListener( 'keyup', keyup, false );

  	this.handleResize();

  	// force an update at start
  	this.update();

  };

  TrackballControls.prototype = Object.create( EventDispatcher.prototype );
  TrackballControls.prototype.constructor = TrackballControls;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // PolyhedronGeometry

  function PolyhedronGeometry( vertices, indices, radius, detail ) {

  	Geometry.call( this );

  	this.type = 'PolyhedronGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
  	this.mergeVertices();

  }

  PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

  	BufferGeometry.call( this );

  	this.type = 'PolyhedronBufferGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	radius = radius || 1;
  	detail = detail || 0;

  	// default buffer data

  	var vertexBuffer = [];
  	var uvBuffer = [];

  	// the subdivision creates the vertex buffer data

  	subdivide( detail );

  	// all vertices should lie on a conceptual sphere with a given radius

  	appplyRadius( radius );

  	// finally, create the uv data

  	generateUVs();

  	// build non-indexed geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

  	if ( detail === 0 ) {

  		this.computeVertexNormals(); // flat normals

  	} else {

  		this.normalizeNormals(); // smooth normals

  	}

  	// helper functions

  	function subdivide( detail ) {

  		var a = new Vector3();
  		var b = new Vector3();
  		var c = new Vector3();

  		// iterate over all faces and apply a subdivison with the given detail value

  		for ( var i = 0; i < indices.length; i += 3 ) {

  			// get the vertices of the face

  			getVertexByIndex( indices[ i + 0 ], a );
  			getVertexByIndex( indices[ i + 1 ], b );
  			getVertexByIndex( indices[ i + 2 ], c );

  			// perform subdivision

  			subdivideFace( a, b, c, detail );

  		}

  	}

  	function subdivideFace( a, b, c, detail ) {

  		var cols = Math.pow( 2, detail );

  		// we use this multidimensional array as a data structure for creating the subdivision

  		var v = [];

  		var i, j;

  		// construct all of the vertices for this subdivision

  		for ( i = 0; i <= cols; i ++ ) {

  			v[ i ] = [];

  			var aj = a.clone().lerp( c, i / cols );
  			var bj = b.clone().lerp( c, i / cols );

  			var rows = cols - i;

  			for ( j = 0; j <= rows; j ++ ) {

  				if ( j === 0 && i === cols ) {

  					v[ i ][ j ] = aj;

  				} else {

  					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  				}

  			}

  		}

  		// construct all of the faces

  		for ( i = 0; i < cols; i ++ ) {

  			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  				var k = Math.floor( j / 2 );

  				if ( j % 2 === 0 ) {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );
  					pushVertex( v[ i ][ k ] );

  				} else {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );

  				}

  			}

  		}

  	}

  	function appplyRadius( radius ) {

  		var vertex = new Vector3();

  		// iterate over the entire buffer and apply the radius to each vertex

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			vertex.normalize().multiplyScalar( radius );

  			vertexBuffer[ i + 0 ] = vertex.x;
  			vertexBuffer[ i + 1 ] = vertex.y;
  			vertexBuffer[ i + 2 ] = vertex.z;

  		}

  	}

  	function generateUVs() {

  		var vertex = new Vector3();

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  			var v = inclination( vertex ) / Math.PI + 0.5;
  			uvBuffer.push( u, 1 - v );

  		}

  		correctUVs();

  		correctSeam();

  	}

  	function correctSeam() {

  		// handle case when face straddles the seam, see #3269

  		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

  			// uv data of a single face

  			var x0 = uvBuffer[ i + 0 ];
  			var x1 = uvBuffer[ i + 2 ];
  			var x2 = uvBuffer[ i + 4 ];

  			var max = Math.max( x0, x1, x2 );
  			var min = Math.min( x0, x1, x2 );

  			// 0.9 is somewhat arbitrary

  			if ( max > 0.9 && min < 0.1 ) {

  				if ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }
  				if ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }
  				if ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }

  			}

  		}

  	}

  	function pushVertex( vertex ) {

  		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  	}

  	function getVertexByIndex( index, vertex ) {

  		var stride = index * 3;

  		vertex.x = vertices[ stride + 0 ];
  		vertex.y = vertices[ stride + 1 ];
  		vertex.z = vertices[ stride + 2 ];

  	}

  	function correctUVs() {

  		var a = new Vector3();
  		var b = new Vector3();
  		var c = new Vector3();

  		var centroid = new Vector3();

  		var uvA = new Vector2();
  		var uvB = new Vector2();
  		var uvC = new Vector2();

  		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  			var azi = azimuth( centroid );

  			correctUV( uvA, j + 0, a, azi );
  			correctUV( uvB, j + 2, b, azi );
  			correctUV( uvC, j + 4, c, azi );

  		}

  	}

  	function correctUV( uv, stride, vector, azimuth ) {

  		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  			uvBuffer[ stride ] = uv.x - 1;

  		}

  		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  		}

  	}

  	// Angle around the Y axis, counter-clockwise when looking from above.

  	function azimuth( vector ) {

  		return Math.atan2( vector.z, - vector.x );

  	}
  	// Angle above the XZ plane.

  	function inclination( vector ) {

  		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  	}

  }

  PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // OctahedronGeometry

  function OctahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'OctahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  OctahedronGeometry.prototype = Object.create( Geometry.prototype );
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry( radius, detail ) {

  	var vertices = [
  		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
  		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
  	];

  	var indices = [
  		0, 2, 4,	0, 4, 3,	0, 3, 5,
  		0, 5, 2,	1, 2, 5,	1, 5, 3,
  		1, 3, 4,	1, 4, 2
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'OctahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // TorusGeometry

  function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  	Geometry.call( this );

  	this.type = 'TorusGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
  	this.mergeVertices();

  }

  TorusGeometry.prototype = Object.create( Geometry.prototype );
  TorusGeometry.prototype.constructor = TorusGeometry;

  // TorusBufferGeometry

  function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  	BufferGeometry.call( this );

  	this.type = 'TorusBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	radius = radius || 1;
  	tube = tube || 0.4;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	tubularSegments = Math.floor( tubularSegments ) || 6;
  	arc = arc || Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var center = new Vector3();
  	var vertex = new Vector3();
  	var normal = new Vector3();

  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= radialSegments; j ++ ) {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			var u = i / tubularSegments * arc;
  			var v = j / radialSegments * Math.PI * 2;

  			// vertex

  			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  			vertex.z = tube * Math.sin( v );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			center.x = radius * Math.cos( u );
  			center.y = radius * Math.sin( u );
  			normal.subVectors( vertex, center ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= radialSegments; j ++ ) {

  		for ( i = 1; i <= tubularSegments; i ++ ) {

  			// indices

  			var a = ( tubularSegments + 1 ) * j + i - 1;
  			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  			var d = ( tubularSegments + 1 ) * j + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TransformControls = function ( camera, domElement ) {

  	Object3D.call( this );

  	domElement = ( domElement !== undefined ) ? domElement : document;

  	this.visible = false;

  	var _gizmo = new TransformControlsGizmo();
  	this.add( _gizmo );

  	var _plane = new TransformControlsPlane();
  	this.add( _plane );

  	var scope = this;

  	// Define properties with getters/setter
  	// Setting the defined property will automatically trigger change event
  	// Defined properties are passed down to gizmo and plane

  	defineProperty( "camera", camera );
  	defineProperty( "object", undefined );
  	defineProperty( "enabled", true );
  	defineProperty( "axis", null );
  	defineProperty( "mode", "translate" );
  	defineProperty( "translationSnap", null );
  	defineProperty( "rotationSnap", null );
  	defineProperty( "space", "world" );
  	defineProperty( "size", 1 );
  	defineProperty( "dragging", false );
  	defineProperty( "showX", true );
  	defineProperty( "showY", true );
  	defineProperty( "showZ", true );

  	var changeEvent = { type: "change" };
  	var mouseDownEvent = { type: "mouseDown" };
  	var mouseUpEvent = { type: "mouseUp", mode: scope.mode };
  	var objectChangeEvent = { type: "objectChange" };

  	// Reusable utility variables

  	var ray = new Raycaster();

  	var _tempVector = new Vector3();
  	var _tempQuaternion = new Quaternion();
  	var _unit = {
  		X: new Vector3( 1, 0, 0 ),
  		Y: new Vector3( 0, 1, 0 ),
  		Z: new Vector3( 0, 0, 1 )
  	};

  	var pointStart = new Vector3();
  	var pointEnd = new Vector3();
  	var offset = new Vector3();
  	var rotationAxis = new Vector3();
  	var startNorm = new Vector3();
  	var endNorm = new Vector3();
  	var rotationAngle = 0;

  	var cameraPosition = new Vector3();
  	var cameraQuaternion = new Quaternion();
  	var cameraScale = new Vector3();

  	var parentPosition = new Vector3();
  	var parentQuaternion = new Quaternion();
  	var parentQuaternionInv = new Quaternion();
  	var parentScale = new Vector3();

  	var worldPositionStart = new Vector3();
  	var worldQuaternionStart = new Quaternion();
  	var worldScaleStart = new Vector3();

  	var worldPosition = new Vector3();
  	var worldQuaternion = new Quaternion();
  	var worldQuaternionInv = new Quaternion();
  	var worldScale = new Vector3();

  	var eye = new Vector3();

  	var positionStart = new Vector3();
  	var quaternionStart = new Quaternion();
  	var scaleStart = new Vector3();

  	// TODO: remove properties unused in plane and gizmo

  	defineProperty( "worldPosition", worldPosition );
  	defineProperty( "worldPositionStart", worldPositionStart );
  	defineProperty( "worldQuaternion", worldQuaternion );
  	defineProperty( "worldQuaternionStart", worldQuaternionStart );
  	defineProperty( "cameraPosition", cameraPosition );
  	defineProperty( "cameraQuaternion", cameraQuaternion );
  	defineProperty( "pointStart", pointStart );
  	defineProperty( "pointEnd", pointEnd );
  	defineProperty( "rotationAxis", rotationAxis );
  	defineProperty( "rotationAngle", rotationAngle );
  	defineProperty( "eye", eye );

  	{

  		domElement.addEventListener( "mousedown", onPointerDown, false );
  		domElement.addEventListener( "touchstart", onPointerDown, false );
  		domElement.addEventListener( "mousemove", onPointerHover, false );
  		domElement.addEventListener( "touchmove", onPointerHover, false );
  		domElement.addEventListener( "touchmove", onPointerMove, false );
  		document.addEventListener( "mouseup", onPointerUp, false );
  		domElement.addEventListener( "touchend", onPointerUp, false );
  		domElement.addEventListener( "touchcancel", onPointerUp, false );
  		domElement.addEventListener( "touchleave", onPointerUp, false );

  	}

  	this.dispose = function () {

  		domElement.removeEventListener( "mousedown", onPointerDown );
  		domElement.removeEventListener( "touchstart", onPointerDown );
  		domElement.removeEventListener( "mousemove", onPointerHover );
  		domElement.removeEventListener( "touchmove", onPointerHover );
  		domElement.removeEventListener( "touchmove", onPointerMove );
  		document.removeEventListener( "mouseup", onPointerUp );
  		domElement.removeEventListener( "touchend", onPointerUp );
  		domElement.removeEventListener( "touchcancel", onPointerUp );
  		domElement.removeEventListener( "touchleave", onPointerUp );

  	};

  	// Set current object
  	this.attach = function ( object ) {

  		this.object = object;
  		this.visible = true;

  	};

  	// Detatch from object
  	this.detach = function () {

  		this.object = undefined;
  		this.visible = false;
  		this.axis = null;

  	};

  	// Defined getter, setter and store for a property
  	function defineProperty( propName, defaultValue ) {

  		var propValue = defaultValue;

  		Object.defineProperty( scope, propName, {

  			get: function() {

  				return propValue !== undefined ? propValue : defaultValue;

  			},

  			set: function( value ) {

  				if ( propValue !== value ) {

  					propValue = value;
  					_plane[ propName ] = value;
  					_gizmo[ propName ] = value;

  					scope.dispatchEvent( { type: propName + "-changed", value: value } );
  					scope.dispatchEvent( changeEvent );

  				}

  			}

  		});

  		scope[ propName ] = defaultValue;
  		_plane[ propName ] = defaultValue;
  		_gizmo[ propName ] = defaultValue;

  	}

  	// updateMatrixWorld  updates key transformation variables
  	this.updateMatrixWorld = function () {

  		if ( this.object !== undefined ) {

  			this.object.updateMatrixWorld();
  			this.object.parent.matrixWorld.decompose( parentPosition, parentQuaternion, parentScale );
  			this.object.matrixWorld.decompose( worldPosition, worldQuaternion, worldScale );

  			parentQuaternionInv.copy( parentQuaternion ).inverse();
  			worldQuaternionInv.copy( worldQuaternion ).inverse();

  		}

  		this.camera.updateMatrixWorld();
  		this.camera.matrixWorld.decompose( cameraPosition, cameraQuaternion, cameraScale );

  		if ( this.camera instanceof PerspectiveCamera ) {

  			eye.copy( cameraPosition ).sub( worldPosition ).normalize();

  		} else if ( this.camera instanceof OrthographicCamera ) {

  			eye.copy( cameraPosition ).normalize();

  		}

  		Object3D.prototype.updateMatrixWorld.call( this );

  	};

  	this.pointerHover = function( pointer ) {

  		if ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }

  		ray.setFromCamera( pointer, this.camera );

  		var intersect = ray.intersectObjects( _gizmo.picker[ this.mode ].children, true )[ 0 ] || false;

  		if ( intersect ) {

  			this.axis = intersect.object.name;

  		} else {

  			this.axis = null;

  		}

  	};

  	this.pointerDown = function( pointer ) {

  		if ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }

  		if ( ( pointer.button === 0 || pointer.button === undefined ) && this.axis !== null ) {

  			ray.setFromCamera( pointer, this.camera );

  			var planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;

  			if ( planeIntersect ) {

  				var space = this.space;

  				if ( this.mode === 'scale') {

  					space = 'local';

  				} else if ( this.axis === 'E' ||  this.axis === 'XYZE' ||  this.axis === 'XYZ' ) {

  					space = 'world';

  				}

  				if ( space === 'local' && this.mode === 'rotate' ) {

  					var snap = this.rotationSnap;

  					if ( this.axis === 'X' && snap ) { this.object.rotation.x = Math.round( this.object.rotation.x / snap ) * snap; }
  					if ( this.axis === 'Y' && snap ) { this.object.rotation.y = Math.round( this.object.rotation.y / snap ) * snap; }
  					if ( this.axis === 'Z' && snap ) { this.object.rotation.z = Math.round( this.object.rotation.z / snap ) * snap; }

  				}

  				this.object.updateMatrixWorld();
  				this.object.parent.updateMatrixWorld();

  				positionStart.copy( this.object.position );
  				quaternionStart.copy( this.object.quaternion );
  				scaleStart.copy( this.object.scale );

  				this.object.matrixWorld.decompose( worldPositionStart, worldQuaternionStart, worldScaleStart );

  				pointStart.copy( planeIntersect.point ).sub( worldPositionStart );

  			}

  			this.dragging = true;
  			mouseDownEvent.mode = this.mode;
  			this.dispatchEvent( mouseDownEvent );

  		}

  	};

  	this.pointerMove = function( pointer ) {

  		var axis = this.axis;
  		var mode = this.mode;
  		var object = this.object;
  		var space = this.space;

  		if ( mode === 'scale') {

  			space = 'local';

  		} else if ( axis === 'E' ||  axis === 'XYZE' ||  axis === 'XYZ' ) {

  			space = 'world';

  		}

  		if ( object === undefined || axis === null || this.dragging === false || ( pointer.button !== undefined && pointer.button !== 0 ) ) { return; }

  		ray.setFromCamera( pointer, this.camera );

  		var planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;

  		if ( planeIntersect === false ) { return; }

  		pointEnd.copy( planeIntersect.point ).sub( worldPositionStart );

  		if ( mode === 'translate' ) {

  			// Apply translate

  			offset.copy( pointEnd ).sub( pointStart );

  			if ( space === 'local' && axis !== 'XYZ' ) {
  				offset.applyQuaternion( worldQuaternionInv );
  			}

  			if ( axis.indexOf( 'X' ) === -1 ) { offset.x = 0; }
  			if ( axis.indexOf( 'Y' ) === -1 ) { offset.y = 0; }
  			if ( axis.indexOf( 'Z' ) === -1 ) { offset.z = 0; }

  			if ( space === 'local' && axis !== 'XYZ') {
  				offset.applyQuaternion( quaternionStart ).divide( parentScale );
  			} else {
  				offset.applyQuaternion( parentQuaternionInv ).divide( parentScale );
  			}

  			object.position.copy( offset ).add( positionStart );

  			// Apply translation snap

  			if ( this.translationSnap ) {

  				if ( space === 'local' ) {

  					object.position.applyQuaternion(_tempQuaternion.copy( quaternionStart ).inverse() );

  					if ( axis.search( 'X' ) !== -1 ) {
  						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;
  					}

  					if ( axis.search( 'Y' ) !== -1 ) {
  						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;
  					}

  					if ( axis.search( 'Z' ) !== -1 ) {
  						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;
  					}

  					object.position.applyQuaternion( quaternionStart );

  				}

  				if ( space === 'world' ) {

  					if ( object.parent ) {
  						object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );
  					}

  					if ( axis.search( 'X' ) !== -1 ) {
  						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;
  					}

  					if ( axis.search( 'Y' ) !== -1 ) {
  						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;
  					}

  					if ( axis.search( 'Z' ) !== -1 ) {
  						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;
  					}

  					if ( object.parent ) {
  						object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );
  					}

  				}

  			}

  		} else if ( mode === 'scale' ) {

  			if ( axis.search( 'XYZ' ) !== -1 ) {

  				var d = pointEnd.length() / pointStart.length();

  				if ( pointEnd.dot( pointStart ) < 0 ) { d *= -1; }

  				_tempVector.set( d, d, d );

  			} else {

  				_tempVector.copy( pointEnd ).divide( pointStart );

  				if ( axis.search( 'X' ) === -1 ) {
  					_tempVector.x = 1;
  				}
  				if ( axis.search( 'Y' ) === -1 ) {
  					_tempVector.y = 1;
  				}
  				if ( axis.search( 'Z' ) === -1 ) {
  					_tempVector.z = 1;
  				}

  			}

  			// Apply scale

  			object.scale.copy( scaleStart ).multiply( _tempVector );

  		} else if ( mode === 'rotate' ) {

  			offset.copy( pointEnd ).sub( pointStart );

  			var ROTATION_SPEED = 20 / worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );

  			if ( axis === 'E' ) {

  				rotationAxis.copy( eye );
  				rotationAngle = pointEnd.angleTo( pointStart );

  				startNorm.copy( pointStart ).normalize();
  				endNorm.copy( pointEnd ).normalize();

  				rotationAngle *= ( endNorm.cross( startNorm ).dot( eye ) < 0 ? 1 : -1);

  			} else if ( axis === 'XYZE' ) {

  				rotationAxis.copy( offset ).cross( eye ).normalize(  );
  				rotationAngle = offset.dot( _tempVector.copy( rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;

  			} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {

  				rotationAxis.copy( _unit[ axis ] );

  				_tempVector.copy( _unit[ axis ] );

  				if ( space === 'local' ) {
  					_tempVector.applyQuaternion( worldQuaternion );
  				}

  				rotationAngle = offset.dot( _tempVector.cross( eye ).normalize() ) * ROTATION_SPEED;

  			}

  			// Apply rotation snap

  			if ( this.rotationSnap ) { rotationAngle = Math.round( rotationAngle / this.rotationSnap ) * this.rotationSnap; }

  			this.rotationAngle = rotationAngle;

  			// Apply rotate
  			if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {

  				object.quaternion.copy( quaternionStart );
  				object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) ).normalize();

  			} else {

  				rotationAxis.applyQuaternion( parentQuaternionInv );
  				object.quaternion.copy( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) );
  				object.quaternion.multiply( quaternionStart ).normalize();

  			}

  		}

  		this.dispatchEvent( changeEvent );
  		this.dispatchEvent( objectChangeEvent );

  	};

  	this.pointerUp = function( pointer ) {

  		if ( pointer.button !== undefined && pointer.button !== 0 ) { return; }

  		if ( this.dragging && ( this.axis !== null ) ) {

  			mouseUpEvent.mode = this.mode;
  			this.dispatchEvent( mouseUpEvent );

  		}

  		this.dragging = false;

  		if ( pointer.button === undefined ) { this.axis = null; }

  	};

  	// normalize mouse / touch pointer and remap {x,y} to view space.

  	function getPointer( event ) {

  		var pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;

  		var rect = domElement.getBoundingClientRect();

  		return {
  			x: ( pointer.clientX - rect.left ) / rect.width * 2 - 1,
  			y: - ( pointer.clientY - rect.top ) / rect.height * 2 + 1,
  			button: event.button
  		};

  	}

  	// mouse / touch event handlers

  	function onPointerHover( event ) {

  		if ( !scope.enabled ) { return; }

  		scope.pointerHover( getPointer( event ) );

  	}

  	function onPointerDown( event ) {

  		if ( !scope.enabled ) { return; }

  		document.addEventListener( "mousemove", onPointerMove, false );

  		scope.pointerHover( getPointer( event ) );
  		scope.pointerDown( getPointer( event ) );

  	}

  	function onPointerMove( event ) {

  		if ( !scope.enabled ) { return; }

  		scope.pointerMove( getPointer( event ) );

  	}

  	function onPointerUp( event ) {

  		if ( !scope.enabled ) { return; }

  		document.removeEventListener( "mousemove", onPointerMove, false );

  		scope.pointerUp( getPointer( event ) );

  	}

  	// TODO: depricate

  	this.getMode = function () {

  		return scope.mode;

  	};

  	this.setMode = function ( mode ) {

  		scope.mode = mode;

  	};

  	this.setTranslationSnap = function ( translationSnap ) {

  		scope.translationSnap = translationSnap;

  	};

  	this.setRotationSnap = function ( rotationSnap ) {

  		scope.rotationSnap = rotationSnap;

  	};

  	this.setSize = function ( size ) {

  		scope.size = size;

  	};

  	this.setSpace = function ( space ) {

  		scope.space = space;

  	};

  	this.update = function () {

  		console.warn( 'TransformControls: update function has been depricated.' );

  	};

  };

  TransformControls.prototype = Object.assign( Object.create( Object3D.prototype ), {

    constructor: TransformControls,

    isTransformControls: true

  } );
  var TransformControlsGizmo = function () {

  	Object3D.call( this );

  	this.type = 'TransformControlsGizmo';

  	// shared materials

  	var gizmoMaterial = new MeshBasicMaterial({
  		depthTest: false,
  		depthWrite: false,
  		transparent: true,
  		side: DoubleSide,
  		fog: false
  	});

  	var gizmoLineMaterial = new LineBasicMaterial({
  		depthTest: false,
  		depthWrite: false,
  		transparent: true,
  		linewidth: 1,
  		fog: false
  	});

  	// Make unique material for each axis/color

  	var matInvisible = gizmoMaterial.clone();
  	matInvisible.opacity = 0.15;

  	var matHelper = gizmoMaterial.clone();
  	matHelper.opacity = 0.33;

  	var matRed = gizmoMaterial.clone();
  	matRed.color.set( 0xff0000 );

  	var matGreen = gizmoMaterial.clone();
  	matGreen.color.set( 0x00ff00 );

  	var matBlue = gizmoMaterial.clone();
  	matBlue.color.set( 0x0000ff );

  	var matWhiteTransperent = gizmoMaterial.clone();
  	matWhiteTransperent.opacity = 0.25;

  	var matYellowTransparent = matWhiteTransperent.clone();
  	matYellowTransparent.color.set( 0xffff00 );

  	var matCyanTransparent = matWhiteTransperent.clone();
  	matCyanTransparent.color.set( 0x00ffff );

  	var matMagentaTransparent = matWhiteTransperent.clone();
  	matMagentaTransparent.color.set( 0xff00ff );

  	var matYellow = gizmoMaterial.clone();
  	matYellow.color.set( 0xffff00 );

  	var matLineRed = gizmoLineMaterial.clone();
  	matLineRed.color.set( 0xff0000 );

  	var matLineGreen = gizmoLineMaterial.clone();
  	matLineGreen.color.set( 0x00ff00 );

  	var matLineBlue = gizmoLineMaterial.clone();
  	matLineBlue.color.set( 0x0000ff );

  	var matLineCyan = gizmoLineMaterial.clone();
  	matLineCyan.color.set( 0x00ffff );

  	var matLineMagenta = gizmoLineMaterial.clone();
  	matLineMagenta.color.set( 0xff00ff );

  	var matLineYellow = gizmoLineMaterial.clone();
  	matLineYellow.color.set( 0xffff00 );

  	var matLineGray = gizmoLineMaterial.clone();
  	matLineGray.color.set( 0x787878);

  	var matLineYellowTransparent = matLineYellow.clone();
  	matLineYellowTransparent.opacity = 0.25;

  	// reusable geometry

  	var arrowGeometry = new CylinderBufferGeometry( 0, 0.05, 0.2, 12, 1, false);

  	var scaleHandleGeometry = new BoxBufferGeometry( 0.125, 0.125, 0.125);

  	var lineGeometry = new BufferGeometry( );
  	lineGeometry.addAttribute('position', new Float32BufferAttribute( [ 0, 0, 0,	1, 0, 0 ], 3 ) );

  	var CircleGeometry = function( radius, arc ) {

  		var geometry = new BufferGeometry( );
  		var vertices = [];

  		for ( var i = 0; i <= 64 * arc; ++i ) {

  			vertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );

  		}

  		geometry.addAttribute('position', new Float32BufferAttribute( vertices, 3 ) );

  		return geometry;

  	};

  	// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

  	var TranslateHelperGeometry = function( radius, arc ) {

  		var geometry = new BufferGeometry();

  		geometry.addAttribute('position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );

  		return geometry;

  	};

  	// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

  	var gizmoTranslate = {
  		X: [
  			[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, -Math.PI / 2 ], null, 'fwd' ],
  			[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, Math.PI / 2 ], null, 'bwd' ],
  			[ new Line( lineGeometry, matLineRed ) ]
  		],
  		Y: [
  			[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], null, null, 'fwd' ],
  			[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], [ Math.PI, 0, 0 ], null, 'bwd' ],
  			[ new Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ] ]
  		],
  		Z: [
  			[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ Math.PI / 2, 0, 0 ], null, 'fwd' ],
  			[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ -Math.PI / 2, 0, 0 ], null, 'bwd' ],
  			[ new Line( lineGeometry, matLineBlue ), null, [ 0, -Math.PI / 2, 0 ] ]
  		],
  		XYZ: [
  			[ new Mesh( new OctahedronBufferGeometry( 0.1, 0 ), matWhiteTransperent ), [ 0, 0, 0 ], [ 0, 0, 0 ] ]
  		],
  		XY: [
  			[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matYellowTransparent ), [ 0.15, 0.15, 0 ] ],
  			[ new Line( lineGeometry, matLineYellow ), [ 0.18, 0.3, 0 ], null, [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineYellow ), [ 0.3, 0.18, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ]
  		],
  		YZ: [
  			[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matCyanTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ] ],
  			[ new Line( lineGeometry, matLineCyan ), [ 0, 0.18, 0.3 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineCyan ), [ 0, 0.3, 0.18 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]
  		],
  		XZ: [
  			[ new Mesh( new PlaneBufferGeometry( 0.295, 0.295 ), matMagentaTransparent ), [ 0.15, 0, 0.15 ], [ -Math.PI / 2, 0, 0 ] ],
  			[ new Line( lineGeometry, matLineMagenta ), [ 0.18, 0, 0.3 ], null, [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineMagenta ), [ 0.3, 0, 0.18 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]
  		]
  	};

  	var pickerTranslate = {
  		X: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0.6, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ]
  		],
  		Y: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0.6, 0 ] ]
  		],
  		Z: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ] ]
  		],
  		XYZ: [
  			[ new Mesh( new OctahedronBufferGeometry( 0.2, 0 ), matInvisible ) ]
  		],
  		XY: [
  			[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0.2, 0 ] ]
  		],
  		YZ: [
  			[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ] ]
  		],
  		XZ: [
  			[ new Mesh( new PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0, 0.2 ], [ -Math.PI / 2, 0, 0 ] ]
  		]
  	};

  	var helperTranslate = {
  		START: [
  			[ new Mesh( new OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
  		],
  		END: [
  			[ new Mesh( new OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
  		],
  		DELTA: [
  			[ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]
  		],
  		X: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
  		],
  		Y: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
  		],
  		Z: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, -Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
  		]
  	};

  	var gizmoRotate = {
  		X: [
  			[ new Line( CircleGeometry( 1, 0.5 ), matLineRed ) ],
  			[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matRed ), [ 0, 0, 0.99 ], null, [ 1, 3, 1 ] ] ],
  		Y: [
  			[ new Line( CircleGeometry( 1, 0.5 ), matLineGreen ), null, [ 0, 0, -Math.PI / 2 ] ],
  			[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matGreen ), [ 0, 0, 0.99 ], null, [ 3, 1, 1 ] ] ],
  		Z: [
  			[ new Line( CircleGeometry( 1, 0.5 ), matLineBlue ), null, [ 0, Math.PI / 2, 0 ] ],
  			[ new Mesh( new OctahedronBufferGeometry( 0.04, 0 ), matBlue ), [ 0.99, 0, 0 ], null, [ 1, 3, 1 ] ] ],
  		E: [
  			[ new Line( CircleGeometry( 1.25, 1 ), matLineYellowTransparent ), null, [ 0, Math.PI / 2, 0 ] ],
  			[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 1.17, 0, 0 ], [ 0, 0, -Math.PI / 2 ], [ 1, 1, 0.001 ]],
  			[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ -1.17, 0, 0 ], [ 0, 0, Math.PI / 2 ], [ 1, 1, 0.001 ]],
  			[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, -1.17, 0 ], [ Math.PI, 0, 0 ], [ 1, 1, 0.001 ]],
  			[ new Mesh( new CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, 1.17, 0 ], [ 0, 0, 0 ], [ 1, 1, 0.001 ]] ],
  		XYZE: [
  			[ new Line( CircleGeometry( 1, 1 ), matLineGray ), null, [ 0, Math.PI / 2, 0 ] ]
  		]
  	};

  	var helperRotate = {
  		AXIS: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
  		]
  	};

  	var pickerRotate = {
  		X: [
  			[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, -Math.PI / 2, -Math.PI / 2 ] ] ],
  		Y: [
  			[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ] ] ],
  		Z: [
  			[ new Mesh( new TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ] ],
  		E: [
  			[ new Mesh( new TorusBufferGeometry( 1.25, 0.1, 2, 24 ), matInvisible ) ]
  		],
  		XYZE: [
  			[ new Mesh( new SphereBufferGeometry( 0.7, 10, 8 ), matInvisible ) ]
  		]
  	};

  	var gizmoScale = {
  		X: [
  			[ new Mesh( scaleHandleGeometry, matRed ), [ 0.8, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ],
  			[ new Line( lineGeometry, matLineRed ), null, null, [ 0.8, 1, 1 ] ]
  		],
  		Y: [
  			[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.8, 0 ] ],
  			[ new Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ], [ 0.8, 1, 1 ] ]
  		],
  		Z: [
  			[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.8 ], [ Math.PI / 2, 0, 0 ] ],
  			[ new Line( lineGeometry, matLineBlue ), null, [ 0, -Math.PI / 2, 0 ], [ 0.8, 1, 1 ] ]
  		],
  		XY: [
  			[ new Mesh( scaleHandleGeometry, matYellowTransparent ), [ 0.85, 0.85, 0 ], null, [ 2, 2, 0.2 ] ],
  			[ new Line( lineGeometry, matLineYellow ), [ 0.855, 0.98, 0 ], null, [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineYellow ), [ 0.98, 0.855, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ]
  		],
  		YZ: [
  			[ new Mesh( scaleHandleGeometry, matCyanTransparent ), [ 0, 0.85, 0.85 ], null, [ 0.2, 2, 2 ] ],
  			[ new Line( lineGeometry, matLineCyan ), [ 0, 0.855, 0.98 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineCyan ), [ 0, 0.98, 0.855 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]
  		],
  		XZ: [
  			[ new Mesh( scaleHandleGeometry, matMagentaTransparent ), [ 0.85, 0, 0.85 ], null, [ 2, 0.2, 2 ] ],
  			[ new Line( lineGeometry, matLineMagenta ), [ 0.855, 0, 0.98 ], null, [ 0.125, 1, 1 ] ],
  			[ new Line( lineGeometry, matLineMagenta ), [ 0.98, 0, 0.855 ], [ 0, -Math.PI / 2, 0 ], [ 0.125, 1, 1 ] ]
  		],
  		XYZX: [
  			[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 1.1, 0, 0 ] ] ],
  		XYZY: [
  			[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 0, 1.1, 0 ] ] ],
  		XYZZ: [
  			[ new Mesh( new BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransperent ), [ 0, 0, 1.1 ] ] ]
  	};

  	var pickerScale = {
  		X: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0.5, 0, 0 ], [ 0, 0, -Math.PI / 2 ] ]
  		],
  		Y: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0.5, 0 ] ]
  		],
  		Z: [
  			[ new Mesh( new CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ] ]
  		],
  		XY: [
  			[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0.85, 0 ], null, [ 3, 3, 0.2 ] ] ],
  		YZ: [
  			[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0, 0.85, 0.85 ], null, [ 0.2, 3, 3 ] ] ],
  		XZ: [
  			[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0, 0.85 ], null, [ 3, 0.2, 3 ] ] ],
  		XYZX: [
  			[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 1.1, 0, 0 ] ] ],
  		XYZY: [
  			[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 1.1, 0 ] ] ],
  		XYZZ: [
  			[ new Mesh( new BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 1.1 ] ] ]
  	};

  	var helperScale = {
  		X: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ -1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
  		],
  		Y: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ 0, -1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
  		],
  		Z: [
  			[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, -1e3 ], [ 0, -Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
  		]
  	};

  	// Creates an Object3D with gizmos described in custom hierarchy definition.

  	var setupGizmo = function( gizmoMap ) {

  		var gizmo = new Object3D();

  		for ( var name in gizmoMap ) {

  			for ( var i = gizmoMap[ name ].length; i --; ) {

  				var object = gizmoMap[ name ][ i ][ 0 ].clone();
  				var position = gizmoMap[ name ][ i ][ 1 ];
  				var rotation = gizmoMap[ name ][ i ][ 2 ];
  				var scale = gizmoMap[ name ][ i ][ 3 ];
  				var tag = gizmoMap[ name ][ i ][ 4 ];

  				// name and tag properties are essential for picking and updating logic.
  				object.name = name;
  				object.tag = tag;

  				if (position) {
  					object.position.set(position[ 0 ], position[ 1 ], position[ 2 ]);
  				}
  				if (rotation) {
  					object.rotation.set(rotation[ 0 ], rotation[ 1 ], rotation[ 2 ]);
  				}
  				if (scale) {
  					object.scale.set(scale[ 0 ], scale[ 1 ], scale[ 2 ]);
  				}

  				object.updateMatrix();

  				var tempGeometry = object.geometry.clone();
  				tempGeometry.applyMatrix(object.matrix);
  				object.geometry = tempGeometry;

  				object.position.set( 0, 0, 0 );
  				object.rotation.set( 0, 0, 0 );
  				object.scale.set(1, 1, 1);

  				gizmo.add(object);

  			}

  		}

  		return gizmo;

  	};

  	// Reusable utility variables

  	var tempVector = new Vector3( 0, 0, 0 );
  	var tempEuler = new Euler();
  	var alignVector = new Vector3( 0, 1, 0 );
  	var zeroVector = new Vector3( 0, 0, 0 );
  	var lookAtMatrix = new Matrix4();
  	var tempQuaternion = new Quaternion();
  	var tempQuaternion2 = new Quaternion();
  	var identityQuaternion = new Quaternion();

  	var unitX = new Vector3( 1, 0, 0 );
  	var unitY = new Vector3( 0, 1, 0 );
  	var unitZ = new Vector3( 0, 0, 1 );

  	// Gizmo creation

  	this.gizmo = {};
  	this.picker = {};
  	this.helper = {};

  	this.add( this.gizmo[ "translate" ] = setupGizmo( gizmoTranslate ) );
  	this.add( this.gizmo[ "rotate" ] = setupGizmo( gizmoRotate ) );
  	this.add( this.gizmo[ "scale" ] = setupGizmo( gizmoScale ) );
  	this.add( this.picker[ "translate" ] = setupGizmo( pickerTranslate ) );
  	this.add( this.picker[ "rotate" ] = setupGizmo( pickerRotate ) );
  	this.add( this.picker[ "scale" ] = setupGizmo( pickerScale ) );
  	this.add( this.helper[ "translate" ] = setupGizmo( helperTranslate ) );
  	this.add( this.helper[ "rotate" ] = setupGizmo( helperRotate ) );
  	this.add( this.helper[ "scale" ] = setupGizmo( helperScale ) );

  	// Pickers should be hidden always

  	this.picker[ "translate" ].visible = false;
  	this.picker[ "rotate" ].visible = false;
  	this.picker[ "scale" ].visible = false;

  	// updateMatrixWorld will update transformations and appearance of individual handles

  	this.updateMatrixWorld = function () {
  		var this$1 = this;


  		var space = this.space;

  		if ( this.mode === 'scale' ) { space = 'local'; } // scale always oriented to local rotation

  		var quaternion = space === "local" ? this.worldQuaternion : identityQuaternion;

  		// Show only gizmos for current transform mode

  		this.gizmo[ "translate" ].visible = this.mode === "translate";
  		this.gizmo[ "rotate" ].visible = this.mode === "rotate";
  		this.gizmo[ "scale" ].visible = this.mode === "scale";

  		this.helper[ "translate" ].visible = this.mode === "translate";
  		this.helper[ "rotate" ].visible = this.mode === "rotate";
  		this.helper[ "scale" ].visible = this.mode === "scale";
  		var handles = [];
  		handles = handles.concat( this.picker[ this.mode ].children );
  		handles = handles.concat( this.gizmo[ this.mode ].children );
  		handles = handles.concat( this.helper[ this.mode ].children );

  		for ( var i = 0; i < handles.length; i++ ) {

  			var handle = handles[i];

  			// hide aligned to camera

  			handle.visible = true;
  			handle.rotation.set( 0, 0, 0 );
  			handle.position.copy( this$1.worldPosition );

  			var eyeDistance = this$1.worldPosition.distanceTo( this$1.cameraPosition);
  			handle.scale.set( 1, 1, 1 ).multiplyScalar( eyeDistance * this$1.size / 7 );

  			// TODO: simplify helpers and consider decoupling from gizmo

  			if ( handle.tag === 'helper' ) {

  				handle.visible = false;

  				if ( handle.name === 'AXIS' ) {

  					handle.position.copy( this$1.worldPositionStart );
  					handle.visible = !!this$1.axis;

  					if ( this$1.axis === 'X' ) {

  						tempQuaternion.setFromEuler( tempEuler.set( 0, 0, 0 ) );
  						handle.quaternion.copy( quaternion ).multiply( tempQuaternion );

  						if ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {
  							handle.visible = false;
  						}

  					}

  					if ( this$1.axis === 'Y' ) {

  						tempQuaternion.setFromEuler( tempEuler.set( 0, 0, Math.PI / 2 ) );
  						handle.quaternion.copy( quaternion ).multiply( tempQuaternion );

  						if ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {
  							handle.visible = false;
  						}

  					}

  					if ( this$1.axis === 'Z' ) {

  						tempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );
  						handle.quaternion.copy( quaternion ).multiply( tempQuaternion );

  						if ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > 0.9 ) {
  							handle.visible = false;
  						}

  					}

  					if ( this$1.axis === 'XYZE' ) {

  						tempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );
  						alignVector.copy( this$1.rotationAxis );
  						handle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( zeroVector, alignVector, unitY ) );
  						handle.quaternion.multiply( tempQuaternion );
  						handle.visible = this$1.dragging;

  					}

  					if ( this$1.axis === 'E' ) {

  						handle.visible = false;

  					}
  				} else if ( handle.name === 'START' ) {

  					handle.position.copy( this$1.worldPositionStart );
  					handle.visible = this$1.dragging;

  				} else if ( handle.name === 'END' ) {

  					handle.position.copy( this$1.worldPosition );
  					handle.visible = this$1.dragging;

  				} else if ( handle.name === 'DELTA' ) {

  					handle.position.copy( this$1.worldPositionStart );
  					handle.quaternion.copy( this$1.worldQuaternionStart );
  					tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this$1.worldPositionStart ).sub( this$1.worldPosition ).multiplyScalar( -1 );
  					tempVector.applyQuaternion( this$1.worldQuaternionStart.clone().inverse() );
  					handle.scale.copy( tempVector );
  					handle.visible = this$1.dragging;

  				} else {

  					handle.quaternion.copy( quaternion );

  					if ( this$1.dragging ) {

  						handle.position.copy( this$1.worldPositionStart );

  					} else {

  						handle.position.copy( this$1.worldPosition );

  					}

  					if ( this$1.axis ) {

  						handle.visible = this$1.axis.search( handle.name ) !== -1;

  					}

  				}

  				// If updating helper, skip rest of the loop
  				continue;

  			}

  			// Align handles to current local or world rotation

  			handle.quaternion.copy( quaternion );

  			if ( this$1.mode === 'translate' || this$1.mode === 'scale' ) {

  				// Hide translate and scale axis facing the camera

  				var AXIS_HIDE_TRESHOLD = 0.99;
  				var PLANE_HIDE_TRESHOLD = 0.2;
  				var AXIS_FLIP_TRESHOLD = -0.4;
  				if ( handle.name === 'X' || handle.name === 'XYZX' ) {
  					if ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}
  				if ( handle.name === 'Y' || handle.name === 'XYZY' ) {
  					if ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}
  				if ( handle.name === 'Z' || handle.name === 'XYZZ' ) {
  					if ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) > AXIS_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}
  				if ( handle.name === 'XY' ) {
  					if ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}
  				if ( handle.name === 'YZ' ) {
  					if ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}
  				if ( handle.name === 'XZ' ) {
  					if ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) ) < PLANE_HIDE_TRESHOLD ) {
  						handle.scale.set( 1e-10, 1e-10, 1e-10 );
  						handle.visible = false;
  					}
  				}

  				// Flip translate and scale axis ocluded behind another axis

  				if ( handle.name.search( 'X' ) !== -1 ) {
  					if ( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {
  						if ( handle.tag === 'fwd' ) {
  							handle.visible = false;
  						} else {
  							handle.scale.x *= -1;
  						}
  					} else if ( handle.tag === 'bwd' ) {
  						handle.visible = false;
  					}
  				}

  				if ( handle.name.search( 'Y' ) !== -1 ) {
  					if ( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {
  						if ( handle.tag === 'fwd' ) {
  							handle.visible = false;
  						} else {
  							handle.scale.y *= -1;
  						}
  					} else if ( handle.tag === 'bwd' ) {
  						handle.visible = false;
  					}
  				}

  				if ( handle.name.search( 'Z' ) !== -1 ) {
  					if ( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this$1.eye ) < AXIS_FLIP_TRESHOLD ) {
  						if ( handle.tag === 'fwd' ) {
  							handle.visible = false;
  						} else {
  							handle.scale.z *= -1;
  						}
  					} else if ( handle.tag === 'bwd' ) {
  						handle.visible = false;
  					}
  				}

  			} else if ( this$1.mode === 'rotate' ) {

  				// Align handles to current local or world rotation

  				tempQuaternion2.copy( quaternion );
  				alignVector.copy( this$1.eye ).applyQuaternion( tempQuaternion.copy( quaternion ).inverse() );

  				if ( handle.name.search( "E" ) !== - 1 ) {

  					handle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( this$1.eye, zeroVector, unitY ) );

  				}

  				if ( handle.name === 'X' ) {

  					tempQuaternion.setFromAxisAngle( unitX, Math.atan2( -alignVector.y, alignVector.z ) );
  					tempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );
  					handle.quaternion.copy( tempQuaternion );

  				}

  				if ( handle.name === 'Y' ) {

  					tempQuaternion.setFromAxisAngle( unitY, Math.atan2( alignVector.x, alignVector.z ) );
  					tempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );
  					handle.quaternion.copy( tempQuaternion );

  				}

  				if ( handle.name === 'Z' ) {

  					tempQuaternion.setFromAxisAngle( unitZ, Math.atan2( alignVector.y, alignVector.x ) );
  					tempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );
  					handle.quaternion.copy( tempQuaternion );

  				}

  			}

  			// Hide disabled axes
  			handle.visible = handle.visible && ( handle.name.indexOf( "X" ) === -1 || this$1.showX );
  			handle.visible = handle.visible && ( handle.name.indexOf( "Y" ) === -1 || this$1.showY );
  			handle.visible = handle.visible && ( handle.name.indexOf( "Z" ) === -1 || this$1.showZ );
  			handle.visible = handle.visible && ( handle.name.indexOf( "E" ) === -1 || ( this$1.showX && this$1.showY && this$1.showZ ) );

  			// highlight selected axis

  			handle.material._opacity = handle.material._opacity || handle.material.opacity;
  			handle.material._color = handle.material._color || handle.material.color.clone();

  			handle.material.color.copy( handle.material._color );
  			handle.material.opacity = handle.material._opacity;

  			if ( !this$1.enabled ) {

  				handle.material.opacity *= 0.5;
  				handle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );

  			} else if ( this$1.axis ) {

  				if ( handle.name === this$1.axis ) {

  					handle.material.opacity = 1.0;
  					handle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );

  				} else if ( this$1.axis.split('').some( function( a ) { return handle.name === a; } ) ) {

  					handle.material.opacity = 1.0;
  					handle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );

  				} else {

  					handle.material.opacity *= 0.25;
  					handle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );

  				}

  			}

  		}

  		Object3D.prototype.updateMatrixWorld.call( this );

  	};

  };

  TransformControlsGizmo.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: TransformControlsGizmo,

  	isTransformControlsGizmo: true

  } );
  var TransformControlsPlane = function () {

  	Mesh.call( this,
  		new PlaneBufferGeometry( 100000, 100000, 2, 2 ),
  		new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1 } )
  	);

  	this.type = 'TransformControlsPlane';

  	var unitX = new Vector3( 1, 0, 0 );
  	var unitY = new Vector3( 0, 1, 0 );
  	var unitZ = new Vector3( 0, 0, 1 );

  	var tempVector = new Vector3();
  	var dirVector = new Vector3();
  	var alignVector = new Vector3();
  	var tempMatrix = new Matrix4();
  	var identityQuaternion = new Quaternion();

  	this.updateMatrixWorld = function() {

  		var space = this.space;

  		this.position.copy( this.worldPosition );

  		if ( this.mode === 'scale' ) { space = 'local'; } // scale always oriented to local rotation

  		unitX.set( 1, 0, 0 ).applyQuaternion( space === "local" ? this.worldQuaternion : identityQuaternion );
  		unitY.set( 0, 1, 0 ).applyQuaternion( space === "local" ? this.worldQuaternion : identityQuaternion );
  		unitZ.set( 0, 0, 1 ).applyQuaternion( space === "local" ? this.worldQuaternion : identityQuaternion );

  		// Align the plane for current transform mode, axis and space.

  		alignVector.copy( unitY );

  		switch ( this.mode ) {
  			case 'translate':
  			case 'scale':
  				switch ( this.axis ) {
  					case 'X':
  						alignVector.copy( this.eye ).cross( unitX );
  						dirVector.copy( unitX ).cross( alignVector );
  						break;
  					case 'Y':
  						alignVector.copy( this.eye ).cross( unitY );
  						dirVector.copy( unitY ).cross( alignVector );
  						break;
  					case 'Z':
  						alignVector.copy( this.eye ).cross( unitZ );
  						dirVector.copy( unitZ ).cross( alignVector );
  						break;
  					case 'XY':
  						dirVector.copy( unitZ );
  						break;
  					case 'YZ':
  						dirVector.copy( unitX );
  						break;
  					case 'XZ':
  						alignVector.copy( unitZ );
  						dirVector.copy( unitY );
  						break;
  					case 'XYZ':
  					case 'E':
  						dirVector.set( 0, 0, 0 );
  						break;
  				}
  				break;
  			case 'rotate':
  			default:
  				// special case for rotate
  				dirVector.set( 0, 0, 0 );
  		}

  		if ( dirVector.length() === 0 ) {

  			// If in rotate mode, make the plane parallel to camera
  			this.quaternion.copy( this.cameraQuaternion );

  		} else {

  			tempMatrix.lookAt( tempVector.set( 0, 0, 0 ), dirVector, alignVector );

  			this.quaternion.setFromRotationMatrix( tempMatrix );

  		}

  		Object3D.prototype.updateMatrixWorld.call( this );

  	};

  };

  TransformControlsPlane.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: TransformControlsPlane,

  	isTransformControlsPlane: true

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Line3( start, end ) {

  	this.start = ( start !== undefined ) ? start : new Vector3();
  	this.end = ( end !== undefined ) ? end : new Vector3();

  }

  Object.assign( Line3.prototype, {

  	set: function ( start, end ) {

  		this.start.copy( start );
  		this.end.copy( end );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( line ) {

  		this.start.copy( line.start );
  		this.end.copy( line.end );

  		return this;

  	},

  	getCenter: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Line3: .getCenter() target is now required' );
  			target = new Vector3();

  		}

  		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  	},

  	delta: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Line3: .delta() target is now required' );
  			target = new Vector3();

  		}

  		return target.subVectors( this.end, this.start );

  	},

  	distanceSq: function () {

  		return this.start.distanceToSquared( this.end );

  	},

  	distance: function () {

  		return this.start.distanceTo( this.end );

  	},

  	at: function ( t, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Line3: .at() target is now required' );
  			target = new Vector3();

  		}

  		return this.delta( target ).multiplyScalar( t ).add( this.start );

  	},

  	closestPointToPointParameter: function () {

  		var startP = new Vector3();
  		var startEnd = new Vector3();

  		return function closestPointToPointParameter( point, clampToLine ) {

  			startP.subVectors( point, this.start );
  			startEnd.subVectors( this.end, this.start );

  			var startEnd2 = startEnd.dot( startEnd );
  			var startEnd_startP = startEnd.dot( startP );

  			var t = startEnd_startP / startEnd2;

  			if ( clampToLine ) {

  				t = _Math.clamp( t, 0, 1 );

  			}

  			return t;

  		};

  	}(),

  	closestPointToPoint: function ( point, clampToLine, target ) {

  		var t = this.closestPointToPointParameter( point, clampToLine );

  		if ( target === undefined ) {

  			console.warn( 'Line3: .closestPointToPoint() target is now required' );
  			target = new Vector3();

  		}

  		return this.delta( target ).multiplyScalar( t ).add( this.start );

  	},

  	applyMatrix4: function ( matrix ) {

  		this.start.applyMatrix4( matrix );
  		this.end.applyMatrix4( matrix );

  		return this;

  	},

  	equals: function ( line ) {

  		return line.start.equals( this.start ) && line.end.equals( this.end );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	var Visible = 0;
  	var Deleted = 1;

  	function QuickHull() {

  		this.tolerance = - 1;

  		this.faces = []; // the generated faces of the convex hull
  		this.newFaces = []; // this array holds the faces that are generated within a single iteration

  		// the vertex lists work as follows:
  		//
  		// let 'a' and 'b' be 'Face' instances
  		// let 'v' be points wrapped as instance of 'Vertex'
  		//
  		//     [v, v, ..., v, v, v, ...]
  		//      ^             ^
  		//      |             |
  		//  a.outside     b.outside
  		//
  		this.assigned = new VertexList();
  		this.unassigned = new VertexList();

  		this.vertices = []; 	// vertices of the hull (internal representation of given geometry data)

  	}

  	Object.assign( QuickHull.prototype, {

  		setFromPoints: function ( points ) {
  			var this$1 = this;


  			if ( Array.isArray( points ) !== true ) {

  				console.error( 'QuickHull: Points parameter is not an array.' );

  			}

  			if ( points.length < 4 ) {

  				console.error( 'QuickHull: The algorithm needs at least four points.' );

  			}

  			this.makeEmpty();

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				this$1.vertices.push( new VertexNode( points[ i ] ) );

  			}

  			this.compute();

  			return this;

  		},

  		setFromObject: function ( object ) {

  			var points = [];

  			object.updateMatrixWorld( true );

  			object.traverse( function ( node ) {

  				var i, l, point;

  				var geometry = node.geometry;

  				if ( geometry !== undefined ) {

  					if ( geometry.isGeometry ) {

  						var vertices = geometry.vertices;

  						for ( i = 0, l = vertices.length; i < l; i ++ ) {

  							point = vertices[ i ].clone();
  							point.applyMatrix4( node.matrixWorld );

  							points.push( point );

  						}

  					} else if ( geometry.isBufferGeometry ) {

  						var attribute = geometry.attributes.position;

  						if ( attribute !== undefined ) {

  							for ( i = 0, l = attribute.count; i < l; i ++ ) {

  								point = new Vector3();

  								point.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  								points.push( point );

  							}

  						}

  					}

  				}

  			} );

  			return this.setFromPoints( points );

  		},

  		makeEmpty: function () {

  			this.faces = [];
  			this.vertices = [];

  			return this;

  		},

  		// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face

  		addVertexToFace: function ( vertex, face ) {

  			vertex.face = face;

  			if ( face.outside === null ) {

  				this.assigned.append( vertex );

  			} else {

  				this.assigned.insertBefore( face.outside, vertex );

  			}

  			face.outside = vertex;

  			return this;

  		},

  		// Removes a vertex from the 'assigned' list of vertices and from the given face

  		removeVertexFromFace: function ( vertex, face ) {

  			if ( vertex === face.outside ) {

  				// fix face.outside link

  				if ( vertex.next !== null && vertex.next.face === face ) {

  					// face has at least 2 outside vertices, move the 'outside' reference

  					face.outside = vertex.next;

  				} else {

  					// vertex was the only outside vertex that face had

  					face.outside = null;

  				}

  			}

  			this.assigned.remove( vertex );

  			return this;

  		},

  		// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list

  		removeAllVerticesFromFace: function ( face ) {

  			if ( face.outside !== null ) {

  				// reference to the first and last vertex of this face

  				var start = face.outside;
  				var end = face.outside;

  				while ( end.next !== null && end.next.face === face ) {

  					end = end.next;

  				}

  				this.assigned.removeSubList( start, end );

  				// fix references

  				start.prev = end.next = null;
  				face.outside = null;

  				return start;

  			}

  		},

  		// Removes all the visible vertices that 'face' is able to see

  		deleteFaceVertices: function ( face, absorbingFace ) {
  			var this$1 = this;


  			var faceVertices = this.removeAllVerticesFromFace( face );

  			if ( faceVertices !== undefined ) {

  				if ( absorbingFace === undefined ) {

  					// mark the vertices to be reassigned to some other face

  					this.unassigned.appendChain( faceVertices );
  				} else {

  					// if there's an absorbing face try to assign as many vertices as possible to it

  					var vertex = faceVertices;

  					do {

  						// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
  						// will be changed by upcoming method calls

  						var nextVertex = vertex.next;

  						var distance = absorbingFace.distanceToPoint( vertex.point );

  						// check if 'vertex' is able to see 'absorbingFace'

  						if ( distance > this$1.tolerance ) {

  							this$1.addVertexToFace( vertex, absorbingFace );

  						} else {

  							this$1.unassigned.append( vertex );

  						}

  						// now assign next vertex

  						vertex = nextVertex;

  					} while ( vertex !== null );

  				}

  			}

  			return this;

  		},

  		// Reassigns as many vertices as possible from the unassigned list to the new faces

  		resolveUnassignedPoints: function ( newFaces ) {
  			var this$1 = this;


  			if ( this.unassigned.isEmpty() === false ) {

  				var vertex = this.unassigned.first();

  				do {

  					// buffer 'next' reference, see .deleteFaceVertices()

  					var nextVertex = vertex.next;

  					var maxDistance = this$1.tolerance;

  					var maxFace = null;

  					for ( var i = 0; i < newFaces.length; i ++ ) {

  						var face = newFaces[ i ];

  						if ( face.mark === Visible ) {

  							var distance = face.distanceToPoint( vertex.point );

  							if ( distance > maxDistance ) {

  								maxDistance = distance;
  								maxFace = face;

  							}

  							if ( maxDistance > 1000 * this$1.tolerance ) { break; }

  						}

  					}

  					// 'maxFace' can be null e.g. if there are identical vertices

  					if ( maxFace !== null ) {

  						this$1.addVertexToFace( vertex, maxFace );

  					}

  					vertex = nextVertex;

  				} while ( vertex !== null );

  			}

  			return this;

  		},

  		// Computes the extremes of a simplex which will be the initial hull

  		computeExtremes: function () {
  			var this$1 = this;


  			var min = new Vector3();
  			var max = new Vector3();

  			var minVertices = [];
  			var maxVertices = [];

  			var i, l, j;

  			// initially assume that the first vertex is the min/max

  			for ( i = 0; i < 3; i ++ ) {

  				minVertices[ i ] = maxVertices[ i ] = this$1.vertices[ 0 ];

  			}

  			min.copy( this.vertices[ 0 ].point );
  			max.copy( this.vertices[ 0 ].point );

  			// compute the min/max vertex on all six directions

  			for ( i = 0, l = this.vertices.length; i < l; i ++ ) {

  				var vertex = this$1.vertices[ i ];
  				var point = vertex.point;

  				// update the min coordinates

  				for ( j = 0; j < 3; j ++ ) {

  					if ( point.getComponent( j ) < min.getComponent( j ) ) {

  						min.setComponent( j, point.getComponent( j ) );
  						minVertices[ j ] = vertex;

  					}

  				}

  				// update the max coordinates

  				for ( j = 0; j < 3; j ++ ) {

  					if ( point.getComponent( j ) > max.getComponent( j ) ) {

  						max.setComponent( j, point.getComponent( j ) );
  						maxVertices[ j ] = vertex;

  					}

  				}

  			}

  			// use min/max vectors to compute an optimal epsilon

  			this.tolerance = 3 * Number.EPSILON * (
  				Math.max( Math.abs( min.x ), Math.abs( max.x ) ) +
  				Math.max( Math.abs( min.y ), Math.abs( max.y ) ) +
  				Math.max( Math.abs( min.z ), Math.abs( max.z ) )
  			);

  			return { min: minVertices, max: maxVertices };

  		},

  		// Computes the initial simplex assigning to its faces all the points
  		// that are candidates to form part of the hull

  		computeInitialHull: function () {

  			var line3, plane, closestPoint;

  			return function computeInitialHull() {
  				var this$1 = this;


  				if ( line3 === undefined ) {

  					line3 = new Line3();
  					plane = new Plane();
  					closestPoint = new Vector3();

  				}

  				var vertex, vertices = this.vertices;
  				var extremes = this.computeExtremes();
  				var min = extremes.min;
  				var max = extremes.max;

  				var v0, v1, v2, v3;
  				var i, l, j;

  				// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
  				// (max.x - min.x)
  				// (max.y - min.y)
  				// (max.z - min.z)

  				var distance, maxDistance = 0;
  				var index = 0;

  				for ( i = 0; i < 3; i ++ ) {

  					distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );

  					if ( distance > maxDistance ) {

  						maxDistance = distance;
  						index = i;

  					}

  				}

  				v0 = min[ index ];
  				v1 = max[ index ];

  				// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

  				maxDistance = 0;
  				line3.set( v0.point, v1.point );

  				for ( i = 0, l = this.vertices.length; i < l; i ++ ) {

  					vertex = vertices[ i ];

  					if ( vertex !== v0 && vertex !== v1 ) {

  						line3.closestPointToPoint( vertex.point, true, closestPoint );

  						distance = closestPoint.distanceToSquared( vertex.point );

  						if ( distance > maxDistance ) {

  							maxDistance = distance;
  							v2 = vertex;

  						}

  					}

  				}

  				// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'

  				maxDistance = - 1;
  				plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );

  				for ( i = 0, l = this.vertices.length; i < l; i ++ ) {

  					vertex = vertices[ i ];

  					if ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {

  						distance = Math.abs( plane.distanceToPoint( vertex.point ) );

  						if ( distance > maxDistance ) {

  							maxDistance = distance;
  							v3 = vertex;

  						}

  					}

  				}

  				var faces = [];

  				if ( plane.distanceToPoint( v3.point ) < 0 ) {

  					// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron

  					faces.push(
  						Face.create( v0, v1, v2 ),
  						Face.create( v3, v1, v0 ),
  						Face.create( v3, v2, v1 ),
  						Face.create( v3, v0, v2 )
  					);

  					// set the twin edge

  					for ( i = 0; i < 3; i ++ ) {

  						j = ( i + 1 ) % 3;

  						// join face[ i ] i > 0, with the first face

  						faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );

  						// join face[ i ] with face[ i + 1 ], 1 <= i <= 3

  						faces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );

  					}

  				} else {

  					// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron

  					faces.push(
  						Face.create( v0, v2, v1 ),
  						Face.create( v3, v0, v1 ),
  						Face.create( v3, v1, v2 ),
  						Face.create( v3, v2, v0 )
  					);

  					// set the twin edge

  					for ( i = 0; i < 3; i ++ ) {

  						j = ( i + 1 ) % 3;

  						// join face[ i ] i > 0, with the first face

  						faces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );

  						// join face[ i ] with face[ i + 1 ]

  						faces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );

  					}

  				}

  				// the initial hull is the tetrahedron

  				for ( i = 0; i < 4; i ++ ) {

  					this$1.faces.push( faces[ i ] );

  				}

  				// initial assignment of vertices to the faces of the tetrahedron

  				for ( i = 0, l = vertices.length; i < l; i ++ ) {

  					vertex = vertices[ i ];

  					if ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {

  						maxDistance = this$1.tolerance;
  						var maxFace = null;

  						for ( j = 0; j < 4; j ++ ) {

  							distance = this$1.faces[ j ].distanceToPoint( vertex.point );

  							if ( distance > maxDistance ) {

  								maxDistance = distance;
  								maxFace = this$1.faces[ j ];

  							}

  						}

  						if ( maxFace !== null ) {

  							this$1.addVertexToFace( vertex, maxFace );

  						}

  					}

  				}

  				return this;

  			};

  		}(),

  		// Removes inactive faces

  		reindexFaces: function () {
  			var this$1 = this;


  			var activeFaces = [];

  			for ( var i = 0; i < this.faces.length; i ++ ) {

  				var face = this$1.faces[ i ];

  				if ( face.mark === Visible ) {

  					activeFaces.push( face );

  				}

  			}

  			this.faces = activeFaces;

  			return this;

  		},

  		// Finds the next vertex to create faces with the current hull

  		nextVertexToAdd: function () {

  			// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'

  			if ( this.assigned.isEmpty() === false ) {

  				var eyeVertex, maxDistance = 0;

  				// grap the first available face and start with the first visible vertex of that face

  				var eyeFace = this.assigned.first().face;
  				var vertex = eyeFace.outside;

  				// now calculate the farthest vertex that face can see

  				do {

  					var distance = eyeFace.distanceToPoint( vertex.point );

  					if ( distance > maxDistance ) {

  						maxDistance = distance;
  						eyeVertex = vertex;

  					}

  					vertex = vertex.next;

  				} while ( vertex !== null && vertex.face === eyeFace );

  				return eyeVertex;

  			}

  		},

  		// Computes a chain of half edges in CCW order called the 'horizon'.
  		// For an edge to be part of the horizon it must join a face that can see
  		// 'eyePoint' and a face that cannot see 'eyePoint'.

  		computeHorizon: function ( eyePoint, crossEdge, face, horizon ) {
  			var this$1 = this;


  			// moves face's vertices to the 'unassigned' vertex list

  			this.deleteFaceVertices( face );

  			face.mark = Deleted;

  			var edge;

  			if ( crossEdge === null ) {

  				edge = crossEdge = face.getEdge( 0 );

  			} else {

  				// start from the next edge since 'crossEdge' was already analyzed
  				// (actually 'crossEdge.twin' was the edge who called this method recursively)

  				edge = crossEdge.next;

  			}

  			do {

  				var twinEdge = edge.twin;
  				var oppositeFace = twinEdge.face;

  				if ( oppositeFace.mark === Visible ) {

  					if ( oppositeFace.distanceToPoint( eyePoint ) > this$1.tolerance ) {

  						// the opposite face can see the vertex, so proceed with next edge

  						this$1.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );

  					} else {

  						// the opposite face can't see the vertex, so this edge is part of the horizon

  						horizon.push( edge );

  					}

  				}

  				edge = edge.next;

  			} while ( edge !== crossEdge );

  			return this;

  		},

  		// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order

  		addAdjoiningFace: function ( eyeVertex, horizonEdge ) {

  			// all the half edges are created in ccw order thus the face is always pointing outside the hull

  			var face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );

  			this.faces.push( face );

  			// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

  			face.getEdge( - 1 ).setTwin( horizonEdge.twin );

  			return face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex
  		},

  		//  Adds 'horizon.length' faces to the hull, each face will be linked with the
  		//  horizon opposite face and the face on the left/right

  		addNewFaces: function ( eyeVertex, horizon ) {
  			var this$1 = this;


  			this.newFaces = [];

  			var firstSideEdge = null;
  			var previousSideEdge = null;

  			for ( var i = 0; i < horizon.length; i ++ ) {

  				var horizonEdge = horizon[ i ];

  				// returns the right side edge

  				var sideEdge = this$1.addAdjoiningFace( eyeVertex, horizonEdge );

  				if ( firstSideEdge === null ) {

  					firstSideEdge = sideEdge;

  				} else {

  					// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )

  					sideEdge.next.setTwin( previousSideEdge );

  				}

  				this$1.newFaces.push( sideEdge.face );
  				previousSideEdge = sideEdge;

  			}

  			// perform final join of new faces

  			firstSideEdge.next.setTwin( previousSideEdge );

  			return this;

  		},

  		// Adds a vertex to the hull

  		addVertexToHull: function ( eyeVertex ) {

  			var horizon = [];

  			this.unassigned.clear();

  			// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

  			this.removeVertexFromFace( eyeVertex, eyeVertex.face );

  			this.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );

  			this.addNewFaces( eyeVertex, horizon );

  			// reassign 'unassigned' vertices to the new faces

  			this.resolveUnassignedPoints( this.newFaces );

  			return	this;

  		},

  		cleanup: function () {

  			this.assigned.clear();
  			this.unassigned.clear();
  			this.newFaces = [];

  			return this;

  		},

  		compute: function () {
  			var this$1 = this;


  			var vertex;

  			this.computeInitialHull();

  			// add all available vertices gradually to the hull

  			while ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {

  				this$1.addVertexToHull( vertex );

  			}

  			this.reindexFaces();

  			this.cleanup();

  			return this;

  		}

  	} );

  	//

  	function Face() {

  		this.normal = new Vector3();
  		this.midpoint = new Vector3();
  		this.area = 0;

  		this.constant = 0; // signed distance from face to the origin
  		this.outside = null; // reference to a vertex in a vertex list this face can see
  		this.mark = Visible;
  		this.edge = null;

  	}

  	Object.assign( Face, {

  		create: function ( a, b, c ) {

  			var face = new Face();

  			var e0 = new HalfEdge( a, face );
  			var e1 = new HalfEdge( b, face );
  			var e2 = new HalfEdge( c, face );

  			// join edges

  			e0.next = e2.prev = e1;
  			e1.next = e0.prev = e2;
  			e2.next = e1.prev = e0;

  			// main half edge reference

  			face.edge = e0;

  			return face.compute();

  		}

  	} );

  	Object.assign( Face.prototype, {

  		getEdge: function ( i ) {

  			var edge = this.edge;

  			while ( i > 0 ) {

  				edge = edge.next;
  				i --;

  			}

  			while ( i < 0 ) {

  				edge = edge.prev;
  				i ++;

  			}

  			return edge;

  		},

  		compute: function () {

  			var triangle;

  			return function compute() {

  				if ( triangle === undefined ) { triangle = new Triangle(); }

  				var a = this.edge.tail();
  				var b = this.edge.head();
  				var c = this.edge.next.head();

  				triangle.set( a.point, b.point, c.point );

  				triangle.getNormal( this.normal );
  				triangle.getMidpoint( this.midpoint );
  				this.area = triangle.getArea();

  				this.constant = this.normal.dot( this.midpoint );

  				return this;

  			};

  		}(),

  		distanceToPoint: function ( point ) {

  			return this.normal.dot( point ) - this.constant;

  		}

  	} );

  	// Entity for a Doubly-Connected Edge List (DCEL).

  	function HalfEdge( vertex, face ) {

  		this.vertex = vertex;
  		this.prev = null;
  		this.next = null;
  		this.twin = null;
  		this.face = face;

  	}

  	Object.assign( HalfEdge.prototype, {

  		head: function () {

  			return this.vertex;

  		},

  		tail: function () {

  			return this.prev ? this.prev.vertex : null;

  		},

  		length: function () {

  			var head = this.head();
  			var tail = this.tail();

  			if ( tail !== null ) {

  				return tail.point.distanceTo( head.point );

  			}

  			return - 1;

  		},

  		lengthSquared: function () {

  			var head = this.head();
  			var tail = this.tail();

  			if ( tail !== null ) {

  				return tail.point.distanceToSquared( head.point );

  			}

  			return - 1;

  		},

  		setTwin: function ( edge ) {

  			this.twin = edge;
  			edge.twin = this;

  			return this;

  		}

  	} );

  	// A vertex as a double linked list node.

  	function VertexNode( point ) {

  		this.point = point;
  		this.prev = null;
  		this.next = null;
  		this.face = null; // the face that is able to see this vertex

  	}

  	// A double linked list that contains vertex nodes.

  	function VertexList() {

  		this.head = null;
  		this.tail = null;

  	}

  	Object.assign( VertexList.prototype, {

  		first: function () {

  			return this.head;

  		},

  		last: function () {

  			return this.tail;

  		},

  		clear: function () {

  			this.head = this.tail = null;

  			return this;

  		},

  		// Inserts a vertex before the target vertex

  		insertBefore: function ( target, vertex ) {

  			vertex.prev = target.prev;
  			vertex.next = target;

  			if ( vertex.prev === null ) {

  				this.head = vertex;

  			} else {

  				vertex.prev.next = vertex;

  			}

  			target.prev = vertex;

  			return this;

  		},

  		// Inserts a vertex after the target vertex

  		insertAfter: function ( target, vertex ) {

  			vertex.prev = target;
  			vertex.next = target.next;

  			if ( vertex.next === null ) {

  				this.tail = vertex;

  			} else {

  				vertex.next.prev = vertex;

  			}

  			target.next = vertex;

  			return this;

  		},

  		// Appends a vertex to the end of the linked list

  		append: function ( vertex ) {

  			if ( this.head === null ) {

  				this.head = vertex;

  			} else {

  				this.tail.next = vertex;

  			}

  			vertex.prev = this.tail;
  			vertex.next = null; // the tail has no subsequent vertex

  			this.tail = vertex;

  			return this;

  		},

  		// Appends a chain of vertices where 'vertex' is the head.

  		appendChain: function ( vertex ) {

  			if ( this.head === null ) {

  				this.head = vertex;

  			} else {

  				this.tail.next = vertex;

  			}

  			vertex.prev = this.tail;

  			// ensure that the 'tail' reference points to the last vertex of the chain

  			while ( vertex.next !== null ) {

  				vertex = vertex.next;

  			}

  			this.tail = vertex;

  			return this;

  		},

  		// Removes a vertex from the linked list

  		remove: function ( vertex ) {

  			if ( vertex.prev === null ) {

  				this.head = vertex.next;

  			} else {

  				vertex.prev.next = vertex.next;

  			}

  			if ( vertex.next === null ) {

  				this.tail = vertex.prev;

  			} else {

  				vertex.next.prev = vertex.prev;

  			}

  			return this;

  		},

  		// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b

  		removeSubList: function ( a, b ) {

  			if ( a.prev === null ) {

  				this.head = b.next;

  			} else {

  				a.prev.next = b.next;

  			}

  			if ( b.next === null ) {

  				this.tail = a.prev;

  			} else {

  				b.next.prev = a.prev;

  			}

  			return this;

  		},

  		isEmpty: function () {

  			return this.head === null;

  		}

  	} );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	// ConvexGeometry

  	function ConvexGeometry( points ) {

  		Geometry.call( this );

  		this.fromBufferGeometry( new ConvexBufferGeometry( points ) );
  		this.mergeVertices();

  	}

  	ConvexGeometry.prototype = Object.create( Geometry.prototype );
  	ConvexGeometry.prototype.constructor = ConvexGeometry;

  	// ConvexBufferGeometry

  	function ConvexBufferGeometry( points ) {

  		BufferGeometry.call( this );

  		// buffers

  		var vertices = [];
  		var normals = [];

  		// execute QuickHull

  		if ( QuickHull === undefined ) {

  			console.error( 'ConvexBufferGeometry: ConvexBufferGeometry relies on QuickHull' );

  		}

  		var quickHull = new QuickHull().setFromPoints( points );

  		// generate vertices and normals

  		var faces = quickHull.faces;

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];
  			var edge = face.edge;

  			// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

  			do {

  				var point = edge.head().point;

  				vertices.push( point.x, point.y, point.z );
  				normals.push( face.normal.x, face.normal.y, face.normal.z );

  				edge = edge.next;

  			} while ( edge !== face.edge );

  		}

  		// build geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  	}

  	ConvexBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	ConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ConvexObjectBreaker = function ( minSizeForBreak, smallDelta ) {
  	var this$1 = this;


  	this.minSizeForBreak = minSizeForBreak || 1.4;
  	this.smallDelta = smallDelta || 0.0001;

  	this.tempLine1 = new Line3();
  	this.tempPlane1 = new Plane();
  	this.tempPlane2 = new Plane();
  	this.tempPlane_Cut = new Plane();
  	this.tempCM1 = new Vector3();
  	this.tempCM2 = new Vector3();
  	this.tempVector3 = new Vector3();
  	this.tempVector3_2 = new Vector3();
  	this.tempVector3_3 = new Vector3();
  	this.tempVector3_P0 = new Vector3();
  	this.tempVector3_P1 = new Vector3();
  	this.tempVector3_P2 = new Vector3();
  	this.tempVector3_N0 = new Vector3();
  	this.tempVector3_N1 = new Vector3();
  	this.tempVector3_AB = new Vector3();
  	this.tempVector3_CB = new Vector3();
  	this.tempResultObjects = { object1: null, object2: null };

  	this.segments = [];
  	var n = 30 * 30;
  	for ( var i = 0; i < n; i ++ ) { this$1.segments[ i ] = false; }

  };

  ConvexObjectBreaker.prototype = {

  	constructor: ConvexObjectBreaker,

  	prepareBreakableObject: function ( object, mass, velocity, angularVelocity, breakable ) {

  		// object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.
  		// Its material property is propagated to its children (sub-pieces)
  		// mass must be > 0

  		if ( ! object.geometry.isBufferGeometry ) {

  			console.error( 'ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.' );

  		}

  		var userData = object.userData;
  		userData.mass = mass;
  		userData.velocity = velocity.clone();
  		userData.angularVelocity = angularVelocity.clone();
  		userData.breakable = breakable;

  	},
  	subdivideByImpact: function ( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {

  		var debris = [];

  		var tempPlane1 = this.tempPlane1;
  		var tempPlane2 = this.tempPlane2;

  		this.tempVector3.addVectors( pointOfImpact, normal );
  		tempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );

  		var maxTotalIterations = maxRandomIterations + maxRadialIterations;

  		var scope = this;

  		function subdivideRadial( subObject, startAngle, endAngle, numIterations ) {

  			if ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {

  				debris.push( subObject );

  				return;

  			}

  			var angle = Math.PI;

  			if ( numIterations === 0 ) {

  				tempPlane2.normal.copy( tempPlane1.normal );
  				tempPlane2.constant = tempPlane1.constant;

  			} else {

  				if ( numIterations <= maxRadialIterations ) {

  					angle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;

  					// Rotate tempPlane2 at impact point around normal axis and the angle
  					scope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );
  					tempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );

  				} else {

  					angle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;

  					// Rotate tempPlane2 at object position around normal axis and the angle
  					scope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );
  					scope.tempVector3_3.copy( normal ).add( subObject.position );
  					tempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );

  				}

  			}

  			// Perform the cut
  			scope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );

  			var obj1 = scope.tempResultObjects.object1;
  			var obj2 = scope.tempResultObjects.object2;

  			if ( obj1 ) {

  				subdivideRadial( obj1, startAngle, angle, numIterations + 1 );

  			}

  			if ( obj2 ) {

  				subdivideRadial( obj2, angle, endAngle, numIterations + 1 );

  			}

  		}

  		subdivideRadial( object, 0, 2 * Math.PI, 0 );

  		return debris;

  	},

  	cutByPlane: function ( object, plane, output ) {
  		var this$1 = this;


  		// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.
  		// object2 can be null if the plane doesn't cut the object.
  		// object1 can be null only in case of internal error
  		// Returned value is number of pieces, 0 for error.

  		var geometry = object.geometry;
  		var coords = geometry.attributes.position.array;
  		var normals = geometry.attributes.normal.array;

  		var numPoints = coords.length / 3;
  		var numFaces = numPoints / 3;

  		var indices = geometry.getIndex();

  		if ( indices ) {

  			indices = indices.array;
  			numFaces = indices.length / 3;

  		}

  		function getVertexIndex( faceIdx, vert ) {

  			// vert = 0, 1 or 2.

  			var idx = faceIdx * 3 + vert;

  			return indices ? indices[ idx ] : idx;

  		}

  		var points1 = [];
  		var points2 = [];

  		var delta = this.smallDelta;

  		// Reset segments mark
  		var numPointPairs = numPoints * numPoints;
  		for ( var i = 0; i < numPointPairs; i ++ ) { this$1.segments[ i ] = false; }

  		var p0 = this.tempVector3_P0;
  		var p1 = this.tempVector3_P1;
  		var n0 = this.tempVector3_N0;
  		var n1 = this.tempVector3_N1;

  		// Iterate through the faces to mark edges shared by coplanar faces
  		for ( var i = 0; i < numFaces - 1; i ++ ) {

  			var a1 = getVertexIndex( i, 0 );
  			var b1 = getVertexIndex( i, 1 );
  			var c1 = getVertexIndex( i, 2 );

  			// Assuming all 3 vertices have the same normal
  			n0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );

  			for ( var j = i + 1; j < numFaces; j ++ ) {

  				var a2 = getVertexIndex( j, 0 );
  				var b2 = getVertexIndex( j, 1 );
  				var c2 = getVertexIndex( j, 2 );

  				// Assuming all 3 vertices have the same normal
  				n1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );

  				var coplanar = 1 - n0.dot( n1 ) < delta;

  				if ( coplanar ) {

  					if ( a1 === a2 || a1 === b2 || a1 === c2 ) {

  						if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

  							this$1.segments[ a1 * numPoints + b1 ] = true;
  							this$1.segments[ b1 * numPoints + a1 ] = true;

  						}	else {

  							this$1.segments[ c1 * numPoints + a1 ] = true;
  							this$1.segments[ a1 * numPoints + c1 ] = true;

  						}

  					}	else if ( b1 === a2 || b1 === b2 || b1 === c2 ) {

  						this$1.segments[ c1 * numPoints + b1 ] = true;
  						this$1.segments[ b1 * numPoints + c1 ] = true;

  					}

  				}

  			}

  		}

  		// Transform the plane to object local space
  		var localPlane = this.tempPlane_Cut;
  		object.updateMatrix();
  		ConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );

  		// Iterate through the faces adding points to both pieces
  		for ( var i = 0; i < numFaces; i ++ ) {

  			var va = getVertexIndex( i, 0 );
  			var vb = getVertexIndex( i, 1 );
  			var vc = getVertexIndex( i, 2 );

  			for ( var segment = 0; segment < 3; segment ++ ) {

  				var i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );
  				var i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );

  				var segmentState = this$1.segments[ i0 * numPoints + i1 ];

  				if ( segmentState ) { continue; } // The segment already has been processed in another face

  				// Mark segment as processed (also inverted segment)
  				this$1.segments[ i0 * numPoints + i1 ] = true;
  				this$1.segments[ i1 * numPoints + i0 ] = true;

  				p0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );
  				p1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );

  				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
  				var mark0 = 0;

  				var d = localPlane.distanceToPoint( p0 );

  				if ( d > delta ) {

  					mark0 = 2;
  					points2.push( p0.clone() );

  				} else if ( d < - delta ) {

  					mark0 = 1;
  					points1.push( p0.clone() );

  				} else {

  					mark0 = 3;
  					points1.push( p0.clone() );
  					points2.push( p0.clone() );

  				}

  				// mark: 1 for negative side, 2 for positive side, 3 for coplanar point
  				var mark1 = 0;

  				var d = localPlane.distanceToPoint( p1 );

  				if ( d > delta ) {

  					mark1 = 2;
  					points2.push( p1.clone() );

  				} else if ( d < - delta ) {

  					mark1 = 1;
  					points1.push( p1.clone() );

  				}	else {

  					mark1 = 3;
  					points1.push( p1.clone() );
  					points2.push( p1.clone() );

  				}

  				if ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {

  					// Intersection of segment with the plane

  					this$1.tempLine1.start.copy( p0 );
  					this$1.tempLine1.end.copy( p1 );

  					var intersection = new Vector3();
  					intersection = localPlane.intersectLine( this$1.tempLine1, intersection );

  					if ( intersection === undefined ) {

  						// Shouldn't happen
  						console.error( "Internal error: segment does not intersect plane." );
  						output.segmentedObject1 = null;
  						output.segmentedObject2 = null;
  						return 0;

  					}

  					points1.push( intersection );
  					points2.push( intersection.clone() );

  				}

  			}

  		}

  		// Calculate debris mass (very fast and imprecise):
  		var newMass = object.userData.mass * 0.5;

  		// Calculate debris Center of Mass (again fast and imprecise)
  		this.tempCM1.set( 0, 0, 0 );
  		var radius1 = 0;
  		var numPoints1 = points1.length;

  		if ( numPoints1 > 0 ) {

  			for ( var i = 0; i < numPoints1; i ++ ) { this$1.tempCM1.add( points1[ i ] ); }

  			this.tempCM1.divideScalar( numPoints1 );
  			for ( var i = 0; i < numPoints1; i ++ ) {

  				var p = points1[ i ];
  				p.sub( this$1.tempCM1 );
  				radius1 = Math.max( radius1, p.x, p.y, p.z );

  			}
  			this.tempCM1.add( object.position );

  		}

  		this.tempCM2.set( 0, 0, 0 );
  		var radius2 = 0;
  		var numPoints2 = points2.length;
  		if ( numPoints2 > 0 ) {

  			for ( var i = 0; i < numPoints2; i ++ ) { this$1.tempCM2.add( points2[ i ] ); }

  			this.tempCM2.divideScalar( numPoints2 );
  			for ( var i = 0; i < numPoints2; i ++ ) {

  				var p = points2[ i ];
  				p.sub( this$1.tempCM2 );
  				radius2 = Math.max( radius2, p.x, p.y, p.z );

  			}
  			this.tempCM2.add( object.position );

  		}

  		var object1 = null;
  		var object2 = null;

  		var numObjects = 0;

  		if ( numPoints1 > 4 ) {

  			object1 = new Mesh( new ConvexBufferGeometry( points1 ), object.material );
  			object1.position.copy( this.tempCM1 );
  			object1.quaternion.copy( object.quaternion );

  			this.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );

  			numObjects ++;

  		}

  		if ( numPoints2 > 4 ) {

  			object2 = new Mesh( new ConvexBufferGeometry( points2 ), object.material );
  			object2.position.copy( this.tempCM2 );
  			object2.quaternion.copy( object.quaternion );

  			this.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );

  			numObjects ++;

  		}

  		output.object1 = object1;
  		output.object2 = object2;

  		return numObjects;

  	}

  };

  ConvexObjectBreaker.transformFreeVector = function ( v, m ) {

  	// input:
  	// vector interpreted as a free vector
  	// Matrix4 orthogonal matrix (matrix without scale)

  	var x = v.x, y = v.y, z = v.z;
  	var e = m.elements;

  	v.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  	v.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  	v.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  	return v;

  };

  ConvexObjectBreaker.transformFreeVectorInverse = function ( v, m ) {

  	// input:
  	// vector interpreted as a free vector
  	// Matrix4 orthogonal matrix (matrix without scale)

  	var x = v.x, y = v.y, z = v.z;
  	var e = m.elements;

  	v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;
  	v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;
  	v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;

  	return v;

  };

  ConvexObjectBreaker.transformTiedVectorInverse = function ( v, m ) {

  	// input:
  	// vector interpreted as a tied (ordinary) vector
  	// Matrix4 orthogonal matrix (matrix without scale)

  	var x = v.x, y = v.y, z = v.z;
  	var e = m.elements;

  	v.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];
  	v.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];
  	v.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];

  	return v;

  };

  ConvexObjectBreaker.transformPlaneToLocalSpace = function () {

  	var v1 = new Vector3();

  	return function transformPlaneToLocalSpace( plane, m, resultPlane ) {

  		resultPlane.normal.copy( plane.normal );
  		resultPlane.constant = plane.constant;

  		var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( v1 ), m );

  		ConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );

  		// recalculate constant (like in setFromNormalAndCoplanarPoint)
  		resultPlane.constant = - referencePoint.dot( resultPlane.normal );
  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Curve() {

  	this.type = 'Curve';

  	this.arcLengthDivisions = 200;

  }

  Object.assign( Curve.prototype, {

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint: function (  ) {

  		console.warn( 'Curve: .getPoint() not implemented.' );
  		return null;

  	},

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt: function ( u, optionalTarget ) {

  		var t = this.getUtoTmapping( u );
  		return this.getPoint( t, optionalTarget );

  	},

  	// Get sequence of points using getPoint( t )

  	getPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPoint( d / divisions ) );

  		}

  		return points;

  	},

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPointAt( d / divisions ) );

  		}

  		return points;

  	},

  	// Get total curve arc length

  	getLength: function () {

  		var lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	},

  	// Get list of cumulative segment lengths

  	getLengths: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = this.arcLengthDivisions; }

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		var cache = [];
  		var current, last = this.getPoint( 0 );
  		var p, sum = 0;

  		cache.push( 0 );

  		for ( p = 1; p <= divisions; p ++ ) {

  			current = this$1.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	},

  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.getLengths();

  	},

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping: function ( u, distance ) {

  		var arcLengths = this.getLengths();

  		var i = 0, il = arcLengths.length;

  		var targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		var low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		var lengthBefore = arcLengths[ i ];
  		var lengthAfter = arcLengths[ i + 1 ];

  		var segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		var t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	},

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent: function ( t ) {

  		var delta = 0.0001;
  		var t1 = t - delta;
  		var t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) { t1 = 0; }
  		if ( t2 > 1 ) { t2 = 1; }

  		var pt1 = this.getPoint( t1 );
  		var pt2 = this.getPoint( t2 );

  		var vec = pt2.clone().sub( pt1 );
  		return vec.normalize();

  	},

  	getTangentAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getTangent( t );

  	},

  	computeFrenetFrames: function ( segments, closed ) {
  		var this$1 = this;


  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		var normal = new Vector3();

  		var tangents = [];
  		var normals = [];
  		var binormals = [];

  		var vec = new Vector3();
  		var mat = new Matrix4();

  		var i, u, theta;

  		// compute the tangent vectors for each segment on the curve

  		for ( i = 0; i <= segments; i ++ ) {

  			u = i / segments;

  			tangents[ i ] = this$1.getTangentAt( u );
  			tangents[ i ].normalize();

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3();
  		binormals[ 0 ] = new Vector3();
  		var min = Number.MAX_VALUE;
  		var tx = Math.abs( tangents[ 0 ].x );
  		var ty = Math.abs( tangents[ 0 ].y );
  		var tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.arcLengthDivisions = source.arcLengthDivisions;

  		return this;

  	},

  	toJSON: function () {

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Curve',
  				generator: 'Curve.toJSON'
  			}
  		};

  		data.arcLengthDivisions = this.arcLengthDivisions;
  		data.type = this.type;

  		return data;

  	},

  	fromJSON: function ( json ) {

  		this.arcLengthDivisions = json.arcLengthDivisions;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	// GrannyKnot

  	function GrannyKnot() {

  		Curve.call( this );

  	}

  	GrannyKnot.prototype = Object.create( Curve.prototype );
  	GrannyKnot.prototype.constructor = GrannyKnot;

  	GrannyKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t = 2 * Math.PI * t;

  		var x = - 0.22 * Math.cos( t ) - 1.28 * Math.sin( t ) - 0.44 * Math.cos( 3 * t ) - 0.78 * Math.sin( 3 * t );
  		var y = - 0.1 * Math.cos( 2 * t ) - 0.27 * Math.sin( 2 * t ) + 0.38 * Math.cos( 4 * t ) + 0.46 * Math.sin( 4 * t );
  		var z = 0.7 * Math.cos( 3 * t ) - 0.4 * Math.sin( 3 * t );

  		return point.set( x, y, z ).multiplyScalar( 20 );

  	};

  	// HeartCurve

  	function HeartCurve( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 5 : scale;

  	}

  	HeartCurve.prototype = Object.create( Curve.prototype );
  	HeartCurve.prototype.constructor = HeartCurve;

  	HeartCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t *= 2 * Math.PI;

  		var x = 16 * Math.pow( Math.sin( t ), 3 );
  		var y = 13 * Math.cos( t ) - 5 * Math.cos( 2 * t ) - 2 * Math.cos( 3 * t ) - Math.cos( 4 * t );
  		var z = 0;

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// Viviani's Curve

  	function VivianiCurve( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 70 : scale;

  	}

  	VivianiCurve.prototype = Object.create( Curve.prototype );
  	VivianiCurve.prototype.constructor = VivianiCurve;

  	VivianiCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t = t * 4 * Math.PI; // normalized to 0..1
  		var a = this.scale / 2;

  		var x = a * ( 1 + Math.cos( t ) );
  		var y = a * Math.sin( t );
  		var z = 2 * a * Math.sin( t / 2 );

  		return point.set( x, y, z );

  	};

  	// KnotCurve

  	function KnotCurve() {

  		Curve.call( this );

  	}

  	KnotCurve.prototype = Object.create( Curve.prototype );
  	KnotCurve.prototype.constructor = KnotCurve;

  	KnotCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t *= 2 * Math.PI;

  		var R = 10;
  		var s = 50;

  		var x = s * Math.sin( t );
  		var y = Math.cos( t ) * ( R + s * Math.cos( t ) );
  		var z = Math.sin( t ) * ( R + s * Math.cos( t ) );

  		return point.set( x, y, z );

  	};

  	// HelixCurve

  	function HelixCurve() {

  		Curve.call( this );

  	}

  	HelixCurve.prototype = Object.create( Curve.prototype );
  	HelixCurve.prototype.constructor = HelixCurve;

  	HelixCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var a = 30; // radius
  		var b = 150; // height

  		var t2 = 2 * Math.PI * t * b / 30;

  		var x = Math.cos( t2 ) * a;
  		var y = Math.sin( t2 ) * a;
  		var z = b * t;

  		return point.set( x, y, z );

  	};

  	// TrefoilKnot

  	function TrefoilKnot( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 10 : scale;

  	}

  	TrefoilKnot.prototype = Object.create( Curve.prototype );
  	TrefoilKnot.prototype.constructor = TrefoilKnot;

  	TrefoilKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t *= Math.PI * 2;

  		var x = ( 2 + Math.cos( 3 * t ) ) * Math.cos( 2 * t );
  		var y = ( 2 + Math.cos( 3 * t ) ) * Math.sin( 2 * t );
  		var z = Math.sin( 3 * t );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// TorusKnot

  	function TorusKnot( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 10 : scale;

  	}

  	TorusKnot.prototype = Object.create( Curve.prototype );
  	TorusKnot.prototype.constructor = TorusKnot;

  	TorusKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var p = 3;
  		var q = 4;

  		t *= Math.PI * 2;

  		var x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );
  		var y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );
  		var z = Math.sin( q * t );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// CinquefoilKnot

  	function CinquefoilKnot( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 10 : scale;

  	}

  	CinquefoilKnot.prototype = Object.create( Curve.prototype );
  	CinquefoilKnot.prototype.constructor = CinquefoilKnot;

  	CinquefoilKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var p = 2;
  		var q = 5;

  		t *= Math.PI * 2;

  		var x = ( 2 + Math.cos( q * t ) ) * Math.cos( p * t );
  		var y = ( 2 + Math.cos( q * t ) ) * Math.sin( p * t );
  		var z = Math.sin( q * t );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// TrefoilPolynomialKnot

  	function TrefoilPolynomialKnot( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 10 : scale;

  	}

  	TrefoilPolynomialKnot.prototype = Object.create( Curve.prototype );
  	TrefoilPolynomialKnot.prototype.constructor = TrefoilPolynomialKnot;

  	TrefoilPolynomialKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t = t * 4 - 2;

  		var x = Math.pow( t, 3 ) - 3 * t;
  		var y = Math.pow( t, 4 ) - 4 * t * t;
  		var z = 1 / 5 * Math.pow( t, 5 ) - 2 * t;

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	var scaleTo = function ( x, y, t ) {

  		var r = y - x;
  		return t * r + x;

  	};

  	// FigureEightPolynomialKnot

  	function FigureEightPolynomialKnot( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 1 : scale;

  	}

  	FigureEightPolynomialKnot.prototype = Object.create( Curve.prototype );
  	FigureEightPolynomialKnot.prototype.constructor = FigureEightPolynomialKnot;

  	FigureEightPolynomialKnot.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t = scaleTo( - 4, 4, t );

  		var x = 2 / 5 * t * ( t * t - 7 ) * ( t * t - 10 );
  		var y = Math.pow( t, 4 ) - 13 * t * t;
  		var z = 1 / 10 * t * ( t * t - 4 ) * ( t * t - 9 ) * ( t * t - 12 );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// DecoratedTorusKnot4a

  	function DecoratedTorusKnot4a( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 40 : scale;

  	}

  	DecoratedTorusKnot4a.prototype = Object.create( Curve.prototype );
  	DecoratedTorusKnot4a.prototype.constructor = DecoratedTorusKnot4a;

  	DecoratedTorusKnot4a.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		t *= Math.PI * 2;

  		var x = Math.cos( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );
  		var y = Math.sin( 2 * t ) * ( 1 + 0.6 * ( Math.cos( 5 * t ) + 0.75 * Math.cos( 10 * t ) ) );
  		var z = 0.35 * Math.sin( 5 * t );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// DecoratedTorusKnot4b

  	function DecoratedTorusKnot4b( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 40 : scale;

  	}

  	DecoratedTorusKnot4b.prototype = Object.create( Curve.prototype );
  	DecoratedTorusKnot4b.prototype.constructor = DecoratedTorusKnot4b;

  	DecoratedTorusKnot4b.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var fi = t * Math.PI * 2;

  		var x = Math.cos( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );
  		var y = Math.sin( 2 * fi ) * ( 1 + 0.45 * Math.cos( 3 * fi ) + 0.4 * Math.cos( 9 * fi ) );
  		var z = 0.2 * Math.sin( 9 * fi );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// DecoratedTorusKnot5a

  	function DecoratedTorusKnot5a( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 40 : scale;

  	}

  	DecoratedTorusKnot5a.prototype = Object.create( Curve.prototype );
  	DecoratedTorusKnot5a.prototype.constructor = DecoratedTorusKnot5a;

  	DecoratedTorusKnot5a.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var fi = t * Math.PI * 2;

  		var x = Math.cos( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );
  		var y = Math.sin( 3 * fi ) * ( 1 + 0.3 * Math.cos( 5 * fi ) + 0.5 * Math.cos( 10 * fi ) );
  		var z = 0.2 * Math.sin( 20 * fi );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  	// DecoratedTorusKnot5c

  	function DecoratedTorusKnot5c( scale ) {

  		Curve.call( this );

  		this.scale = ( scale === undefined ) ? 40 : scale;

  	}

  	DecoratedTorusKnot5c.prototype = Object.create( Curve.prototype );
  	DecoratedTorusKnot5c.prototype.constructor = DecoratedTorusKnot5c;

  	DecoratedTorusKnot5c.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var fi = t * Math.PI * 2;

  		var x = Math.cos( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );
  		var y = Math.sin( 4 * fi ) * ( 1 + 0.5 * ( Math.cos( 5 * fi ) + 0.4 * Math.cos( 20 * fi ) ) );
  		var z = 0.35 * Math.sin( 15 * fi );

  		return point.set( x, y, z ).multiplyScalar( this.scale );

  	};

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NURBSUtils = {
  	findSpan: function( p,  u,  U ) {

  		var n = U.length - p - 1;

  		if ( u >= U[ n ] ) {

  			return n - 1;

  		}

  		if ( u <= U[ p ] ) {

  			return p;

  		}

  		var low = p;
  		var high = n;
  		var mid = Math.floor( ( low + high ) / 2 );

  		while ( u < U[ mid ] || u >= U[ mid + 1 ] ) {

  			if ( u < U[ mid ] ) {

  				high = mid;

  			} else {

  				low = mid;

  			}

  			mid = Math.floor( ( low + high ) / 2 );

  		}

  		return mid;

  	},
  	calcBasisFunctions: function( span, u, p, U ) {

  		var N = [];
  		var left = [];
  		var right = [];
  		N[ 0 ] = 1.0;

  		for ( var j = 1; j <= p; ++ j ) {

  			left[ j ] = u - U[ span + 1 - j ];
  			right[ j ] = U[ span + j ] - u;

  			var saved = 0.0;

  			for ( var r = 0; r < j; ++ r ) {

  				var rv = right[ r + 1 ];
  				var lv = left[ j - r ];
  				var temp = N[ r ] / ( rv + lv );
  				N[ r ] = saved + rv * temp;
  				saved = lv * temp;

  			 }

  			 N[ j ] = saved;

  		 }

  		 return N;

  	},
  	calcBSplinePoint: function( p, U, P, u ) {

  		var span = this.findSpan( p, u, U );
  		var N = this.calcBasisFunctions( span, u, p, U );
  		var C = new Vector4( 0, 0, 0, 0 );

  		for ( var j = 0; j <= p; ++ j ) {

  			var point = P[ span - p + j ];
  			var Nj = N[ j ];
  			var wNj = point.w * Nj;
  			C.x += point.x * wNj;
  			C.y += point.y * wNj;
  			C.z += point.z * wNj;
  			C.w += point.w * Nj;

  		}

  		return C;

  	},
  	calcBasisFunctionDerivatives: function( span,  u,  p,  n,  U ) {

  		var zeroArr = [];
  		for ( var i = 0; i <= p; ++ i )
  			{ zeroArr[ i ] = 0.0; }

  		var ders = [];
  		for ( var i = 0; i <= n; ++ i )
  			{ ders[ i ] = zeroArr.slice( 0 ); }

  		var ndu = [];
  		for ( var i = 0; i <= p; ++ i )
  			{ ndu[ i ] = zeroArr.slice( 0 ); }

  		ndu[ 0 ][ 0 ] = 1.0;

  		var left = zeroArr.slice( 0 );
  		var right = zeroArr.slice( 0 );

  		for ( var j = 1; j <= p; ++ j ) {

  			left[ j ] = u - U[ span + 1 - j ];
  			right[ j ] = U[ span + j ] - u;

  			var saved = 0.0;

  			for ( var r = 0; r < j; ++ r ) {

  				var rv = right[ r + 1 ];
  				var lv = left[ j - r ];
  				ndu[ j ][ r ] = rv + lv;

  				var temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];
  				ndu[ r ][ j ] = saved + rv * temp;
  				saved = lv * temp;

  			}

  			ndu[ j ][ j ] = saved;

  		}

  		for ( var j = 0; j <= p; ++ j ) {

  			ders[ 0 ][ j ] = ndu[ j ][ p ];

  		}

  		for ( var r = 0; r <= p; ++ r ) {

  			var s1 = 0;
  			var s2 = 1;

  			var a = [];
  			for ( var i = 0; i <= p; ++ i ) {

  				a[ i ] = zeroArr.slice( 0 );

  			}
  			a[ 0 ][ 0 ] = 1.0;

  			for ( var k = 1; k <= n; ++ k ) {

  				var d = 0.0;
  				var rk = r - k;
  				var pk = p - k;

  				if ( r >= k ) {

  					a[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];
  					d = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];

  				}

  				var j1 = ( rk >= - 1 ) ? 1 : - rk;
  				var j2 = ( r - 1 <= pk ) ? k - 1 :  p - r;

  				for ( var j = j1; j <= j2; ++ j ) {

  					a[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];
  					d += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];

  				}

  				if ( r <= pk ) {

  					a[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];
  					d += a[ s2 ][ k ] * ndu[ r ][ pk ];

  				}

  				ders[ k ][ r ] = d;

  				var j = s1;
  				s1 = s2;
  				s2 = j;

  			}

  		}

  		var r = p;

  		for ( var k = 1; k <= n; ++ k ) {

  			for ( var j = 0; j <= p; ++ j ) {

  				ders[ k ][ j ] *= r;

  			}
  			r *= p - k;

  		}

  		return ders;

  	},
  	calcBSplineDerivatives: function( p,  U,  P,  u,  nd ) {

  		var du = nd < p ? nd : p;
  		var CK = [];
  		var span = this.findSpan( p, u, U );
  		var nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );
  		var Pw = [];

  		for ( var i = 0; i < P.length; ++ i ) {

  			var point = P[ i ].clone();
  			var w = point.w;

  			point.x *= w;
  			point.y *= w;
  			point.z *= w;

  			Pw[ i ] = point;

  		}
  		for ( var k = 0; k <= du; ++ k ) {

  			var point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );

  			for ( var j = 1; j <= p; ++ j ) {

  				point.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );

  			}

  			CK[ k ] = point;

  		}

  		for ( var k = du + 1; k <= nd + 1; ++ k ) {

  			CK[ k ] = new Vector4( 0, 0, 0 );

  		}

  		return CK;

  	},
  	calcKoverI: function( k, i ) {

  		var nom = 1;

  		for ( var j = 2; j <= k; ++ j ) {

  			nom *= j;

  		}

  		var denom = 1;

  		for ( var j = 2; j <= i; ++ j ) {

  			denom *= j;

  		}

  		for ( var j = 2; j <= k - i; ++ j ) {

  			denom *= j;

  		}

  		return nom / denom;

  	},
  	calcRationalCurveDerivatives: function ( Pders ) {
  		var this$1 = this;


  		var nd = Pders.length;
  		var Aders = [];
  		var wders = [];

  		for ( var i = 0; i < nd; ++ i ) {

  			var point = Pders[ i ];
  			Aders[ i ] = new Vector3( point.x, point.y, point.z );
  			wders[ i ] = point.w;

  		}

  		var CK = [];

  		for ( var k = 0; k < nd; ++ k ) {

  			var v = Aders[ k ].clone();

  			for ( var i = 1; i <= k; ++ i ) {

  				v.sub( CK[ k - i ].clone().multiplyScalar( this$1.calcKoverI( k, i ) * wders[ i ] ) );

  			}

  			CK[ k ] = v.divideScalar( wders[ 0 ] );

  		}

  		return CK;

  	},
  	calcNURBSDerivatives: function( p,  U,  P,  u,  nd ) {

  		var Pders = this.calcBSplineDerivatives( p, U, P, u, nd );
  		return this.calcRationalCurveDerivatives( Pders );

  	},
  	calcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {

  		var uspan = this.findSpan( p, u, U );
  		var vspan = this.findSpan( q, v, V );
  		var Nu = this.calcBasisFunctions( uspan, u, p, U );
  		var Nv = this.calcBasisFunctions( vspan, v, q, V );
  		var temp = [];

  		for ( var l = 0; l <= q; ++ l ) {

  			temp[ l ] = new Vector4( 0, 0, 0, 0 );
  			for ( var k = 0; k <= p; ++ k ) {

  				var point = P[ uspan - p + k ][ vspan - q + l ].clone();
  				var w = point.w;
  				point.x *= w;
  				point.y *= w;
  				point.z *= w;
  				temp[ l ].add( point.multiplyScalar( Nu[ k ] ) );

  			}

  		}

  		var Sw = new Vector4( 0, 0, 0, 0 );
  		for ( var l = 0; l <= q; ++ l ) {

  			Sw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );

  		}

  		Sw.divideScalar( Sw.w );
  		target.set( Sw.x, Sw.y, Sw.z );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NURBSCurve = function ( degree, knots , controlPoints , startKnot , endKnot  ) {
  	var this$1 = this;


  	Curve.call( this );

  	this.degree = degree;
  	this.knots = knots;
  	this.controlPoints = [];
  	// Used by periodic NURBS to remove hidden spans
  	this.startKnot = startKnot || 0;
  	this.endKnot = endKnot || ( this.knots.length - 1 );
  	for ( var i = 0; i < controlPoints.length; ++ i ) {

  		// ensure Vector4 for control points
  		var point = controlPoints[ i ];
  		this$1.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );

  	}

  };
  NURBSCurve.prototype = Object.create( Curve.prototype );
  NURBSCurve.prototype.constructor = NURBSCurve;
  NURBSCurve.prototype.getPoint = function ( t ) {

  	var u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u

  	// following results in (wx, wy, wz, w) homogeneous point
  	var hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );

  	if ( hpoint.w != 1.0 ) {

  		// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
  		hpoint.divideScalar( hpoint.w );

  	}

  	return new Vector3( hpoint.x, hpoint.y, hpoint.z );

  };
  NURBSCurve.prototype.getTangent = function ( t ) {

  	var u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );
  	var ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );
  	var tangent = ders[ 1 ].clone();
  	tangent.normalize();

  	return tangent;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NURBSSurface = function ( degree1, degree2, knots1, knots2 , controlPoints  ) {
  	var this$1 = this;


  	this.degree1 = degree1;
  	this.degree2 = degree2;
  	this.knots1 = knots1;
  	this.knots2 = knots2;
  	this.controlPoints = [];

  	var len1 = knots1.length - degree1 - 1;
  	var len2 = knots2.length - degree2 - 1;

  	// ensure Vector4 for control points
  	for ( var i = 0; i < len1; ++ i ) {

  		this$1.controlPoints[ i ] = [];
  		for ( var j = 0; j < len2; ++ j ) {

  			var point = controlPoints[ i ][ j ];
  			this$1.controlPoints[ i ][ j ] = new Vector4( point.x, point.y, point.z, point.w );

  		}

  	}

  };
  NURBSSurface.prototype = {

  	constructor: NURBSSurface,

  	getPoint: function ( t1, t2, target ) {

  		var u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u
  		var v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u

  		NURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );

  	}
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function StereoCamera() {

  	this.type = 'StereoCamera';

  	this.aspect = 1;

  	this.eyeSep = 0.064;

  	this.cameraL = new PerspectiveCamera();
  	this.cameraL.layers.enable( 1 );
  	this.cameraL.matrixAutoUpdate = false;

  	this.cameraR = new PerspectiveCamera();
  	this.cameraR.layers.enable( 2 );
  	this.cameraR.matrixAutoUpdate = false;

  }

  Object.assign( StereoCamera.prototype, {

  	update: ( function () {

  		var instance, focus, fov, aspect, near, far, zoom, eyeSep;

  		var eyeRight = new Matrix4();
  		var eyeLeft = new Matrix4();

  		return function update( camera ) {

  			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
  												aspect !== camera.aspect * this.aspect || near !== camera.near ||
  												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

  			if ( needsUpdate ) {

  				instance = this;
  				focus = camera.focus;
  				fov = camera.fov;
  				aspect = camera.aspect * this.aspect;
  				near = camera.near;
  				far = camera.far;
  				zoom = camera.zoom;

  				// Off-axis stereoscopic effect based on
  				// http://paulbourke.net/stereographics/stereorender/

  				var projectionMatrix = camera.projectionMatrix.clone();
  				eyeSep = this.eyeSep / 2;
  				var eyeSepOnProjection = eyeSep * near / focus;
  				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
  				var xmin, xmax;

  				// translate xOffset

  				eyeLeft.elements[ 12 ] = - eyeSep;
  				eyeRight.elements[ 12 ] = eyeSep;

  				// for left eye

  				xmin = - ymax * aspect + eyeSepOnProjection;
  				xmax = ymax * aspect + eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraL.projectionMatrix.copy( projectionMatrix );

  				// for right eye

  				xmin = - ymax * aspect - eyeSepOnProjection;
  				xmax = ymax * aspect - eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraR.projectionMatrix.copy( projectionMatrix );

  			}

  			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
  			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

  		};

  	} )()

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AnaglyphEffect = function ( renderer, width, height ) {

  	// Matrices generated with angler.js https://github.com/tschw/angler.js/
  	// (in column-major element order, as accepted by WebGL)

  	this.colorMatrixLeft = new Matrix3().fromArray( [

  			1.0671679973602295, 	-0.0016435992438346148,		 0.0001777536963345483, // r out
  			-0.028107794001698494,	-0.00019593400065787137,	-0.0002875397040043026, // g out
  			-0.04279090091586113,	 0.000015809757314855233,	-0.00024287120322696865 // b out

  	] );

  	//		red						green 						blue  						in

  	this.colorMatrixRight = new Matrix3().fromArray( [

  			-0.0355340838432312,	-0.06440307199954987,		 0.018319187685847282,	// r out
  			-0.10269022732973099,	 0.8079727292060852,		-0.04835830628871918,	// g out
  			0.0001224992738571018,	-0.009558862075209618,		 0.567823588848114		// b out

  	] );

  	var _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  	var _scene = new Scene();

  	var _stereo = new StereoCamera();

  	var _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };

  	if ( width === undefined ) { width = 512; }
  	if ( height === undefined ) { height = 512; }

  	var _renderTargetL = new WebGLRenderTarget( width, height, _params );
  	var _renderTargetR = new WebGLRenderTarget( width, height, _params );

  	var _material = new ShaderMaterial( {

  		uniforms: {

  			"mapLeft": { value: _renderTargetL.texture },
  			"mapRight": { value: _renderTargetR.texture },

  			"colorMatrixLeft": { value: this.colorMatrixLeft },
  			"colorMatrixRight": { value: this.colorMatrixRight }

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  			"	vUv = vec2( uv.x, uv.y );",
  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D mapLeft;",
  			"uniform sampler2D mapRight;",
  			"varying vec2 vUv;",

  			"uniform mat3 colorMatrixLeft;",
  			"uniform mat3 colorMatrixRight;",

  			// These functions implement sRGB linearization and gamma correction

  			"float lin( float c ) {",
  			"	return c <= 0.04045 ? c * 0.0773993808 :",
  			"			pow( c * 0.9478672986 + 0.0521327014, 2.4 );",
  			"}",

  			"vec4 lin( vec4 c ) {",
  			"	return vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );",
  			"}",

  			"float dev( float c ) {",
  			"	return c <= 0.0031308 ? c * 12.92",
  			"			: pow( c, 0.41666 ) * 1.055 - 0.055;",
  			"}",
  			"void main() {",

  			"	vec2 uv = vUv;",

  			"	vec4 colorL = lin( texture2D( mapLeft, uv ) );",
  			"	vec4 colorR = lin( texture2D( mapRight, uv ) );",

  			"	vec3 color = clamp(",
  			"			colorMatrixLeft * colorL.rgb +",
  			"			colorMatrixRight * colorR.rgb, 0., 1. );",

  			"	gl_FragColor = vec4(",
  			"			dev( color.r ), dev( color.g ), dev( color.b ),",
  			"			max( colorL.a, colorR.a ) );",

  			"}"

  		].join( "\n" )

  	} );

  	var _mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );
  	_scene.add( _mesh );

  	this.setSize = function ( width, height ) {

  		renderer.setSize( width, height );

  		var pixelRatio = renderer.getPixelRatio();

  		_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
  		_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

  	};

  	this.render = function ( scene, camera ) {

  		var currentRenderTarget = renderer.getRenderTarget();

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_stereo.update( camera );

  		renderer.setRenderTarget( _renderTargetL );
  		renderer.clear();
  		renderer.render( scene, _stereo.cameraL );

  		renderer.setRenderTarget( _renderTargetR );
  		renderer.clear();
  		renderer.render( scene, _stereo.cameraR );

  		renderer.setRenderTarget( null );
  		renderer.render( _scene, _camera );

  		renderer.setRenderTarget( currentRenderTarget );

  	};

  	this.dispose = function () {

  		if ( _renderTargetL ) { _renderTargetL.dispose(); }
  		if ( _renderTargetR ) { _renderTargetR.dispose(); }
  		if ( _mesh ) { _mesh.geometry.dispose(); }
  		if ( _material ) { _material.dispose(); }

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AsciiEffect = function ( renderer, charSet, options ) {

  	// its fun to create one your own!

  	charSet = ( charSet === undefined ) ? ' .:-=+*#%@' : charSet;

  	// ' .,:;=|iI+hHOE#`$';
  	// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/
  	// ' .\'`^",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');

  	if ( ! options ) { options = {}; }

  	// Some ASCII settings

  	var bResolution = ! options[ 'resolution' ] ? 0.15 : options[ 'resolution' ]; // Higher for more details
  	var iScale = ! options[ 'scale' ] ? 1 : options[ 'scale' ];
  	var bColor = ! options[ 'color' ] ? false : options[ 'color' ]; // nice but slows down rendering!
  	var bAlpha = ! options[ 'alpha' ] ? false : options[ 'alpha' ]; // Transparency
  	var bBlock = ! options[ 'block' ] ? false : options[ 'block' ]; // blocked characters. like good O dos
  	var bInvert = ! options[ 'invert' ] ? false : options[ 'invert' ]; // black is white, white is black

  	var strResolution = 'low';

  	var width, height;

  	var domElement = document.createElement( 'div' );
  	domElement.style.cursor = 'default';

  	var oAscii = document.createElement( "table" );
  	domElement.appendChild( oAscii );

  	var iWidth, iHeight;
  	var oImg;

  	this.setSize = function ( w, h ) {

  		width = w;
  		height = h;

  		renderer.setSize( w, h );

  		initAsciiSize();

  	};
  	this.render = function ( scene, camera ) {

  		renderer.render( scene, camera );
  		asciifyImage( renderer, oAscii );

  	};

  	this.domElement = domElement;
  	// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js
  	function initAsciiSize() {

  		iWidth = Math.round( width * fResolution );
  		iHeight = Math.round( height * fResolution );

  		oCanvas.width = iWidth;
  		oCanvas.height = iHeight;
  		// oCanvas.style.display = "none";
  		// oCanvas.style.width = iWidth;
  		// oCanvas.style.height = iHeight;

  		oImg = renderer.domElement;

  		if ( oImg.style.backgroundColor ) {

  			oAscii.rows[ 0 ].cells[ 0 ].style.backgroundColor = oImg.style.backgroundColor;
  			oAscii.rows[ 0 ].cells[ 0 ].style.color = oImg.style.color;

  		}

  		oAscii.cellSpacing = 0;
  		oAscii.cellPadding = 0;

  		var oStyle = oAscii.style;
  		oStyle.display = "inline";
  		oStyle.width = Math.round( iWidth / fResolution * iScale ) + "px";
  		oStyle.height = Math.round( iHeight / fResolution * iScale ) + "px";
  		oStyle.whiteSpace = "pre";
  		oStyle.margin = "0px";
  		oStyle.padding = "0px";
  		oStyle.letterSpacing = fLetterSpacing + "px";
  		oStyle.fontFamily = strFont;
  		oStyle.fontSize = fFontSize + "px";
  		oStyle.lineHeight = fLineHeight + "px";
  		oStyle.textAlign = "left";
  		oStyle.textDecoration = "none";

  	}
  	var aDefaultCharList = ( " .,:;i1tfLCG08@" ).split( "" );
  	var aDefaultColorCharList = ( " CGO08@" ).split( "" );
  	var strFont = "courier new, monospace";

  	var oCanvasImg = renderer.domElement;

  	var oCanvas = document.createElement( "canvas" );
  	if ( ! oCanvas.getContext ) {

  		return;

  	}

  	var oCtx = oCanvas.getContext( "2d" );
  	if ( ! oCtx.getImageData ) {

  		return;

  	}

  	var aCharList = ( bColor ? aDefaultColorCharList : aDefaultCharList );

  	if ( charSet ) { aCharList = charSet; }

  	var fResolution = 0.5;

  	switch ( strResolution ) {

  		case "low" : 	fResolution = 0.25; break;
  		case "medium" : fResolution = 0.5; break;
  		case "high" : 	fResolution = 1; break;

  	}

  	if ( bResolution ) { fResolution = bResolution; }

  	// Setup dom

  	var fFontSize = ( 2 / fResolution ) * iScale;
  	var fLineHeight = ( 2 / fResolution ) * iScale;

  	// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.

  	var fLetterSpacing = 0;

  	{

  		switch ( iScale ) {
  			case 1 : fLetterSpacing = - 1; break;
  			case 2 :
  			case 3 : fLetterSpacing = - 2.1; break;
  			case 4 : fLetterSpacing = - 3.1; break;
  			case 5 : fLetterSpacing = - 4.15; break;
  		}

  	}
  	// can't get a span or div to flow like an img element, but a table works?
  	// convert img element to ascii

  	function asciifyImage( canvasRenderer, oAscii ) {

  		oCtx.clearRect( 0, 0, iWidth, iHeight );
  		oCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );
  		var oImgData = oCtx.getImageData( 0, 0, iWidth, iHeight ).data;

  		// Coloring loop starts now
  		var strChars = "";

  		// console.time('rendering');

  		for ( var y = 0; y < iHeight; y += 2 ) {

  			for ( var x = 0; x < iWidth; x ++ ) {

  				var iOffset = ( y * iWidth + x ) * 4;

  				var iRed = oImgData[ iOffset ];
  				var iGreen = oImgData[ iOffset + 1 ];
  				var iBlue = oImgData[ iOffset + 2 ];
  				var iAlpha = oImgData[ iOffset + 3 ];
  				var iCharIdx;

  				var fBrightness;

  				fBrightness = ( 0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue ) / 255;
  				// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;

  				if ( iAlpha == 0 ) {

  					// should calculate alpha instead, but quick hack :)
  					//fBrightness *= (iAlpha / 255);
  					fBrightness = 1;

  				}

  				iCharIdx = Math.floor( ( 1 - fBrightness ) * ( aCharList.length - 1 ) );

  				if ( bInvert ) {

  					iCharIdx = aCharList.length - iCharIdx - 1;

  				}

  				// good for debugging
  				//fBrightness = Math.floor(fBrightness * 10);
  				//strThisChar = fBrightness;

  				var strThisChar = aCharList[ iCharIdx ];

  				if ( strThisChar === undefined || strThisChar == " " )
  					{ strThisChar = "&nbsp;"; }

  				if ( bColor ) {

  					strChars += "<span style='"
  						+ "color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");"
  						+ ( bBlock ? "background-color:rgb(" + iRed + "," + iGreen + "," + iBlue + ");" : "" )
  						+ ( bAlpha ? "opacity:" + ( iAlpha / 255 ) + ";" : "" )
  						+ "'>" + strThisChar + "</span>";

  				} else {

  					strChars += strThisChar;

  				}

  			}
  			strChars += "<br/>";

  		}

  		oAscii.innerHTML = "<tr><td>" + strChars + "</td></tr>";

  		// console.timeEnd('rendering');

  		// return oAscii;

  	}

  	// end modified asciifyImage block

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var alphamap_fragment = "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var alphamap_pars_fragment = "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var alphatest_fragment = "\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var aomap_fragment = "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var aomap_pars_fragment = "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var begin_vertex = "\nvec3 transformed = vec3( position );\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var bsdfs = "\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from \"Physically Based Shading on Mobile\"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\t// Paper incorrect indicates coefficient is PI/21, and will\n\t// be corrected to 1/21 in future updates.\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit(  ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit(  );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var bumpmap_pars_fragment = "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var clipping_planes_fragment = "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var clipping_planes_pars_fragment = "\n#if NUM_CLIPPING_PLANES > 0\n\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var clipping_planes_pars_vertex = "\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var clipping_planes_vertex = "\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var color_fragment = "\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var color_pars_fragment = "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var color_pars_vertex = "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var color_vertex = "\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var common = "\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var cube_uv_reflection_fragment = "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\t// float powScale = exp2(roughnessLevel + mipLevel);\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\n\tfloat rcpPowScale = 1.0 / powScale;\n\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\n\t// round to nearest mipmap if we are not interpolating.\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\n\t// Tri linear interpolation.\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n\tvec4 result = mix(color10, color20, t);\n\n\treturn vec4(result.rgb, 1.0);\n}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var defaultnormal_vertex = "\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var displacementmap_pars_vertex = "\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var displacementmap_vertex = "\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var emissivemap_fragment = "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var emissivemap_pars_fragment = "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var encodings_fragment = "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var encodings_pars_fragment = "\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var envmap_fragment = "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\tenvColor = envMapTexelToLinear( envColor );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var envmap_pars_fragment = "\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var envmap_pars_vertex = "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var envmap_vertex = "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var fog_vertex = "\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var fog_pars_vertex = "\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var fog_fragment = "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var fog_pars_fragment = "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var gradientmap_pars_fragment = "\n#ifdef TOON\n\n\tuniform sampler2D gradientMap;\n\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t\t// dotNL will be from -1.0 to 1.0\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t\t#ifdef USE_GRADIENTMAP\n\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t\t#else\n\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t\t#endif\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lightmap_fragment = "\n#ifdef USE_LIGHTMAP\n\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lightmap_pars_fragment = "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_lambert_vertex = "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_pars_begin = "\nuniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var envmap_physical_pars_fragment = "\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n\tvec3 getLightProbeIndirectIrradiance(  const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance(  const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_phong_fragment = "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_phong_pars_fragment = "\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t#ifdef TOON\n\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#else\n\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\n\t#endif\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_physical_fragment = "\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_physical_pars_fragment = "\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t// Defer to the IndirectSpecular function to compute\n\t// the indirectDiffuse if energy preservation is enabled.\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\t#endif\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\n\t// Both indirect specular and diffuse light accumulate here\n\t// if energy preservation enabled, and PMREM provided.\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\t\t// The multiscattering paper uses the below formula for calculating diffuse \n\t\t// for dielectrics, but this is already handled when initially computing the \n\t\t// specular and diffuse color, so we can just use the diffuseColor directly.\n\t\t//vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\tvec3 diffuse = material.diffuseColor;\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n\t#else\n\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n\t#endif\n\n\t#ifndef STANDARD\n\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n\t#endif\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_fragment_begin = "\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_fragment_maps = "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tirradiance += getLightProbeIndirectIrradiance(  geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance(  geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance(  geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lights_fragment_end = "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var logdepthbuf_fragment = "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var logdepthbuf_pars_fragment = "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var logdepthbuf_pars_vertex = "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var logdepthbuf_vertex = "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\tgl_Position.z *= gl_Position.w;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var map_fragment = "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var map_pars_fragment = "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var map_particle_fragment = "\n#ifdef USE_MAP\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var map_particle_pars_fragment = "\n#ifdef USE_MAP\n\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var metalnessmap_fragment = "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var metalnessmap_pars_fragment = "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var morphnormal_vertex = "\n#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var morphtarget_pars_vertex = "\n#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var morphtarget_vertex = "\n#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var normal_fragment_begin = "\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var normal_fragment_maps = "\n#ifdef USE_NORMALMAP\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t\t#ifdef FLIP_SIDED\n\n\t\t\tnormal = - normal;\n\n\t\t#endif\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tnormal = normalize( normalMatrix * normal );\n\n\t#else // tangent-space normal map\n\n\t\t#ifdef USE_TANGENT\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\n\t\t#else\n\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n\t\t#endif\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var normalmap_pars_fragment = "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\t\tuniform mat3 normalMatrix;\n\n\t#else\n\n\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t\treturn normalize( tsn * mapN );\n\n\t\t}\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var packing = "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var premultiplied_alpha_fragment = "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var project_vertex = "\nvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var dithering_fragment = "\n#if defined( DITHERING )\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var dithering_pars_fragment = "\n#if defined( DITHERING )\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var roughnessmap_fragment = "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var roughnessmap_pars_fragment = "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadowmap_pars_fragment = "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadowmap_pars_vertex = "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadowmap_vertex = "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadowmask_pars_fragment = "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\tDirectionalLight directionalLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\tSpotLight spotLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\tPointLight pointLight;\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\n\t#endif\n\t#endif\n\n\treturn shadow;\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var skinbase_vertex = "\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var skinning_pars_vertex = "\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var skinning_vertex = "\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var skinnormal_vertex = "\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var specularmap_fragment = "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var specularmap_pars_fragment = "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var tonemapping_fragment = "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var tonemapping_pars_fragment = "\n#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv_pars_fragment = "\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv_pars_vertex = "\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv_vertex = "\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv2_pars_fragment = "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv2_pars_vertex = "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var uv2_vertex = "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var worldpos_vertex = "\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var background_frag = "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var background_vert = "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var cube_frag = "\nuniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\nvoid main() {\n\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var cube_vert = "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var depth_frag = "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\n\t#endif\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var depth_vert = "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var distanceRGBA_frag = "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var distanceRGBA_vert = "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var equirect_frag = "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var equirect_vert = "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var linedashed_frag = "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var linedashed_vert = "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\n\tvLineDistance = scale * lineDistance;\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshbasic_frag = "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshbasic_vert = "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshlambert_frag = "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshlambert_vert = "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshmatcap_frag = "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshmatcap_vert = "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshphong_frag = "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshphong_vert = "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshphysical_frag = "\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var meshphysical_vert = "\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var normal_frag = "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var normal_vert = "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var points_frag = "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var points_vert = "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadow_frag = "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var shadow_vert = "\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var sprite_frag = "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var sprite_vert = "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n";

  var ShaderChunk = {
  	alphamap_fragment: alphamap_fragment,
  	alphamap_pars_fragment: alphamap_pars_fragment,
  	alphatest_fragment: alphatest_fragment,
  	aomap_fragment: aomap_fragment,
  	aomap_pars_fragment: aomap_pars_fragment,
  	begin_vertex: begin_vertex,
  	beginnormal_vertex: beginnormal_vertex,
  	bsdfs: bsdfs,
  	bumpmap_pars_fragment: bumpmap_pars_fragment,
  	clipping_planes_fragment: clipping_planes_fragment,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  	clipping_planes_vertex: clipping_planes_vertex,
  	color_fragment: color_fragment,
  	color_pars_fragment: color_pars_fragment,
  	color_pars_vertex: color_pars_vertex,
  	color_vertex: color_vertex,
  	common: common,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  	defaultnormal_vertex: defaultnormal_vertex,
  	displacementmap_pars_vertex: displacementmap_pars_vertex,
  	displacementmap_vertex: displacementmap_vertex,
  	emissivemap_fragment: emissivemap_fragment,
  	emissivemap_pars_fragment: emissivemap_pars_fragment,
  	encodings_fragment: encodings_fragment,
  	encodings_pars_fragment: encodings_pars_fragment,
  	envmap_fragment: envmap_fragment,
  	envmap_pars_fragment: envmap_pars_fragment,
  	envmap_pars_vertex: envmap_pars_vertex,
  	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  	envmap_vertex: envmap_vertex,
  	fog_vertex: fog_vertex,
  	fog_pars_vertex: fog_pars_vertex,
  	fog_fragment: fog_fragment,
  	fog_pars_fragment: fog_pars_fragment,
  	gradientmap_pars_fragment: gradientmap_pars_fragment,
  	lightmap_fragment: lightmap_fragment,
  	lightmap_pars_fragment: lightmap_pars_fragment,
  	lights_lambert_vertex: lights_lambert_vertex,
  	lights_pars_begin: lights_pars_begin,
  	lights_phong_fragment: lights_phong_fragment,
  	lights_phong_pars_fragment: lights_phong_pars_fragment,
  	lights_physical_fragment: lights_physical_fragment,
  	lights_physical_pars_fragment: lights_physical_pars_fragment,
  	lights_fragment_begin: lights_fragment_begin,
  	lights_fragment_maps: lights_fragment_maps,
  	lights_fragment_end: lights_fragment_end,
  	logdepthbuf_fragment: logdepthbuf_fragment,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  	logdepthbuf_vertex: logdepthbuf_vertex,
  	map_fragment: map_fragment,
  	map_pars_fragment: map_pars_fragment,
  	map_particle_fragment: map_particle_fragment,
  	map_particle_pars_fragment: map_particle_pars_fragment,
  	metalnessmap_fragment: metalnessmap_fragment,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  	morphnormal_vertex: morphnormal_vertex,
  	morphtarget_pars_vertex: morphtarget_pars_vertex,
  	morphtarget_vertex: morphtarget_vertex,
  	normal_fragment_begin: normal_fragment_begin,
  	normal_fragment_maps: normal_fragment_maps,
  	normalmap_pars_fragment: normalmap_pars_fragment,
  	packing: packing,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  	project_vertex: project_vertex,
  	dithering_fragment: dithering_fragment,
  	dithering_pars_fragment: dithering_pars_fragment,
  	roughnessmap_fragment: roughnessmap_fragment,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  	shadowmap_pars_fragment: shadowmap_pars_fragment,
  	shadowmap_pars_vertex: shadowmap_pars_vertex,
  	shadowmap_vertex: shadowmap_vertex,
  	shadowmask_pars_fragment: shadowmask_pars_fragment,
  	skinbase_vertex: skinbase_vertex,
  	skinning_pars_vertex: skinning_pars_vertex,
  	skinning_vertex: skinning_vertex,
  	skinnormal_vertex: skinnormal_vertex,
  	specularmap_fragment: specularmap_fragment,
  	specularmap_pars_fragment: specularmap_pars_fragment,
  	tonemapping_fragment: tonemapping_fragment,
  	tonemapping_pars_fragment: tonemapping_pars_fragment,
  	uv_pars_fragment: uv_pars_fragment,
  	uv_pars_vertex: uv_pars_vertex,
  	uv_vertex: uv_vertex,
  	uv2_pars_fragment: uv2_pars_fragment,
  	uv2_pars_vertex: uv2_pars_vertex,
  	uv2_vertex: uv2_vertex,
  	worldpos_vertex: worldpos_vertex,

  	background_frag: background_frag,
  	background_vert: background_vert,
  	cube_frag: cube_frag,
  	cube_vert: cube_vert,
  	depth_frag: depth_frag,
  	depth_vert: depth_vert,
  	distanceRGBA_frag: distanceRGBA_frag,
  	distanceRGBA_vert: distanceRGBA_vert,
  	equirect_frag: equirect_frag,
  	equirect_vert: equirect_vert,
  	linedashed_frag: linedashed_frag,
  	linedashed_vert: linedashed_vert,
  	meshbasic_frag: meshbasic_frag,
  	meshbasic_vert: meshbasic_vert,
  	meshlambert_frag: meshlambert_frag,
  	meshlambert_vert: meshlambert_vert,
  	meshmatcap_frag: meshmatcap_frag,
  	meshmatcap_vert: meshmatcap_vert,
  	meshphong_frag: meshphong_frag,
  	meshphong_vert: meshphong_vert,
  	meshphysical_frag: meshphysical_frag,
  	meshphysical_vert: meshphysical_vert,
  	normal_frag: normal_frag,
  	normal_vert: normal_vert,
  	points_frag: points_frag,
  	points_vert: points_vert,
  	shadow_frag: shadow_frag,
  	shadow_vert: shadow_vert,
  	sprite_frag: sprite_frag,
  	sprite_vert: sprite_vert
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var UniformsLib = {

  	common: {

  		diffuse: { value: new Color( 0xeeeeee ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		uvTransform: { value: new Matrix3() },

  		alphaMap: { value: null },

  	},

  	specularmap: {

  		specularMap: { value: null },

  	},

  	envmap: {

  		envMap: { value: null },
  		flipEnvMap: { value: - 1 },
  		reflectivity: { value: 1.0 },
  		refractionRatio: { value: 0.98 },
  		maxMipLevel: { value: 0 }

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalScale: { value: new Vector2( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: new Color( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotShadowMap: { value: [] },
  		spotShadowMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {},
  			shadowCameraNear: {},
  			shadowCameraFar: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} }

  	},

  	points: {

  		diffuse: { value: new Color( 0xeeeeee ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		uvTransform: { value: new Matrix3() }

  	},

  	sprite: {

  		diffuse: { value: new Color( 0xeeeeee ) },
  		opacity: { value: 1.0 },
  		center: { value: new Vector2( 0.5, 0.5 ) },
  		rotation: { value: 0.0 },
  		map: { value: null },
  		uvTransform: { value: new Matrix3() }

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderLib = {

  	basic: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.meshbasic_vert,
  		fragmentShader: ShaderChunk.meshbasic_frag

  	},

  	lambert: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshlambert_vert,
  		fragmentShader: ShaderChunk.meshlambert_frag

  	},

  	phong: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.gradientmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) },
  				specular: { value: new Color( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphong_vert,
  		fragmentShader: ShaderChunk.meshphong_frag

  	},

  	standard: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.roughnessmap,
  			UniformsLib.metalnessmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color( 0x000000 ) },
  				roughness: { value: 0.5 },
  				metalness: { value: 0.5 },
  				envMapIntensity: { value: 1 } // temporary
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	},

  	matcap: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.fog,
  			{
  				matcap: { value: null }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshmatcap_vert,
  		fragmentShader: ShaderChunk.meshmatcap_frag

  	},

  	points: {

  		uniforms: mergeUniforms( [
  			UniformsLib.points,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.points_vert,
  		fragmentShader: ShaderChunk.points_frag

  	},

  	dashed: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk.linedashed_vert,
  		fragmentShader: ShaderChunk.linedashed_frag

  	},

  	depth: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap
  		] ),

  		vertexShader: ShaderChunk.depth_vert,
  		fragmentShader: ShaderChunk.depth_frag

  	},

  	normal: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.normal_vert,
  		fragmentShader: ShaderChunk.normal_frag

  	},

  	sprite: {

  		uniforms: mergeUniforms( [
  			UniformsLib.sprite,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.sprite_vert,
  		fragmentShader: ShaderChunk.sprite_frag

  	},

  	background: {

  		uniforms: {
  			uvTransform: { value: new Matrix3() },
  			t2D: { value: null },
  		},

  		vertexShader: ShaderChunk.background_vert,
  		fragmentShader: ShaderChunk.background_frag

  	},
  	cube: {

  		uniforms: {
  			tCube: { value: null },
  			tFlip: { value: - 1 },
  			opacity: { value: 1.0 }
  		},

  		vertexShader: ShaderChunk.cube_vert,
  		fragmentShader: ShaderChunk.cube_frag

  	},

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader: ShaderChunk.equirect_vert,
  		fragmentShader: ShaderChunk.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: mergeUniforms( [
  			UniformsLib.common,
  			UniformsLib.displacementmap,
  			{
  				referencePosition: { value: new Vector3() },
  				nearDistance: { value: 1 },
  				farDistance: { value: 1000 }
  			}
  		] ),

  		vertexShader: ShaderChunk.distanceRGBA_vert,
  		fragmentShader: ShaderChunk.distanceRGBA_frag

  	},

  	shadow: {

  		uniforms: mergeUniforms( [
  			UniformsLib.lights,
  			UniformsLib.fog,
  			{
  				color: { value: new Color( 0x00000 ) },
  				opacity: { value: 1.0 }
  			} ] ),

  		vertexShader: ShaderChunk.shadow_vert,
  		fragmentShader: ShaderChunk.shadow_frag

  	}

  };

  ShaderLib.physical = {

  	uniforms: mergeUniforms( [
  		ShaderLib.standard.uniforms,
  		{
  			clearCoat: { value: 0 },
  			clearCoatRoughness: { value: 0 }
  		}
  	] ),

  	vertexShader: ShaderChunk.meshphysical_vert,
  	fragmentShader: ShaderChunk.meshphysical_frag

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var OutlineEffect = function ( renderer, parameters ) {

  	parameters = parameters || {};

  	this.enabled = true;

  	var defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;
  	var defaultColor = new Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );
  	var defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;
  	var defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;

  	// object.material.uuid -> outlineMaterial or
  	// object.material[ n ].uuid -> outlineMaterial
  	// save at the outline material creation and release
  	// if it's unused removeThresholdCount frames
  	// unless keepAlive is true.
  	var cache = {};

  	var removeThresholdCount = 60;

  	// outlineMaterial.uuid -> object.material or
  	// outlineMaterial.uuid -> object.material[ n ]
  	// save before render and release after render.
  	var originalMaterials = {};

  	// object.uuid -> originalOnBeforeRender
  	// save before render and release after render.
  	var originalOnBeforeRenders = {};

  	//this.cache = cache;  // for debug

  	// copied from WebGLPrograms and removed some materials
  	var shaderIDs = {
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'phong',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical'
  	};

  	var uniformsChunk = {
  		outlineThickness: { type: "f", value: defaultThickness },
  		outlineColor: { type: "c", value: defaultColor },
  		outlineAlpha: { type: "f", value: defaultAlpha }
  	};

  	var vertexShaderChunk = [

  		"#include <fog_pars_vertex>",

  		"uniform float outlineThickness;",

  		"vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {",

  		"	float thickness = outlineThickness;",
  		"	const float ratio = 1.0;", // TODO: support outline thickness ratio for each vertex
  		"	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );",
  		// NOTE: subtract pos2 from pos because BackSide objectNormal is negative
  		"	vec4 norm = normalize( pos - pos2 );",
  		"	return pos + norm * thickness * pos.w * ratio;",

  		"}"

  	].join( "\n" );

  	var vertexShaderChunk2 = [

  		"#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )",
  		"	#ifndef USE_ENVMAP",
  		"		vec3 objectNormal = normalize( normal );",
  		"	#endif",
  		"#endif",

  		"#ifdef FLIP_SIDED",
  		"	objectNormal = -objectNormal;",
  		"#endif",

  		"#ifdef DECLARE_TRANSFORMED",
  		"	vec3 transformed = vec3( position );",
  		"#endif",

  		"gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );",

  		"#include <fog_vertex>"

  	].join( "\n" );

  	var fragmentShader = [

  		"#include <common>",
  		"#include <fog_pars_fragment>",

  		"uniform vec3 outlineColor;",
  		"uniform float outlineAlpha;",

  		"void main() {",

  		"	gl_FragColor = vec4( outlineColor, outlineAlpha );",

  		"	#include <fog_fragment>",

  		"}"

  	].join( "\n" );

  	function createInvisibleMaterial() {

  		return new ShaderMaterial( { name: 'invisible', visible: false } );

  	}

  	function createMaterial( originalMaterial ) {

  		var shaderID = shaderIDs[ originalMaterial.type ];
  		var originalUniforms, originalVertexShader;
  		var outlineParameters = originalMaterial.userData.outlineParameters;

  		if ( shaderID !== undefined ) {

  			var shader = ShaderLib[ shaderID ];
  			originalUniforms = shader.uniforms;
  			originalVertexShader = shader.vertexShader;

  		} else if ( originalMaterial.isRawShaderMaterial === true ) {

  			originalUniforms = originalMaterial.uniforms;
  			originalVertexShader = originalMaterial.vertexShader;

  			if ( ! /attribute\s+vec3\s+position\s*;/.test( originalVertexShader ) ||
  			     ! /attribute\s+vec3\s+normal\s*;/.test( originalVertexShader ) ) {

  				console.warn( 'OutlineEffect requires both vec3 position and normal attributes in vertex shader, ' +
  				              'does not draw outline for ' + originalMaterial.name + '(uuid:' + originalMaterial.uuid + ') material.' );

  				return createInvisibleMaterial();

  			}

  		} else if ( originalMaterial.isShaderMaterial === true ) {

  			originalUniforms = originalMaterial.uniforms;
  			originalVertexShader = originalMaterial.vertexShader;

  		} else {

  			return createInvisibleMaterial();

  		}

  		var uniforms = Object.assign( {}, originalUniforms, uniformsChunk );

  		var vertexShader = originalVertexShader
  					// put vertexShaderChunk right before "void main() {...}"
  					.replace( /void\s+main\s*\(\s*\)/, vertexShaderChunk + '\nvoid main()' )
  					// put vertexShaderChunk2 the end of "void main() {...}"
  					// Note: here assums originalVertexShader ends with "}" of "void main() {...}"
  					.replace( /\}\s*$/, vertexShaderChunk2 + '\n}' )
  					// remove any light related lines
  					// Note: here is very sensitive to originalVertexShader
  					// TODO: consider safer way
  					.replace( /#include\s+<[\w_]*light[\w_]*>/g, '' );

  		var defines = {};

  		if ( ! /vec3\s+transformed\s*=/.test( originalVertexShader ) &&
  		     ! /#include\s+<begin_vertex>/.test( originalVertexShader ) ) { defines.DECLARE_TRANSFORMED = true; }

  		return new ShaderMaterial( {
  			defines: defines,
  			uniforms: uniforms,
  			vertexShader: vertexShader,
  			fragmentShader: fragmentShader,
  			side: BackSide,
  			//wireframe: true,
  			skinning: false,
  			morphTargets: false,
  			morphNormals: false,
  			fog: false
  		} );

  	}

  	function getOutlineMaterialFromCache( originalMaterial ) {

  		var data = cache[ originalMaterial.uuid ];

  		if ( data === undefined ) {

  			data = {
  				material: createMaterial( originalMaterial ),
  				used: true,
  				keepAlive: defaultKeepAlive,
  				count: 0
  			};

  			cache[ originalMaterial.uuid ] = data;

  		}

  		data.used = true;

  		return data.material;

  	}

  	function getOutlineMaterial( originalMaterial ) {

  		var outlineMaterial = getOutlineMaterialFromCache( originalMaterial );

  		originalMaterials[ outlineMaterial.uuid ] = originalMaterial;

  		updateOutlineMaterial( outlineMaterial, originalMaterial );

  		return outlineMaterial;

  	}

  	function setOutlineMaterial( object ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				object.material[ i ] = getOutlineMaterial( object.material[ i ] );

  			}

  		} else {

  			object.material = getOutlineMaterial( object.material );

  		}

  		originalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;
  		object.onBeforeRender = onBeforeRender;

  	}

  	function restoreOriginalMaterial( object ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				object.material[ i ] = originalMaterials[ object.material[ i ].uuid ];

  			}

  		} else {

  			object.material = originalMaterials[ object.material.uuid ];

  		}

  		object.onBeforeRender = originalOnBeforeRenders[ object.uuid ];

  	}

  	function onBeforeRender( renderer, scene, camera, geometry, material, group ) {

  		var originalMaterial = originalMaterials[ material.uuid ];

  		// just in case
  		if ( originalMaterial === undefined ) { return; }

  		updateUniforms( material, originalMaterial );

  	}

  	function updateUniforms( material, originalMaterial ) {

  		var outlineParameters = originalMaterial.userData.outlineParameters;

  		material.uniforms.outlineAlpha.value = originalMaterial.opacity;

  		if ( outlineParameters !== undefined ) {

  			if ( outlineParameters.thickness !== undefined ) { material.uniforms.outlineThickness.value = outlineParameters.thickness; }
  			if ( outlineParameters.color !== undefined ) { material.uniforms.outlineColor.value.fromArray( outlineParameters.color ); }
  			if ( outlineParameters.alpha !== undefined ) { material.uniforms.outlineAlpha.value = outlineParameters.alpha; }

  		}

  	}

  	function updateOutlineMaterial( material, originalMaterial ) {

  		if ( material.name === 'invisible' ) { return; }

  		var outlineParameters = originalMaterial.userData.outlineParameters;

  		material.skinning = originalMaterial.skinning;
  		material.morphTargets = originalMaterial.morphTargets;
  		material.morphNormals = originalMaterial.morphNormals;
  		material.fog = originalMaterial.fog;

  		if ( outlineParameters !== undefined ) {

  			if ( originalMaterial.visible === false ) {

  				material.visible = false;

  			} else {

  				material.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;

  			}

  			material.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;

  			if ( outlineParameters.keepAlive !== undefined ) { cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive; }

  		} else {

  			material.transparent = originalMaterial.transparent;
  			material.visible = originalMaterial.visible;

  		}

  		if ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) { material.visible = false; }

  	}

  	function cleanupCache() {

  		var keys;

  		// clear originialMaterials
  		keys = Object.keys( originalMaterials );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			originalMaterials[ keys[ i ] ] = undefined;

  		}

  		// clear originalOnBeforeRenders
  		keys = Object.keys( originalOnBeforeRenders );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			originalOnBeforeRenders[ keys[ i ] ] = undefined;

  		}

  		// remove unused outlineMaterial from cache
  		keys = Object.keys( cache );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			var key = keys[ i ];

  			if ( cache[ key ].used === false ) {

  				cache[ key ].count++;

  				if ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {

  					delete cache[ key ];

  				}

  			} else {

  				cache[ key ].used = false;
  				cache[ key ].count = 0;

  			}

  		}

  	}

  	this.render = function ( scene, camera ) {

  		var renderTarget = null;
  		var forceClear = false;

  		if ( arguments[ 2 ] !== undefined ) {

  			console.warn( 'OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
  			renderTarget = arguments[ 2 ];

  		}

  		if ( arguments[ 3 ] !== undefined ) {

  			console.warn( 'OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.' );
  			forceClear = arguments[ 3 ];

  		}

  		renderer.setRenderTarget( renderTarget );

  		if ( forceClear ) { renderer.clear(); }

  		if ( this.enabled === false ) {

  			renderer.render( scene, camera );
  			return;

  		}

  		var currentAutoClear = renderer.autoClear;
  		renderer.autoClear = this.autoClear;

  		// 1. render normally
  		renderer.render( scene, camera );

  		// 2. render outline
  		var currentSceneAutoUpdate = scene.autoUpdate;
  		var currentSceneBackground = scene.background;
  		var currentShadowMapEnabled = renderer.shadowMap.enabled;

  		scene.autoUpdate = false;
  		scene.background = null;
  		renderer.autoClear = false;
  		renderer.shadowMap.enabled = false;

  		scene.traverse( setOutlineMaterial );

  		renderer.render( scene, camera );

  		scene.traverse( restoreOriginalMaterial );

  		cleanupCache();

  		scene.autoUpdate = currentSceneAutoUpdate;
  		scene.background = currentSceneBackground;
  		renderer.autoClear = currentAutoClear;
  		renderer.shadowMap.enabled = currentShadowMapEnabled;

  	};
  	this.autoClear = renderer.autoClear;
  	this.domElement = renderer.domElement;
  	this.shadowMap = renderer.shadowMap;

  	this.clear = function ( color, depth, stencil ) {

  		renderer.clear( color, depth, stencil );

  	};

  	this.getPixelRatio = function () {

  		return renderer.getPixelRatio();

  	};

  	this.setPixelRatio = function ( value ) {

  		renderer.setPixelRatio( value );

  	};

  	this.getSize = function ( target ) {

  		return renderer.getSize( target );

  	};

  	this.setSize = function ( width, height, updateStyle ) {

  		renderer.setSize( width, height, updateStyle );

  	};

  	this.setViewport = function ( x, y, width, height ) {

  		renderer.setViewport( x, y, width, height );

  	};

  	this.setScissor = function ( x, y, width, height ) {

  		renderer.setScissor( x, y, width, height );

  	};

  	this.setScissorTest = function ( boolean ) {

  		renderer.setScissorTest( boolean );

  	};

  	this.setRenderTarget = function ( renderTarget ) {

  		renderer.setRenderTarget( renderTarget );

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ParallaxBarrierEffect = function ( renderer ) {

  	var _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  	var _scene = new Scene();

  	var _stereo = new StereoCamera();

  	var _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };

  	var _renderTargetL = new WebGLRenderTarget( 512, 512, _params );
  	var _renderTargetR = new WebGLRenderTarget( 512, 512, _params );

  	var _material = new ShaderMaterial( {

  		uniforms: {

  			"mapLeft": { value: _renderTargetL.texture },
  			"mapRight": { value: _renderTargetR.texture }

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  			"	vUv = vec2( uv.x, uv.y );",
  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D mapLeft;",
  			"uniform sampler2D mapRight;",
  			"varying vec2 vUv;",

  			"void main() {",

  			"	vec2 uv = vUv;",

  			"	if ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {",

  			"		gl_FragColor = texture2D( mapLeft, uv );",

  			"	} else {",

  			"		gl_FragColor = texture2D( mapRight, uv );",

  			"	}",

  			"}"

  		].join( "\n" )

  	} );

  	var mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );
  	_scene.add( mesh );

  	this.setSize = function ( width, height ) {

  		renderer.setSize( width, height );

  		var pixelRatio = renderer.getPixelRatio();

  		_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
  		_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_stereo.update( camera );

  		renderer.setRenderTarget( _renderTargetL );
  		renderer.clear();
  		renderer.render( scene, _stereo.cameraL );

  		renderer.setRenderTarget( _renderTargetR );
  		renderer.clear();
  		renderer.render( scene, _stereo.cameraR );

  		renderer.setRenderTarget( null );
  		renderer.render( _scene, _camera );

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PeppersGhostEffect = function ( renderer ) {

  	var scope = this;

  	scope.cameraDistance = 15;
  	scope.reflectFromAbove = false;

  	// Internals
  	var _halfWidth, _width, _height;

  	var _cameraF = new PerspectiveCamera(); //front
  	var _cameraB = new PerspectiveCamera(); //back
  	var _cameraL = new PerspectiveCamera(); //left
  	var _cameraR = new PerspectiveCamera(); //right

  	var _position = new Vector3();
  	var _quaternion = new Quaternion();
  	var _scale = new Vector3();

  	// Initialization
  	renderer.autoClear = false;

  	this.setSize = function ( width, height ) {

  		_halfWidth = width / 2;
  		if ( width < height ) {

  			_width = width / 3;
  			_height = width / 3;

  		} else {

  			_width = height / 3;
  			_height = height / 3;

  		}
  		renderer.setSize( width, height );

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		camera.matrixWorld.decompose( _position, _quaternion, _scale );

  		// front
  		_cameraF.position.copy( _position );
  		_cameraF.quaternion.copy( _quaternion );
  		_cameraF.translateZ( scope.cameraDistance );
  		_cameraF.lookAt( scene.position );

  		// back
  		_cameraB.position.copy( _position );
  		_cameraB.quaternion.copy( _quaternion );
  		_cameraB.translateZ( - ( scope.cameraDistance ) );
  		_cameraB.lookAt( scene.position );
  		_cameraB.rotation.z += 180 * ( Math.PI / 180 );

  		// left
  		_cameraL.position.copy( _position );
  		_cameraL.quaternion.copy( _quaternion );
  		_cameraL.translateX( - ( scope.cameraDistance ) );
  		_cameraL.lookAt( scene.position );
  		_cameraL.rotation.x += 90 * ( Math.PI / 180 );

  		// right
  		_cameraR.position.copy( _position );
  		_cameraR.quaternion.copy( _quaternion );
  		_cameraR.translateX( scope.cameraDistance );
  		_cameraR.lookAt( scene.position );
  		_cameraR.rotation.x += 90 * ( Math.PI / 180 );
  		renderer.clear();
  		renderer.setScissorTest( true );

  		renderer.setScissor( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );
  		renderer.setViewport( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );

  		if ( scope.reflectFromAbove ) {

  			renderer.render( scene, _cameraB );

  		} else {

  			renderer.render( scene, _cameraF );

  		}

  		renderer.setScissor( _halfWidth - ( _width / 2 ), 0, _width, _height );
  		renderer.setViewport( _halfWidth - ( _width / 2 ), 0, _width, _height );

  		if ( scope.reflectFromAbove ) {

  			renderer.render( scene, _cameraF );

  		} else {

  			renderer.render( scene, _cameraB );

  		}

  		renderer.setScissor( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );
  		renderer.setViewport( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );

  		if ( scope.reflectFromAbove ) {

  			renderer.render( scene, _cameraR );

  		} else {

  			renderer.render( scene, _cameraL );

  		}

  		renderer.setScissor( _halfWidth + ( _width / 2 ), _height, _width, _height );
  		renderer.setViewport( _halfWidth + ( _width / 2 ), _height, _width, _height );

  		if ( scope.reflectFromAbove ) {

  			renderer.render( scene, _cameraL );

  		} else {

  			renderer.render( scene, _cameraR );

  		}

  		renderer.setScissorTest( false );

  	};
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var StereoEffect = function ( renderer ) {

  	var _stereo = new StereoCamera();
  	_stereo.aspect = 0.5;
  	var size = new Vector2();

  	this.setEyeSeparation = function ( eyeSep ) {

  		_stereo.eyeSep = eyeSep;

  	};

  	this.setSize = function ( width, height ) {

  		renderer.setSize( width, height );

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_stereo.update( camera );

  		renderer.getSize( size );

  		if ( renderer.autoClear ) { renderer.clear(); }
  		renderer.setScissorTest( true );

  		renderer.setScissor( 0, 0, size.width / 2, size.height );
  		renderer.setViewport( 0, 0, size.width / 2, size.height );
  		renderer.render( scene, _stereo.cameraL );

  		renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
  		renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
  		renderer.render( scene, _stereo.cameraR );

  		renderer.setScissorTest( false );

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshLambertMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshLambertMaterial';

  	this.color = new Color( 0xffffff ); // diffuse

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshLambertMaterial.prototype = Object.create( Material$1.prototype );
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColladaExporter = function () {};

  ColladaExporter.prototype = {

  	constructor: ColladaExporter,

  	parse: function ( object, onDone, options ) {
  		if ( options === void 0 ) options = {};


  		options = Object.assign( {
  			version: '1.4.1',
  			author: null,
  			textureDirectory: '',
  		}, options );

  		if ( options.textureDirectory !== '' ) {

  			options.textureDirectory = ((options.textureDirectory) + "/")
  				.replace( /\\/g, '/' )
  				.replace( /\/+/g, '/' );

  		}

  		var version = options.version;
  		if ( version !== '1.4.1' && version !== '1.5.0' ) {

  			console.warn( ("ColladaExporter : Version " + version + " not supported for export. Only 1.4.1 and 1.5.0.") );
  			return null;

  		}

  		// Convert the urdf xml into a well-formatted, indented format
  		function format( urdf ) {

  			var IS_END_TAG = /^<\//;
  			var IS_SELF_CLOSING = /(\?>$)|(\/>$)/;
  			var HAS_TEXT = /<[^>]+>[^<]*<\/[^<]+>/;

  			var pad = function ( ch, num ) { return ( num > 0 ? ch + pad( ch, num - 1 ) : '' ); };

  			var tagnum = 0;
  			return urdf
  				.match( /(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g )
  				.map( function (tag) {

  					if ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {

  						tagnum --;

  					}

  					var res = "" + (pad( '  ', tagnum )) + tag;

  					if ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {

  						tagnum ++;

  					}

  					return res;

  				} )
  				.join( '\n' );

  		}

  		// Convert an image into a png format for saving
  		function base64ToBuffer( str ) {

  			var b = atob( str );
  			var buf = new Uint8Array( b.length );

  			for ( var i = 0, l = buf.length; i < l; i ++ ) {

  				buf[ i ] = b.charCodeAt( i );

  			}

  			return buf;

  		}

  		var canvas, ctx;
  		function imageToData( image, ext ) {

  			canvas = canvas || document.createElement( 'canvas' );
  			ctx = ctx || canvas.getContext( '2d' );

  			canvas.width = image.naturalWidth;
  			canvas.height = image.naturalHeight;

  			ctx.drawImage( image, 0, 0 );

  			// Get the base64 encoded data
  			var base64data = canvas
  				.toDataURL( ("image/" + ext), 1 )
  				.replace( /^data:image\/(png|jpg);base64,/, '' );

  			// Convert to a uint8 array
  			return base64ToBuffer( base64data );

  		}

  		// gets the attribute array. Generate a new array if the attribute is interleaved
  		var getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];
  		function attrBufferToArray( attr ) {

  			if ( attr.isInterleavedBufferAttribute ) {

  				// use the typed array constructor to save on memory
  				var arr = new attr.array.constructor( attr.count * attr.itemSize );
  				var size = attr.itemSize;
  				for ( var i = 0, l = attr.count; i < l; i ++ ) {

  					for ( var j = 0; j < size; j ++ ) {

  						arr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );

  					}

  				}

  				return arr;

  			} else {

  				return attr.array;

  			}

  		}

  		// Returns an array of the same type starting at the `st` index,
  		// and `ct` length
  		function subArray( arr, st, ct ) {

  			if ( Array.isArray( arr ) ) { return arr.slice( st, st + ct ); }
  			else { return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct ); }

  		}

  		// Returns the string for a geometry's attribute
  		function getAttribute( attr, name, params, type ) {

  			var array = attrBufferToArray( attr );
  			var res =
  					"<source id=\"" + name + "\">" +

  					"<float_array id=\"" + name + "-array\" count=\"" + (array.length) + "\">" +
  					array.join( ' ' ) +
  					'</float_array>' +

  					'<technique_common>' +
  					"<accessor source=\"#" + name + "-array\" count=\"" + (Math.floor( array.length / attr.itemSize )) + "\" stride=\"" + (attr.itemSize) + "\">" +

  					params.map( function (n) { return ("<param name=\"" + n + "\" type=\"" + type + "\" />"); } ).join( '' ) +

  					'</accessor>' +
  					'</technique_common>' +
  					'</source>';

  			return res;

  		}

  		// Returns the string for a node's transform information
  		var transMat;
  		function getTransform( o ) {

  			// ensure the object's matrix is up to date
  			// before saving the transform
  			o.updateMatrix();

  			transMat = transMat || new Matrix4();
  			transMat.copy( o.matrix );
  			transMat.transpose();
  			return ("<matrix>" + (transMat.toArray().join( ' ' )) + "</matrix>");

  		}

  		// Process the given piece of geometry into the geometry library
  		// Returns the mesh id
  		function processGeometry( g ) {

  			var info = geometryInfo.get( g );

  			if ( ! info ) {

  				// convert the geometry to bufferGeometry if it isn't already
  				var bufferGeometry = g;
  				if ( bufferGeometry instanceof Geometry ) {

  					bufferGeometry = ( new BufferGeometry() ).fromGeometry( bufferGeometry );

  				}

  				var meshid = "Mesh" + (libraryGeometries.length + 1);

  				var indexCount =
  					bufferGeometry.index ?
  						bufferGeometry.index.count * bufferGeometry.index.itemSize :
  						bufferGeometry.attributes.position.count;

  				var groups =
  					bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?
  						bufferGeometry.groups :
  						[ { start: 0, count: indexCount, materialIndex: 0 } ];

  				var gnode = "<geometry id=\"" + meshid + "\" name=\"" + (g.name) + "\"><mesh>";

  				// define the geometry node and the vertices for the geometry
  				var posName = meshid + "-position";
  				var vertName = meshid + "-vertices";
  				gnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );
  				gnode += "<vertices id=\"" + vertName + "\"><input semantic=\"POSITION\" source=\"#" + posName + "\" /></vertices>";

  				// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and
  				// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening
  				// models with attributes that share an offset.
  				// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/

  				// serialize normals
  				var triangleInputs = "<input semantic=\"VERTEX\" source=\"#" + vertName + "\" offset=\"0\" />";
  				if ( 'normal' in bufferGeometry.attributes ) {

  					var normName = meshid + "-normal";
  					gnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );
  					triangleInputs += "<input semantic=\"NORMAL\" source=\"#" + normName + "\" offset=\"0\" />";

  				}

  				// serialize uvs
  				if ( 'uv' in bufferGeometry.attributes ) {

  					var uvName = meshid + "-texcoord";
  					gnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );
  					triangleInputs += "<input semantic=\"TEXCOORD\" source=\"#" + uvName + "\" offset=\"0\" set=\"0\" />";

  				}

  				// serialize colors
  				if ( 'color' in bufferGeometry.attributes ) {

  					var colName = meshid + "-color";
  					gnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );
  					triangleInputs += "<input semantic=\"COLOR\" source=\"#" + colName + "\" offset=\"0\" />";

  				}

  				var indexArray = null;
  				if ( bufferGeometry.index ) {

  					indexArray = attrBufferToArray( bufferGeometry.index );

  				} else {

  					indexArray = new Array( indexCount );
  					for ( var i = 0, l = indexArray.length; i < l; i ++ ) { indexArray[ i ] = i; }

  				}

  				for ( var i = 0, l = groups.length; i < l; i ++ ) {

  					var group = groups[ i ];
  					var subarr = subArray( indexArray, group.start, group.count );
  					var polycount = subarr.length / 3;
  					gnode += "<triangles material=\"MESH_MATERIAL_" + (group.materialIndex) + "\" count=\"" + polycount + "\">";
  					gnode += triangleInputs;

  					gnode += "<p>" + (subarr.join( ' ' )) + "</p>";
  					gnode += '</triangles>';

  				}

  				gnode += "</mesh></geometry>";

  				libraryGeometries.push( gnode );

  				info = { meshid: meshid, bufferGeometry: bufferGeometry };
  				geometryInfo.set( g, info );

  			}

  			return info;

  		}

  		// Process the given texture into the image library
  		// Returns the image library
  		function processTexture( tex ) {

  			var texid = imageMap.get( tex );
  			if ( texid == null ) {

  				texid = "image-" + (libraryImages.length + 1);

  				var ext = 'png';
  				var name = tex.name || texid;
  				var imageNode = "<image id=\"" + texid + "\" name=\"" + name + "\">";

  				if ( version === '1.5.0' ) {

  					imageNode += "<init_from><ref>" + (options.textureDirectory) + name + "." + ext + "</ref></init_from>";

  				} else {

  					// version image node 1.4.1
  					imageNode += "<init_from>" + (options.textureDirectory) + name + "." + ext + "</init_from>";

  				}

  				imageNode += '</image>';

  				libraryImages.push( imageNode );
  				imageMap.set( tex, texid );
  				textures.push( {
  					directory: options.textureDirectory,
  					name: name,
  					ext: ext,
  					data: imageToData( tex.image, ext ),
  					original: tex
  				} );

  			}

  			return texid;

  		}

  		// Process the given material into the material and effect libraries
  		// Returns the material id
  		function processMaterial( m ) {

  			var matid = materialMap.get( m );

  			if ( matid == null ) {

  				matid = "Mat" + (libraryEffects.length + 1);

  				var type = 'phong';

  				if ( m instanceof MeshLambertMaterial ) {

  					type = 'lambert';

  				} else if ( m instanceof MeshBasicMaterial ) {

  					type = 'constant';

  					if ( m.map !== null ) {

  						// The Collada spec does not support diffuse texture maps with the
  						// constant shader type.
  						// mrdoob/three.js#15469
  						console.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );

  					}

  				}

  				var emissive = m.emissive ? m.emissive : new Color( 0, 0, 0 );
  				var diffuse = m.color ? m.color : new Color( 0, 0, 0 );
  				var specular = m.specular ? m.specular : new Color( 1, 1, 1 );
  				var shininess = m.shininess || 0;
  				var reflectivity = m.reflectivity || 0;

  				// Do not export and alpha map for the reasons mentioned in issue (#13792)
  				// in js alpha maps are black and white, but collada expects the alpha
  				// channel to specify the transparency
  				var transparencyNode = '';
  				if ( m.transparent === true ) {

  					transparencyNode +=
  						"<transparent>" +
  						(
  							m.map ?
  								"<texture texture=\"diffuse-sampler\"></texture>" :
  								'<float>1</float>'
  						) +
  						'</transparent>';

  					if ( m.opacity < 1 ) {

  						transparencyNode += "<transparency><float>" + (m.opacity) + "</float></transparency>";

  					}

  				}

  				var techniqueNode = "<technique sid=\"common\"><" + type + ">" +

  					'<emission>' +

  					(
  						m.emissiveMap ?
  							'<texture texture="emissive-sampler" texcoord="TEXCOORD" />' :
  							("<color sid=\"emission\">" + (emissive.r) + " " + (emissive.g) + " " + (emissive.b) + " 1</color>")
  					) +

  					'</emission>' +

  					(
  						type !== 'constant' ?
  							'<diffuse>' +

  						(
  							m.map ?
  								'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />' :
  								("<color sid=\"diffuse\">" + (diffuse.r) + " " + (diffuse.g) + " " + (diffuse.b) + " 1</color>")
  						) +
  						'</diffuse>'
  							: ''
  					) +

  					(
  						type === 'phong' ?
  							"<specular><color sid=\"specular\">" + (specular.r) + " " + (specular.g) + " " + (specular.b) + " 1</color></specular>" +

  						'<shininess>' +

  						(
  							m.specularMap ?
  								'<texture texture="specular-sampler" texcoord="TEXCOORD" />' :
  								("<float sid=\"shininess\">" + shininess + "</float>")
  						) +

  						'</shininess>'
  							: ''
  					) +

  					"<reflective><color>" + (diffuse.r) + " " + (diffuse.g) + " " + (diffuse.b) + " 1</color></reflective>" +

  					"<reflectivity><float>" + reflectivity + "</float></reflectivity>" +

  					transparencyNode +

  					"</" + type + "></technique>";

  				var effectnode =
  					"<effect id=\"" + matid + "-effect\">" +
  					'<profile_COMMON>' +

  					(
  						m.map ?
  							'<newparam sid="diffuse-surface"><surface type="2D">' +
  							"<init_from>" + (processTexture( m.map )) + "</init_from>" +
  							'</surface></newparam>' +
  							'<newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :
  							''
  					) +

  					(
  						m.specularMap ?
  							'<newparam sid="specular-surface"><surface type="2D">' +
  							"<init_from>" + (processTexture( m.specularMap )) + "</init_from>" +
  							'</surface></newparam>' +
  							'<newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :
  							''
  					) +

  					(
  						m.emissiveMap ?
  							'<newparam sid="emissive-surface"><surface type="2D">' +
  							"<init_from>" + (processTexture( m.emissiveMap )) + "</init_from>" +
  							'</surface></newparam>' +
  							'<newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :
  							''
  					) +

  					techniqueNode +

  					(
  						m.side === DoubleSide ?
  							"<extra><technique><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>" :
  							''
  					) +

  					'</profile_COMMON>' +

  					'</effect>';

  				libraryMaterials.push( ("<material id=\"" + matid + "\" name=\"" + (m.name) + "\"><instance_effect url=\"#" + matid + "-effect\" /></material>") );
  				libraryEffects.push( effectnode );
  				materialMap.set( m, matid );

  			}

  			return matid;

  		}

  		// Recursively process the object into a scene
  		function processObject( o ) {

  			var node = "<node name=\"" + (o.name) + "\">";

  			node += getTransform( o );

  			if ( o instanceof Mesh && o.geometry != null ) {

  				// function returns the id associated with the mesh and a "BufferGeometry" version
  				// of the geometry in case it's not a geometry.
  				var geomInfo = processGeometry( o.geometry );
  				var meshid = geomInfo.meshid;
  				var geometry = geomInfo.bufferGeometry;

  				// ids of the materials to bind to the geometry
  				var matids = null;
  				var matidsArray = [];

  				// get a list of materials to bind to the sub groups of the geometry.
  				// If the amount of subgroups is greater than the materials, than reuse
  				// the materials.
  				var mat = o.material || new MeshBasicMaterial();
  				var materials = Array.isArray( mat ) ? mat : [ mat ];

  				if ( geometry.groups.length > materials.length ) {

  					matidsArray = new Array( geometry.groups.length );

  				} else {

  					matidsArray = new Array( materials.length );

  				}
  				matids = matidsArray.fill()
  					.map( function ( v, i ) { return processMaterial( materials[ i % materials.length ] ); } );

  				node +=
  					"<instance_geometry url=\"#" + meshid + "\">" +

  					(
  						matids != null ?
  							'<bind_material><technique_common>' +
  							matids.map( function ( id, i ) { return "<instance_material symbol=\"MESH_MATERIAL_" + i + "\" target=\"#" + id + "\" >" +

  								'<bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" />' +

  								'</instance_material>'; }
  							).join( '' ) +
  							'</technique_common></bind_material>' :
  							''
  					) +

  					'</instance_geometry>';

  			}

  			o.children.forEach( function (c) { return node += processObject( c ); } );

  			node += '</node>';

  			return node;

  		}

  		var geometryInfo = new WeakMap();
  		var materialMap = new WeakMap();
  		var imageMap = new WeakMap();
  		var textures = [];

  		var libraryImages = [];
  		var libraryGeometries = [];
  		var libraryEffects = [];
  		var libraryMaterials = [];
  		var libraryVisualScenes = processObject( object );

  		var specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';
  		var dae =
  			'<?xml version="1.0" encoding="UTF-8" standalone="no" ?>' +
  			"<COLLADA xmlns=\"" + specLink + "\" version=\"" + version + "\">" +
  			'<asset>' +
  			(
  				'<contributor>' +
  				'<authoring_tool>js Collada Exporter</authoring_tool>' +
  				( options.author !== null ? ("<author>" + (options.author) + "</author>") : '' ) +
  				'</contributor>' +
  				"<created>" + (( new Date() ).toISOString()) + "</created>" +
  				"<modified>" + (( new Date() ).toISOString()) + "</modified>" +
  				'<up_axis>Y_UP</up_axis>'
  			) +
  			'</asset>';

  		dae += "<library_images>" + (libraryImages.join( '' )) + "</library_images>";

  		dae += "<library_effects>" + (libraryEffects.join( '' )) + "</library_effects>";

  		dae += "<library_materials>" + (libraryMaterials.join( '' )) + "</library_materials>";

  		dae += "<library_geometries>" + (libraryGeometries.join( '' )) + "</library_geometries>";

  		dae += "<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">" + libraryVisualScenes + "</visual_scene></library_visual_scenes>";

  		dae += '<scene><instance_visual_scene url="#Scene"/></scene>';

  		dae += '</COLLADA>';

  		var res = {
  			data: format( dae ),
  			textures: textures
  		};

  		if ( typeof onDone === 'function' ) {

  			requestAnimationFrame( function () { return onDone( res ); } );

  		}

  		return res;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //------------------------------------------------------------------------------
  // Constants
  //------------------------------------------------------------------------------
  var WEBGL_CONSTANTS = {
  	POINTS: 0x0000,
  	LINES: 0x0001,
  	LINE_LOOP: 0x0002,
  	LINE_STRIP: 0x0003,
  	TRIANGLES: 0x0004,
  	TRIANGLE_STRIP: 0x0005,
  	TRIANGLE_FAN: 0x0006,

  	UNSIGNED_BYTE: 0x1401,
  	UNSIGNED_SHORT: 0x1403,
  	FLOAT: 0x1406,
  	UNSIGNED_INT: 0x1405,
  	ARRAY_BUFFER: 0x8892,
  	ELEMENT_ARRAY_BUFFER: 0x8893,

  	NEAREST: 0x2600,
  	LINEAR: 0x2601,
  	NEAREST_MIPMAP_NEAREST: 0x2700,
  	LINEAR_MIPMAP_NEAREST: 0x2701,
  	NEAREST_MIPMAP_LINEAR: 0x2702,
  	LINEAR_MIPMAP_LINEAR: 0x2703,

  	CLAMP_TO_EDGE: 33071,
  	MIRRORED_REPEAT: 33648,
  	REPEAT: 10497
  };

  var THREE_TO_WEBGL = {};

  THREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;
  THREE_TO_WEBGL[ NearestMipMapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
  THREE_TO_WEBGL[ NearestMipMapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
  THREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;
  THREE_TO_WEBGL[ LinearMipMapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
  THREE_TO_WEBGL[ LinearMipMapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;

  THREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
  THREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;
  THREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;

  var PATH_PROPERTIES = {
  	scale: 'scale',
  	position: 'translation',
  	quaternion: 'rotation',
  	morphTargetInfluences: 'weights'
  };

  //------------------------------------------------------------------------------
  // GLTF Exporter
  //------------------------------------------------------------------------------
  var GLTFExporter = function () {};

  GLTFExporter.prototype = {

  	constructor: GLTFExporter,
  	parse: function ( input, onDone, options ) {

  		var DEFAULT_OPTIONS = {
  			binary: false,
  			trs: false,
  			onlyVisible: true,
  			truncateDrawRange: true,
  			embedImages: true,
  			animations: [],
  			forceIndices: false,
  			forcePowerOfTwoTextures: false
  		};

  		options = Object.assign( {}, DEFAULT_OPTIONS, options );

  		if ( options.animations.length > 0 ) {

  			// Only TRS properties, and not matrices, may be targeted by animation.
  			options.trs = true;

  		}

  		var outputJSON = {

  			asset: {

  				version: "2.0",
  				generator: "GLTFExporter"

  			}

  		};

  		var byteOffset = 0;
  		var buffers = [];
  		var pending = [];
  		var nodeMap = new Map();
  		var skins = [];
  		var extensionsUsed = {};
  		var cachedData = {

  			meshes: new Map(),
  			attributes: new Map(),
  			attributesNormalized: new Map(),
  			materials: new Map(),
  			textures: new Map(),
  			images: new Map()

  		};

  		var cachedCanvas;
  		function equalArray( array1, array2 ) {

  			return ( array1.length === array2.length ) && array1.every( function ( element, index ) {

  				return element === array2[ index ];

  			} );

  		}
  		function stringToArrayBuffer( text ) {

  			if ( window.TextEncoder !== undefined ) {

  				return new TextEncoder().encode( text ).buffer;

  			}

  			var array = new Uint8Array( new ArrayBuffer( text.length ) );

  			for ( var i = 0, il = text.length; i < il; i ++ ) {

  				var value = text.charCodeAt( i );

  				// Replacing multi-byte character with space(0x20).
  				array[ i ] = value > 0xFF ? 0x20 : value;

  			}

  			return array.buffer;

  		}
  		function getMinMax( attribute, start, count ) {

  			var output = {

  				min: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),
  				max: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )

  			};

  			for ( var i = start; i < start + count; i ++ ) {

  				for ( var a = 0; a < attribute.itemSize; a ++ ) {

  					var value = attribute.array[ i * attribute.itemSize + a ];
  					output.min[ a ] = Math.min( output.min[ a ], value );
  					output.max[ a ] = Math.max( output.max[ a ], value );

  				}

  			}

  			return output;

  		}
  		function isPowerOfTwo( image ) {

  			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

  		}
  		function isNormalizedNormalAttribute( normal ) {

  			if ( cachedData.attributesNormalized.has( normal ) ) {

  				return false;

  			}

  			var v = new Vector3();

  			for ( var i = 0, il = normal.count; i < il; i ++ ) {

  				// 0.0005 is from glTF-validator
  				if ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) { return false; }

  			}

  			return true;

  		}
  		function createNormalizedNormalAttribute( normal ) {

  			if ( cachedData.attributesNormalized.has( normal ) ) {

  				return cachedData.attributesNormalized.get( normal );

  			}

  			var attribute = normal.clone();

  			var v = new Vector3();

  			for ( var i = 0, il = attribute.count; i < il; i ++ ) {

  				v.fromArray( attribute.array, i * 3 );

  				if ( v.x === 0 && v.y === 0 && v.z === 0 ) {

  					// if values can't be normalized set (1, 0, 0)
  					v.setX( 1.0 );

  				} else {

  					v.normalize();

  				}

  				v.toArray( attribute.array, i * 3 );

  			}

  			cachedData.attributesNormalized.set( normal, attribute );

  			return attribute;

  		}
  		function getPaddedBufferSize( bufferSize ) {

  			return Math.ceil( bufferSize / 4 ) * 4;

  		}
  		function getPaddedArrayBuffer( arrayBuffer, paddingByte ) {

  			paddingByte = paddingByte || 0;

  			var paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );

  			if ( paddedLength !== arrayBuffer.byteLength ) {

  				var array = new Uint8Array( paddedLength );
  				array.set( new Uint8Array( arrayBuffer ) );

  				if ( paddingByte !== 0 ) {

  					for ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {

  						array[ i ] = paddingByte;

  					}

  				}

  				return array.buffer;

  			}

  			return arrayBuffer;

  		}
  		function serializeUserData( object ) {

  			try {

  				return JSON.parse( JSON.stringify( object.userData ) );

  			} catch ( error ) {

  				console.warn( 'GLTFExporter: userData of \'' + object.name + '\' ' +
  					'won\'t be serialized because of JSON.stringify error - ' + error.message );

  				return {};

  			}

  		}
  		function applyTextureTransform( mapDef, texture ) {

  			var didTransform = false;
  			var transformDef = {};

  			if ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {

  				transformDef.offset = texture.offset.toArray();
  				didTransform = true;

  			}

  			if ( texture.rotation !== 0 ) {

  				transformDef.rotation = texture.rotation;
  				didTransform = true;

  			}

  			if ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {

  				transformDef.scale = texture.repeat.toArray();
  				didTransform = true;

  			}

  			if ( didTransform ) {

  				mapDef.extensions = mapDef.extensions || {};
  				mapDef.extensions[ 'KHR_texture_transform' ] = transformDef;
  				extensionsUsed[ 'KHR_texture_transform' ] = true;

  			}

  		}
  		function processBuffer( buffer ) {

  			if ( ! outputJSON.buffers ) {

  				outputJSON.buffers = [ { byteLength: 0 } ];

  			}

  			// All buffers are merged before export.
  			buffers.push( buffer );

  			return 0;

  		}
  		function processBufferView( attribute, componentType, start, count, target ) {

  			if ( ! outputJSON.bufferViews ) {

  				outputJSON.bufferViews = [];

  			}

  			// Create a new dataview and dump the attribute's array into it

  			var componentSize;

  			if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

  				componentSize = 1;

  			} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

  				componentSize = 2;

  			} else {

  				componentSize = 4;

  			}

  			var byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );
  			var dataView = new DataView( new ArrayBuffer( byteLength ) );
  			var offset = 0;

  			for ( var i = start; i < start + count; i ++ ) {

  				for ( var a = 0; a < attribute.itemSize; a ++ ) {

  					// @TODO Fails on InterleavedBufferAttribute, and could probably be
  					// optimized for normal BufferAttribute.
  					var value = attribute.array[ i * attribute.itemSize + a ];

  					if ( componentType === WEBGL_CONSTANTS.FLOAT ) {

  						dataView.setFloat32( offset, value, true );

  					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {

  						dataView.setUint32( offset, value, true );

  					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {

  						dataView.setUint16( offset, value, true );

  					} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {

  						dataView.setUint8( offset, value );

  					}

  					offset += componentSize;

  				}

  			}

  			var gltfBufferView = {

  				buffer: processBuffer( dataView.buffer ),
  				byteOffset: byteOffset,
  				byteLength: byteLength

  			};

  			if ( target !== undefined ) { gltfBufferView.target = target; }

  			if ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {

  				// Only define byteStride for vertex attributes.
  				gltfBufferView.byteStride = attribute.itemSize * componentSize;

  			}

  			byteOffset += byteLength;

  			outputJSON.bufferViews.push( gltfBufferView );

  			// @TODO Merge bufferViews where possible.
  			var output = {

  				id: outputJSON.bufferViews.length - 1,
  				byteLength: 0

  			};

  			return output;

  		}
  		function processBufferViewImage( blob ) {

  			if ( ! outputJSON.bufferViews ) {

  				outputJSON.bufferViews = [];

  			}

  			return new Promise( function ( resolve ) {

  				var reader = new window.FileReader();
  				reader.readAsArrayBuffer( blob );
  				reader.onloadend = function () {

  					var buffer = getPaddedArrayBuffer( reader.result );

  					var bufferView = {
  						buffer: processBuffer( buffer ),
  						byteOffset: byteOffset,
  						byteLength: buffer.byteLength
  					};

  					byteOffset += buffer.byteLength;

  					outputJSON.bufferViews.push( bufferView );

  					resolve( outputJSON.bufferViews.length - 1 );

  				};

  			} );

  		}
  		function processAccessor( attribute, geometry, start, count ) {

  			var types = {

  				1: 'SCALAR',
  				2: 'VEC2',
  				3: 'VEC3',
  				4: 'VEC4',
  				16: 'MAT4'

  			};

  			var componentType;

  			// Detect the component type of the attribute array (float, uint or ushort)
  			if ( attribute.array.constructor === Float32Array ) {

  				componentType = WEBGL_CONSTANTS.FLOAT;

  			} else if ( attribute.array.constructor === Uint32Array ) {

  				componentType = WEBGL_CONSTANTS.UNSIGNED_INT;

  			} else if ( attribute.array.constructor === Uint16Array ) {

  				componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;

  			} else if ( attribute.array.constructor === Uint8Array ) {

  				componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;

  			} else {

  				throw new Error( 'GLTFExporter: Unsupported bufferAttribute component type.' );

  			}

  			if ( start === undefined ) { start = 0; }
  			if ( count === undefined ) { count = attribute.count; }

  			// @TODO Indexed buffer geometry with drawRange not supported yet
  			if ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {

  				var end = start + count;
  				var end2 = geometry.drawRange.count === Infinity
  					? attribute.count
  					: geometry.drawRange.start + geometry.drawRange.count;

  				start = Math.max( start, geometry.drawRange.start );
  				count = Math.min( end, end2 ) - start;

  				if ( count < 0 ) { count = 0; }

  			}

  			// Skip creating an accessor if the attribute doesn't have data to export
  			if ( count === 0 ) {

  				return null;

  			}

  			var minMax = getMinMax( attribute, start, count );

  			var bufferViewTarget;

  			// If geometry isn't provided, don't infer the target usage of the bufferView. For
  			// animation samplers, target must not be set.
  			if ( geometry !== undefined ) {

  				bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;

  			}

  			var bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );

  			var gltfAccessor = {

  				bufferView: bufferView.id,
  				byteOffset: bufferView.byteOffset,
  				componentType: componentType,
  				count: count,
  				max: minMax.max,
  				min: minMax.min,
  				type: types[ attribute.itemSize ]

  			};

  			if ( ! outputJSON.accessors ) {

  				outputJSON.accessors = [];

  			}

  			outputJSON.accessors.push( gltfAccessor );

  			return outputJSON.accessors.length - 1;

  		}
  		function processImage( image, format, flipY ) {

  			if ( ! cachedData.images.has( image ) ) {

  				cachedData.images.set( image, {} );

  			}

  			var cachedImages = cachedData.images.get( image );
  			var mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';
  			var key = mimeType + ":flipY/" + flipY.toString();

  			if ( cachedImages[ key ] !== undefined ) {

  				return cachedImages[ key ];

  			}

  			if ( ! outputJSON.images ) {

  				outputJSON.images = [];

  			}

  			var gltfImage = { mimeType: mimeType };

  			if ( options.embedImages ) {

  				var canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );

  				canvas.width = image.width;
  				canvas.height = image.height;

  				if ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( image ) ) {

  					console.warn( 'GLTFExporter: Resized non-power-of-two image.', image );

  					canvas.width = _Math.floorPowerOfTwo( canvas.width );
  					canvas.height = _Math.floorPowerOfTwo( canvas.height );

  				}

  				var ctx = canvas.getContext( '2d' );

  				if ( flipY === true ) {

  					ctx.translate( 0, canvas.height );
  					ctx.scale( 1, - 1 );

  				}

  				ctx.drawImage( image, 0, 0, canvas.width, canvas.height );

  				if ( options.binary === true ) {

  					pending.push( new Promise( function ( resolve ) {

  						canvas.toBlob( function ( blob ) {

  							processBufferViewImage( blob ).then( function ( bufferViewIndex ) {

  								gltfImage.bufferView = bufferViewIndex;

  								resolve();

  							} );

  						}, mimeType );

  					} ) );

  				} else {

  					gltfImage.uri = canvas.toDataURL( mimeType );

  				}

  			} else {

  				gltfImage.uri = image.src;

  			}

  			outputJSON.images.push( gltfImage );

  			var index = outputJSON.images.length - 1;
  			cachedImages[ key ] = index;

  			return index;

  		}
  		function processSampler( map ) {

  			if ( ! outputJSON.samplers ) {

  				outputJSON.samplers = [];

  			}

  			var gltfSampler = {

  				magFilter: THREE_TO_WEBGL[ map.magFilter ],
  				minFilter: THREE_TO_WEBGL[ map.minFilter ],
  				wrapS: THREE_TO_WEBGL[ map.wrapS ],
  				wrapT: THREE_TO_WEBGL[ map.wrapT ]

  			};

  			outputJSON.samplers.push( gltfSampler );

  			return outputJSON.samplers.length - 1;

  		}
  		function processTexture( map ) {

  			if ( cachedData.textures.has( map ) ) {

  				return cachedData.textures.get( map );

  			}

  			if ( ! outputJSON.textures ) {

  				outputJSON.textures = [];

  			}

  			var gltfTexture = {

  				sampler: processSampler( map ),
  				source: processImage( map.image, map.format, map.flipY )

  			};

  			outputJSON.textures.push( gltfTexture );

  			var index = outputJSON.textures.length - 1;
  			cachedData.textures.set( map, index );

  			return index;

  		}
  		function processMaterial( material ) {

  			if ( cachedData.materials.has( material ) ) {

  				return cachedData.materials.get( material );

  			}

  			if ( ! outputJSON.materials ) {

  				outputJSON.materials = [];

  			}

  			if ( material.isShaderMaterial ) {

  				console.warn( 'GLTFExporter: ShaderMaterial not supported.' );
  				return null;

  			}

  			// @QUESTION Should we avoid including any attribute that has the default value?
  			var gltfMaterial = {

  				pbrMetallicRoughness: {}

  			};

  			if ( material.isMeshBasicMaterial ) {

  				gltfMaterial.extensions = { KHR_materials_unlit: {} };

  				extensionsUsed[ 'KHR_materials_unlit' ] = true;

  			} else if ( ! material.isMeshStandardMaterial ) {

  				console.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );

  			}

  			// pbrMetallicRoughness.baseColorFactor
  			var color = material.color.toArray().concat( [ material.opacity ] );

  			if ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {

  				gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;

  			}

  			if ( material.isMeshStandardMaterial ) {

  				gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;
  				gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;

  			} else if ( material.isMeshBasicMaterial ) {

  				gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;
  				gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;

  			} else {

  				gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
  				gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;

  			}

  			// pbrMetallicRoughness.metallicRoughnessTexture
  			if ( material.metalnessMap || material.roughnessMap ) {

  				if ( material.metalnessMap === material.roughnessMap ) {

  					var metalRoughMapDef = { index: processTexture( material.metalnessMap ) };
  					applyTextureTransform( metalRoughMapDef, material.metalnessMap );
  					gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;

  				} else {

  					console.warn( 'GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );

  				}

  			}

  			// pbrMetallicRoughness.baseColorTexture
  			if ( material.map ) {

  				var baseColorMapDef = { index: processTexture( material.map ) };
  				applyTextureTransform( baseColorMapDef, material.map );
  				gltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;

  			}

  			if ( material.isMeshBasicMaterial ||
  				material.isLineBasicMaterial ||
  				material.isPointsMaterial ) ; else {

  				// emissiveFactor
  				var emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();

  				if ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {

  					gltfMaterial.emissiveFactor = emissive;

  				}

  				// emissiveTexture
  				if ( material.emissiveMap ) {

  					var emissiveMapDef = { index: processTexture( material.emissiveMap ) };
  					applyTextureTransform( emissiveMapDef, material.emissiveMap );
  					gltfMaterial.emissiveTexture = emissiveMapDef;

  				}

  			}

  			// normalTexture
  			if ( material.normalMap ) {

  				var normalMapDef = { index: processTexture( material.normalMap ) };

  				if ( material.normalScale.x !== - 1 ) {

  					if ( material.normalScale.x !== material.normalScale.y ) {

  						console.warn( 'GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );

  					}

  					normalMapDef.scale = material.normalScale.x;

  				}

  				applyTextureTransform( normalMapDef, material.normalMap );

  				gltfMaterial.normalTexture = normalMapDef;

  			}

  			// occlusionTexture
  			if ( material.aoMap ) {

  				var occlusionMapDef = {
  					index: processTexture( material.aoMap ),
  					texCoord: 1
  				};

  				if ( material.aoMapIntensity !== 1.0 ) {

  					occlusionMapDef.strength = material.aoMapIntensity;

  				}

  				applyTextureTransform( occlusionMapDef, material.aoMap );

  				gltfMaterial.occlusionTexture = occlusionMapDef;

  			}

  			// alphaMode
  			if ( material.transparent || material.alphaTest > 0.0 ) {

  				gltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';

  				// Write alphaCutoff if it's non-zero and different from the default (0.5).
  				if ( material.alphaTest > 0.0 && material.alphaTest !== 0.5 ) {

  					gltfMaterial.alphaCutoff = material.alphaTest;

  				}

  			}

  			// doubleSided
  			if ( material.side === DoubleSide ) {

  				gltfMaterial.doubleSided = true;

  			}

  			if ( material.name !== '' ) {

  				gltfMaterial.name = material.name;

  			}

  			if ( Object.keys( material.userData ).length > 0 ) {

  				gltfMaterial.extras = serializeUserData( material );

  			}

  			outputJSON.materials.push( gltfMaterial );

  			var index = outputJSON.materials.length - 1;
  			cachedData.materials.set( material, index );

  			return index;

  		}
  		function processMesh( mesh ) {

  			var cacheKey = mesh.geometry.uuid + ':' + mesh.material.uuid;
  			if ( cachedData.meshes.has( cacheKey ) ) {

  				return cachedData.meshes.get( cacheKey );

  			}

  			var geometry = mesh.geometry;

  			var mode;

  			// Use the correct mode
  			if ( mesh.isLineSegments ) {

  				mode = WEBGL_CONSTANTS.LINES;

  			} else if ( mesh.isLineLoop ) {

  				mode = WEBGL_CONSTANTS.LINE_LOOP;

  			} else if ( mesh.isLine ) {

  				mode = WEBGL_CONSTANTS.LINE_STRIP;

  			} else if ( mesh.isPoints ) {

  				mode = WEBGL_CONSTANTS.POINTS;

  			} else {

  				if ( ! geometry.isBufferGeometry ) {

  					console.warn( 'GLTFExporter: Exporting Geometry will increase file size. Use BufferGeometry instead.' );

  					var geometryTemp = new BufferGeometry();
  					geometryTemp.fromGeometry( geometry );
  					geometry = geometryTemp;

  				}

  				if ( mesh.drawMode === TriangleFanDrawMode ) {

  					console.warn( 'GLTFExporter: TriangleFanDrawMode and wireframe incompatible.' );
  					mode = WEBGL_CONSTANTS.TRIANGLE_FAN;

  				} else if ( mesh.drawMode === TriangleStripDrawMode ) {

  					mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;

  				} else {

  					mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;

  				}

  			}

  			var gltfMesh = {};

  			var attributes = {};
  			var primitives = [];
  			var targets = [];

  			// Conversion between attributes names in threejs and gltf spec
  			var nameConversion = {

  				uv: 'TEXCOORD_0',
  				uv2: 'TEXCOORD_1',
  				color: 'COLOR_0',
  				skinWeight: 'WEIGHTS_0',
  				skinIndex: 'JOINTS_0'

  			};

  			var originalNormal = geometry.getAttribute( 'normal' );

  			if ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {

  				console.warn( 'GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );

  				geometry.addAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );

  			}

  			// @QUESTION Detect if .vertexColors = VertexColors?
  			// For every attribute create an accessor
  			var modifiedAttribute = null;
  			for ( var attributeName in geometry.attributes ) {

  				var attribute = geometry.attributes[ attributeName ];
  				attributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();

  				if ( cachedData.attributes.has( attribute ) ) {

  					attributes[ attributeName ] = cachedData.attributes.get( attribute );
  					continue;

  				}

  				// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
  				modifiedAttribute = null;
  				var array = attribute.array;
  				if ( attributeName === 'JOINTS_0' &&
  					! ( array instanceof Uint16Array ) &&
  					! ( array instanceof Uint8Array ) ) {

  					console.warn( 'GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.' );
  					modifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );

  				}

  				if ( attributeName.substr( 0, 5 ) !== 'MORPH' ) {

  					var accessor = processAccessor( modifiedAttribute || attribute, geometry );
  					if ( accessor !== null ) {

  						attributes[ attributeName ] = accessor;
  						cachedData.attributes.set( attribute, accessor );

  					}

  				}

  			}

  			if ( originalNormal !== undefined ) { geometry.addAttribute( 'normal', originalNormal ); }

  			// Skip if no exportable attributes found
  			if ( Object.keys( attributes ).length === 0 ) {

  				return null;

  			}

  			// Morph targets
  			if ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {

  				var weights = [];
  				var targetNames = [];
  				var reverseDictionary = {};

  				if ( mesh.morphTargetDictionary !== undefined ) {

  					for ( var key in mesh.morphTargetDictionary ) {

  						reverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;

  					}

  				}

  				for ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {

  					var target = {};

  					var warned = false;

  					for ( var attributeName in geometry.morphAttributes ) {

  						// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
  						// Three.js doesn't support TANGENT yet.

  						if ( attributeName !== 'position' && attributeName !== 'normal' ) {

  							if ( ! warned ) {

  								console.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );
  								warned = true;

  							}

  							continue;

  						}

  						var attribute = geometry.morphAttributes[ attributeName ][ i ];
  						var gltfAttributeName = attributeName.toUpperCase();

  						// Three.js morph attribute has absolute values while the one of glTF has relative values.
  						//
  						// glTF 2.0 Specification:
  						// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

  						var baseAttribute = geometry.attributes[ attributeName ];

  						if ( cachedData.attributes.has( attribute ) ) {

  							target[ gltfAttributeName ] = cachedData.attributes.get( attribute );
  							continue;

  						}

  						// Clones attribute not to override
  						var relativeAttribute = attribute.clone();

  						for ( var j = 0, jl = attribute.count; j < jl; j ++ ) {

  							relativeAttribute.setXYZ(
  								j,
  								attribute.getX( j ) - baseAttribute.getX( j ),
  								attribute.getY( j ) - baseAttribute.getY( j ),
  								attribute.getZ( j ) - baseAttribute.getZ( j )
  							);

  						}

  						target[ gltfAttributeName ] = processAccessor( relativeAttribute, geometry );
  						cachedData.attributes.set( baseAttribute, target[ gltfAttributeName ] );

  					}

  					targets.push( target );

  					weights.push( mesh.morphTargetInfluences[ i ] );
  					if ( mesh.morphTargetDictionary !== undefined ) { targetNames.push( reverseDictionary[ i ] ); }

  				}

  				gltfMesh.weights = weights;

  				if ( targetNames.length > 0 ) {

  					gltfMesh.extras = {};
  					gltfMesh.extras.targetNames = targetNames;

  				}

  			}

  			var extras = ( Object.keys( geometry.userData ).length > 0 ) ? serializeUserData( geometry ) : undefined;

  			var forceIndices = options.forceIndices;
  			var isMultiMaterial = Array.isArray( mesh.material );

  			if ( isMultiMaterial && geometry.groups.length === 0 ) { return null; }

  			if ( ! forceIndices && geometry.index === null && isMultiMaterial ) {

  				// temporal workaround.
  				console.warn( 'GLTFExporter: Creating index for non-indexed multi-material mesh.' );
  				forceIndices = true;

  			}

  			var didForceIndices = false;

  			if ( geometry.index === null && forceIndices ) {

  				var indices = [];

  				for ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {

  					indices[ i ] = i;

  				}

  				geometry.setIndex( indices );

  				didForceIndices = true;

  			}

  			var materials = isMultiMaterial ? mesh.material : [ mesh.material ];
  			var groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];

  			for ( var i = 0, il = groups.length; i < il; i ++ ) {

  				var primitive = {
  					mode: mode,
  					attributes: attributes,
  				};

  				if ( extras ) { primitive.extras = extras; }

  				if ( targets.length > 0 ) { primitive.targets = targets; }

  				if ( geometry.index !== null ) {

  					if ( cachedData.attributes.has( geometry.index ) ) {

  						primitive.indices = cachedData.attributes.get( geometry.index );

  					} else {

  						primitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );
  						cachedData.attributes.set( geometry.index, primitive.indices );

  					}

  				}

  				var material = processMaterial( materials[ groups[ i ].materialIndex ] );

  				if ( material !== null ) {

  					primitive.material = material;

  				}

  				primitives.push( primitive );

  			}

  			if ( didForceIndices ) {

  				geometry.setIndex( null );

  			}

  			gltfMesh.primitives = primitives;

  			if ( ! outputJSON.meshes ) {

  				outputJSON.meshes = [];

  			}

  			outputJSON.meshes.push( gltfMesh );

  			var index = outputJSON.meshes.length - 1;
  			cachedData.meshes.set( cacheKey, index );

  			return index;

  		}
  		function processCamera( camera ) {

  			if ( ! outputJSON.cameras ) {

  				outputJSON.cameras = [];

  			}

  			var isOrtho = camera.isOrthographicCamera;

  			var gltfCamera = {

  				type: isOrtho ? 'orthographic' : 'perspective'

  			};

  			if ( isOrtho ) {

  				gltfCamera.orthographic = {

  					xmag: camera.right * 2,
  					ymag: camera.top * 2,
  					zfar: camera.far <= 0 ? 0.001 : camera.far,
  					znear: camera.near < 0 ? 0 : camera.near

  				};

  			} else {

  				gltfCamera.perspective = {

  					aspectRatio: camera.aspect,
  					yfov: _Math.degToRad( camera.fov ),
  					zfar: camera.far <= 0 ? 0.001 : camera.far,
  					znear: camera.near < 0 ? 0 : camera.near

  				};

  			}

  			if ( camera.name !== '' ) {

  				gltfCamera.name = camera.type;

  			}

  			outputJSON.cameras.push( gltfCamera );

  			return outputJSON.cameras.length - 1;

  		}
  		function processAnimation( clip, root ) {

  			if ( ! outputJSON.animations ) {

  				outputJSON.animations = [];

  			}

  			clip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );

  			var tracks = clip.tracks;
  			var channels = [];
  			var samplers = [];

  			for ( var i = 0; i < tracks.length; ++ i ) {

  				var track = tracks[ i ];
  				var trackBinding = PropertyBinding.parseTrackName( track.name );
  				var trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );
  				var trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];

  				if ( trackBinding.objectName === 'bones' ) {

  					if ( trackNode.isSkinnedMesh === true ) {

  						trackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );

  					} else {

  						trackNode = undefined;

  					}

  				}

  				if ( ! trackNode || ! trackProperty ) {

  					console.warn( 'GLTFExporter: Could not export animation track "%s".', track.name );
  					return null;

  				}

  				var inputItemSize = 1;
  				var outputItemSize = track.values.length / track.times.length;

  				if ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {

  					outputItemSize /= trackNode.morphTargetInfluences.length;

  				}

  				var interpolation;

  				// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

  				// Detecting glTF cubic spline interpolant by checking factory method's special property
  				// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
  				// valid value from .getInterpolation().
  				if ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {

  					interpolation = 'CUBICSPLINE';

  					// itemSize of CUBICSPLINE keyframe is 9
  					// (VEC3 * 3: inTangent, splineVertex, and outTangent)
  					// but needs to be stored as VEC3 so dividing by 3 here.
  					outputItemSize /= 3;

  				} else if ( track.getInterpolation() === InterpolateDiscrete ) {

  					interpolation = 'STEP';

  				} else {

  					interpolation = 'LINEAR';

  				}

  				samplers.push( {

  					input: processAccessor( new BufferAttribute( track.times, inputItemSize ) ),
  					output: processAccessor( new BufferAttribute( track.values, outputItemSize ) ),
  					interpolation: interpolation

  				} );

  				channels.push( {

  					sampler: samplers.length - 1,
  					target: {
  						node: nodeMap.get( trackNode ),
  						path: trackProperty
  					}

  				} );

  			}

  			outputJSON.animations.push( {

  				name: clip.name || 'clip_' + outputJSON.animations.length,
  				samplers: samplers,
  				channels: channels

  			} );

  			return outputJSON.animations.length - 1;

  		}

  		function processSkin( object ) {

  			var node = outputJSON.nodes[ nodeMap.get( object ) ];

  			var skeleton = object.skeleton;
  			var rootJoint = object.skeleton.bones[ 0 ];

  			if ( rootJoint === undefined ) { return null; }

  			var joints = [];
  			var inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );

  			for ( var i = 0; i < skeleton.bones.length; ++ i ) {

  				joints.push( nodeMap.get( skeleton.bones[ i ] ) );

  				skeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );

  			}

  			if ( outputJSON.skins === undefined ) {

  				outputJSON.skins = [];

  			}

  			outputJSON.skins.push( {

  				inverseBindMatrices: processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),
  				joints: joints,
  				skeleton: nodeMap.get( rootJoint )

  			} );

  			var skinIndex = node.skin = outputJSON.skins.length - 1;

  			return skinIndex;

  		}

  		function processLight( light ) {

  			var lightDef = {};

  			if ( light.name ) { lightDef.name = light.name; }

  			lightDef.color = light.color.toArray();

  			lightDef.intensity = light.intensity;

  			if ( light.isDirectionalLight ) {

  				lightDef.type = 'directional';

  			} else if ( light.isPointLight ) {

  				lightDef.type = 'point';
  				if ( light.distance > 0 ) { lightDef.range = light.distance; }

  			} else if ( light.isSpotLight ) {

  				lightDef.type = 'spot';
  				if ( light.distance > 0 ) { lightDef.range = light.distance; }
  				lightDef.spot = {};
  				lightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;
  				lightDef.spot.outerConeAngle = light.angle;

  			}

  			if ( light.decay !== undefined && light.decay !== 2 ) {

  				console.warn( 'GLTFExporter: Light decay may be lost. glTF is physically-based, '
  					+ 'and expects light.decay=2.' );

  			}

  			if ( light.target
  					&& ( light.target.parent !== light
  					 || light.target.position.x !== 0
  					 || light.target.position.y !== 0
  					 || light.target.position.z !== - 1 ) ) {

  				console.warn( 'GLTFExporter: Light direction may be lost. For best results, '
  					+ 'make light.target a child of the light with position 0,0,-1.' );

  			}

  			var lights = outputJSON.extensions[ 'KHR_lights_punctual' ].lights;
  			lights.push( lightDef );
  			return lights.length - 1;

  		}
  		function processNode( object ) {

  			if ( ! outputJSON.nodes ) {

  				outputJSON.nodes = [];

  			}

  			var gltfNode = {};

  			if ( options.trs ) {

  				var rotation = object.quaternion.toArray();
  				var position = object.position.toArray();
  				var scale = object.scale.toArray();

  				if ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {

  					gltfNode.rotation = rotation;

  				}

  				if ( ! equalArray( position, [ 0, 0, 0 ] ) ) {

  					gltfNode.translation = position;

  				}

  				if ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {

  					gltfNode.scale = scale;

  				}

  			} else {

  				object.updateMatrix();
  				if ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {

  					gltfNode.matrix = object.matrix.elements;

  				}

  			}

  			// We don't export empty strings name because it represents no-name in Three.js.
  			if ( object.name !== '' ) {

  				gltfNode.name = String( object.name );

  			}

  			if ( object.userData && Object.keys( object.userData ).length > 0 ) {

  				gltfNode.extras = serializeUserData( object );

  			}

  			if ( object.isMesh || object.isLine || object.isPoints ) {

  				var mesh = processMesh( object );

  				if ( mesh !== null ) {

  					gltfNode.mesh = mesh;

  				}

  			} else if ( object.isCamera ) {

  				gltfNode.camera = processCamera( object );

  			} else if ( object.isDirectionalLight || object.isPointLight || object.isSpotLight ) {

  				if ( ! extensionsUsed[ 'KHR_lights_punctual' ] ) {

  					outputJSON.extensions = outputJSON.extensions || {};
  					outputJSON.extensions[ 'KHR_lights_punctual' ] = { lights: [] };
  					extensionsUsed[ 'KHR_lights_punctual' ] = true;

  				}

  				gltfNode.extensions = gltfNode.extensions || {};
  				gltfNode.extensions[ 'KHR_lights_punctual' ] = { light: processLight( object ) };

  			} else if ( object.isLight ) {

  				console.warn( 'GLTFExporter: Only directional, point, and spot lights are supported.' );
  				return null;

  			}

  			if ( object.isSkinnedMesh ) {

  				skins.push( object );

  			}

  			if ( object.children.length > 0 ) {

  				var children = [];

  				for ( var i = 0, l = object.children.length; i < l; i ++ ) {

  					var child = object.children[ i ];

  					if ( child.visible || options.onlyVisible === false ) {

  						var node = processNode( child );

  						if ( node !== null ) {

  							children.push( node );

  						}

  					}

  				}

  				if ( children.length > 0 ) {

  					gltfNode.children = children;

  				}
  			}

  			outputJSON.nodes.push( gltfNode );

  			var nodeIndex = outputJSON.nodes.length - 1;
  			nodeMap.set( object, nodeIndex );

  			return nodeIndex;

  		}
  		function processScene( scene ) {

  			if ( ! outputJSON.scenes ) {

  				outputJSON.scenes = [];
  				outputJSON.scene = 0;

  			}

  			var gltfScene = {

  				nodes: []

  			};

  			if ( scene.name !== '' ) {

  				gltfScene.name = scene.name;

  			}

  			if ( scene.userData && Object.keys( scene.userData ).length > 0 ) {

  				gltfScene.extras = serializeUserData( scene );

  			}

  			outputJSON.scenes.push( gltfScene );

  			var nodes = [];

  			for ( var i = 0, l = scene.children.length; i < l; i ++ ) {

  				var child = scene.children[ i ];

  				if ( child.visible || options.onlyVisible === false ) {

  					var node = processNode( child );

  					if ( node !== null ) {

  						nodes.push( node );

  					}

  				}

  			}

  			if ( nodes.length > 0 ) {

  				gltfScene.nodes = nodes;

  			}

  		}
  		function processObjects( objects ) {

  			var scene = new Scene();
  			scene.name = 'AuxScene';

  			for ( var i = 0; i < objects.length; i ++ ) {

  				// We push directly to children instead of calling `add` to prevent
  				// modify the .parent and break its original scene and hierarchy
  				scene.children.push( objects[ i ] );

  			}

  			processScene( scene );

  		}

  		function processInput( input ) {

  			input = input instanceof Array ? input : [ input ];

  			var objectsWithoutScene = [];

  			for ( var i = 0; i < input.length; i ++ ) {

  				if ( input[ i ] instanceof Scene ) {

  					processScene( input[ i ] );

  				} else {

  					objectsWithoutScene.push( input[ i ] );

  				}

  			}

  			if ( objectsWithoutScene.length > 0 ) {

  				processObjects( objectsWithoutScene );

  			}

  			for ( var i = 0; i < skins.length; ++ i ) {

  				processSkin( skins[ i ] );

  			}

  			for ( var i = 0; i < options.animations.length; ++ i ) {

  				processAnimation( options.animations[ i ], input[ 0 ] );

  			}

  		}

  		processInput( input );

  		Promise.all( pending ).then( function () {

  			// Merge buffers.
  			var blob = new Blob( buffers, { type: 'application/octet-stream' } );

  			// Declare extensions.
  			var extensionsUsedList = Object.keys( extensionsUsed );
  			if ( extensionsUsedList.length > 0 ) { outputJSON.extensionsUsed = extensionsUsedList; }

  			if ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {

  				// Update bytelength of the single buffer.
  				outputJSON.buffers[ 0 ].byteLength = blob.size;

  				var reader = new window.FileReader();

  				if ( options.binary === true ) {

  					// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

  					var GLB_HEADER_BYTES = 12;
  					var GLB_HEADER_MAGIC = 0x46546C67;
  					var GLB_VERSION = 2;

  					var GLB_CHUNK_PREFIX_BYTES = 8;
  					var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
  					var GLB_CHUNK_TYPE_BIN = 0x004E4942;

  					reader.readAsArrayBuffer( blob );
  					reader.onloadend = function () {

  						// Binary chunk.
  						var binaryChunk = getPaddedArrayBuffer( reader.result );
  						var binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  						binaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );
  						binaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );

  						// JSON chunk.
  						var jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );
  						var jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );
  						jsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );
  						jsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );

  						// GLB header.
  						var header = new ArrayBuffer( GLB_HEADER_BYTES );
  						var headerView = new DataView( header );
  						headerView.setUint32( 0, GLB_HEADER_MAGIC, true );
  						headerView.setUint32( 4, GLB_VERSION, true );
  						var totalByteLength = GLB_HEADER_BYTES
  							+ jsonChunkPrefix.byteLength + jsonChunk.byteLength
  							+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;
  						headerView.setUint32( 8, totalByteLength, true );

  						var glbBlob = new Blob( [
  							header,
  							jsonChunkPrefix,
  							jsonChunk,
  							binaryChunkPrefix,
  							binaryChunk
  						], { type: 'application/octet-stream' } );

  						var glbReader = new window.FileReader();
  						glbReader.readAsArrayBuffer( glbBlob );
  						glbReader.onloadend = function () {

  							onDone( glbReader.result );

  						};

  					};

  				} else {

  					reader.readAsDataURL( blob );
  					reader.onloadend = function () {

  						var base64data = reader.result;
  						outputJSON.buffers[ 0 ].uri = base64data;
  						onDone( outputJSON );

  					};

  				}

  			} else {

  				onDone( outputJSON );

  			}

  		} );

  	}

  };

  GLTFExporter.Utils = {

  	insertKeyframe: function ( track, time ) {

  		var tolerance = 0.001; // 1ms
  		var valueSize = track.getValueSize();

  		var times = new track.TimeBufferType( track.times.length + 1 );
  		var values = new track.ValueBufferType( track.values.length + valueSize );
  		var interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );

  		var index;

  		if ( track.times.length === 0 ) {

  			times[ 0 ] = time;

  			for ( var i = 0; i < valueSize; i ++ ) {

  				values[ i ] = 0;

  			}

  			index = 0;

  		} else if ( time < track.times[ 0 ] ) {

  			if ( Math.abs( track.times[ 0 ] - time ) < tolerance ) { return 0; }

  			times[ 0 ] = time;
  			times.set( track.times, 1 );

  			values.set( interpolant.evaluate( time ), 0 );
  			values.set( track.values, valueSize );

  			index = 0;

  		} else if ( time > track.times[ track.times.length - 1 ] ) {

  			if ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {

  				return track.times.length - 1;

  			}

  			times[ times.length - 1 ] = time;
  			times.set( track.times, 0 );

  			values.set( track.values, 0 );
  			values.set( interpolant.evaluate( time ), track.values.length );

  			index = times.length - 1;

  		} else {

  			for ( var i = 0; i < track.times.length; i ++ ) {

  				if ( Math.abs( track.times[ i ] - time ) < tolerance ) { return i; }

  				if ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {

  					times.set( track.times.slice( 0, i + 1 ), 0 );
  					times[ i + 1 ] = time;
  					times.set( track.times.slice( i + 1 ), i + 2 );

  					values.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );
  					values.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );
  					values.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );

  					index = i + 1;

  					break;

  				}

  			}

  		}

  		track.times = times;
  		track.values = values;

  		return index;

  	},

  	mergeMorphTargetTracks: function ( clip, root ) {
  		var this$1 = this;


  		var tracks = [];
  		var mergedTracks = {};
  		var sourceTracks = clip.tracks;

  		for ( var i = 0; i < sourceTracks.length; ++ i ) {

  			var sourceTrack = sourceTracks[ i ];
  			var sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );
  			var sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );

  			if ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {

  				// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.
  				tracks.push( sourceTrack );
  				continue;

  			}

  			if ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete
  				&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {

  				if ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

  					// This should never happen, because glTF morph target animations
  					// affect all targets already.
  					throw new Error( 'GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );

  				}

  				console.warn( 'GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );

  				sourceTrack = sourceTrack.clone();
  				sourceTrack.setInterpolation( InterpolateLinear );

  			}

  			var targetCount = sourceTrackNode.morphTargetInfluences.length;
  			var targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];

  			if ( targetIndex === undefined ) {

  				throw new Error( 'GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );

  			}

  			var mergedTrack;

  			// If this is the first time we've seen this object, create a new
  			// track to store merged keyframe data for each morph target.
  			if ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {

  				mergedTrack = sourceTrack.clone();

  				var values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );

  				for ( var j = 0; j < mergedTrack.times.length; j ++ ) {

  					values[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];

  				}

  				mergedTrack.name = '.morphTargetInfluences';
  				mergedTrack.values = values;

  				mergedTracks[ sourceTrackNode.uuid ] = mergedTrack;
  				tracks.push( mergedTrack );

  				continue;

  			}
  			var sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );

  			mergedTrack = mergedTracks[ sourceTrackNode.uuid ];

  			// For every existing keyframe of the merged track, write a (possibly
  			// interpolated) value from the source track.
  			for ( var j = 0; j < mergedTrack.times.length; j ++ ) {

  				mergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );

  			}

  			// For every existing keyframe of the source track, write a (possibly
  			// new) keyframe to the merged track. Values from the previous loop may
  			// be written again, but keyframes are de-duplicated.
  			for ( var j = 0; j < sourceTrack.times.length; j ++ ) {

  				var keyframeIndex = this$1.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );
  				mergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];

  			}

  		}

  		clip.tracks = tracks;

  		return clip;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MMDExporter = function () {

  	// Unicode to Shift_JIS table
  	var u2sTable;

  	function unicodeToShiftjis( str ) {

  		if ( u2sTable === undefined ) {

  			var encoder = new MMDParser.CharsetEncoder();
  			var table = encoder.s2uTable;
  			u2sTable = {};

  			var keys = Object.keys( table );

  			for ( var i = 0, il = keys.length; i < il; i ++ ) {

  				var key = keys[ i ];

  				var value = table[ key ];
  				key = parseInt( key );

  				u2sTable[ value ] = key;

  			}

  		}

  		var array = [];

  		for ( var i = 0, il = str.length; i < il; i ++ ) {

  			var code = str.charCodeAt( i );

  			var value = u2sTable[ code ];

  			if ( value === undefined ) {

  				throw 'cannot convert charcode 0x' + code.toString( 16 );

  			} else if ( value > 0xff ) {

  				array.push( ( value >> 8 ) & 0xff );
  				array.push( value & 0xff );

  			} else {

  				array.push( value & 0xff );

  			}

  		}

  		return new Uint8Array( array );

  	}

  	function getBindBones( skin ) {

  		// any more efficient ways?
  		var poseSkin = skin.clone();
  		poseSkin.pose();
  		return poseSkin.skeleton.bones;

  	}
  	this.parseVpd = function ( skin, outputShiftJis, useOriginalBones ) {

  		if ( skin.isSkinnedMesh !== true ) {

  			console.warn( 'MMDExporter: parseVpd() requires SkinnedMesh instance.' );
  			return null;

  		}

  		function toStringsFromNumber( num ) {

  			if ( Math.abs( num ) < 1e-6 ) { num = 0; }

  			var a = num.toString();

  			if ( a.indexOf( '.' ) === - 1 ) {

  				a += '.';

  			}

  			a += '000000';

  			var index = a.indexOf( '.' );

  			var d = a.slice( 0, index );
  			var p = a.slice( index + 1, index + 7 );

  			return d + '.' + p;

  		}

  		function toStringsFromArray( array ) {

  			var a = [];

  			for ( var i = 0, il = array.length; i < il; i ++ ) {

  				a.push( toStringsFromNumber( array[ i ] ) );

  			}

  			return a.join( ',' );

  		}

  		skin.updateMatrixWorld( true );

  		var bones = skin.skeleton.bones;
  		var bones2 = getBindBones( skin );

  		var position = new Vector3();
  		var quaternion = new Quaternion();
  		var quaternion2 = new Quaternion();
  		var matrix = new Matrix4();

  		var array = [];
  		array.push( 'Vocaloid Pose Data file' );
  		array.push( '' );
  		array.push( ( skin.name !== '' ? skin.name.replace( /\s/g, '_' ) : 'skin' ) + '.osm;' );
  		array.push( bones.length + ';' );
  		array.push( '' );

  		for ( var i = 0, il = bones.length; i < il; i ++ ) {

  			var bone = bones[ i ];
  			var bone2 = bones2[ i ];
  			if ( useOriginalBones === true &&
  				bone.userData.ik !== undefined &&
  				bone.userData.ik.originalMatrix !== undefined ) {

  				matrix.fromArray( bone.userData.ik.originalMatrix );

  			} else {

  				matrix.copy( bone.matrix );

  			}

  			position.setFromMatrixPosition( matrix );
  			quaternion.setFromRotationMatrix( matrix );

  			var pArray = position.sub( bone2.position ).toArray();
  			var qArray = quaternion2.copy( bone2.quaternion ).conjugate().multiply( quaternion ).toArray();

  			// right to left
  			pArray[ 2 ] = - pArray[ 2 ];
  			qArray[ 0 ] = - qArray[ 0 ];
  			qArray[ 1 ] = - qArray[ 1 ];

  			array.push( 'Bone' + i + '{' + bone.name );
  			array.push( '  ' + toStringsFromArray( pArray ) + ';' );
  			array.push( '  ' + toStringsFromArray( qArray ) + ';' );
  			array.push( '}' );
  			array.push( '' );

  		}

  		array.push( '' );

  		var lines = array.join( '\n' );

  		return ( outputShiftJis === true ) ? unicodeToShiftjis( lines ) : lines;

  	};
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var OBJExporter = function () {};

  OBJExporter.prototype = {

  	constructor: OBJExporter,

  	parse: function ( object ) {

  		var output = '';

  		var indexVertex = 0;
  		var indexVertexUvs = 0;
  		var indexNormals = 0;

  		var vertex = new Vector3();
  		var normal = new Vector3();
  		var uv = new Vector2();

  		var i, j, k, l, m, face = [];

  		var parseMesh = function ( mesh ) {

  			var nbVertex = 0;
  			var nbNormals = 0;
  			var nbVertexUvs = 0;

  			var geometry = mesh.geometry;

  			var normalMatrixWorld = new Matrix3();

  			if ( geometry instanceof Geometry ) {

  				geometry = new BufferGeometry().setFromObject( mesh );

  			}

  			if ( geometry instanceof BufferGeometry ) {

  				// shortcuts
  				var vertices = geometry.getAttribute( 'position' );
  				var normals = geometry.getAttribute( 'normal' );
  				var uvs = geometry.getAttribute( 'uv' );
  				var indices = geometry.getIndex();

  				// name of the mesh object
  				output += 'o ' + mesh.name + '\n';

  				// name of the mesh material
  				if ( mesh.material && mesh.material.name ) {

  					output += 'usemtl ' + mesh.material.name + '\n';

  				}

  				// vertices

  				if ( vertices !== undefined ) {

  					for ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

  						vertex.x = vertices.getX( i );
  						vertex.y = vertices.getY( i );
  						vertex.z = vertices.getZ( i );

  						// transfrom the vertex to world space
  						vertex.applyMatrix4( mesh.matrixWorld );

  						// transform the vertex to export format
  						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

  					}

  				}

  				// uvs

  				if ( uvs !== undefined ) {

  					for ( i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {

  						uv.x = uvs.getX( i );
  						uv.y = uvs.getY( i );

  						// transform the uv to export format
  						output += 'vt ' + uv.x + ' ' + uv.y + '\n';

  					}

  				}

  				// normals

  				if ( normals !== undefined ) {

  					normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

  					for ( i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {

  						normal.x = normals.getX( i );
  						normal.y = normals.getY( i );
  						normal.z = normals.getZ( i );

  						// transfrom the normal to world space
  						normal.applyMatrix3( normalMatrixWorld );

  						// transform the normal to export format
  						output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';

  					}

  				}

  				// faces

  				if ( indices !== null ) {

  					for ( i = 0, l = indices.count; i < l; i += 3 ) {

  						for ( m = 0; m < 3; m ++ ) {

  							j = indices.getX( i + m ) + 1;

  							face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );

  						}

  						// transform the face to export format
  						output += 'f ' + face.join( ' ' ) + "\n";

  					}

  				} else {

  					for ( i = 0, l = vertices.count; i < l; i += 3 ) {

  						for ( m = 0; m < 3; m ++ ) {

  							j = i + m + 1;

  							face[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );

  						}

  						// transform the face to export format
  						output += 'f ' + face.join( ' ' ) + "\n";

  					}

  				}

  			} else {

  				console.warn( 'OBJExporter.parseMesh(): geometry type unsupported', geometry );

  			}

  			// update index
  			indexVertex += nbVertex;
  			indexVertexUvs += nbVertexUvs;
  			indexNormals += nbNormals;

  		};

  		var parseLine = function ( line ) {

  			var nbVertex = 0;

  			var geometry = line.geometry;
  			var type = line.type;

  			if ( geometry instanceof Geometry ) {

  				geometry = new BufferGeometry().setFromObject( line );

  			}

  			if ( geometry instanceof BufferGeometry ) {

  				// shortcuts
  				var vertices = geometry.getAttribute( 'position' );

  				// name of the line object
  				output += 'o ' + line.name + '\n';

  				if ( vertices !== undefined ) {

  					for ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {

  						vertex.x = vertices.getX( i );
  						vertex.y = vertices.getY( i );
  						vertex.z = vertices.getZ( i );

  						// transfrom the vertex to world space
  						vertex.applyMatrix4( line.matrixWorld );

  						// transform the vertex to export format
  						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';

  					}

  				}

  				if ( type === 'Line' ) {

  					output += 'l ';

  					for ( j = 1, l = vertices.count; j <= l; j ++ ) {

  						output += ( indexVertex + j ) + ' ';

  					}

  					output += '\n';

  				}

  				if ( type === 'LineSegments' ) {

  					for ( j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {

  						output += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\n';

  					}

  				}

  			} else {

  				console.warn( 'OBJExporter.parseLine(): geometry type unsupported', geometry );

  			}

  			// update index
  			indexVertex += nbVertex;

  		};

  		object.traverse( function ( child ) {

  			if ( child instanceof Mesh ) {

  				parseMesh( child );

  			}

  			if ( child instanceof Line ) {

  				parseLine( child );

  			}

  		} );

  		return output;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PLYExporter = function () {};

  PLYExporter.prototype = {

  	constructor: PLYExporter,

  	parse: function ( object, onDone, options ) {

  		if ( onDone && typeof onDone === 'object' ) {

  			console.warn( 'PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.' );
  			options = onDone;
  			onDone = undefined;

  		}

  		// Iterate over the valid meshes in the object
  		function traverseMeshes( cb ) {

  			object.traverse( function ( child ) {

  				if ( child.isMesh === true ) {

  					var mesh = child;
  					var geometry = mesh.geometry;

  					if ( geometry.isGeometry === true ) {

  						geometry = geomToBufferGeom.get( geometry );

  					}

  					if ( geometry.isBufferGeometry === true ) {

  						if ( geometry.getAttribute( 'position' ) !== undefined ) {

  							cb( mesh, geometry );

  						}

  					}

  				}

  			} );

  		}

  		// Default options
  		var defaultOptions = {
  			binary: false,
  			excludeAttributes: [] // normal, uv, color, index
  		};

  		options = Object.assign( defaultOptions, options );

  		var excludeAttributes = options.excludeAttributes;
  		var geomToBufferGeom = new WeakMap();
  		var includeNormals = false;
  		var includeColors = false;
  		var includeUVs = false;

  		// count the vertices, check which properties are used,
  		// and cache the BufferGeometry
  		var vertexCount = 0;
  		var faceCount = 0;
  		object.traverse( function ( child ) {

  			if ( child.isMesh === true ) {

  				var mesh = child;
  				var geometry = mesh.geometry;

  				if ( geometry.isGeometry === true ) {

  					var bufferGeometry = geomToBufferGeom.get( geometry ) || new BufferGeometry().setFromObject( mesh );
  					geomToBufferGeom.set( geometry, bufferGeometry );
  					geometry = bufferGeometry;

  				}

  				if ( geometry.isBufferGeometry === true ) {

  					var vertices = geometry.getAttribute( 'position' );
  					var normals = geometry.getAttribute( 'normal' );
  					var uvs = geometry.getAttribute( 'uv' );
  					var colors = geometry.getAttribute( 'color' );
  					var indices = geometry.getIndex();

  					if ( vertices === undefined ) {

  						return;

  					}

  					vertexCount += vertices.count;
  					faceCount += indices ? indices.count / 3 : vertices.count / 3;

  					if ( normals !== undefined ) { includeNormals = true; }

  					if ( uvs !== undefined ) { includeUVs = true; }

  					if ( colors !== undefined ) { includeColors = true; }

  				}

  			}

  		} );

  		var includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;
  		includeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;
  		includeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;
  		includeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;
  		if ( includeIndices && faceCount !== Math.floor( faceCount ) ) {

  			// point cloud meshes will not have an index array and may not have a
  			// number of vertices that is divisble by 3 (and therefore representable
  			// as triangles)
  			console.error(

  				'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +
  				'number of indices is not divisible by 3.'

  			);

  			return null;

  		}

  		// get how many bytes will be needed to save out the faces
  		// so we can use a minimal amount of memory / data
  		var indexByteCount = 1;

  		if ( vertexCount > 256 ) { // 2^8 bits

  			indexByteCount = 2;

  		}

  		if ( vertexCount > 65536 ) { // 2^16 bits

  			indexByteCount = 4;

  		}
  		var header =
  			'ply\n' +
  			"format " + (options.binary ? 'binary_big_endian' : 'ascii') + " 1.0\n" +
  			"element vertex " + vertexCount + "\n" +

  			// position
  			'property float x\n' +
  			'property float y\n' +
  			'property float z\n';

  		if ( includeNormals === true ) {

  			// normal
  			header +=
  				'property float nx\n' +
  				'property float ny\n' +
  				'property float nz\n';

  		}

  		if ( includeUVs === true ) {

  			// uvs
  			header +=
  				'property float s\n' +
  				'property float t\n';

  		}

  		if ( includeColors === true ) {

  			// colors
  			header +=
  				'property uchar red\n' +
  				'property uchar green\n' +
  				'property uchar blue\n';

  		}

  		if ( includeIndices === true ) {

  			// faces
  			header +=
  				"element face " + faceCount + "\n" +
  				"property list uchar uint" + (indexByteCount * 8) + " vertex_index\n";

  		}

  		header += 'end_header\n';
  		// Generate attribute data
  		var vertex = new Vector3();
  		var normalMatrixWorld = new Matrix3();
  		var result = null;

  		if ( options.binary === true ) {

  			// Binary File Generation
  			var headerBin = new TextEncoder().encode( header );

  			// 3 position values at 4 bytes
  			// 3 normal values at 4 bytes
  			// 3 color channels with 1 byte
  			// 2 uv values at 4 bytes
  			var vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );

  			// 1 byte shape desciptor
  			// 3 vertex indices at ${indexByteCount} bytes
  			var faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;
  			var output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );
  			new Uint8Array( output.buffer ).set( headerBin, 0 );
  			var vOffset = headerBin.length;
  			var fOffset = headerBin.length + vertexListLength;
  			var writtenVertices = 0;
  			traverseMeshes( function ( mesh, geometry ) {

  				var vertices = geometry.getAttribute( 'position' );
  				var normals = geometry.getAttribute( 'normal' );
  				var uvs = geometry.getAttribute( 'uv' );
  				var colors = geometry.getAttribute( 'color' );
  				var indices = geometry.getIndex();

  				normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

  				for ( var i = 0, l = vertices.count; i < l; i ++ ) {

  					vertex.x = vertices.getX( i );
  					vertex.y = vertices.getY( i );
  					vertex.z = vertices.getZ( i );

  					vertex.applyMatrix4( mesh.matrixWorld );
  					// Position information
  					output.setFloat32( vOffset, vertex.x );
  					vOffset += 4;

  					output.setFloat32( vOffset, vertex.y );
  					vOffset += 4;

  					output.setFloat32( vOffset, vertex.z );
  					vOffset += 4;

  					// Normal information
  					if ( includeNormals === true ) {

  						if ( normals != null ) {

  							vertex.x = normals.getX( i );
  							vertex.y = normals.getY( i );
  							vertex.z = normals.getZ( i );

  							vertex.applyMatrix3( normalMatrixWorld );

  							output.setFloat32( vOffset, vertex.x );
  							vOffset += 4;

  							output.setFloat32( vOffset, vertex.y );
  							vOffset += 4;

  							output.setFloat32( vOffset, vertex.z );
  							vOffset += 4;

  						} else {

  							output.setFloat32( vOffset, 0 );
  							vOffset += 4;

  							output.setFloat32( vOffset, 0 );
  							vOffset += 4;

  							output.setFloat32( vOffset, 0 );
  							vOffset += 4;

  						}

  					}

  					// UV information
  					if ( includeUVs === true ) {

  						if ( uvs != null ) {

  							output.setFloat32( vOffset, uvs.getX( i ) );
  							vOffset += 4;

  							output.setFloat32( vOffset, uvs.getY( i ) );
  							vOffset += 4;

  						} else if ( includeUVs !== false ) {

  							output.setFloat32( vOffset, 0 );
  							vOffset += 4;

  							output.setFloat32( vOffset, 0 );
  							vOffset += 4;

  						}

  					}

  					// Color information
  					if ( includeColors === true ) {

  						if ( colors != null ) {

  							output.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );
  							vOffset += 1;

  							output.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );
  							vOffset += 1;

  							output.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );
  							vOffset += 1;

  						} else {

  							output.setUint8( vOffset, 255 );
  							vOffset += 1;

  							output.setUint8( vOffset, 255 );
  							vOffset += 1;

  							output.setUint8( vOffset, 255 );
  							vOffset += 1;

  						}

  					}

  				}

  				if ( includeIndices === true ) {

  					// Create the face list
  					var faceIndexFunc = "setUint" + (indexByteCount * 8);
  					if ( indices !== null ) {

  						for ( var i = 0, l = indices.count; i < l; i += 3 ) {

  							output.setUint8( fOffset, 3 );
  							fOffset += 1;

  							output[ faceIndexFunc ]( fOffset, indices.getX( i + 0 ) + writtenVertices );
  							fOffset += indexByteCount;

  							output[ faceIndexFunc ]( fOffset, indices.getX( i + 1 ) + writtenVertices );
  							fOffset += indexByteCount;

  							output[ faceIndexFunc ]( fOffset, indices.getX( i + 2 ) + writtenVertices );
  							fOffset += indexByteCount;

  						}

  					} else {

  						for ( var i = 0, l = vertices.count; i < l; i += 3 ) {

  							output.setUint8( fOffset, 3 );
  							fOffset += 1;

  							output[ faceIndexFunc ]( fOffset, writtenVertices + i );
  							fOffset += indexByteCount;

  							output[ faceIndexFunc ]( fOffset, writtenVertices + i + 1 );
  							fOffset += indexByteCount;

  							output[ faceIndexFunc ]( fOffset, writtenVertices + i + 2 );
  							fOffset += indexByteCount;

  						}

  					}

  				}
  				// Save the amount of verts we've already written so we can offset
  				// the face index on the next mesh
  				writtenVertices += vertices.count;

  			} );

  			result = output.buffer;

  		} else {

  			// Ascii File Generation
  			// count the number of vertices
  			var writtenVertices = 0;
  			var vertexList = '';
  			var faceList = '';

  			traverseMeshes( function ( mesh, geometry ) {

  				var vertices = geometry.getAttribute( 'position' );
  				var normals = geometry.getAttribute( 'normal' );
  				var uvs = geometry.getAttribute( 'uv' );
  				var colors = geometry.getAttribute( 'color' );
  				var indices = geometry.getIndex();

  				normalMatrixWorld.getNormalMatrix( mesh.matrixWorld );

  				// form each line
  				for ( var i = 0, l = vertices.count; i < l; i ++ ) {

  					vertex.x = vertices.getX( i );
  					vertex.y = vertices.getY( i );
  					vertex.z = vertices.getZ( i );

  					vertex.applyMatrix4( mesh.matrixWorld );
  					// Position information
  					var line =
  						vertex.x + ' ' +
  						vertex.y + ' ' +
  						vertex.z;

  					// Normal information
  					if ( includeNormals === true ) {

  						if ( normals != null ) {

  							vertex.x = normals.getX( i );
  							vertex.y = normals.getY( i );
  							vertex.z = normals.getZ( i );

  							vertex.applyMatrix3( normalMatrixWorld );

  							line += ' ' +
  								vertex.x + ' ' +
  								vertex.y + ' ' +
  								vertex.z;

  						} else {

  							line += ' 0 0 0';

  						}

  					}

  					// UV information
  					if ( includeUVs === true ) {

  						if ( uvs != null ) {

  							line += ' ' +
  								uvs.getX( i ) + ' ' +
  								uvs.getY( i );

  						} else if ( includeUVs !== false ) {

  							line += ' 0 0';

  						}

  					}

  					// Color information
  					if ( includeColors === true ) {

  						if ( colors != null ) {

  							line += ' ' +
  								Math.floor( colors.getX( i ) * 255 ) + ' ' +
  								Math.floor( colors.getY( i ) * 255 ) + ' ' +
  								Math.floor( colors.getZ( i ) * 255 );

  						} else {

  							line += ' 255 255 255';

  						}

  					}

  					vertexList += line + '\n';

  				}

  				// Create the face list
  				if ( includeIndices === true ) {

  					if ( indices !== null ) {

  						for ( var i = 0, l = indices.count; i < l; i += 3 ) {

  							faceList += "3 " + (indices.getX( i + 0 ) + writtenVertices);
  							faceList += " " + (indices.getX( i + 1 ) + writtenVertices);
  							faceList += " " + (indices.getX( i + 2 ) + writtenVertices) + "\n";

  						}

  					} else {

  						for ( var i = 0, l = vertices.count; i < l; i += 3 ) {

  							faceList += "3 " + (writtenVertices + i) + " " + (writtenVertices + i + 1) + " " + (writtenVertices + i + 2) + "\n";

  						}

  					}

  					faceCount += indices ? indices.count / 3 : vertices.count / 3;

  				}

  				writtenVertices += vertices.count;

  			} );

  			result = "" + header + vertexList + "\n" + (includeIndices ? (faceList + "\n") : '');

  		}

  		if ( typeof onDone === 'function' ) { requestAnimationFrame( function () { return onDone( result ); } ); }
  		return result;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var STLExporter = function () {};

  STLExporter.prototype = {

  	constructor: STLExporter,

  	parse: ( function () {

  		var vector = new Vector3();
  		var normalMatrixWorld = new Matrix3();

  		return function parse( scene, options ) {

  			if ( options === undefined ) { options = {}; }

  			var binary = options.binary !== undefined ? options.binary : false;

  			//

  			var objects = [];
  			var triangles = 0;

  			scene.traverse( function ( object ) {

  				if ( object.isMesh ) {

  					var geometry = object.geometry;

  					if ( geometry.isBufferGeometry ) {

  						geometry = new Geometry().fromBufferGeometry( geometry );

  					}

  					if ( geometry.isGeometry ) {

  						triangles += geometry.faces.length;

  						objects.push( {

  							geometry: geometry,
  							matrixWorld: object.matrixWorld

  						} );

  					}

  				}

  			} );

  			if ( binary ) {

  				var offset = 80; // skip header
  				var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
  				var arrayBuffer = new ArrayBuffer( bufferLength );
  				var output = new DataView( arrayBuffer );
  				output.setUint32( offset, triangles, true ); offset += 4;

  				for ( var i = 0, il = objects.length; i < il; i ++ ) {

  					var object = objects[ i ];

  					var vertices = object.geometry.vertices;
  					var faces = object.geometry.faces;
  					var matrixWorld = object.matrixWorld;

  					normalMatrixWorld.getNormalMatrix( matrixWorld );

  					for ( var j = 0, jl = faces.length; j < jl; j ++ ) {

  						var face = faces[ j ];

  						vector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();

  						output.setFloat32( offset, vector.x, true ); offset += 4; // normal
  						output.setFloat32( offset, vector.y, true ); offset += 4;
  						output.setFloat32( offset, vector.z, true ); offset += 4;

  						var indices = [ face.a, face.b, face.c ];

  						for ( var k = 0; k < 3; k ++ ) {

  							vector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );

  							output.setFloat32( offset, vector.x, true ); offset += 4; // vertices
  							output.setFloat32( offset, vector.y, true ); offset += 4;
  							output.setFloat32( offset, vector.z, true ); offset += 4;

  						}

  						output.setUint16( offset, 0, true ); offset += 2; // attribute byte count

  					}

  				}

  				return output;

  			} else {

  				var output = '';

  				output += 'solid exported\n';

  				for ( var i = 0, il = objects.length; i < il; i ++ ) {

  					var object = objects[ i ];

  					var vertices = object.geometry.vertices;
  					var faces = object.geometry.faces;
  					var matrixWorld = object.matrixWorld;

  					normalMatrixWorld.getNormalMatrix( matrixWorld );

  					for ( var j = 0, jl = faces.length; j < jl; j ++ ) {

  						var face = faces[ j ];

  						vector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();

  						output += '\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
  						output += '\t\touter loop\n';

  						var indices = [ face.a, face.b, face.c ];

  						for ( var k = 0; k < 3; k ++ ) {

  							vector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );

  							output += '\t\t\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';

  						}

  						output += '\t\tendloop\n';
  						output += '\tendfacet\n';

  					}

  				}

  				output += 'endsolid exported\n';

  				return output;

  			}

  		};

  	}() )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TypedGeometryExporter = function () {};

  TypedGeometryExporter.prototype = {

  	constructor: TypedGeometryExporter,

  	parse: function ( geometry ) {

  		var output = {
  			metadata: {
  				version: 4.0,
  				type: 'TypedGeometry',
  				generator: 'TypedGeometryExporter'
  			}
  		};

  		var attributes = [ 'vertices', 'normals', 'uvs' ];

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];

  			var typedArray = geometry[ attribute ];
  			var array = [];

  			for ( var i = 0, l = typedArray.length; i < l; i ++ ) {

  				array[ i ] = typedArray[ i ];

  			}

  			output[ attribute ] = array;

  		}

  		var boundingSphere = geometry.boundingSphere;

  		if ( boundingSphere !== null ) {

  			output.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return output;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BoxLineGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	BufferGeometry.call( this );

  	width = width || 1;
  	height = height || 1;
  	depth = depth || 1;

  	widthSegments = Math.floor( widthSegments ) || 1;
  	heightSegments = Math.floor( heightSegments ) || 1;
  	depthSegments = Math.floor( depthSegments ) || 1;

  	var widthHalf = width / 2;
  	var heightHalf = height / 2;
  	var depthHalf = depth / 2;

  	var segmentWidth = width / widthSegments;
  	var segmentHeight = height / heightSegments;
  	var segmentDepth = depth / depthSegments;

  	var vertices = [];

  	var x = - widthHalf, y = - heightHalf, z = - depthHalf;

  	for ( var i = 0; i <= widthSegments; i ++ ) {

  		vertices.push( x, - heightHalf, - depthHalf, x,   heightHalf, - depthHalf );
  		vertices.push( x,   heightHalf, - depthHalf, x,   heightHalf,   depthHalf );
  		vertices.push( x,   heightHalf,   depthHalf, x, - heightHalf,   depthHalf );
  		vertices.push( x, - heightHalf,   depthHalf, x, - heightHalf, - depthHalf );

  		x += segmentWidth;

  	}

  	for ( var i = 0; i <= heightSegments; i ++ ) {

  		vertices.push( - widthHalf, y, - depthHalf,   widthHalf, y, - depthHalf );
  		vertices.push(   widthHalf, y, - depthHalf,   widthHalf, y,   depthHalf );
  		vertices.push(   widthHalf, y,   depthHalf, - widthHalf, y,   depthHalf );
  		vertices.push( - widthHalf, y,   depthHalf, - widthHalf, y, - depthHalf );

  		y += segmentHeight;

  	}

  	for ( var i = 0; i <= depthSegments; i ++ ) {

  		vertices.push( - widthHalf, - heightHalf, z, - widthHalf,   heightHalf, z );
  		vertices.push( - widthHalf,   heightHalf, z,   widthHalf,   heightHalf, z );
  		vertices.push(   widthHalf,   heightHalf, z,   widthHalf, - heightHalf, z );
  		vertices.push(   widthHalf, - heightHalf, z, - widthHalf, - heightHalf, z );

  		z += segmentDepth;

  	}

  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  };

  BoxLineGeometry.prototype = Object.create( BufferGeometry.prototype );
  BoxLineGeometry.prototype.constructor = BoxLineGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	function DecalGeometry( mesh, position, orientation, size ) {

  		BufferGeometry.call( this );

  		// buffers

  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helpers

  		var plane = new Vector3();

  		// this matrix represents the transformation of the decal projector

  		var projectorMatrix = new Matrix4();
  		projectorMatrix.makeRotationFromEuler( orientation );
  		projectorMatrix.setPosition( position );

  		var projectorMatrixInverse = new Matrix4().getInverse( projectorMatrix );

  		// generate buffers

  		generate();

  		// build geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function generate() {

  			var i;
  			var geometry = new BufferGeometry();
  			var decalVertices = [];

  			var vertex = new Vector3();
  			var normal = new Vector3();

  			// handle different geometry types

  			if ( mesh.geometry.isGeometry ) {

  				geometry.fromGeometry( mesh.geometry );

  			} else {

  				geometry.copy( mesh.geometry );

  			}

  			var positionAttribute = geometry.attributes.position;
  			var normalAttribute = geometry.attributes.normal;

  			// first, create an array of 'DecalVertex' objects
  			// three consecutive 'DecalVertex' objects represent a single face
  			//
  			// this data structure will be later used to perform the clipping

  			if ( geometry.index !== null ) {

  				// indexed BufferGeometry

  				var index = geometry.index;

  				for ( i = 0; i < index.count; i ++ ) {

  					vertex.fromBufferAttribute( positionAttribute, index.getX( i ) );
  					normal.fromBufferAttribute( normalAttribute, index.getX( i ) );

  					pushDecalVertex( decalVertices, vertex, normal );

  				}

  			} else {

  				// non-indexed BufferGeometry

  				for ( i = 0; i < positionAttribute.count; i ++ ) {

  					vertex.fromBufferAttribute( positionAttribute, i );
  					normal.fromBufferAttribute( normalAttribute, i );

  					pushDecalVertex( decalVertices, vertex, normal );

  				}

  			}

  			// second, clip the geometry so that it doesn't extend out from the projector

  			decalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );
  			decalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );
  			decalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );
  			decalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );
  			decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );
  			decalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );

  			// third, generate final vertices, normals and uvs

  			for ( i = 0; i < decalVertices.length; i ++ ) {

  				var decalVertex = decalVertices[ i ];

  				// create texture coordinates (we are still in projector space)

  				uvs.push(
  					0.5 + ( decalVertex.position.x / size.x ),
  					0.5 + ( decalVertex.position.y / size.y )
  				);

  				// transform the vertex back to world space

  				decalVertex.position.applyMatrix4( projectorMatrix );

  				// now create vertex and normal buffer data

  				vertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );
  				normals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );

  			}

  		}

  		function pushDecalVertex( decalVertices, vertex, normal ) {

  			// transform the vertex to world space, then to projector space

  			vertex.applyMatrix4( mesh.matrixWorld );
  			vertex.applyMatrix4( projectorMatrixInverse );

  			decalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );

  		}

  		function clipGeometry( inVertices, plane ) {

  			var outVertices = [];

  			var s = 0.5 * Math.abs( size.dot( plane ) );

  			// a single iteration clips one face,
  			// which consists of three consecutive 'DecalVertex' objects

  			for ( var i = 0; i < inVertices.length; i += 3 ) {

  				var v1Out, v2Out, v3Out, total = 0;
  				var nV1, nV2, nV3, nV4;

  				var d1 = inVertices[ i + 0 ].position.dot( plane ) - s;
  				var d2 = inVertices[ i + 1 ].position.dot( plane ) - s;
  				var d3 = inVertices[ i + 2 ].position.dot( plane ) - s;

  				v1Out = d1 > 0;
  				v2Out = d2 > 0;
  				v3Out = d3 > 0;

  				// calculate, how many vertices of the face lie outside of the clipping plane

  				total = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );

  				switch ( total ) {

  					case 0: {

  						// the entire face lies inside of the plane, no clipping needed

  						outVertices.push( inVertices[ i ] );
  						outVertices.push( inVertices[ i + 1 ] );
  						outVertices.push( inVertices[ i + 2 ] );
  						break;

  					}

  					case 1: {

  						// one vertex lies outside of the plane, perform clipping

  						if ( v1Out ) {

  							nV1 = inVertices[ i + 1 ];
  							nV2 = inVertices[ i + 2 ];
  							nV3 = clip( inVertices[ i ], nV1, plane, s );
  							nV4 = clip( inVertices[ i ], nV2, plane, s );

  						}

  						if ( v2Out ) {

  							nV1 = inVertices[ i ];
  							nV2 = inVertices[ i + 2 ];
  							nV3 = clip( inVertices[ i + 1 ], nV1, plane, s );
  							nV4 = clip( inVertices[ i + 1 ], nV2, plane, s );

  							outVertices.push( nV3 );
  							outVertices.push( nV2.clone() );
  							outVertices.push( nV1.clone() );

  							outVertices.push( nV2.clone() );
  							outVertices.push( nV3.clone() );
  							outVertices.push( nV4 );
  							break;

  						}

  						if ( v3Out ) {

  							nV1 = inVertices[ i ];
  							nV2 = inVertices[ i + 1 ];
  							nV3 = clip( inVertices[ i + 2 ], nV1, plane, s );
  							nV4 = clip( inVertices[ i + 2 ], nV2, plane, s );

  						}

  						outVertices.push( nV1.clone() );
  						outVertices.push( nV2.clone() );
  						outVertices.push( nV3 );

  						outVertices.push( nV4 );
  						outVertices.push( nV3.clone() );
  						outVertices.push( nV2.clone() );

  						break;

  					}

  					case 2: {

  						// two vertices lies outside of the plane, perform clipping

  						if ( ! v1Out ) {

  							nV1 = inVertices[ i ].clone();
  							nV2 = clip( nV1, inVertices[ i + 1 ], plane, s );
  							nV3 = clip( nV1, inVertices[ i + 2 ], plane, s );
  							outVertices.push( nV1 );
  							outVertices.push( nV2 );
  							outVertices.push( nV3 );

  						}

  						if ( ! v2Out ) {

  							nV1 = inVertices[ i + 1 ].clone();
  							nV2 = clip( nV1, inVertices[ i + 2 ], plane, s );
  							nV3 = clip( nV1, inVertices[ i ], plane, s );
  							outVertices.push( nV1 );
  							outVertices.push( nV2 );
  							outVertices.push( nV3 );

  						}

  						if ( ! v3Out ) {

  							nV1 = inVertices[ i + 2 ].clone();
  							nV2 = clip( nV1, inVertices[ i ], plane, s );
  							nV3 = clip( nV1, inVertices[ i + 1 ], plane, s );
  							outVertices.push( nV1 );
  							outVertices.push( nV2 );
  							outVertices.push( nV3 );

  						}

  						break;

  					}

  					case 3: {

  						// the entire face lies outside of the plane, so let's discard the corresponding vertices

  						break;

  					}

  				}

  			}

  			return outVertices;

  		}

  		function clip( v0, v1, p, s ) {

  			var d0 = v0.position.dot( p ) - s;
  			var d1 = v1.position.dot( p ) - s;

  			var s0 = d0 / ( d0 - d1 );

  			var v = new DecalVertex(
  				new Vector3(
  					v0.position.x + s0 * ( v1.position.x - v0.position.x ),
  					v0.position.y + s0 * ( v1.position.y - v0.position.y ),
  					v0.position.z + s0 * ( v1.position.z - v0.position.z )
  				),
  				new Vector3(
  					v0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),
  					v0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),
  					v0.normal.z + s0 * ( v1.normal.z - v0.normal.z )
  				)
  			);

  			// need to clip more values (texture coordinates)? do it this way:
  			// intersectpoint.value = a.value + s * ( b.value - a.value );

  			return v;

  		}

  	}

  	DecalGeometry.prototype = Object.create( BufferGeometry.prototype );
  	DecalGeometry.prototype.constructor = DecalGeometry;

  	// helper

  	function DecalVertex( position, normal ) {

  		this.position = position;
  		this.normal = normal;

  	}

  	DecalVertex.prototype.clone = function () {

  		return new DecalVertex( this.position.clone(), this.normal.clone() );

  	};

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function hilbert2D( center, size, iterations, v0, v1, v2, v3 ) {

  	// Default Vars
  	var center = center !== undefined ? center : new Vector3( 0, 0, 0 ),
  		size = size !== undefined ? size : 10,
  		half = size / 2,
  		iterations = iterations !== undefined ? iterations : 1,
  		v0 = v0 !== undefined ? v0 : 0,
  		v1 = v1 !== undefined ? v1 : 1,
  		v2 = v2 !== undefined ? v2 : 2,
  		v3 = v3 !== undefined ? v3 : 3
  	;

  	var vec_s = [
  		new Vector3( center.x - half, center.y, center.z - half ),
  		new Vector3( center.x - half, center.y, center.z + half ),
  		new Vector3( center.x + half, center.y, center.z + half ),
  		new Vector3( center.x + half, center.y, center.z - half )
  	];

  	var vec = [
  		vec_s[ v0 ],
  		vec_s[ v1 ],
  		vec_s[ v2 ],
  		vec_s[ v3 ]
  	];

  	// Recurse iterations
  	if ( 0 <= -- iterations ) {

  		var tmp = [];

  		Array.prototype.push.apply( tmp, hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ) );
  		Array.prototype.push.apply( tmp, hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ) );
  		Array.prototype.push.apply( tmp, hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ) );
  		Array.prototype.push.apply( tmp, hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 ) );

  		// Return recursive call
  		return tmp;

  	}

  	// Return complete Hilbert Curve.
  	return vec;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function hilbert3D( center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7 ) {

  	// Default Vars
  	var center = center !== undefined ? center : new Vector3( 0, 0, 0 ),
  		size = size !== undefined ? size : 10,
  		half = size / 2,
  		iterations = iterations !== undefined ? iterations : 1,
  		v0 = v0 !== undefined ? v0 : 0,
  		v1 = v1 !== undefined ? v1 : 1,
  		v2 = v2 !== undefined ? v2 : 2,
  		v3 = v3 !== undefined ? v3 : 3,
  		v4 = v4 !== undefined ? v4 : 4,
  		v5 = v5 !== undefined ? v5 : 5,
  		v6 = v6 !== undefined ? v6 : 6,
  		v7 = v7 !== undefined ? v7 : 7
  	;

  	var vec_s = [
  		new Vector3( center.x - half, center.y + half, center.z - half ),
  		new Vector3( center.x - half, center.y + half, center.z + half ),
  		new Vector3( center.x - half, center.y - half, center.z + half ),
  		new Vector3( center.x - half, center.y - half, center.z - half ),
  		new Vector3( center.x + half, center.y - half, center.z - half ),
  		new Vector3( center.x + half, center.y - half, center.z + half ),
  		new Vector3( center.x + half, center.y + half, center.z + half ),
  		new Vector3( center.x + half, center.y + half, center.z - half )
  	];

  	var vec = [
  		vec_s[ v0 ],
  		vec_s[ v1 ],
  		vec_s[ v2 ],
  		vec_s[ v3 ],
  		vec_s[ v4 ],
  		vec_s[ v5 ],
  		vec_s[ v6 ],
  		vec_s[ v7 ]
  	];

  	// Recurse iterations
  	if ( -- iterations >= 0 ) {

  		var tmp = [];

  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );
  		Array.prototype.push.apply( tmp, hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 ) );

  		// Return recursive call
  		return tmp;

  	}

  	// Return complete Hilbert Curve.
  	return vec;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Ported from Stefan Gustavson's java implementation
  // http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
  // Read Stefan's excellent paper for details on how this code works.
  //
  // Sean McCullough banksean@gmail.com
  //
  // Added 4D noise
  // Joshua Koo zz85nus@gmail.com 
  var SimplexNoise = function(r) {
  	var this$1 = this;

  	if (r == undefined) { r = Math; }
  	this.grad3 = [[ 1,1,0 ],[ -1,1,0 ],[ 1,-1,0 ],[ -1,-1,0 ], 
                                   [ 1,0,1 ],[ -1,0,1 ],[ 1,0,-1 ],[ -1,0,-1 ], 
                                   [ 0,1,1 ],[ 0,-1,1 ],[ 0,1,-1 ],[ 0,-1,-1 ]]; 

  	this.grad4 = [[ 0,1,1,1 ], [ 0,1,1,-1 ], [ 0,1,-1,1 ], [ 0,1,-1,-1 ],
  	     [ 0,-1,1,1 ], [ 0,-1,1,-1 ], [ 0,-1,-1,1 ], [ 0,-1,-1,-1 ],
  	     [ 1,0,1,1 ], [ 1,0,1,-1 ], [ 1,0,-1,1 ], [ 1,0,-1,-1 ],
  	     [ -1,0,1,1 ], [ -1,0,1,-1 ], [ -1,0,-1,1 ], [ -1,0,-1,-1 ],
  	     [ 1,1,0,1 ], [ 1,1,0,-1 ], [ 1,-1,0,1 ], [ 1,-1,0,-1 ],
  	     [ -1,1,0,1 ], [ -1,1,0,-1 ], [ -1,-1,0,1 ], [ -1,-1,0,-1 ],
  	     [ 1,1,1,0 ], [ 1,1,-1,0 ], [ 1,-1,1,0 ], [ 1,-1,-1,0 ],
  	     [ -1,1,1,0 ], [ -1,1,-1,0 ], [ -1,-1,1,0 ], [ -1,-1,-1,0 ]];

  	this.p = [];
  	for (var i = 0; i < 256; i ++) {
  		this$1.p[i] = Math.floor(r.random() * 256);
  	}
    // To remove the need for index wrapping, double the permutation table length 
  	this.perm = []; 
  	for (var i = 0; i < 512; i ++) {
  		this$1.perm[i] = this$1.p[i & 255];
  	} 

    // A lookup table to traverse the simplex around a given point in 4D. 
    // Details can be found where this table is used, in the 4D noise method. 
  	this.simplex = [ 
      [ 0,1,2,3 ],[ 0,1,3,2 ],[ 0,0,0,0 ],[ 0,2,3,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,2,3,0 ], 
      [ 0,2,1,3 ],[ 0,0,0,0 ],[ 0,3,1,2 ],[ 0,3,2,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,3,2,0 ], 
      [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], 
      [ 1,2,0,3 ],[ 0,0,0,0 ],[ 1,3,0,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,3,0,1 ],[ 2,3,1,0 ], 
      [ 1,0,2,3 ],[ 1,0,3,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,0,3,1 ],[ 0,0,0,0 ],[ 2,1,3,0 ], 
      [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], 
      [ 2,0,1,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,0,1,2 ],[ 3,0,2,1 ],[ 0,0,0,0 ],[ 3,1,2,0 ], 
      [ 2,1,0,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,1,0,2 ],[ 0,0,0,0 ],[ 3,2,0,1 ],[ 3,2,1,0 ]]; 
  };

  SimplexNoise.prototype.dot = function(g, x, y) { 
  	return g[0] * x + g[1] * y;
  };

  SimplexNoise.prototype.dot3 = function(g, x, y, z) {
  	return g[0] * x + g[1] * y + g[2] * z; 
  };

  SimplexNoise.prototype.dot4 = function(g, x, y, z, w) {
  	return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
  };

  SimplexNoise.prototype.noise = function(xin, yin) { 
  	var n0, n1, n2; // Noise contributions from the three corners 
    // Skew the input space to determine which simplex cell we're in 
  	var F2 = 0.5 * (Math.sqrt(3.0) - 1.0); 
  	var s = (xin + yin) * F2; // Hairy factor for 2D 
  	var i = Math.floor(xin + s); 
  	var j = Math.floor(yin + s); 
  	var G2 = (3.0 - Math.sqrt(3.0)) / 6.0; 
  	var t = (i + j) * G2; 
  	var X0 = i - t; // Unskew the cell origin back to (x,y) space 
  	var Y0 = j - t; 
  	var x0 = xin - X0; // The x,y distances from the cell origin 
  	var y0 = yin - Y0; 
    // For the 2D case, the simplex shape is an equilateral triangle. 
    // Determine which simplex we are in. 
  	var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords 
  	if (x0 > y0) {i1 = 1; j1 = 0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) 
  	else {i1 = 0; j1 = 1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) 
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and 
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where 
    // c = (3-sqrt(3))/6 
  	var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords 
  	var y1 = y0 - j1 + G2; 
  	var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords 
  	var y2 = y0 - 1.0 + 2.0 * G2; 
    // Work out the hashed gradient indices of the three simplex corners 
  	var ii = i & 255; 
  	var jj = j & 255; 
  	var gi0 = this.perm[ii + this.perm[jj]] % 12; 
  	var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12; 
  	var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; 
    // Calculate the contribution from the three corners 
  	var t0 = 0.5 - x0 * x0 - y0 * y0; 
  	if (t0 < 0) { n0 = 0.0; } 
  	else { 
  		t0 *= t0; 
  		n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient 
  	} 
  	var t1 = 0.5 - x1 * x1 - y1 * y1; 
  	if (t1 < 0) { n1 = 0.0; } 
  	else { 
  		t1 *= t1; 
  		n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); 
  	}
  	var t2 = 0.5 - x2 * x2 - y2 * y2; 
  	if (t2 < 0) { n2 = 0.0; } 
  	else { 
  		t2 *= t2; 
  		n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); 
  	} 
    // Add contributions from each corner to get the final noise value. 
    // The result is scaled to return values in the interval [-1,1]. 
  	return 70.0 * (n0 + n1 + n2); 
  };

  // 3D simplex noise 
  SimplexNoise.prototype.noise3d = function(xin, yin, zin) { 
  	var n0, n1, n2, n3; // Noise contributions from the four corners 
    // Skew the input space to determine which simplex cell we're in 
  	var F3 = 1.0 / 3.0; 
  	var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D 
  	var i = Math.floor(xin + s); 
  	var j = Math.floor(yin + s); 
  	var k = Math.floor(zin + s); 
  	var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too 
  	var t = (i + j + k) * G3; 
  	var X0 = i - t; // Unskew the cell origin back to (x,y,z) space 
  	var Y0 = j - t; 
  	var Z0 = k - t; 
  	var x0 = xin - X0; // The x,y,z distances from the cell origin 
  	var y0 = yin - Y0; 
  	var z0 = zin - Z0; 
    // For the 3D case, the simplex shape is a slightly irregular tetrahedron. 
    // Determine which simplex we are in. 
  	var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords 
  	var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords 
  	if (x0 >= y0) { 
  		if (y0 >= z0) 
        { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order 
        else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order 
  		else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order 
  	} 
  	else { // x0<y0 
  		if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order 
      else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order 
  		else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order 
  	} 
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), 
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and 
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where 
    // c = 1/6.
  	var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords 
  	var y1 = y0 - j1 + G3; 
  	var z1 = z0 - k1 + G3; 
  	var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords 
  	var y2 = y0 - j2 + 2.0 * G3; 
  	var z2 = z0 - k2 + 2.0 * G3; 
  	var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords 
  	var y3 = y0 - 1.0 + 3.0 * G3; 
  	var z3 = z0 - 1.0 + 3.0 * G3; 
    // Work out the hashed gradient indices of the four simplex corners 
  	var ii = i & 255; 
  	var jj = j & 255; 
  	var kk = k & 255; 
  	var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12; 
  	var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12; 
  	var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12; 
  	var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; 
    // Calculate the contribution from the four corners 
  	var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; 
  	if (t0 < 0) { n0 = 0.0; } 
  	else { 
  		t0 *= t0; 
  		n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); 
  	}
  	var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; 
  	if (t1 < 0) { n1 = 0.0; } 
  	else { 
  		t1 *= t1; 
  		n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); 
  	} 
  	var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; 
  	if (t2 < 0) { n2 = 0.0; } 
  	else { 
  		t2 *= t2; 
  		n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); 
  	} 
  	var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; 
  	if (t3 < 0) { n3 = 0.0; } 
  	else { 
  		t3 *= t3; 
  		n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); 
  	} 
    // Add contributions from each corner to get the final noise value. 
    // The result is scaled to stay just inside [-1,1] 
  	return 32.0 * (n0 + n1 + n2 + n3); 
  };

  // 4D simplex noise
  SimplexNoise.prototype.noise4d = function( x, y, z, w ) {
  	// For faster and easier lookups
  	var grad4 = this.grad4;
  	var simplex = this.simplex;
  	var perm = this.perm;
  	
     // The skewing and unskewing factors are hairy again for the 4D case
  	var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  	var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
  	var n0, n1, n2, n3, n4; // Noise contributions from the five corners
     // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
  	var s = (x + y + z + w) * F4; // Factor for 4D skewing
  	var i = Math.floor(x + s);
  	var j = Math.floor(y + s);
  	var k = Math.floor(z + s);
  	var l = Math.floor(w + s);
  	var t = (i + j + k + l) * G4; // Factor for 4D unskewing
  	var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
  	var Y0 = j - t;
  	var Z0 = k - t;
  	var W0 = l - t;
  	var x0 = x - X0;  // The x,y,z,w distances from the cell origin
  	var y0 = y - Y0;
  	var z0 = z - Z0;
  	var w0 = w - W0;

     // For the 4D case, the simplex is a 4D shape I won't even try to describe.
     // To find out which of the 24 possible simplices we're in, we need to
     // determine the magnitude ordering of x0, y0, z0 and w0.
     // The method below is a good way of finding the ordering of x,y,z,w and
     // then find the correct traversal order for the simplex were in.
     // First, six pair-wise comparisons are performed between each possible pair
     // of the four coordinates, and the results are used to add up binary bits
     // for an integer index.
  	var c1 = (x0 > y0) ? 32 : 0;
  	var c2 = (x0 > z0) ? 16 : 0;
  	var c3 = (y0 > z0) ? 8 : 0;
  	var c4 = (x0 > w0) ? 4 : 0;
  	var c5 = (y0 > w0) ? 2 : 0;
  	var c6 = (z0 > w0) ? 1 : 0;
  	var c = c1 + c2 + c3 + c4 + c5 + c6;
  	var i1, j1, k1, l1; // The integer offsets for the second simplex corner
  	var i2, j2, k2, l2; // The integer offsets for the third simplex corner
  	var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
     // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
     // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
     // impossible. Only the 24 indices which have non-zero entries make any sense.
     // We use a thresholding to set the coordinates in turn from the largest magnitude.
     // The number 3 in the "simplex" array is at the position of the largest coordinate.
  	i1 = simplex[c][0] >= 3 ? 1 : 0;
  	j1 = simplex[c][1] >= 3 ? 1 : 0;
  	k1 = simplex[c][2] >= 3 ? 1 : 0;
  	l1 = simplex[c][3] >= 3 ? 1 : 0;
     // The number 2 in the "simplex" array is at the second largest coordinate.
  	i2 = simplex[c][0] >= 2 ? 1 : 0;
  	j2 = simplex[c][1] >= 2 ? 1 : 0;    k2 = simplex[c][2] >= 2 ? 1 : 0;
  	l2 = simplex[c][3] >= 2 ? 1 : 0;
     // The number 1 in the "simplex" array is at the second smallest coordinate.
  	i3 = simplex[c][0] >= 1 ? 1 : 0;
  	j3 = simplex[c][1] >= 1 ? 1 : 0;
  	k3 = simplex[c][2] >= 1 ? 1 : 0;
  	l3 = simplex[c][3] >= 1 ? 1 : 0;
     // The fifth corner has all coordinate offsets = 1, so no need to look that up.
  	var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
  	var y1 = y0 - j1 + G4;
  	var z1 = z0 - k1 + G4;
  	var w1 = w0 - l1 + G4;
  	var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
  	var y2 = y0 - j2 + 2.0 * G4;
  	var z2 = z0 - k2 + 2.0 * G4;
  	var w2 = w0 - l2 + 2.0 * G4;
  	var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
  	var y3 = y0 - j3 + 3.0 * G4;
  	var z3 = z0 - k3 + 3.0 * G4;
  	var w3 = w0 - l3 + 3.0 * G4;
  	var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
  	var y4 = y0 - 1.0 + 4.0 * G4;
  	var z4 = z0 - 1.0 + 4.0 * G4;
  	var w4 = w0 - 1.0 + 4.0 * G4;
     // Work out the hashed gradient indices of the five simplex corners
  	var ii = i & 255;
  	var jj = j & 255;
  	var kk = k & 255;
  	var ll = l & 255;
  	var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
  	var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
  	var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
  	var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
  	var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
     // Calculate the contribution from the five corners
  	var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
  	if (t0 < 0) { n0 = 0.0; }
  	else {
  		t0 *= t0;
  		n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
  	}
  	var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
  	if (t1 < 0) { n1 = 0.0; }
  	else {
  		t1 *= t1;
  		n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
  	}
  	var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
  	if (t2 < 0) { n2 = 0.0; }
  	else {
  		t2 *= t2;
  		n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
  	}   var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
  	if (t3 < 0) { n3 = 0.0; }
  	else {
  		t3 *= t3;
  		n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
  	}
  	var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
  	if (t4 < 0) { n4 = 0.0; }
  	else {
  		t4 *= t4;
  		n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
  	}
     // Sum up and scale the result to cover the range [-1,1]
  	return 27.0 * (n0 + n1 + n2 + n3 + n4);
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LightningStrike = function ( rayParameters ) {

  	BufferGeometry.call( this );

  	this.type = 'LightningStrike';

  	// Set parameters, and set undefined parameters to default values
  	rayParameters = rayParameters || {};
  	this.init( LightningStrike.copyParameters( rayParameters, rayParameters ) );

  	// Creates and populates the mesh
  	this.createMesh();

  };

  LightningStrike.prototype = Object.create( BufferGeometry.prototype );

  LightningStrike.prototype.constructor = LightningStrike;

  LightningStrike.prototype.isLightningStrike = true;

  // Ray states
  LightningStrike.RAY_INITIALIZED = 0;
  LightningStrike.RAY_UNBORN = 1;
  LightningStrike.RAY_PROPAGATING = 2;
  LightningStrike.RAY_STEADY = 3;
  LightningStrike.RAY_VANISHING = 4;
  LightningStrike.RAY_EXTINGUISHED = 5;

  LightningStrike.COS30DEG = Math.cos( 30 * Math.PI / 180 );
  LightningStrike.SIN30DEG = Math.sin( 30 * Math.PI / 180 );

  LightningStrike.createRandomGenerator = function () {

  	var numSeeds = 2053;
  	var seeds = [];

  	for ( var i = 0; i < numSeeds; i++ ) {

  		seeds.push( Math.random() );

  	}

  	var generator = {

  		currentSeed: 0,

  		random: function () {

  			var value = seeds[ generator.currentSeed ];

  			generator.currentSeed = ( generator.currentSeed + 1 ) % numSeeds;

  			return value;

  		},

  		getSeed: function () {

  			return generator.currentSeed / numSeeds;

  		},

  		setSeed: function ( seed ) {

  			generator.currentSeed = Math.floor( seed * numSeeds ) % numSeeds;

  		}

  	};

  	return generator;

  };

  LightningStrike.copyParameters = function ( dest, source) {

  	source = source || {};
  	dest = dest || {};

  	var vecCopy = function( v ) {

  		if ( source === dest ) {

  			return v;

  		}
  		else {

  			return v.clone();

  		}

  	};

  	dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy( source.sourceOffset ) : new Vector3( 0, 100, 0 ),
  	dest.destOffset = source.destOffset !== undefined ? vecCopy( source.destOffset ) : new Vector3( 0, 0, 0 ),

  	dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1,
  	dest.roughness = source.roughness !== undefined ? source.roughness : 0.9,
  	dest.straightness = source.straightness !== undefined ? source.straightness : 0.7,

  	dest.up0 = source.up0 !== undefined ? vecCopy( source.up0 ) : new Vector3( 0, 0, 1 );
  	dest.up1 = source.up1 !== undefined ? vecCopy( source.up1 ) : new Vector3( 0, 0, 1 ),
  	dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1,
  	dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1,
  	dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5,
  	dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2,
  	dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2,

  	// These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:

  	dest.isEternal = source.isEternal !== undefined ? source.isEternal : ( source.birthTime === undefined || source.deathTime === undefined ),
  	dest.birthTime = source.birthTime,
  	dest.deathTime = source.deathTime,
  	dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1,
  	dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9,
  	dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4,
  	dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6;

  	// These parameters cannot change after lightning creation:

  	dest.maxIterations =  source.maxIterations !== undefined ? source.maxIterations : 9;
  	dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;
  	dest.ramification = source.ramification !== undefined ? source.ramification : 5;
  	dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;
  	dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;
  	dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;
  	dest.randomGenerator = source.randomGenerator,
  	dest.noiseSeed = source.noiseSeed,
  	dest.onDecideSubrayCreation = source.onDecideSubrayCreation,
  	dest.onSubrayCreation = source.onSubrayCreation;

  	return dest;

  };

  LightningStrike.prototype.update = function ( time ) {

  	if ( this.isStatic ) {
  		return;
  	}
  	
  	if ( this.rayParameters.isEternal || ( this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime ) ) {

  		this.updateMesh( time );

  		if ( time < this.subrays[ 0 ].endPropagationTime ) {
  		
  			this.state = LightningStrike.RAY_PROPAGATING;

  		}	
  		else if ( time > this.subrays[ 0 ].beginVanishingTime ) {

  			this.state = LightningStrike.RAY_VANISHING;

  		}
  		else {

  			this.state = LightningStrike.RAY_STEADY;

  		}

  		this.visible = true;

  	}
  	else {

  		this.visible = false;

  		if ( time < this.rayParameters.birthTime ) {

  			this.state = LightningStrike.RAY_UNBORN;

  		}
  		else {

  			this.state = LightningStrike.RAY_EXTINGUISHED;

  		}

  	}

  };

  LightningStrike.prototype.init = function ( rayParameters ) {
  	var this$1 = this;


  	// Init all the state from the parameters

  	this.rayParameters = rayParameters;

  	// These parameters cannot change after lightning creation:

  	this.maxIterations =  rayParameters.maxIterations !== undefined ? Math.floor( rayParameters.maxIterations ) : 9;
  	rayParameters.maxIterations = this.maxIterations;
  	this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;
  	rayParameters.isStatic = this.isStatic;
  	this.ramification = rayParameters.ramification !== undefined ? Math.floor( rayParameters.ramification ) : 5;
  	rayParameters.ramification = this.ramification;
  	this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor( rayParameters.maxSubrayRecursion ) : 3;
  	rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
  	this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;
  	rayParameters.recursionProbability = this.recursionProbability;
  	this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;
  	rayParameters.generateUVs = this.generateUVs;

  	// Random generator
  	if ( rayParameters.randomGenerator !== undefined ) {

  		this.randomGenerator = rayParameters.randomGenerator;
  		this.seedGenerator = rayParameters.randomGenerator;

  		if ( rayParameters.noiseSeed !== undefined ) {
  		
  			this.seedGenerator.setSeed( rayParameters.noiseSeed );

  		}

  	}
  	else {

  		this.randomGenerator = LightningStrike.createRandomGenerator();
  		this.seedGenerator = Math;

  	}

  	// Ray creation callbacks
  	if ( rayParameters.onDecideSubrayCreation !== undefined ) {

  		this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;

  	}
  	else {

  		this.createDefaultSubrayCreationCallbacks();

  		if ( rayParameters.onSubrayCreation !== undefined ) {

  			this.onSubrayCreation = rayParameters.onSubrayCreation;

  		}

  	}

  	// Internal state

  	this.state = LightningStrike.RAY_INITIALIZED;

  	this.maxSubrays = Math.ceil( 1 + Math.pow( this.ramification, Math.max( 0, this.maxSubrayRecursion - 1 ) ) );
  	rayParameters.maxSubrays = this.maxSubrays;
  	
  	this.maxRaySegments = 2 * ( 1 << this.maxIterations );

  	this.subrays = [];

  	for ( var i = 0; i < this.maxSubrays; i++ ) {

  		this$1.subrays.push( this$1.createSubray() );

  	}

  	this.raySegments = [];

  	for ( var i = 0; i < this.maxRaySegments; i++ ) {

  		this$1.raySegments.push( this$1.createSegment() );

  	}

  	this.time = 0;
  	this.timeFraction = 0;
  	this.currentSegmentCallback = null;
  	this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
  	this.numSubrays = 0;
  	this.currentSubray = null;
  	this.currentSegmentIndex = 0;
  	this.isInitialSegment = false;
  	this.subrayProbability = 0;

  	this.currentVertex = 0;
  	this.currentIndex = 0;
  	this.currentCoordinate = 0;
  	this.currentUVCoordinate = 0;
  	this.vertices = null;
  	this.uvs = null;
  	this.indices = null;
  	this.positionAttribute = null;
  	this.uvsAttribute = null;
  	
  	this.simplexX = new SimplexNoise( this.seedGenerator );
  	this.simplexY = new SimplexNoise( this.seedGenerator );
  	this.simplexZ = new SimplexNoise( this.seedGenerator );

  	// Temp vectors
  	this.forwards = new Vector3();
  	this.forwardsFill = new Vector3();
  	this.side = new Vector3();
  	this.down = new Vector3();
  	this.middlePos = new Vector3();
  	this.middleLinPos = new Vector3();
  	this.newPos = new Vector3();
  	this.vPos = new Vector3();
  	this.cross1 = new Vector3();

  };

  LightningStrike.prototype.createMesh = function () {

  	var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
  	
  	var maxVerts = 3 * ( maxDrawableSegmentsPerSubRay + 1 ) * this.maxSubrays;
  	var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;

  	this.vertices = new Float32Array( maxVerts * 3 );
  	this.indices = new Uint32Array( maxIndices );
  	if ( this.generateUVs ) {
  		this.uvs = new Float32Array( maxVerts * 2 );
  	}

  	// Populate the mesh
  	this.fillMesh( 0 );
  	
  	this.setIndex( new Uint32BufferAttribute( this.indices, 1 ) );

  	this.positionAttribute = new Float32BufferAttribute( this.vertices, 3 );
  	this.addAttribute( 'position', this.positionAttribute );

  	if ( this.generateUVs ) {		this.uvsAttribute = new Float32BufferAttribute( new Float32Array( this.uvs ), 2 );
  		this.addAttribute( 'uv', this.uvsAttribute );
  	}

  	if ( ! this.isStatic ) {
  		this.index.dynamic = true;
  		this.positionAttribute.dynamic = true;
  		if ( this.generateUVs ) {
  			this.uvsAttribute.dynamic = true;
  		}
  	}

  	// Store buffers for later modification
  	this.vertices = this.positionAttribute.array;
  	this.indices = this.index.array;
  	if ( this.generateUVs ) {
  		this.uvs = this.uvsAttribute.array;
  	}

  };
  	
  LightningStrike.prototype.updateMesh = function ( time ) {

  	this.fillMesh( time );

  	this.drawRange.count = this.currentIndex;

  	this.index.needsUpdate = true;

  	this.positionAttribute.needsUpdate = true;

  	if ( this.generateUVs ) {
  		this.uvsAttribute.needsUpdate = true;
  	}

  };

  LightningStrike.prototype.fillMesh = function ( time ) {

  	var scope = this;

  	this.currentVertex = 0;
  	this.currentIndex = 0;
  	this.currentCoordinate = 0;
  	this.currentUVCoordinate = 0;

  	this.fractalRay( time, function fillVertices ( segment ) {

  		var subray = scope.currentSubray;

  		if ( time < subray.birthTime ) {//&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {

  			return;

  		}
  		else if ( this.rayParameters.isEternal && scope.currentSubray.recursion == 0 ) {

  			// Eternal rays don't propagate nor vanish, but its subrays do

  			scope.createPrism( segment );

  			scope.onDecideSubrayCreation( segment, scope );

  		}
  		else if ( time < subray.endPropagationTime ) {

  			if ( scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor ) {

  				// Ray propagation has arrived to this segment

  				scope.createPrism( segment );

  				scope.onDecideSubrayCreation( segment, scope );

  			}

  		}
  		else if ( time < subray.beginVanishingTime ) {

  			// Ray is steady (nor propagating nor vanishing)

  			scope.createPrism( segment );

  			scope.onDecideSubrayCreation( segment, scope );

  		}
  		else {

  			if ( scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1  * ( 1 - subray.vanishingTimeFactor ) ) {

  				// Segment has not yet vanished

  				scope.createPrism( segment );

  			}

  			scope.onDecideSubrayCreation( segment, scope );

  		}

  	} );

  };

  LightningStrike.prototype.addNewSubray = function ( rayParameters ) {

  	return this.subrays[ this.numSubrays++ ];

  };

  LightningStrike.prototype.initSubray = function ( subray, rayParameters ) {

  	subray.pos0.copy( rayParameters.sourceOffset );
  	subray.pos1.copy( rayParameters.destOffset );
  	subray.up0.copy( rayParameters.up0 );
  	subray.up1.copy( rayParameters.up1 );
  	subray.radius0 = rayParameters.radius0;
  	subray.radius1 = rayParameters.radius1;
  	subray.birthTime = rayParameters.birthTime;
  	subray.deathTime = rayParameters.deathTime;
  	subray.timeScale = rayParameters.timeScale;
  	subray.roughness = rayParameters.roughness;
  	subray.straightness = rayParameters.straightness;
  	subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
  	subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;

  	subray.maxIterations = this.maxIterations;
  	subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;
  	subray.recursion = 0;

  };

  LightningStrike.prototype.fractalRay = function ( time, segmentCallback ) {
  	var this$1 = this;


  	this.time = time;
  	this.currentSegmentCallback = segmentCallback;
  	this.numSubrays = 0;

  	// Add the top level subray
  	this.initSubray( this.addNewSubray(), this.rayParameters );

  	// Process all subrays that are being generated until consuming all of them
  	for ( var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++ ) {

  		var subray = this$1.subrays[ subrayIndex ];
  		this$1.currentSubray = subray;

  		this$1.randomGenerator.setSeed( subray.seed );

  		subray.endPropagationTime = _Math.lerp( subray.birthTime, subray.deathTime, subray.propagationTimeFactor );
  		subray.beginVanishingTime = _Math.lerp( subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor );

  		var random1 = this$1.randomGenerator.random;
  		subray.linPos0.set( random1(), random1(), random1() ).multiplyScalar( 1000 );
  		subray.linPos1.set( random1(), random1(), random1() ).multiplyScalar( 1000 );

  		this$1.timeFraction = ( time - subray.birthTime ) / ( subray.deathTime - subray.birthTime );

  		this$1.currentSegmentIndex  = 0;
  		this$1.isInitialSegment = true;

  		var segment = this$1.getNewSegment();
  		segment.iteration = 0;
  		segment.pos0.copy( subray.pos0 );
  		segment.pos1.copy( subray.pos1 );
  		segment.linPos0.copy( subray.linPos0 );
  		segment.linPos1.copy( subray.linPos1 );
  		segment.up0.copy( subray.up0 );
  		segment.up1.copy( subray.up1 );
  		segment.radius0 = subray.radius0;
  		segment.radius1 = subray.radius1;
  		segment.fraction0 = 0;
  		segment.fraction1 = 1;
  		segment.positionVariationFactor = 1 - subray.straightness;

  		this$1.subrayProbability = this$1.ramification * Math.pow( this$1.recursionProbability, subray.recursion ) / ( 1 << subray.maxIterations );

  		this$1.fractalRayRecursive( segment );

  	}

  	this.currentSegmentCallback = null;
  	this.currentSubray = null;

  };

  LightningStrike.prototype.fractalRayRecursive = function ( segment ) {

  	// Leave recursion condition
  	if ( segment.iteration >= this.currentSubray.maxIterations ) {

  		this.currentSegmentCallback( segment );

  		return;

  	}

  	// Interpolation
  	this.forwards.subVectors( segment.pos1, segment.pos0 );
  	var lForwards = this.forwards.length();

  	if ( lForwards < 0.000001) {
  		this.forwards.set( 0, 0, 0.01 );
  		lForwards = this.forwards.length();
  	}

  	var middleRadius = ( segment.radius0 + segment.radius1 ) * 0.5;
  	var middleFraction = ( segment.fraction0 + segment.fraction1 ) * 0.5;

  	var timeDimension = this.time * this.currentSubray.timeScale * Math.pow( 2, segment.iteration );

  	this.middlePos.lerpVectors( segment.pos0, segment.pos1, 0.5 );
  	this.middleLinPos.lerpVectors( segment.linPos0, segment.linPos1, 0.5 );
  	var p = this.middleLinPos;

  	// Noise	
  	this.newPos.set( this.simplexX.noise4d( p.x, p.y, p.z, timeDimension ),
  						this.simplexY.noise4d( p.x, p.y, p.z, timeDimension ),
  						this.simplexZ.noise4d( p.x, p.y, p.z, timeDimension ) );

  	this.newPos.multiplyScalar( segment.positionVariationFactor * lForwards );
  	this.newPos.add( this.middlePos );

  	// Recursion

  	var newSegment1 = this.getNewSegment();
  	newSegment1.pos0.copy( segment.pos0 );
  	newSegment1.pos1.copy( this.newPos );
  	newSegment1.linPos0.copy( segment.linPos0 );
  	newSegment1.linPos1.copy( this.middleLinPos );
  	newSegment1.up0.copy( segment.up0 );
  	newSegment1.up1.copy( segment.up1 );
  	newSegment1.radius0 = segment.radius0;
  	newSegment1.radius1 = middleRadius;
  	newSegment1.fraction0 = segment.fraction0;
  	newSegment1.fraction1 = middleFraction;
  	newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
  	newSegment1.iteration = segment.iteration + 1;

  	var newSegment2 = this.getNewSegment();
  	newSegment2.pos0.copy( this.newPos );
  	newSegment2.pos1.copy( segment.pos1 );
  	newSegment2.linPos0.copy( this.middleLinPos );
  	newSegment2.linPos1.copy( segment.linPos1 );
  	this.cross1.crossVectors( segment.up0, this.forwards.normalize() );
  	newSegment2.up0.crossVectors( this.forwards, this.cross1 ).normalize();
  	newSegment2.up1.copy( segment.up1 );
  	newSegment2.radius0 = middleRadius;
  	newSegment2.radius1 = segment.radius1;
  	newSegment2.fraction0 = middleFraction;
  	newSegment2.fraction1 = segment.fraction1;
  	newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
  	newSegment2.iteration = segment.iteration + 1;

  	this.fractalRayRecursive( newSegment1 );

  	this.fractalRayRecursive( newSegment2 );

  };

  LightningStrike.prototype.createPrism = function ( segment ) {

  	// Creates one triangular prism and its vertices at the segment

  	this.forwardsFill.subVectors( segment.pos1, segment.pos0 ).normalize();

  	if ( this.isInitialSegment ) {

  		this.currentCreateTriangleVertices( segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0 );
  		
  		this.isInitialSegment = false;

  	}

  	this.currentCreateTriangleVertices( segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1 );

  	this.createPrismFaces();

  };

  LightningStrike.prototype.createTriangleVerticesWithoutUVs = function ( pos, up, forwards, radius ) {

  	// Create an equilateral triangle (only vertices)
  	
  	this.side.crossVectors( up, forwards ).multiplyScalar( radius * LightningStrike.COS30DEG );
  	this.down.copy( up ).multiplyScalar( - radius * LightningStrike.SIN30DEG );

  	var p = this.vPos;
  	var v = this.vertices;

  	p.copy( pos ).sub( this.side ).add( this.down );

  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	p.copy( pos ).add( this.side ).add( this.down );

  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	p.copy( up ).multiplyScalar( radius ).add( pos );
  	
  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	this.currentVertex += 3;

  };

  LightningStrike.prototype.createTriangleVerticesWithUVs = function ( pos, up, forwards, radius, u ) {

  	// Create an equilateral triangle (only vertices)
  	
  	this.side.crossVectors( up, forwards ).multiplyScalar( radius * LightningStrike.COS30DEG );
  	this.down.copy( up ).multiplyScalar( - radius * LightningStrike.SIN30DEG );

  	var p = this.vPos;
  	var v = this.vertices;
  	var uv = this.uvs;

  	p.copy( pos ).sub( this.side ).add( this.down );

  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	uv[ this.currentUVCoordinate++ ] = u;
  	uv[ this.currentUVCoordinate++ ] = 0;

  	p.copy( pos ).add( this.side ).add( this.down );

  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	uv[ this.currentUVCoordinate++ ] = u;
  	uv[ this.currentUVCoordinate++ ] = 0.5;

  	p.copy( up ).multiplyScalar( radius ).add( pos );
  	
  	v[ this.currentCoordinate++ ] = p.x;
  	v[ this.currentCoordinate++ ] = p.y;
  	v[ this.currentCoordinate++ ] = p.z;

  	uv[ this.currentUVCoordinate++ ] = u;
  	uv[ this.currentUVCoordinate++ ] = 1;

  	this.currentVertex += 3;

  };

  LightningStrike.prototype.createPrismFaces = function ( vertex, index ) {

  	var indices = this.indices;
  	var vertex = this.currentVertex - 6;

  	indices[ this.currentIndex++ ] = vertex + 1;
  	indices[ this.currentIndex++ ] = vertex + 2;
  	indices[ this.currentIndex++ ] = vertex + 5;
  	indices[ this.currentIndex++ ] = vertex + 1;
  	indices[ this.currentIndex++ ] = vertex + 5;
  	indices[ this.currentIndex++ ] = vertex + 4;
  	indices[ this.currentIndex++ ] = vertex + 0;
  	indices[ this.currentIndex++ ] = vertex + 1;
  	indices[ this.currentIndex++ ] = vertex + 4;
  	indices[ this.currentIndex++ ] = vertex + 0;
  	indices[ this.currentIndex++ ] = vertex + 4;
  	indices[ this.currentIndex++ ] = vertex + 3;
  	indices[ this.currentIndex++ ] = vertex + 2;
  	indices[ this.currentIndex++ ] = vertex + 0;
  	indices[ this.currentIndex++ ] = vertex + 3;
  	indices[ this.currentIndex++ ] = vertex + 2;
  	indices[ this.currentIndex++ ] = vertex + 3;
  	indices[ this.currentIndex++ ] = vertex + 5;

  };

  LightningStrike.prototype.createDefaultSubrayCreationCallbacks = function () {

  	var random1 = this.randomGenerator.random;

  	this.onDecideSubrayCreation = function ( segment, lightningStrike ) {

  		// Decide subrays creation at parent (sub)ray segment

  		var subray = lightningStrike.currentSubray;

  		var period = lightningStrike.rayParameters.subrayPeriod;
  		var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
  		
  		var phase0 = ( lightningStrike.rayParameters.isEternal && subray.recursion == 0 ) ? - random1() * period : _Math.lerp( subray.birthTime, subray.endPropagationTime, segment.fraction0 ) - random1() * period;
  		
  		var phase = lightningStrike.time - phase0;
  		var currentCycle = Math.floor( phase / period );

  		var childSubraySeed = random1() * ( currentCycle + 1 );

  		var isActive = phase % period <= dutyCycle * period;

  		probability = lightningStrike.subrayProbability;
  		var probability = 0;
  		if ( isActive ) {
  			probability = lightningStrike.subrayProbability;
  			// Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;
  		}

  		if ( subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability ) {

  			var childSubray = lightningStrike.addNewSubray();

  			var parentSeed = lightningStrike.randomGenerator.getSeed();
  			childSubray.seed = childSubraySeed;
  			lightningStrike.randomGenerator.setSeed( childSubraySeed );

  			childSubray.recursion = subray.recursion + 1;
  			childSubray.maxIterations = Math.max( 1, subray.maxIterations - 1 );

  			childSubray.linPos0.set( random1(), random1(), random1() ).multiplyScalar( 1000 );
  			childSubray.linPos1.set( random1(), random1(), random1() ).multiplyScalar( 1000 );
  			childSubray.up0.copy( subray.up0 );
  			childSubray.up1.copy( subray.up1 );
  			childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
  			childSubray.radius1 = Math.min( lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor );
  			
  			childSubray.birthTime = phase0 + ( currentCycle ) * period;
  			childSubray.deathTime = childSubray.birthTime + period * dutyCycle;

  			if ( ! lightningStrike.rayParameters.isEternal && subray.recursion == 0 ) {

  				childSubray.birthTime = Math.max( childSubray.birthTime, subray.birthTime );
  				childSubray.deathTime = Math.min( childSubray.deathTime, subray.deathTime );

  			}

  			childSubray.timeScale = subray.timeScale * 2;
  			childSubray.roughness = subray.roughness;
  			childSubray.straightness = subray.straightness;
  			childSubray.propagationTimeFactor = subray.propagationTimeFactor;
  			childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;

  			lightningStrike.onSubrayCreation( segment, subray, childSubray, lightningStrike );

  			lightningStrike.randomGenerator.setSeed( parentSeed );

  		}

  	};

  	var vec1Pos = new Vector3();
  	var vec2Forward = new Vector3();
  	var vec3Side = new Vector3();
  	var vec4Up = new Vector3();
  	
  	this.onSubrayCreation = function ( segment, parentSubray, childSubray, lightningStrike ) {

  		// Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray

  		// Just use the default cone position generator
  		lightningStrike.subrayCylinderPosition( segment, parentSubray, childSubray, 0.5, 0.6, 0.2 );

  	};

  	this.subrayConePosition = function ( segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor ) {
  		
  		// Sets childSubray pos0 and pos1 in a cone
  		
  		childSubray.pos0.copy( segment.pos0 );

  		vec1Pos.subVectors( parentSubray.pos1, parentSubray.pos0 );
  		vec2Forward.copy( vec1Pos ).normalize();
  		vec1Pos.multiplyScalar( segment.fraction0 + ( 1 - segment.fraction0 ) * ( random1() * heightFactor ) );
  		var length = vec1Pos.length();
  		vec3Side.crossVectors( parentSubray.up0, vec2Forward );
  		var angle = 2 * Math.PI * random1();
  		vec3Side.multiplyScalar( Math.cos ( angle ) );
  		vec4Up.copy( parentSubray.up0 ).multiplyScalar( Math.sin ( angle ) );

  		childSubray.pos1.copy( vec3Side ).add( vec4Up ).multiplyScalar( length * sideWidthFactor * ( minSideWidthFactor + random1() * ( 1 - minSideWidthFactor ) ) ).add( vec1Pos ).add( parentSubray.pos0 );

  	};

  	this.subrayCylinderPosition = function ( segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor ) {
  		
  		// Sets childSubray pos0 and pos1 in a cylinder

  		childSubray.pos0.copy( segment.pos0 );

  		vec1Pos.subVectors( parentSubray.pos1, parentSubray.pos0 );
  		vec2Forward.copy( vec1Pos ).normalize();
  		vec1Pos.multiplyScalar( segment.fraction0 + ( 1 - segment.fraction0 ) * ( ( 2 * random1() - 1 ) * heightFactor ) );
  		var length = vec1Pos.length();
  		vec3Side.crossVectors( parentSubray.up0, vec2Forward );
  		var angle = 2 * Math.PI * random1();
  		vec3Side.multiplyScalar( Math.cos ( angle ) );
  		vec4Up.copy( parentSubray.up0 ).multiplyScalar( Math.sin ( angle ) );

  		childSubray.pos1.copy( vec3Side ).add( vec4Up ).multiplyScalar( length * sideWidthFactor * ( minSideWidthFactor + random1() * ( 1 - minSideWidthFactor ) ) ).add( vec1Pos ).add( parentSubray.pos0 );

  	};

  };

  LightningStrike.prototype.createSubray = function () {

  	return {

  		seed: 0,
  		maxIterations: 0,
  		recursion: 0,
  		pos0: new Vector3(),
  		pos1: new Vector3(),
  		linPos0: new Vector3(),
  		linPos1: new Vector3(),
  		up0: new Vector3(),
  		up1: new Vector3(),
  		radius0: 0,
  		radius1: 0,
  		birthTime: 0,
  		deathTime: 0,
  		timeScale: 0,
  		roughness: 0,
  		straightness: 0,
  		propagationTimeFactor: 0,
  		vanishingTimeFactor: 0,
  		endPropagationTime: 0,
  		beginVanishingTime: 0

  	};

  };

  LightningStrike.prototype.createSegment = function () {

  	return {
  		iteration: 0,
  		pos0: new Vector3(),
  		pos1: new Vector3(),
  		linPos0: new Vector3(),
  		linPos1: new Vector3(),
  		up0: new Vector3(),
  		up1: new Vector3(),
  		radius0: 0,
  		radius1: 0,
  		fraction0: 0,
  		fraction1: 0,
  		positionVariationFactor: 0
  	}

  };

  LightningStrike.prototype.getNewSegment = function () {

  	return this.raySegments[ this.currentSegmentIndex++ ];

  };

  LightningStrike.prototype.copy = function ( source ) {
  	
  	BufferGeometry.prototype.copy.call( this, source );

  	this.init( LightningStrike.copyParameters( {}, source.rayParameters ) );

  	return this;

  };

  LightningStrike.prototype.clone = function () {

  	return new this.constructor( LightningStrike.copyParameters( {}, this.rayParameters ) );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TeapotBufferGeometry = function ( size, segments, bottom, lid, body, fitLid, blinn ) {

  	// 32 * 4 * 4 Bezier spline patches
  	var teapotPatches = [
  		
  		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  		3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27,
  		18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39,
  		30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12,
  		
  		12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
  		15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68,
  		27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77,
  		39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56,
  		56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  		59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104,
  		68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113,
  		77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92,
  		
  		120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,
  		123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132,
  		132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154,
  		135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68,
  		
  		161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,
  		164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173,
  		173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,
  		176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193,
  		
  		203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212,
  		203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218,
  		203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224,
  		203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209,
  		209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,
  		212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249,
  		218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258,
  		224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237,
  		
  		265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113,
  		265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104,
  		265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95,
  		265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92
  	];

  	var teapotVertices = [
  		1.4, 0, 2.4,
  		1.4, - 0.784, 2.4,
  		0.784, - 1.4, 2.4,
  		0, - 1.4, 2.4,
  		1.3375, 0, 2.53125,
  		1.3375, - 0.749, 2.53125,
  		0.749, - 1.3375, 2.53125,
  		0, - 1.3375, 2.53125,
  		1.4375, 0, 2.53125,
  		1.4375, - 0.805, 2.53125,
  		0.805, - 1.4375, 2.53125,
  		0, - 1.4375, 2.53125,
  		1.5, 0, 2.4,
  		1.5, - 0.84, 2.4,
  		0.84, - 1.5, 2.4,
  		0, - 1.5, 2.4,
  		- 0.784, - 1.4, 2.4,
  		- 1.4, - 0.784, 2.4,
  		- 1.4, 0, 2.4,
  		- 0.749, - 1.3375, 2.53125,
  		- 1.3375, - 0.749, 2.53125,
  		- 1.3375, 0, 2.53125,
  		- 0.805, - 1.4375, 2.53125,
  		- 1.4375, - 0.805, 2.53125,
  		- 1.4375, 0, 2.53125,
  		- 0.84, - 1.5, 2.4,
  		- 1.5, - 0.84, 2.4,
  		- 1.5, 0, 2.4,
  		- 1.4, 0.784, 2.4,
  		- 0.784, 1.4, 2.4,
  		0, 1.4, 2.4,
  		- 1.3375, 0.749, 2.53125,
  		- 0.749, 1.3375, 2.53125,
  		0, 1.3375, 2.53125,
  		- 1.4375, 0.805, 2.53125,
  		- 0.805, 1.4375, 2.53125,
  		0, 1.4375, 2.53125,
  		- 1.5, 0.84, 2.4,
  		- 0.84, 1.5, 2.4,
  		0, 1.5, 2.4,
  		0.784, 1.4, 2.4,
  		1.4, 0.784, 2.4,
  		0.749, 1.3375, 2.53125,
  		1.3375, 0.749, 2.53125,
  		0.805, 1.4375, 2.53125,
  		1.4375, 0.805, 2.53125,
  		0.84, 1.5, 2.4,
  		1.5, 0.84, 2.4,
  		1.75, 0, 1.875,
  		1.75, - 0.98, 1.875,
  		0.98, - 1.75, 1.875,
  		0, - 1.75, 1.875,
  		2, 0, 1.35,
  		2, - 1.12, 1.35,
  		1.12, - 2, 1.35,
  		0, - 2, 1.35,
  		2, 0, 0.9,
  		2, - 1.12, 0.9,
  		1.12, - 2, 0.9,
  		0, - 2, 0.9,
  		- 0.98, - 1.75, 1.875,
  		- 1.75, - 0.98, 1.875,
  		- 1.75, 0, 1.875,
  		- 1.12, - 2, 1.35,
  		- 2, - 1.12, 1.35,
  		- 2, 0, 1.35,
  		- 1.12, - 2, 0.9,
  		- 2, - 1.12, 0.9,
  		- 2, 0, 0.9,
  		- 1.75, 0.98, 1.875,
  		- 0.98, 1.75, 1.875,
  		0, 1.75, 1.875,
  		- 2, 1.12, 1.35,
  		- 1.12, 2, 1.35,
  		0, 2, 1.35,
  		- 2, 1.12, 0.9,
  		- 1.12, 2, 0.9,
  		0, 2, 0.9,
  		0.98, 1.75, 1.875,
  		1.75, 0.98, 1.875,
  		1.12, 2, 1.35,
  		2, 1.12, 1.35,
  		1.12, 2, 0.9,
  		2, 1.12, 0.9,
  		2, 0, 0.45,
  		2, - 1.12, 0.45,
  		1.12, - 2, 0.45,
  		0, - 2, 0.45,
  		1.5, 0, 0.225,
  		1.5, - 0.84, 0.225,
  		0.84, - 1.5, 0.225,
  		0, - 1.5, 0.225,
  		1.5, 0, 0.15,
  		1.5, - 0.84, 0.15,
  		0.84, - 1.5, 0.15,
  		0, - 1.5, 0.15,
  		- 1.12, - 2, 0.45,
  		- 2, - 1.12, 0.45,
  		- 2, 0, 0.45,
  		- 0.84, - 1.5, 0.225,
  		- 1.5, - 0.84, 0.225,
  		- 1.5, 0, 0.225,
  		- 0.84, - 1.5, 0.15,
  		- 1.5, - 0.84, 0.15,
  		- 1.5, 0, 0.15,
  		- 2, 1.12, 0.45,
  		- 1.12, 2, 0.45,
  		0, 2, 0.45,
  		- 1.5, 0.84, 0.225,
  		- 0.84, 1.5, 0.225,
  		0, 1.5, 0.225,
  		- 1.5, 0.84, 0.15,
  		- 0.84, 1.5, 0.15,
  		0, 1.5, 0.15,
  		1.12, 2, 0.45,
  		2, 1.12, 0.45,
  		0.84, 1.5, 0.225,
  		1.5, 0.84, 0.225,
  		0.84, 1.5, 0.15,
  		1.5, 0.84, 0.15,
  		- 1.6, 0, 2.025,
  		- 1.6, - 0.3, 2.025,
  		- 1.5, - 0.3, 2.25,
  		- 1.5, 0, 2.25,
  		- 2.3, 0, 2.025,
  		- 2.3, - 0.3, 2.025,
  		- 2.5, - 0.3, 2.25,
  		- 2.5, 0, 2.25,
  		- 2.7, 0, 2.025,
  		- 2.7, - 0.3, 2.025,
  		- 3, - 0.3, 2.25,
  		- 3, 0, 2.25,
  		- 2.7, 0, 1.8,
  		- 2.7, - 0.3, 1.8,
  		- 3, - 0.3, 1.8,
  		- 3, 0, 1.8,
  		- 1.5, 0.3, 2.25,
  		- 1.6, 0.3, 2.025,
  		- 2.5, 0.3, 2.25,
  		- 2.3, 0.3, 2.025,
  		- 3, 0.3, 2.25,
  		- 2.7, 0.3, 2.025,
  		- 3, 0.3, 1.8,
  		- 2.7, 0.3, 1.8,
  		- 2.7, 0, 1.575,
  		- 2.7, - 0.3, 1.575,
  		- 3, - 0.3, 1.35,
  		- 3, 0, 1.35,
  		- 2.5, 0, 1.125,
  		- 2.5, - 0.3, 1.125,
  		- 2.65, - 0.3, 0.9375,
  		- 2.65, 0, 0.9375,
  		- 2, - 0.3, 0.9,
  		- 1.9, - 0.3, 0.6,
  		- 1.9, 0, 0.6,
  		- 3, 0.3, 1.35,
  		- 2.7, 0.3, 1.575,
  		- 2.65, 0.3, 0.9375,
  		- 2.5, 0.3, 1.125,
  		- 1.9, 0.3, 0.6,
  		- 2, 0.3, 0.9,
  		1.7, 0, 1.425,
  		1.7, - 0.66, 1.425,
  		1.7, - 0.66, 0.6,
  		1.7, 0, 0.6,
  		2.6, 0, 1.425,
  		2.6, - 0.66, 1.425,
  		3.1, - 0.66, 0.825,
  		3.1, 0, 0.825,
  		2.3, 0, 2.1,
  		2.3, - 0.25, 2.1,
  		2.4, - 0.25, 2.025,
  		2.4, 0, 2.025,
  		2.7, 0, 2.4,
  		2.7, - 0.25, 2.4,
  		3.3, - 0.25, 2.4,
  		3.3, 0, 2.4,
  		1.7, 0.66, 0.6,
  		1.7, 0.66, 1.425,
  		3.1, 0.66, 0.825,
  		2.6, 0.66, 1.425,
  		2.4, 0.25, 2.025,
  		2.3, 0.25, 2.1,
  		3.3, 0.25, 2.4,
  		2.7, 0.25, 2.4,
  		2.8, 0, 2.475,
  		2.8, - 0.25, 2.475,
  		3.525, - 0.25, 2.49375,
  		3.525, 0, 2.49375,
  		2.9, 0, 2.475,
  		2.9, - 0.15, 2.475,
  		3.45, - 0.15, 2.5125,
  		3.45, 0, 2.5125,
  		2.8, 0, 2.4,
  		2.8, - 0.15, 2.4,
  		3.2, - 0.15, 2.4,
  		3.2, 0, 2.4,
  		3.525, 0.25, 2.49375,
  		2.8, 0.25, 2.475,
  		3.45, 0.15, 2.5125,
  		2.9, 0.15, 2.475,
  		3.2, 0.15, 2.4,
  		2.8, 0.15, 2.4,
  		0, 0, 3.15,
  		0.8, 0, 3.15,
  		0.8, - 0.45, 3.15,
  		0.45, - 0.8, 3.15,
  		0, - 0.8, 3.15,
  		0, 0, 2.85,
  		0.2, 0, 2.7,
  		0.2, - 0.112, 2.7,
  		0.112, - 0.2, 2.7,
  		0, - 0.2, 2.7,
  		- 0.45, - 0.8, 3.15,
  		- 0.8, - 0.45, 3.15,
  		- 0.8, 0, 3.15,
  		- 0.112, - 0.2, 2.7,
  		- 0.2, - 0.112, 2.7,
  		- 0.2, 0, 2.7,
  		- 0.8, 0.45, 3.15,
  		- 0.45, 0.8, 3.15,
  		0, 0.8, 3.15,
  		- 0.2, 0.112, 2.7,
  		- 0.112, 0.2, 2.7,
  		0, 0.2, 2.7,
  		0.45, 0.8, 3.15,
  		0.8, 0.45, 3.15,
  		0.112, 0.2, 2.7,
  		0.2, 0.112, 2.7,
  		0.4, 0, 2.55,
  		0.4, - 0.224, 2.55,
  		0.224, - 0.4, 2.55,
  		0, - 0.4, 2.55,
  		1.3, 0, 2.55,
  		1.3, - 0.728, 2.55,
  		0.728, - 1.3, 2.55,
  		0, - 1.3, 2.55,
  		1.3, 0, 2.4,
  		1.3, - 0.728, 2.4,
  		0.728, - 1.3, 2.4,
  		0, - 1.3, 2.4,
  		- 0.224, - 0.4, 2.55,
  		- 0.4, - 0.224, 2.55,
  		- 0.4, 0, 2.55,
  		- 0.728, - 1.3, 2.55,
  		- 1.3, - 0.728, 2.55,
  		- 1.3, 0, 2.55,
  		- 0.728, - 1.3, 2.4,
  		- 1.3, - 0.728, 2.4,
  		- 1.3, 0, 2.4,
  		- 0.4, 0.224, 2.55,
  		- 0.224, 0.4, 2.55,
  		0, 0.4, 2.55,
  		- 1.3, 0.728, 2.55,
  		- 0.728, 1.3, 2.55,
  		0, 1.3, 2.55,
  		- 1.3, 0.728, 2.4,
  		- 0.728, 1.3, 2.4,
  		0, 1.3, 2.4,
  		0.224, 0.4, 2.55,
  		0.4, 0.224, 2.55,
  		0.728, 1.3, 2.55,
  		1.3, 0.728, 2.55,
  		0.728, 1.3, 2.4,
  		1.3, 0.728, 2.4,
  		0, 0, 0,
  		1.425, 0, 0,
  		1.425, 0.798, 0,
  		0.798, 1.425, 0,
  		0, 1.425, 0,
  		1.5, 0, 0.075,
  		1.5, 0.84, 0.075,
  		0.84, 1.5, 0.075,
  		0, 1.5, 0.075,
  		- 0.798, 1.425, 0,
  		- 1.425, 0.798, 0,
  		- 1.425, 0, 0,
  		- 0.84, 1.5, 0.075,
  		- 1.5, 0.84, 0.075,
  		- 1.5, 0, 0.075,
  		- 1.425, - 0.798, 0,
  		- 0.798, - 1.425, 0,
  		0, - 1.425, 0,
  		- 1.5, - 0.84, 0.075,
  		- 0.84, - 1.5, 0.075,
  		0, - 1.5, 0.075,
  		0.798, - 1.425, 0,
  		1.425, - 0.798, 0,
  		0.84, - 1.5, 0.075,
  		1.5, - 0.84, 0.075
  	];

  	BufferGeometry.call( this );

  	size = size || 50;

  	// number of segments per patch
  	segments = segments !== undefined ? Math.max( 2, Math.floor( segments ) || 10 ) : 10;

  	// which parts should be visible
  	bottom = bottom === undefined ? true : bottom;
  	lid = lid === undefined ? true : lid;
  	body = body === undefined ? true : body;

  	// Should the lid be snug? It's not traditional, but we make it snug by default
  	fitLid = fitLid === undefined ? true : fitLid;

  	// Jim Blinn scaled the teapot down in size by about 1.3 for
  	// some rendering tests. He liked the new proportions that he kept
  	// the data in this form. The model was distributed with these new
  	// proportions and became the norm. Trivia: comparing images of the
  	// real teapot and the computer model, the ratio for the bowl of the
  	// real teapot is more like 1.25, but since 1.3 is the traditional
  	// value given, we use it here.
  	var blinnScale = 1.3;
  	blinn = blinn === undefined ? true : blinn;

  	// scale the size to be the real scaling factor
  	var maxHeight = 3.15 * ( blinn ? 1 : blinnScale );

  	var maxHeight2 = maxHeight / 2;
  	var trueSize = size / maxHeight2;

  	// Number of elements depends on what is needed. Subtract degenerate
  	// triangles at tip of bottom and lid out in advance.
  	var numTriangles = bottom ? ( 8 * segments - 4 ) * segments : 0;
  	numTriangles += lid ? ( 16 * segments - 4 ) * segments : 0;
  	numTriangles += body ? 40 * segments * segments : 0;

  	var indices = new Uint32Array( numTriangles * 3 );

  	var numVertices = bottom ? 4 : 0;
  	numVertices += lid ? 8 : 0;
  	numVertices += body ? 20 : 0;
  	numVertices *= ( segments + 1 ) * ( segments + 1 );

  	var vertices = new Float32Array( numVertices * 3 );
  	var normals = new Float32Array( numVertices * 3 );
  	var uvs = new Float32Array( numVertices * 2 );

  	// Bezier form
  	var ms = new Matrix4();
  	ms.set(
  		- 1.0, 3.0, - 3.0, 1.0,
  		3.0, - 6.0, 3.0, 0.0,
  		- 3.0, 3.0, 0.0, 0.0,
  		1.0, 0.0, 0.0, 0.0 );

  	var g = [];
  	var i, r, c;

  	var sp = [];
  	var tp = [];
  	var dsp = [];
  	var dtp = [];

  	// M * G * M matrix, sort of see
  	// http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html
  	var mgm = [];

  	var vert = [];
  	var sdir = [];
  	var tdir = [];

  	var norm = new Vector3();

  	var tcoord;

  	var sstep, tstep;
  	var vertPerRow;

  	var s, t, sval, tval, p;
  	var dsval = 0;
  	var dtval = 0;

  	var normOut = new Vector3();
  	var v1, v2, v3, v4;

  	var gmx = new Matrix4();
  	var tmtx = new Matrix4();

  	var vsp = new Vector4();
  	var vtp = new Vector4();
  	var vdsp = new Vector4();
  	var vdtp = new Vector4();

  	var vsdir = new Vector3();
  	var vtdir = new Vector3();

  	var mst = ms.clone();
  	mst.transpose();

  	// internal function: test if triangle has any matching vertices;
  	// if so, don't save triangle, since it won't display anything.
  	var notDegenerate = function ( vtx1, vtx2, vtx3 ) {

  		// if any vertex matches, return false
  		return ! ( ( ( vertices[ vtx1 * 3 ] === vertices[ vtx2 * 3 ] ) &&
  					 ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx2 * 3 + 1 ] ) &&
  					 ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx2 * 3 + 2 ] ) ) ||
  				   ( ( vertices[ vtx1 * 3 ] === vertices[ vtx3 * 3 ] ) &&
  					 ( vertices[ vtx1 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&
  					 ( vertices[ vtx1 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) ||
  				   ( ( vertices[ vtx2 * 3 ] === vertices[ vtx3 * 3 ] ) &&
  					 ( vertices[ vtx2 * 3 + 1 ] === vertices[ vtx3 * 3 + 1 ] ) &&
  					 ( vertices[ vtx2 * 3 + 2 ] === vertices[ vtx3 * 3 + 2 ] ) ) );

  	};
  	for ( i = 0; i < 3; i ++ ) {

  		mgm[ i ] = new Matrix4();

  	}

  	var minPatches = body ? 0 : 20;
  	var maxPatches = bottom ? 32 : 28;

  	vertPerRow = segments + 1;

  	var surfCount = 0;

  	var vertCount = 0;
  	var normCount = 0;
  	var uvCount = 0;

  	var indexCount = 0;

  	for ( var surf = minPatches; surf < maxPatches; surf ++ ) {

  		// lid is in the middle of the data, patches 20-27,
  		// so ignore it for this part of the loop if the lid is not desired
  		if ( lid || ( surf < 20 || surf >= 28 ) ) {

  			// get M * G * M matrix for x,y,z
  			for ( i = 0; i < 3; i ++ ) {

  				// get control patches
  				for ( r = 0; r < 4; r ++ ) {

  					for ( c = 0; c < 4; c ++ ) {

  						// transposed
  						g[ c * 4 + r ] = teapotVertices[ teapotPatches[ surf * 16 + r * 4 + c ] * 3 + i ];

  						// is the lid to be made larger, and is this a point on the lid
  						// that is X or Y?
  						if ( fitLid && ( surf >= 20 && surf < 28 ) && ( i !== 2 ) ) {

  							// increase XY size by 7.7%, found empirically. I don't
  							// increase Z so that the teapot will continue to fit in the
  							// space -1 to 1 for Y (Y is up for the final model).
  							g[ c * 4 + r ] *= 1.077;

  						}

  						// Blinn "fixed" the teapot by dividing Z by blinnScale, and that's the
  						// data we now use. The original teapot is taller. Fix it:
  						if ( ! blinn && ( i === 2 ) ) {

  							g[ c * 4 + r ] *= blinnScale;

  						}

  					}

  				}

  				gmx.set( g[ 0 ], g[ 1 ], g[ 2 ], g[ 3 ], g[ 4 ], g[ 5 ], g[ 6 ], g[ 7 ], g[ 8 ], g[ 9 ], g[ 10 ], g[ 11 ], g[ 12 ], g[ 13 ], g[ 14 ], g[ 15 ] );

  				tmtx.multiplyMatrices( gmx, ms );
  				mgm[ i ].multiplyMatrices( mst, tmtx );

  			}

  			// step along, get points, and output
  			for ( sstep = 0; sstep <= segments; sstep ++ ) {

  				s = sstep / segments;

  				for ( tstep = 0; tstep <= segments; tstep ++ ) {

  					t = tstep / segments;

  					// point from basis
  					// get power vectors and their derivatives
  					for ( p = 4, sval = tval = 1.0; p --; ) {

  						sp[ p ] = sval;
  						tp[ p ] = tval;
  						sval *= s;
  						tval *= t;

  						if ( p === 3 ) {

  							dsp[ p ] = dtp[ p ] = 0.0;
  							dsval = dtval = 1.0;

  						} else {

  							dsp[ p ] = dsval * ( 3 - p );
  							dtp[ p ] = dtval * ( 3 - p );
  							dsval *= s;
  							dtval *= t;

  						}

  					}

  					vsp.fromArray( sp );
  					vtp.fromArray( tp );
  					vdsp.fromArray( dsp );
  					vdtp.fromArray( dtp );

  					// do for x,y,z
  					for ( i = 0; i < 3; i ++ ) {

  						// multiply power vectors times matrix to get value
  						tcoord = vsp.clone();
  						tcoord.applyMatrix4( mgm[ i ] );
  						vert[ i ] = tcoord.dot( vtp );

  						// get s and t tangent vectors
  						tcoord = vdsp.clone();
  						tcoord.applyMatrix4( mgm[ i ] );
  						sdir[ i ] = tcoord.dot( vtp );

  						tcoord = vsp.clone();
  						tcoord.applyMatrix4( mgm[ i ] );
  						tdir[ i ] = tcoord.dot( vdtp );

  					}

  					// find normal
  					vsdir.fromArray( sdir );
  					vtdir.fromArray( tdir );
  					norm.crossVectors( vtdir, vsdir );
  					norm.normalize();

  					// if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number
  					if ( vert[ 0 ] === 0 && vert[ 1 ] === 0 ) {

  						// if above the middle of the teapot, normal points up, else down
  						normOut.set( 0, vert[ 2 ] > maxHeight2 ? 1 : - 1, 0 );

  					} else {

  						// standard output: rotate on X axis
  						normOut.set( norm.x, norm.z, - norm.y );

  					}

  					// store it all
  					vertices[ vertCount ++ ] = trueSize * vert[ 0 ];
  					vertices[ vertCount ++ ] = trueSize * ( vert[ 2 ] - maxHeight2 );
  					vertices[ vertCount ++ ] = - trueSize * vert[ 1 ];

  					normals[ normCount ++ ] = normOut.x;
  					normals[ normCount ++ ] = normOut.y;
  					normals[ normCount ++ ] = normOut.z;

  					uvs[ uvCount ++ ] = 1 - t;
  					uvs[ uvCount ++ ] = 1 - s;

  				}

  			}

  			// save the faces
  			for ( sstep = 0; sstep < segments; sstep ++ ) {

  				for ( tstep = 0; tstep < segments; tstep ++ ) {

  					v1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;
  					v2 = v1 + 1;
  					v3 = v2 + vertPerRow;
  					v4 = v1 + vertPerRow;

  					// Normals and UVs cannot be shared. Without clone(), you can see the consequences
  					// of sharing if you call geometry.applyMatrix( matrix ).
  					if ( notDegenerate( v1, v2, v3 ) ) {

  						indices[ indexCount ++ ] = v1;
  						indices[ indexCount ++ ] = v2;
  						indices[ indexCount ++ ] = v3;

  					}
  					if ( notDegenerate( v1, v3, v4 ) ) {

  						indices[ indexCount ++ ] = v1;
  						indices[ indexCount ++ ] = v3;
  						indices[ indexCount ++ ] = v4;

  					}

  				}

  			}

  			// increment only if a surface was used
  			surfCount ++;

  		}

  	}

  	this.setIndex( new BufferAttribute( indices, 1 ) );
  	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

  	this.computeBoundingSphere();

  };
  TeapotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TeapotBufferGeometry.prototype.constructor = TeapotBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { data: data, width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  	this.generateMipmaps = false;
  	this.flipY = false;
  	this.unpackAlignment = 1;

  }

  DataTexture.prototype = Object.create( Texture.prototype );
  DataTexture.prototype.constructor = DataTexture;

  DataTexture.prototype.isDataTexture = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function GPUComputationRenderer( sizeX, sizeY, renderer ) {

  	this.variables = [];

  	this.currentTextureIndex = 0;

  	var scene = new Scene();

  	var camera = new Camera();
  	camera.position.z = 1;

  	var passThruUniforms = {
  		texture: { value: null }
  	};

  	var passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );

  	var mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), passThruShader );
  	scene.add( mesh );
  	this.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {

  		var material = this.createShaderMaterial( computeFragmentShader );

  		var variable = {
  			name: variableName,
  			initialValueTexture: initialValueTexture,
  			material: material,
  			dependencies: null,
  			renderTargets: [],
  			wrapS: null,
  			wrapT: null,
  			minFilter: NearestFilter,
  			magFilter: NearestFilter
  		};

  		this.variables.push( variable );

  		return variable;
  		
  	};

  	this.setVariableDependencies = function( variable, dependencies ) {

  		variable.dependencies = dependencies;

  	};

  	this.init = function() {
  		var this$1 = this;


  		if ( ! renderer.extensions.get( "OES_texture_float" ) ) {

  			return "No OES_texture_float support for float textures.";

  		}

  		if ( renderer.capabilities.maxVertexTextures === 0 ) {

  			return "No support for vertex shader textures.";

  		}

  		for ( var i = 0; i < this.variables.length; i++ ) {

  			var variable = this$1.variables[ i ];

  			// Creates rendertargets and initialize them with input texture
  			variable.renderTargets[ 0 ] = this$1.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );
  			variable.renderTargets[ 1 ] = this$1.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );
  			this$1.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );
  			this$1.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );

  			// Adds dependencies uniforms to the ShaderMaterial
  			var material = variable.material;
  			var uniforms = material.uniforms;
  			if ( variable.dependencies !== null ) {

  				for ( var d = 0; d < variable.dependencies.length; d++ ) {

  					var depVar = variable.dependencies[ d ];

  					if ( depVar.name !== variable.name ) {

  						// Checks if variable exists
  						var found = false;
  						for ( var j = 0; j < this.variables.length; j++ ) {

  							if ( depVar.name === this$1.variables[ j ].name ) {
  								found = true;
  								break;
  							}

  						}
  						if ( ! found ) {
  							return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
  						}

  					}

  					uniforms[ depVar.name ] = { value: null };

  					material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;

  				}
  			}
  		}

  		this.currentTextureIndex = 0;

  		return null;

  	};

  	this.compute = function() {
  		var this$1 = this;


  		var currentTextureIndex = this.currentTextureIndex;
  		var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;

  		for ( var i = 0, il = this.variables.length; i < il; i++ ) {

  			var variable = this$1.variables[ i ];

  			// Sets texture dependencies uniforms
  			if ( variable.dependencies !== null ) {

  				var uniforms = variable.material.uniforms;
  				for ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {

  					var depVar = variable.dependencies[ d ];

  					uniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;

  				}

  			}

  			// Performs the computation for this variable
  			this$1.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );

  		}

  		this.currentTextureIndex = nextTextureIndex;
  	};

  	this.getCurrentRenderTarget = function( variable ) {

  		return variable.renderTargets[ this.currentTextureIndex ];

  	};

  	this.getAlternateRenderTarget = function( variable ) {

  		return variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];

  	};

  	function addResolutionDefine( materialShader ) {

  		materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + " )";

  	}
  	this.addResolutionDefine = addResolutionDefine;
  	// The following functions can be used to compute things manually

  	function createShaderMaterial( computeFragmentShader, uniforms ) {

  		uniforms = uniforms || {};

  		var material = new ShaderMaterial( {
  			uniforms: uniforms,
  			vertexShader: getPassThroughVertexShader(),
  			fragmentShader: computeFragmentShader
  		} );

  		addResolutionDefine( material );

  		return material;

  	}

  	this.createShaderMaterial = createShaderMaterial;

  	this.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {

  		sizeXTexture = sizeXTexture || sizeX;
  		sizeYTexture = sizeYTexture || sizeY;

  		wrapS = wrapS || ClampToEdgeWrapping;
  		wrapT = wrapT || ClampToEdgeWrapping;

  		minFilter = minFilter || NearestFilter;
  		magFilter = magFilter || NearestFilter;

  		var renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {
  			wrapS: wrapS,
  			wrapT: wrapT,
  			minFilter: minFilter,
  			magFilter: magFilter,
  			format: RGBAFormat,
  			type: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? HalfFloatType : FloatType,
  			stencilBuffer: false,
  			depthBuffer: false
  		} );

  		return renderTarget;

  	};

  	this.createTexture = function() {

  		var a = new Float32Array( sizeX * sizeY * 4 );
  		var texture = new DataTexture( a, sizeX, sizeY, RGBAFormat, FloatType );
  		texture.needsUpdate = true;

  		return texture;

  	};

  	this.renderTexture = function( input, output ) {

  		// Takes a texture, and render out in rendertarget
  		// input = Texture
  		// output = RenderTarget

  		passThruUniforms.texture.value = input;

  		this.doRenderTarget( passThruShader, output);

  		passThruUniforms.texture.value = null;

  	};

  	this.doRenderTarget = function( material, output ) {

  		var currentRenderTarget = renderer.getRenderTarget();

  		mesh.material = material;
  		renderer.setRenderTarget( output );
  		renderer.render( scene, camera );
  		mesh.material = passThruShader;

  		renderer.setRenderTarget( currentRenderTarget );

  	};

  	// Shaders

  	function getPassThroughVertexShader() {

  		return	"void main()	{\n" +
  				"\n" +
  				"	gl_Position = vec4( position, 1.0 );\n" +
  				"\n" +
  				"}\n";

  	}

  	function getPassThroughFragmentShader() {

  		return	"uniform sampler2D texture;\n" +
  				"\n" +
  				"void main() {\n" +
  				"\n" +
  				"	vec2 uv = gl_FragCoord.xy / resolution.xy;\n" +
  				"\n" +
  				"	gl_FragColor = texture2D( texture, uv );\n" +
  				"\n" +
  				"}\n";

  	}

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Cache = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LoadingManager( onLoad, onProgress, onError ) {

  	var scope = this;

  	var isLoading = false;
  	var itemsLoaded = 0;
  	var itemsTotal = 0;
  	var urlModifier = undefined;

  	// Refer to #5689 for the reason why we don't set .onStart
  	// in the constructor

  	this.onStart = undefined;
  	this.onLoad = onLoad;
  	this.onProgress = onProgress;
  	this.onError = onError;

  	this.itemStart = function ( url ) {

  		itemsTotal ++;

  		if ( isLoading === false ) {

  			if ( scope.onStart !== undefined ) {

  				scope.onStart( url, itemsLoaded, itemsTotal );

  			}

  		}

  		isLoading = true;

  	};

  	this.itemEnd = function ( url ) {

  		itemsLoaded ++;

  		if ( scope.onProgress !== undefined ) {

  			scope.onProgress( url, itemsLoaded, itemsTotal );

  		}

  		if ( itemsLoaded === itemsTotal ) {

  			isLoading = false;

  			if ( scope.onLoad !== undefined ) {

  				scope.onLoad();

  			}

  		}

  	};

  	this.itemError = function ( url ) {

  		if ( scope.onError !== undefined ) {

  			scope.onError( url );

  		}

  	};

  	this.resolveURL = function ( url ) {

  		if ( urlModifier ) {

  			return urlModifier( url );

  		}

  		return url;

  	};

  	this.setURLModifier = function ( transform ) {

  		urlModifier = transform;
  		return this;

  	};

  }

  var DefaultLoadingManager = new LoadingManager();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ImageLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( ImageLoader.prototype, {

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		url = this.manager.resolveURL( url );

  		var scope = this;

  		var cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  		function onImageLoad() {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  			Cache.add( url, this );

  			if ( onLoad ) { onLoad( this ); }

  			scope.manager.itemEnd( url );

  		}

  		function onImageError( event ) {

  			image.removeEventListener( 'load', onImageLoad, false );
  			image.removeEventListener( 'error', onImageError, false );

  			if ( onError ) { onError( event ); }

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		}

  		image.addEventListener( 'load', onImageLoad, false );
  		image.addEventListener( 'error', onImageError, false );

  		if ( url.substr( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( TextureLoader.prototype, {

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var texture = new Texture();

  		var loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		loader.load( url, function ( image ) {

  			texture.image = image;

  			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  			var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  			texture.format = isJPEG ? RGBFormat : RGBAFormat;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PointsMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'PointsMaterial';

  	this.color = new Color( 0xffffff );

  	this.map = null;

  	this.size = 1;
  	this.sizeAttenuation = true;

  	this.morphTargets = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  PointsMaterial.prototype = Object.create( Material$1.prototype );
  PointsMaterial.prototype.constructor = PointsMaterial;

  PointsMaterial.prototype.isPointsMaterial = true;

  PointsMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.size = source.size;
  	this.sizeAttenuation = source.sizeAttenuation;

  	this.morphTargets = source.morphTargets;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Points( geometry, material ) {

  	Object3D.call( this );

  	this.type = 'Points';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

  }

  Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Points,

  	isPoints: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		return function raycast( raycaster, intersects ) {

  			var object = this;
  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;
  			var threshold = raycaster.params.Points.threshold;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );
  			sphere.radius += threshold;

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  			var localThresholdSq = localThreshold * localThreshold;
  			var position = new Vector3();
  			var intersectPoint = new Vector3();

  			function testPoint( point, index ) {

  				var rayPointDistanceSq = ray.distanceSqToPoint( point );

  				if ( rayPointDistanceSq < localThresholdSq ) {

  					ray.closestPointToPoint( point, intersectPoint );
  					intersectPoint.applyMatrix4( matrixWorld );

  					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  					if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  					intersects.push( {

  						distance: distance,
  						distanceToRay: Math.sqrt( rayPointDistanceSq ),
  						point: intersectPoint.clone(),
  						index: index,
  						face: null,
  						object: object

  					} );

  				}

  			}

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, il = indices.length; i < il; i ++ ) {

  						var a = indices[ i ];

  						position.fromArray( positions, a * 3 );

  						testPoint( position, a );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

  						position.fromArray( positions, i * 3 );

  						testPoint( position, i );

  					}

  				}

  			} else {

  				var vertices = geometry.vertices;

  				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

  					testPoint( vertices[ i ], i );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GPUParticleSystem = function ( options ) {
  	var this$1 = this;


  	Object3D.apply( this, arguments );

  	options = options || {};

  	// parse options and use defaults

  	this.PARTICLE_COUNT = options.maxParticles || 1000000;
  	this.PARTICLE_CONTAINERS = options.containerCount || 1;

  	this.PARTICLE_NOISE_TEXTURE = options.particleNoiseTex || null;
  	this.PARTICLE_SPRITE_TEXTURE = options.particleSpriteTex || null;

  	this.PARTICLES_PER_CONTAINER = Math.ceil( this.PARTICLE_COUNT / this.PARTICLE_CONTAINERS );
  	this.PARTICLE_CURSOR = 0;
  	this.time = 0;
  	this.particleContainers = [];
  	this.rand = [];

  	// custom vertex and fragement shader

  	var GPUParticleShader = {

  		vertexShader: [

  			'uniform float uTime;',
  			'uniform float uScale;',
  			'uniform sampler2D tNoise;',

  			'attribute vec3 positionStart;',
  			'attribute float startTime;',
  			'attribute vec3 velocity;',
  			'attribute float turbulence;',
  			'attribute vec3 color;',
  			'attribute float size;',
  			'attribute float lifeTime;',

  			'varying vec4 vColor;',
  			'varying float lifeLeft;',

  			'void main() {',

  			// unpack things from our attributes'

  			'	vColor = vec4( color, 1.0 );',

  			// convert our velocity back into a value we can use'

  			'	vec3 newPosition;',
  			'	vec3 v;',

  			'	float timeElapsed = uTime - startTime;',

  			'	lifeLeft = 1.0 - ( timeElapsed / lifeTime );',

  			'	gl_PointSize = ( uScale * size ) * lifeLeft;',

  			'	v.x = ( velocity.x - 0.5 ) * 3.0;',
  			'	v.y = ( velocity.y - 0.5 ) * 3.0;',
  			'	v.z = ( velocity.z - 0.5 ) * 3.0;',

  			'	newPosition = positionStart + ( v * 10.0 ) * timeElapsed;',

  			'	vec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;',
  			'	vec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;',

  			'	newPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );',

  			'	if( v.y > 0. && v.y < .05 ) {',

  			'		lifeLeft = 0.0;',

  			'	}',

  			'	if( v.x < - 1.45 ) {',

  			'		lifeLeft = 0.0;',

  			'	}',

  			'	if( timeElapsed > 0.0 ) {',

  			'		gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );',

  			'	} else {',

  			'		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
  			'		lifeLeft = 0.0;',
  			'		gl_PointSize = 0.;',

  			'	}',

  			'}'

  		].join( '\n' ),

  		fragmentShader: [

  			'float scaleLinear( float value, vec2 valueDomain ) {',

  			'	return ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );',

  			'}',

  			'float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {',

  			'	return mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );',

  			'}',

  			'varying vec4 vColor;',
  			'varying float lifeLeft;',

  			'uniform sampler2D tSprite;',

  			'void main() {',

  			'	float alpha = 0.;',

  			'	if( lifeLeft > 0.995 ) {',

  			'		alpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );',

  			'	} else {',

  			'		alpha = lifeLeft * 0.75;',

  			'	}',

  			'	vec4 tex = texture2D( tSprite, gl_PointCoord );',
  			'	gl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );',

  			'}'

  		].join( '\n' )

  	};

  	// preload a million random numbers

  	var i;

  	for ( i = 1e5; i > 0; i -- ) {

  		this$1.rand.push( Math.random() - 0.5 );

  	}

  	this.random = function () {

  		return ++ i >= this.rand.length ? this.rand[ i = 1 ] : this.rand[ i ];

  	};

  	var textureLoader = new TextureLoader();

  	this.particleNoiseTex = this.PARTICLE_NOISE_TEXTURE || textureLoader.load( 'textures/perlin-512.png' );
  	this.particleNoiseTex.wrapS = this.particleNoiseTex.wrapT = RepeatWrapping;

  	this.particleSpriteTex = this.PARTICLE_SPRITE_TEXTURE || textureLoader.load( 'textures/particle2.png' );
  	this.particleSpriteTex.wrapS = this.particleSpriteTex.wrapT = RepeatWrapping;

  	this.particleShaderMat = new ShaderMaterial( {
  		transparent: true,
  		depthWrite: false,
  		uniforms: {
  			'uTime': {
  				value: 0.0
  			},
  			'uScale': {
  				value: 1.0
  			},
  			'tNoise': {
  				value: this.particleNoiseTex
  			},
  			'tSprite': {
  				value: this.particleSpriteTex
  			}
  		},
  		blending: AdditiveBlending,
  		vertexShader: GPUParticleShader.vertexShader,
  		fragmentShader: GPUParticleShader.fragmentShader
  	} );

  	// define defaults for all values

  	this.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [ 0, 0, 0, 0 ];
  	this.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [ 0, 0, 0, 0 ];

  	this.init = function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {

  			var c = new GPUParticleContainer( this$1.PARTICLES_PER_CONTAINER, this$1 );
  			this$1.particleContainers.push( c );
  			this$1.add( c );

  		}

  	};

  	this.spawnParticle = function ( options ) {

  		this.PARTICLE_CURSOR ++;

  		if ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {

  			this.PARTICLE_CURSOR = 1;

  		}

  		var currentContainer = this.particleContainers[ Math.floor( this.PARTICLE_CURSOR / this.PARTICLES_PER_CONTAINER ) ];

  		currentContainer.spawnParticle( options );

  	};

  	this.update = function ( time ) {
  		var this$1 = this;


  		for ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {

  			this$1.particleContainers[ i ].update( time );

  		}

  	};

  	this.dispose = function () {
  		var this$1 = this;


  		this.particleShaderMat.dispose();
  		this.particleNoiseTex.dispose();
  		this.particleSpriteTex.dispose();

  		for ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {

  			this$1.particleContainers[ i ].dispose();

  		}

  	};

  	this.init();

  };

  GPUParticleSystem.prototype = Object.create( Object3D.prototype );
  GPUParticleSystem.prototype.constructor = GPUParticleSystem;
  // Subclass for particle containers, allows for very large arrays to be spread out

  var GPUParticleContainer = function ( maxParticles, particleSystem ) {

  	Object3D.apply( this, arguments );

  	this.PARTICLE_COUNT = maxParticles || 100000;
  	this.PARTICLE_CURSOR = 0;
  	this.time = 0;
  	this.offset = 0;
  	this.count = 0;
  	this.DPR = window.devicePixelRatio;
  	this.GPUParticleSystem = particleSystem;
  	this.particleUpdate = false;

  	// geometry

  	this.particleShaderGeo = new BufferGeometry();

  	this.particleShaderGeo.addAttribute( 'position', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'positionStart', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'startTime', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'velocity', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'turbulence', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'color', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'size', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );
  	this.particleShaderGeo.addAttribute( 'lifeTime', new BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );

  	// material

  	this.particleShaderMat = this.GPUParticleSystem.particleShaderMat;

  	var position = new Vector3();
  	var velocity = new Vector3();
  	var color = new Color();

  	this.spawnParticle = function ( options ) {

  		var positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );
  		var startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );
  		var velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );
  		var turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );
  		var colorAttribute = this.particleShaderGeo.getAttribute( 'color' );
  		var sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );
  		var lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );

  		options = options || {};

  		// setup reasonable default values for all arguments

  		position = options.position !== undefined ? position.copy( options.position ) : position.set( 0, 0, 0 );
  		velocity = options.velocity !== undefined ? velocity.copy( options.velocity ) : velocity.set( 0, 0, 0 );
  		color = options.color !== undefined ? color.set( options.color ) : color.set( 0xffffff );

  		var positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0;
  		var velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0;
  		var colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;
  		var turbulence = options.turbulence !== undefined ? options.turbulence : 1;
  		var lifetime = options.lifetime !== undefined ? options.lifetime : 5;
  		var size = options.size !== undefined ? options.size : 10;
  		var sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;
  		var smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;

  		if ( this.DPR !== undefined ) { size *= this.DPR; }

  		var i = this.PARTICLE_CURSOR;

  		// position

  		positionStartAttribute.array[ i * 3 + 0 ] = position.x + ( particleSystem.random() * positionRandomness );
  		positionStartAttribute.array[ i * 3 + 1 ] = position.y + ( particleSystem.random() * positionRandomness );
  		positionStartAttribute.array[ i * 3 + 2 ] = position.z + ( particleSystem.random() * positionRandomness );

  		if ( smoothPosition === true ) {

  			positionStartAttribute.array[ i * 3 + 0 ] += - ( velocity.x * particleSystem.random() );
  			positionStartAttribute.array[ i * 3 + 1 ] += - ( velocity.y * particleSystem.random() );
  			positionStartAttribute.array[ i * 3 + 2 ] += - ( velocity.z * particleSystem.random() );

  		}

  		// velocity

  		var maxVel = 2;

  		var velX = velocity.x + particleSystem.random() * velocityRandomness;
  		var velY = velocity.y + particleSystem.random() * velocityRandomness;
  		var velZ = velocity.z + particleSystem.random() * velocityRandomness;

  		velX = _Math.clamp( ( velX - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );
  		velY = _Math.clamp( ( velY - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );
  		velZ = _Math.clamp( ( velZ - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );

  		velocityAttribute.array[ i * 3 + 0 ] = velX;
  		velocityAttribute.array[ i * 3 + 1 ] = velY;
  		velocityAttribute.array[ i * 3 + 2 ] = velZ;

  		// color

  		color.r = _Math.clamp( color.r + particleSystem.random() * colorRandomness, 0, 1 );
  		color.g = _Math.clamp( color.g + particleSystem.random() * colorRandomness, 0, 1 );
  		color.b = _Math.clamp( color.b + particleSystem.random() * colorRandomness, 0, 1 );

  		colorAttribute.array[ i * 3 + 0 ] = color.r;
  		colorAttribute.array[ i * 3 + 1 ] = color.g;
  		colorAttribute.array[ i * 3 + 2 ] = color.b;

  		// turbulence, size, lifetime and starttime

  		turbulenceAttribute.array[ i ] = turbulence;
  		sizeAttribute.array[ i ] = size + particleSystem.random() * sizeRandomness;
  		lifeTimeAttribute.array[ i ] = lifetime;
  		startTimeAttribute.array[ i ] = this.time + particleSystem.random() * 2e-2;

  		// offset

  		if ( this.offset === 0 ) {

  			this.offset = this.PARTICLE_CURSOR;

  		}

  		// counter and cursor

  		this.count ++;
  		this.PARTICLE_CURSOR ++;

  		if ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {

  			this.PARTICLE_CURSOR = 0;

  		}

  		this.particleUpdate = true;

  	};

  	this.init = function () {

  		this.particleSystem = new Points( this.particleShaderGeo, this.particleShaderMat );
  		this.particleSystem.frustumCulled = false;
  		this.add( this.particleSystem );

  	};

  	this.update = function ( time ) {

  		this.time = time;
  		this.particleShaderMat.uniforms.uTime.value = time;

  		this.geometryUpdate();

  	};

  	this.geometryUpdate = function () {

  		if ( this.particleUpdate === true ) {

  			this.particleUpdate = false;

  			var positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );
  			var startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );
  			var velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );
  			var turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );
  			var colorAttribute = this.particleShaderGeo.getAttribute( 'color' );
  			var sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );
  			var lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );

  			if ( this.offset + this.count < this.PARTICLE_COUNT ) {

  				positionStartAttribute.updateRange.offset = this.offset * positionStartAttribute.itemSize;
  				startTimeAttribute.updateRange.offset = this.offset * startTimeAttribute.itemSize;
  				velocityAttribute.updateRange.offset = this.offset * velocityAttribute.itemSize;
  				turbulenceAttribute.updateRange.offset = this.offset * turbulenceAttribute.itemSize;
  				colorAttribute.updateRange.offset = this.offset * colorAttribute.itemSize;
  				sizeAttribute.updateRange.offset = this.offset * sizeAttribute.itemSize;
  				lifeTimeAttribute.updateRange.offset = this.offset * lifeTimeAttribute.itemSize;

  				positionStartAttribute.updateRange.count = this.count * positionStartAttribute.itemSize;
  				startTimeAttribute.updateRange.count = this.count * startTimeAttribute.itemSize;
  				velocityAttribute.updateRange.count = this.count * velocityAttribute.itemSize;
  				turbulenceAttribute.updateRange.count = this.count * turbulenceAttribute.itemSize;
  				colorAttribute.updateRange.count = this.count * colorAttribute.itemSize;
  				sizeAttribute.updateRange.count = this.count * sizeAttribute.itemSize;
  				lifeTimeAttribute.updateRange.count = this.count * lifeTimeAttribute.itemSize;

  			} else {

  				positionStartAttribute.updateRange.offset = 0;
  				startTimeAttribute.updateRange.offset = 0;
  				velocityAttribute.updateRange.offset = 0;
  				turbulenceAttribute.updateRange.offset = 0;
  				colorAttribute.updateRange.offset = 0;
  				sizeAttribute.updateRange.offset = 0;
  				lifeTimeAttribute.updateRange.offset = 0;

  				// Use -1 to update the entire buffer, see #11476
  				positionStartAttribute.updateRange.count = - 1;
  				startTimeAttribute.updateRange.count = - 1;
  				velocityAttribute.updateRange.count = - 1;
  				turbulenceAttribute.updateRange.count = - 1;
  				colorAttribute.updateRange.count = - 1;
  				sizeAttribute.updateRange.count = - 1;
  				lifeTimeAttribute.updateRange.count = - 1;

  			}

  			positionStartAttribute.needsUpdate = true;
  			startTimeAttribute.needsUpdate = true;
  			velocityAttribute.needsUpdate = true;
  			turbulenceAttribute.needsUpdate = true;
  			colorAttribute.needsUpdate = true;
  			sizeAttribute.needsUpdate = true;
  			lifeTimeAttribute.needsUpdate = true;

  			this.offset = 0;
  			this.count = 0;

  		}

  	};

  	this.dispose = function () {

  		this.particleShaderGeo.dispose();

  	};

  	this.init();

  };

  GPUParticleContainer.prototype = Object.create( Object3D.prototype );
  GPUParticleContainer.prototype.constructor = GPUParticleContainer;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Gyroscope = function () {

  	Object3D.call( this );

  };

  Gyroscope.prototype = Object.create( Object3D.prototype );
  Gyroscope.prototype.constructor = Gyroscope;

  Gyroscope.prototype.updateMatrixWorld = ( function () {

  	var translationObject = new Vector3();
  	var quaternionObject = new Quaternion();
  	var scaleObject = new Vector3();

  	var translationWorld = new Vector3();
  	var quaternionWorld = new Quaternion();
  	var scaleWorld = new Vector3();

  	return function updateMatrixWorld( force ) {
  		var this$1 = this;


  		this.matrixAutoUpdate && this.updateMatrix();

  		// update matrixWorld

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent !== null ) {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
  				this.matrix.decompose( translationObject, quaternionObject, scaleObject );

  				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );
  			} else {

  				this.matrixWorld.copy( this.matrix );

  			}
  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  			this$1.children[ i ].updateMatrixWorld( force );

  		}

  	};

  }() );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // http://mrl.nyu.edu/~perlin/noise/

  var ImprovedNoise = function () {

  	var p = [ 151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,
  		 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,
  		 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,
  		 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,
  		 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
  		 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
  		 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
  		 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
  		 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,
  		 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ];

  	for (var i = 0; i < 256 ; i ++) {

  		p[256 + i] = p[i];

  	}

  	function fade(t) {

  		return t * t * t * (t * (t * 6 - 15) + 10);

  	}

  	function lerp(t, a, b) {

  		return a + t * (b - a);

  	}

  	function grad(hash, x, y, z) {

  		var h = hash & 15;
  		var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
  		return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);

  	}

  	return {

  		noise: function (x, y, z) {

  			var floorX = Math.floor(x), floorY = Math.floor(y), floorZ = Math.floor(z);

  			var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

  			x -= floorX;
  			y -= floorY;
  			z -= floorZ;

  			var xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;

  			var u = fade(x), v = fade(y), w = fade(z);

  			var A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;

  			return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
  							grad(p[BA], xMinus1, y, z)),
  						lerp(u, grad(p[AB], x, yMinus1, z),
  							grad(p[BB], xMinus1, yMinus1, z))),
  					lerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1),
  							grad(p[BA + 1], xMinus1, y, z - 1)),
  						lerp(u, grad(p[AB + 1], x, yMinus1, zMinus1),
  							grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));

  		}
  	}
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Frustum( p0, p1, p2, p3, p4, p5 ) {

  	this.planes = [

  		( p0 !== undefined ) ? p0 : new Plane(),
  		( p1 !== undefined ) ? p1 : new Plane(),
  		( p2 !== undefined ) ? p2 : new Plane(),
  		( p3 !== undefined ) ? p3 : new Plane(),
  		( p4 !== undefined ) ? p4 : new Plane(),
  		( p5 !== undefined ) ? p5 : new Plane()

  	];

  }

  Object.assign( Frustum.prototype, {

  	set: function ( p0, p1, p2, p3, p4, p5 ) {

  		var planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( frustum ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	},

  	setFromMatrix: function ( m ) {

  		var planes = this.planes;
  		var me = m.elements;
  		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		return this;

  	},

  	intersectsObject: function () {

  		var sphere = new Sphere();

  		return function intersectsObject( object ) {

  			var geometry = object.geometry;

  			if ( geometry.boundingSphere === null )
  				{ geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere )
  				.applyMatrix4( object.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSprite: function () {

  		var sphere = new Sphere();

  		return function intersectsSprite( sprite ) {

  			sphere.center.set( 0, 0, 0 );
  			sphere.radius = 0.7071067811865476;
  			sphere.applyMatrix4( sprite.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		var planes = this.planes;
  		var center = sphere.center;
  		var negRadius = - sphere.radius;

  		for ( var i = 0; i < 6; i ++ ) {

  			var distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	},

  	intersectsBox: function () {

  		var p = new Vector3();

  		return function intersectsBox( box ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				var plane = planes[ i ];

  				// corner at max distance

  				p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  				p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  				p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  				if ( plane.distanceToPoint( p ) < 0 ) {

  					return false;

  				}

  			}

  			return true;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SelectionBox = ( function () {

  	var frustum = new Frustum();
  	var center = new Vector3();

  	function SelectionBox( camera, scene, deep ) {

  		this.camera = camera;
  		this.scene = scene;
  		this.startPoint = new Vector3();
  		this.endPoint = new Vector3();
  		this.collection = [];
  		this.deep = deep || Number.MAX_VALUE;

  	}

  	SelectionBox.prototype.select = function ( startPoint, endPoint ) {

  		this.startPoint = startPoint || this.startPoint;
  		this.endPoint = endPoint || this.endPoint;
  		this.collection = [];

  		this.updateFrustum( this.startPoint, this.endPoint );
  		this.searchChildInFrustum( frustum, this.scene );

  		return this.collection;

  	};

  	SelectionBox.prototype.updateFrustum = function ( startPoint, endPoint ) {

  		startPoint = startPoint || this.startPoint;
  		endPoint = endPoint || this.endPoint;

  		this.camera.updateProjectionMatrix();
  		this.camera.updateMatrixWorld();

  		var tmpPoint = startPoint.clone();
  		tmpPoint.x = Math.min( startPoint.x, endPoint.x );
  		tmpPoint.y = Math.max( startPoint.y, endPoint.y );
  		endPoint.x = Math.max( startPoint.x, endPoint.x );
  		endPoint.y = Math.min( startPoint.y, endPoint.y );

  		var vecNear = this.camera.position.clone();
  		var vecTopLeft = tmpPoint.clone();
  		var vecTopRight = new Vector3( endPoint.x, tmpPoint.y, 0 );
  		var vecDownRight = endPoint.clone();
  		var vecDownLeft = new Vector3( tmpPoint.x, endPoint.y, 0 );
  		vecTopLeft.unproject( this.camera );
  		vecTopRight.unproject( this.camera );
  		vecDownRight.unproject( this.camera );
  		vecDownLeft.unproject( this.camera );

  		var vectemp1 = vecTopLeft.clone().sub( vecNear );
  		var vectemp2 = vecTopRight.clone().sub( vecNear );
  		var vectemp3 = vecDownRight.clone().sub( vecNear );
  		vectemp1.normalize();
  		vectemp2.normalize();
  		vectemp3.normalize();

  		vectemp1.multiplyScalar( this.deep );
  		vectemp2.multiplyScalar( this.deep );
  		vectemp3.multiplyScalar( this.deep );
  		vectemp1.add( vecNear );
  		vectemp2.add( vecNear );
  		vectemp3.add( vecNear );

  		var planes = frustum.planes;

  		planes[ 0 ].setFromCoplanarPoints( vecNear, vecTopLeft, vecTopRight );
  		planes[ 1 ].setFromCoplanarPoints( vecNear, vecTopRight, vecDownRight );
  		planes[ 2 ].setFromCoplanarPoints( vecDownRight, vecDownLeft, vecNear );
  		planes[ 3 ].setFromCoplanarPoints( vecDownLeft, vecTopLeft, vecNear );
  		planes[ 4 ].setFromCoplanarPoints( vecTopRight, vecDownRight, vecDownLeft );
  		planes[ 5 ].setFromCoplanarPoints( vectemp3, vectemp2, vectemp1 );
  		planes[ 5 ].normal.multiplyScalar( - 1 );

  	};

  	SelectionBox.prototype.searchChildInFrustum = function ( frustum, object ) {
  		var this$1 = this;


  		if ( object.isMesh ) {

  			if ( object.material !== undefined ) {

  				object.geometry.computeBoundingSphere();

  				center.copy( object.geometry.boundingSphere.center );

  				center.applyMatrix4( object.matrixWorld );

  				if ( frustum.containsPoint( center ) ) {

  					this.collection.push( object );

  				}

  			}

  		}

  		if ( object.children.length > 0 ) {

  			for ( var x = 0; x < object.children.length; x ++ ) {

  				this$1.searchChildInFrustum( frustum, object.children[ x ] );

  			}

  		}

  	};

  	return SelectionBox;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SelectionHelper = ( function () {

  	function SelectionHelper( selectionBox, renderer, cssClassName ) {

  		this.element = document.createElement( 'div' );
  		this.element.classList.add( cssClassName );
  		this.element.style.pointerEvents = 'none';

  		this.renderer = renderer;

  		this.startPoint = { x: 0, y: 0 };
  		this.pointTopLeft = { x: 0, y: 0 };
  		this.pointBottomRight = { x: 0, y: 0 };

  		this.isDown = false;

  		this.renderer.domElement.addEventListener( 'mousedown', function ( event ) {

  			this.isDown = true;
  			this.onSelectStart( event );

  		}.bind( this ), false );

  		this.renderer.domElement.addEventListener( 'mousemove', function ( event ) {

  			if ( this.isDown ) {

  				this.onSelectMove( event );

  			}

  		}.bind( this ), false );

  		this.renderer.domElement.addEventListener( 'mouseup', function ( event ) {

  			this.isDown = false;
  			this.onSelectOver( event );

  		}.bind( this ), false );

  	}

  	SelectionHelper.prototype.onSelectStart = function ( event ) {

  		this.renderer.domElement.parentElement.appendChild( this.element );

  		this.element.style.left = event.clientX + 'px';
  		this.element.style.top = event.clientY + 'px';
  		this.element.style.width = '0px';
  		this.element.style.height = '0px';

  		this.startPoint.x = event.clientX;
  		this.startPoint.y = event.clientY;

  	};

  	SelectionHelper.prototype.onSelectMove = function ( event ) {

  		this.pointBottomRight.x = Math.max( this.startPoint.x, event.clientX );
  		this.pointBottomRight.y = Math.max( this.startPoint.y, event.clientY );
  		this.pointTopLeft.x = Math.min( this.startPoint.x, event.clientX );
  		this.pointTopLeft.y = Math.min( this.startPoint.y, event.clientY );

  		this.element.style.left = this.pointTopLeft.x + 'px';
  		this.element.style.top = this.pointTopLeft.y + 'px';
  		this.element.style.width = ( this.pointBottomRight.x - this.pointTopLeft.x ) + 'px';
  		this.element.style.height = ( this.pointBottomRight.y - this.pointTopLeft.y ) + 'px';

  	};

  	SelectionHelper.prototype.onSelectOver = function () {

  		this.element.parentElement.removeChild( this.element );

  	};

  	return SelectionHelper;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InstancedBufferGeometry() {

  	BufferGeometry.call( this );

  	this.type = 'InstancedBufferGeometry';
  	this.maxInstancedCount = undefined;

  }

  InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

  	constructor: InstancedBufferGeometry,

  	isInstancedBufferGeometry: true,

  	copy: function ( source ) {

  		BufferGeometry.prototype.copy.call( this, source );

  		this.maxInstancedCount = source.maxInstancedCount;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InterleavedBuffer( array, stride ) {

  	this.array = array;
  	this.stride = stride;
  	this.count = array !== undefined ? array.length / stride : 0;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.version = 0;

  }

  Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( InterleavedBuffer.prototype, {

  	isInterleavedBuffer: true,

  	onUploadCallback: function () {},

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.stride : 0;
  		this.array = array;

  		return this;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {
  		var this$1 = this;


  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( var i = 0, l = this.stride; i < l; i ++ ) {

  			this$1.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.array.set( value, offset );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

  	InterleavedBuffer.call( this, array, stride );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

  	constructor: InstancedInterleavedBuffer,

  	isInstancedInterleavedBuffer: true,

  	copy: function ( source ) {

  		InterleavedBuffer.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

  	this.data = interleavedBuffer;
  	this.itemSize = itemSize;
  	this.offset = offset;

  	this.normalized = normalized === true;

  }

  Object.defineProperties( InterleavedBufferAttribute.prototype, {

  	count: {

  		get: function () {

  			return this.data.count;

  		}

  	},

  	array: {

  		get: function () {

  			return this.data.array;

  		}

  	}

  } );

  Object.assign( InterleavedBufferAttribute.prototype, {

  	isInterleavedBufferAttribute: true,

  	setX: function ( index, x ) {

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	},

  	setY: function ( index, y ) {

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	},

  	setZ: function ( index, z ) {

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	},

  	setW: function ( index, w ) {

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	},

  	getX: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset ];

  	},

  	getY: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 1 ];

  	},

  	getZ: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 2 ];

  	},

  	getW: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 3 ];

  	},

  	setXY: function ( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WireframeGeometry( geometry ) {

  	BufferGeometry.call( this );

  	this.type = 'WireframeGeometry';

  	// buffer

  	var vertices = [];

  	// helper variables

  	var i, j, l, o, ol;
  	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];
  	var vertex;

  	// different logic for Geometry and BufferGeometry

  	if ( geometry && geometry.isGeometry ) {

  		// create a data structure that contains all edges without duplicates

  		var faces = geometry.faces;

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			for ( j = 0; j < 3; j ++ ) {

  				edge1 = face[ keys[ j ] ];
  				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  				edge[ 1 ] = Math.max( edge1, edge2 );

  				key = edge[ 0 ] + ',' + edge[ 1 ];

  				if ( edges[ key ] === undefined ) {

  					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  				}

  			}

  		}

  		// generate vertices

  		for ( key in edges ) {

  			e = edges[ key ];

  			vertex = geometry.vertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = geometry.vertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	} else if ( geometry && geometry.isBufferGeometry ) {

  		var position, indices, groups;
  		var group, start, count;
  		var index1, index2;

  		vertex = new Vector3();

  		if ( geometry.index !== null ) {

  			// indexed BufferGeometry

  			position = geometry.attributes.position;
  			indices = geometry.index;
  			groups = geometry.groups;

  			if ( groups.length === 0 ) {

  				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  			}

  			// create a data structure that contains all eges without duplicates

  			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

  				group = groups[ o ];

  				start = group.start;
  				count = group.count;

  				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

  					for ( j = 0; j < 3; j ++ ) {

  						edge1 = indices.getX( i + j );
  						edge2 = indices.getX( i + ( j + 1 ) % 3 );
  						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  						edge[ 1 ] = Math.max( edge1, edge2 );

  						key = edge[ 0 ] + ',' + edge[ 1 ];

  						if ( edges[ key ] === undefined ) {

  							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  						}

  					}

  				}

  			}

  			// generate vertices

  			for ( key in edges ) {

  				e = edges[ key ];

  				vertex.fromBufferAttribute( position, e.index1 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex.fromBufferAttribute( position, e.index2 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else {

  			// non-indexed BufferGeometry

  			position = geometry.attributes.position;

  			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  				for ( j = 0; j < 3; j ++ ) {

  					// three edges per triangle, an edge is represented as (index1, index2)
  					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  					index1 = 3 * i + j;
  					vertex.fromBufferAttribute( position, index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					index2 = 3 * i + ( ( j + 1 ) % 3 );
  					vertex.fromBufferAttribute( position, index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			}

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
  WireframeGeometry.prototype.constructor = WireframeGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LineSegmentsGeometry = function () {

  	InstancedBufferGeometry.call( this );

  	this.type = 'LineSegmentsGeometry';

  	var plane = new BufferGeometry();

  	var positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];
  	var uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];
  	var index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];

  	this.setIndex( index );
  	this.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  };

  LineSegmentsGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {

  	constructor: LineSegmentsGeometry,

  	isLineSegmentsGeometry: true,

  	applyMatrix: function ( matrix ) {

  		var start = this.attributes.instanceStart;
  		var end = this.attributes.instanceEnd;

  		if ( start !== undefined ) {

  			matrix.applyToBufferAttribute( start );

  			matrix.applyToBufferAttribute( end );

  			start.data.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	},

  	setPositions: function ( array ) {

  		var lineSegments;

  		if ( array instanceof Float32Array ) {

  			lineSegments = array;

  		} else if ( Array.isArray( array ) ) {

  			lineSegments = new Float32Array( array );

  		}

  		var instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

  		this.addAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
  		this.addAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

  		//

  		this.computeBoundingBox();
  		this.computeBoundingSphere();

  		return this;

  	},

  	setColors: function ( array ) {

  		var colors;

  		if ( array instanceof Float32Array ) {

  			colors = array;

  		} else if ( Array.isArray( array ) ) {

  			colors = new Float32Array( array );

  		}

  		var instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

  		this.addAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
  		this.addAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

  		return this;

  	},

  	fromWireframeGeometry: function ( geometry ) {

  		this.setPositions( geometry.attributes.position.array );

  		return this;

  	},

  	fromEdgesGeometry: function ( geometry ) {

  		this.setPositions( geometry.attributes.position.array );

  		return this;

  	},

  	fromMesh: function ( mesh ) {

  		this.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );

  		// set colors, maybe

  		return this;

  	},

  	fromLineSegements: function ( lineSegments ) {

  		var geometry = lineSegments.geometry;

  		if ( geometry.isGeometry ) {

  			this.setPositions( geometry.vertices );

  		} else if ( geometry.isBufferGeometry ) {

  			this.setPositions( geometry.position.array ); // assumes non-indexed

  		}

  		// set colors, maybe

  		return this;

  	},

  	computeBoundingBox: function () {

  		var box = new Box3();

  		return function computeBoundingBox() {

  			if ( this.boundingBox === null ) {

  				this.boundingBox = new Box3();

  			}

  			var start = this.attributes.instanceStart;
  			var end = this.attributes.instanceEnd;

  			if ( start !== undefined && end !== undefined ) {

  				this.boundingBox.setFromBufferAttribute( start );

  				box.setFromBufferAttribute( end );

  				this.boundingBox.union( box );

  			}

  		};

  	}(),

  	computeBoundingSphere: function () {

  		var vector = new Vector3();

  		return function computeBoundingSphere() {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere();

  			}

  			if ( this.boundingBox === null ) {

  				this.computeBoundingBox();

  			}

  			var start = this.attributes.instanceStart;
  			var end = this.attributes.instanceEnd;

  			if ( start !== undefined && end !== undefined ) {

  				var center = this.boundingSphere.center;

  				this.boundingBox.getCenter( center );

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = start.count; i < il; i ++ ) {

  					vector.fromBufferAttribute( start, i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  					vector.fromBufferAttribute( end, i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  				}

  				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  				if ( isNaN( this.boundingSphere.radius ) ) {

  					console.error( 'LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

  				}

  			}

  		};

  	}(),

  	toJSON: function () {

  		// todo

  	},

  	clone: function () {

  		// todo

  	},

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  UniformsLib.line = {

  	linewidth: { value: 1 },
  	resolution: { value: new Vector2( 1, 1 ) },
  	dashScale: { value: 1 },
  	dashSize: { value: 1 },
  	gapSize: { value: 1 } // todo FIX - maybe change to totalSize

  };

  ShaderLib[ 'line' ] = {

  	uniforms: UniformsUtils.merge( [
  		UniformsLib.common,
  		UniformsLib.fog,
  		UniformsLib.line
  	] ),

  	vertexShader:
  		"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",

  	fragmentShader:
  		"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
  };

  var LineMaterial = function ( parameters ) {

  	ShaderMaterial.call( this, {

  		type: 'LineMaterial',

  		uniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),

  		vertexShader: ShaderLib[ 'line' ].vertexShader,
  		fragmentShader: ShaderLib[ 'line' ].fragmentShader

  	} );

  	this.dashed = false;

  	Object.defineProperties( this, {

  		color: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.diffuse.value;

  			},

  			set: function ( value ) {

  				this.uniforms.diffuse.value = value;

  			}

  		},

  		linewidth: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.linewidth.value;

  			},

  			set: function ( value ) {

  				this.uniforms.linewidth.value = value;

  			}

  		},

  		dashScale: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.dashScale.value;

  			},

  			set: function ( value ) {

  				this.uniforms.dashScale.value = value;

  			}

  		},

  		dashSize: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.dashSize.value;

  			},

  			set: function ( value ) {

  				this.uniforms.dashSize.value = value;

  			}

  		},

  		gapSize: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.gapSize.value;

  			},

  			set: function ( value ) {

  				this.uniforms.gapSize.value = value;

  			}

  		},

  		resolution: {

  			enumerable: true,

  			get: function () {

  				return this.uniforms.resolution.value;

  			},

  			set: function ( value ) {

  				this.uniforms.resolution.value.copy( value );

  			}

  		}

  	} );

  	this.setValues( parameters );

  };

  LineMaterial.prototype = Object.create( ShaderMaterial.prototype );
  LineMaterial.prototype.constructor = LineMaterial;

  LineMaterial.prototype.isLineMaterial = true;

  LineMaterial.prototype.copy = function ( source ) {

  	ShaderMaterial.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;

  	this.resolution = source.resolution;

  	// todo

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LineSegments2 = function ( geometry, material ) {

  	Mesh.call( this );

  	this.type = 'LineSegments2';

  	this.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();
  	this.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );

  };

  LineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: LineSegments2,

  	isLineSegments2: true,

  	computeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...

  		var start = new Vector3();
  		var end = new Vector3();

  		return function computeLineDistances() {

  			var geometry = this.geometry;

  			var instanceStart = geometry.attributes.instanceStart;
  			var instanceEnd = geometry.attributes.instanceEnd;
  			var lineDistances = new Float32Array( 2 * instanceStart.data.count );

  			for ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {

  				start.fromBufferAttribute( instanceStart, i );
  				end.fromBufferAttribute( instanceEnd, i );

  				lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];
  				lineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );

  			}

  			var instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

  			geometry.addAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0
  			geometry.addAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

  			return this;

  		};

  	}() ),

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LineGeometry = function () {

  	LineSegmentsGeometry.call( this );

  	this.type = 'LineGeometry';

  };

  LineGeometry.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {

  	constructor: LineGeometry,

  	isLineGeometry: true,

  	setPositions: function ( array ) {

  		// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format

  		var length = array.length - 3;
  		var points = new Float32Array( 2 * length );

  		for ( var i = 0; i < length; i += 3 ) {

  			points[ 2 * i ] = array[ i ];
  			points[ 2 * i + 1 ] = array[ i + 1 ];
  			points[ 2 * i + 2 ] = array[ i + 2 ];

  			points[ 2 * i + 3 ] = array[ i + 3 ];
  			points[ 2 * i + 4 ] = array[ i + 4 ];
  			points[ 2 * i + 5 ] = array[ i + 5 ];

  		}

  		LineSegmentsGeometry.prototype.setPositions.call( this, points );

  		return this;

  	},

  	setColors: function ( array ) {

  		// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format

  		var length = array.length - 3;
  		var colors = new Float32Array( 2 * length );

  		for ( var i = 0; i < length; i += 3 ) {

  			colors[ 2 * i ] = array[ i ];
  			colors[ 2 * i + 1 ] = array[ i + 1 ];
  			colors[ 2 * i + 2 ] = array[ i + 2 ];

  			colors[ 2 * i + 3 ] = array[ i + 3 ];
  			colors[ 2 * i + 4 ] = array[ i + 4 ];
  			colors[ 2 * i + 5 ] = array[ i + 5 ];

  		}

  		LineSegmentsGeometry.prototype.setColors.call( this, colors );

  		return this;

  	},

  	fromLine: function ( line ) {

  		var geometry = line.geometry;

  		if ( geometry.isGeometry ) {

  			this.setPositions( geometry.vertices );

  		} else if ( geometry.isBufferGeometry ) {

  			this.setPositions( geometry.position.array ); // assumes non-indexed

  		}

  		// set colors, maybe

  		return this;

  	},

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Line2 = function ( geometry, material ) {

  	LineSegments2.call( this );

  	this.type = 'Line2';

  	this.geometry = geometry !== undefined ? geometry : new LineGeometry();
  	this.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );

  };

  Line2.prototype = Object.assign( Object.create( LineSegments2.prototype ), {

  	constructor: Line2,

  	isLine2: true,

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Wireframe = function ( geometry, material ) {

  	Mesh.call( this );

  	this.type = 'Wireframe';

  	this.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();
  	this.material = material !== undefined ? material : new LineMaterial( { color: Math.random() * 0xffffff } );

  };

  Wireframe.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: Wireframe,

  	isWireframe: true,

  	computeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...

  		var start = new Vector3();
  		var end = new Vector3();

  		return function computeLineDistances() {

  			var geometry = this.geometry;

  			var instanceStart = geometry.attributes.instanceStart;
  			var instanceEnd = geometry.attributes.instanceEnd;
  			var lineDistances = new Float32Array( 2 * instanceStart.data.count );

  			for ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {

  				start.fromBufferAttribute( instanceStart, i );
  				end.fromBufferAttribute( instanceEnd, i );

  				lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];
  				lineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );

  			}

  			var instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

  			geometry.addAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0
  			geometry.addAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

  			return this;

  		};

  	}() ),

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var WireframeGeometry2 = function ( geometry ) {

  	LineSegmentsGeometry.call( this );

  	this.type = 'WireframeGeometry2';

  	this.fromWireframeGeometry( new WireframeGeometry( geometry ) );

  	// set colors, maybe

  };

  WireframeGeometry2.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {

  	constructor: WireframeGeometry2,

  	isWireframeGeometry2: true,

  	copy: function ( source ) {

  		// todo

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var loading = {};

  function FileLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( FileLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {
  		var this$1 = this;


  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		url = this.manager.resolveURL( url );

  		var scope = this;

  		var cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check if request is duplicate

  		if ( loading[ url ] !== undefined ) {

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			return;

  		}

  		// Check for data: URI
  		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  		var dataUriRegexResult = url.match( dataUriRegex );

  		// Safari can not handle Data URIs through XMLHttpRequest so process manually
  		if ( dataUriRegexResult ) {

  			var mimeType = dataUriRegexResult[ 1 ];
  			var isBase64 = !! dataUriRegexResult[ 2 ];
  			var data = dataUriRegexResult[ 3 ];

  			data = decodeURIComponent( data );

  			if ( isBase64 ) { data = atob( data ); }

  			try {

  				var response;
  				var responseType = ( this.responseType || '' ).toLowerCase();

  				switch ( responseType ) {

  					case 'arraybuffer':
  					case 'blob':

  						var view = new Uint8Array( data.length );

  						for ( var i = 0; i < data.length; i ++ ) {

  							view[ i ] = data.charCodeAt( i );

  						}

  						if ( responseType === 'blob' ) {

  							response = new Blob( [ view.buffer ], { type: mimeType } );

  						} else {

  							response = view.buffer;

  						}

  						break;

  					case 'document':

  						var parser = new DOMParser();
  						response = parser.parseFromString( data, mimeType );

  						break;

  					case 'json':

  						response = JSON.parse( data );

  						break;

  					default: // 'text' or other

  						response = data;

  						break;

  				}

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				setTimeout( function () {

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} catch ( error ) {

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				setTimeout( function () {

  					if ( onError ) { onError( error ); }

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}, 0 );

  			}

  		} else {

  			// Initialise array for duplicate requests

  			loading[ url ] = [];

  			loading[ url ].push( {

  				onLoad: onLoad,
  				onProgress: onProgress,
  				onError: onError

  			} );

  			var request = new XMLHttpRequest();

  			request.open( 'GET', url, true );

  			request.addEventListener( 'load', function ( event ) {

  				var response = this.response;

  				Cache.add( url, response );

  				var callbacks = loading[ url ];

  				delete loading[ url ];

  				if ( this.status === 200 || this.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					if ( this.status === 0 ) { console.warn( 'FileLoader: HTTP Status 0 received.' ); }

  					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  						var callback = callbacks[ i ];
  						if ( callback.onLoad ) { callback.onLoad( response ); }

  					}

  					scope.manager.itemEnd( url );

  				} else {

  					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  						var callback = callbacks[ i ];
  						if ( callback.onError ) { callback.onError( event ); }

  					}

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}

  			}, false );

  			request.addEventListener( 'progress', function ( event ) {

  				var callbacks = loading[ url ];

  				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  					var callback = callbacks[ i ];
  					if ( callback.onProgress ) { callback.onProgress( event ); }

  				}

  			}, false );

  			request.addEventListener( 'error', function ( event ) {

  				var callbacks = loading[ url ];

  				delete loading[ url ];

  				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  					var callback = callbacks[ i ];
  					if ( callback.onError ) { callback.onError( event ); }

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			}, false );

  			request.addEventListener( 'abort', function ( event ) {

  				var callbacks = loading[ url ];

  				delete loading[ url ];

  				for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  					var callback = callbacks[ i ];
  					if ( callback.onError ) { callback.onError( event ); }

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			}, false );

  			if ( this.responseType !== undefined ) { request.responseType = this.responseType; }
  			if ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }

  			if ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }

  			for ( var header in this$1.requestHeader ) {

  				request.setRequestHeader( header, this$1.requestHeader[ header ] );

  			}

  			request.send( null );

  		}

  		scope.manager.itemStart( url );

  		return request;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResponseType: function ( value ) {

  		this.responseType = value;
  		return this;

  	},

  	setWithCredentials: function ( value ) {

  		this.withCredentials = value;
  		return this;

  	},

  	setMimeType: function ( value ) {

  		this.mimeType = value;
  		return this;

  	},

  	setRequestHeader: function ( value ) {

  		this.requestHeader = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshPhongMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshPhongMaterial';

  	this.color = new Color( 0xffffff ); // diffuse
  	this.specular = new Color( 0x111111 );
  	this.shininess = 30;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalMapType = TangentSpaceNormalMap;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshPhongMaterial.prototype = Object.create( Material$1.prototype );
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.specular.copy( source.specular );
  	this.shininess = source.shininess;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalMapType = source.normalMapType;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LoaderUtils = {

  	decodeText: function ( array ) {

  		if ( typeof TextDecoder !== 'undefined' ) {

  			return new TextDecoder().decode( array );

  		}

  		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  		// throws a "maximum call stack size exceeded" error for large arrays.

  		var s = '';

  		for ( var i = 0, il = array.length; i < il; i ++ ) {

  			// Implicitly assumes little-endian.
  			s += String.fromCharCode( array[ i ] );

  		}

  		// Merges multi-byte utf-8 characters.
  		return decodeURIComponent( escape( s ) );

  	},

  	extractUrlBase: function ( url ) {

  		var index = url.lastIndexOf( '/' );

  		if ( index === - 1 ) { return './'; }

  		return url.substr( 0, index + 1 );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ThreeMFLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.availableExtensions = [];

  };

  ThreeMFLoader.prototype = {

  	constructor: ThreeMFLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;
  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( buffer ) {

  			onLoad( scope.parse( buffer ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data ) {

  		var scope = this;

  		function loadDocument( data ) {

  			var zip = null;
  			var file = null;

  			var relsName;
  			var modelPartNames = [];
  			var texturesPartNames = [];

  			var rels;
  			var modelParts = {};
  			var printTicketParts = {};
  			var texturesParts = {};
  			var otherParts = {};

  			try {

  				zip = new JSZip( data ); // eslint-disable-line no-undef

  			} catch ( e ) {

  				if ( e instanceof ReferenceError ) {

  					console.error( 'ThreeMFLoader: jszip missing and file is compressed.' );
  					return null;

  				}

  			}

  			for ( file in zip.files ) {

  				if ( file.match( /\.rels$/ ) ) {

  					relsName = file;

  				} else if ( file.match( /^3D\/.*\.model$/ ) ) {

  					modelPartNames.push( file );

  				} else if ( file.match( /^3D\/Metadata\/.*\.xml$/ ) ) ; else if ( file.match( /^3D\/Textures\/.*/ ) ) {

  					texturesPartNames.push( file );

  				} else if ( file.match( /^3D\/Other\/.*/ ) ) ;

  			}

  			var relsView = new Uint8Array( zip.file( relsName ).asArrayBuffer() );
  			var relsFileText = LoaderUtils.decodeText( relsView );
  			rels = parseRelsXml( relsFileText );

  			for ( var i = 0; i < modelPartNames.length; i ++ ) {

  				var modelPart = modelPartNames[ i ];
  				var view = new Uint8Array( zip.file( modelPart ).asArrayBuffer() );

  				var fileText = LoaderUtils.decodeText( view );
  				var xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );

  				if ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) {

  					console.error( 'ThreeMFLoader: Error loading 3MF - no 3MF document found: ', modelPart );

  				}

  				var modelNode = xmlData.querySelector( 'model' );
  				var extensions = {};

  				for ( var i = 0; i < modelNode.attributes.length; i ++ ) {

  					var attr = modelNode.attributes[ i ];
  					if ( attr.name.match( /^xmlns:(.+)$/ ) ) {

  						extensions[ attr.value ] = RegExp.$1;

  					}

  				}

  				var modelData = parseModelNode( modelNode );
  				modelData[ 'xml' ] = modelNode;

  				if ( 0 < Object.keys( extensions ).length ) {

  					modelData[ 'extensions' ] = extensions;

  				}

  				modelParts[ modelPart ] = modelData;

  			}

  			for ( var i = 0; i < texturesPartNames.length; i ++ ) {

  				var texturesPartName = texturesPartNames[ i ];
  				texturesParts[ texturesPartName ] = zip.file( texturesPartName ).asBinary();

  			}

  			return {
  				rels: rels,
  				model: modelParts,
  				printTicket: printTicketParts,
  				texture: texturesParts,
  				other: otherParts
  			};

  		}

  		function parseRelsXml( relsFileText ) {

  			var relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' );
  			var relsNode = relsXmlData.querySelector( 'Relationship' );
  			var target = relsNode.getAttribute( 'Target' );
  			var id = relsNode.getAttribute( 'Id' );
  			var type = relsNode.getAttribute( 'Type' );

  			return {
  				target: target,
  				id: id,
  				type: type
  			};

  		}

  		function parseMetadataNodes( metadataNodes ) {

  			var metadataData = {};

  			for ( var i = 0; i < metadataNodes.length; i ++ ) {

  				var metadataNode = metadataNodes[ i ];
  				var name = metadataNode.getAttribute( 'name' );
  				var validNames = [
  					'Title',
  					'Designer',
  					'Description',
  					'Copyright',
  					'LicenseTerms',
  					'Rating',
  					'CreationDate',
  					'ModificationDate'
  				];

  				if ( 0 <= validNames.indexOf( name ) ) {

  					metadataData[ name ] = metadataNode.textContent;

  				}

  			}

  			return metadataData;

  		}

  		function parseBasematerialsNode( basematerialsNode ) {
  		}

  		function parseMeshNode( meshNode, extensions ) {

  			var meshData = {};

  			var vertices = [];
  			var vertexNodes = meshNode.querySelectorAll( 'vertices vertex' );

  			for ( var i = 0; i < vertexNodes.length; i ++ ) {

  				var vertexNode = vertexNodes[ i ];
  				var x = vertexNode.getAttribute( 'x' );
  				var y = vertexNode.getAttribute( 'y' );
  				var z = vertexNode.getAttribute( 'z' );

  				vertices.push( parseFloat( x ), parseFloat( y ), parseFloat( z ) );

  			}

  			meshData[ 'vertices' ] = new Float32Array( vertices.length );

  			for ( var i = 0; i < vertices.length; i ++ ) {

  				meshData[ 'vertices' ][ i ] = vertices[ i ];

  			}

  			var triangleProperties = [];
  			var triangles = [];
  			var triangleNodes = meshNode.querySelectorAll( 'triangles triangle' );

  			for ( var i = 0; i < triangleNodes.length; i ++ ) {

  				var triangleNode = triangleNodes[ i ];
  				var v1 = triangleNode.getAttribute( 'v1' );
  				var v2 = triangleNode.getAttribute( 'v2' );
  				var v3 = triangleNode.getAttribute( 'v3' );
  				var p1 = triangleNode.getAttribute( 'p1' );
  				var p2 = triangleNode.getAttribute( 'p2' );
  				var p3 = triangleNode.getAttribute( 'p3' );
  				var pid = triangleNode.getAttribute( 'pid' );

  				triangles.push( parseInt( v1, 10 ), parseInt( v2, 10 ), parseInt( v3, 10 ) );

  				var triangleProperty = {};

  				if ( p1 ) {

  					triangleProperty[ 'p1' ] = parseInt( p1, 10 );

  				}

  				if ( p2 ) {

  					triangleProperty[ 'p2' ] = parseInt( p2, 10 );

  				}

  				if ( p3 ) {

  					triangleProperty[ 'p3' ] = parseInt( p3, 10 );

  				}

  				if ( pid ) {

  					triangleProperty[ 'pid' ] = pid;

  				}

  				if ( 0 < Object.keys( triangleProperty ).length ) {

  					triangleProperties.push( triangleProperty );

  				}

  			}

  			meshData[ 'triangleProperties' ] = triangleProperties;
  			meshData[ 'triangles' ] = new Uint32Array( triangles.length );

  			for ( var i = 0; i < triangles.length; i ++ ) {

  				meshData[ 'triangles' ][ i ] = triangles[ i ];

  			}

  			return meshData;

  		}

  		function parseComponentsNode( componentsNode ) {

  		}

  		function parseObjectNode( objectNode ) {

  			var objectData = {
  				type: objectNode.getAttribute( 'type' )
  			};

  			var id = objectNode.getAttribute( 'id' );

  			if ( id ) {

  				objectData[ 'id' ] = id;

  			}

  			var pid = objectNode.getAttribute( 'pid' );

  			if ( pid ) {

  				objectData[ 'pid' ] = pid;

  			}

  			var pindex = objectNode.getAttribute( 'pindex' );

  			if ( pindex ) {

  				objectData[ 'pindex' ] = pindex;

  			}

  			var thumbnail = objectNode.getAttribute( 'thumbnail' );

  			if ( thumbnail ) {

  				objectData[ 'thumbnail' ] = thumbnail;

  			}

  			var partnumber = objectNode.getAttribute( 'partnumber' );

  			if ( partnumber ) {

  				objectData[ 'partnumber' ] = partnumber;

  			}

  			var name = objectNode.getAttribute( 'name' );

  			if ( name ) {

  				objectData[ 'name' ] = name;

  			}

  			var meshNode = objectNode.querySelector( 'mesh' );

  			if ( meshNode ) {

  				objectData[ 'mesh' ] = parseMeshNode( meshNode );

  			}

  			var componentsNode = objectNode.querySelector( 'components' );

  			if ( componentsNode ) {

  				objectData[ 'components' ] = parseComponentsNode( componentsNode );

  			}

  			return objectData;

  		}

  		function parseResourcesNode( resourcesNode ) {

  			var resourcesData = {};
  			var basematerialsNode = resourcesNode.querySelector( 'basematerials' );

  			if ( basematerialsNode ) {

  				resourcesData[ 'basematerial' ] = parseBasematerialsNode( basematerialsNode );

  			}

  			resourcesData[ 'object' ] = {};
  			var objectNodes = resourcesNode.querySelectorAll( 'object' );

  			for ( var i = 0; i < objectNodes.length; i ++ ) {

  				var objectNode = objectNodes[ i ];
  				var objectData = parseObjectNode( objectNode );
  				resourcesData[ 'object' ][ objectData[ 'id' ] ] = objectData;

  			}

  			return resourcesData;

  		}

  		function parseBuildNode( buildNode ) {

  			var buildData = [];
  			var itemNodes = buildNode.querySelectorAll( 'item' );

  			for ( var i = 0; i < itemNodes.length; i ++ ) {

  				var itemNode = itemNodes[ i ];
  				var buildItem = {
  					objectid: itemNode.getAttribute( 'objectid' )
  				};
  				var transform = itemNode.getAttribute( 'transform' );

  				if ( transform ) {

  					var t = [];
  					transform.split( ' ' ).forEach( function ( s ) {

  						t.push( parseFloat( s ) );

  					} );
  					var mat4 = new Matrix4();
  					buildItem[ 'transform' ] = mat4.set(
  						t[ 0 ], t[ 3 ], t[ 6 ], t[ 9 ],
  						t[ 1 ], t[ 4 ], t[ 7 ], t[ 10 ],
  						t[ 2 ], t[ 5 ], t[ 8 ], t[ 11 ],
  						 0.0, 0.0, 0.0, 1.0
  					);

  				}

  				buildData.push( buildItem );

  			}

  			return buildData;

  		}

  		function parseModelNode( modelNode ) {

  			var modelData = { unit: modelNode.getAttribute( 'unit' ) || 'millimeter' };
  			var metadataNodes = modelNode.querySelectorAll( 'metadata' );

  			if ( metadataNodes ) {

  				modelData[ 'metadata' ] = parseMetadataNodes( metadataNodes );

  			}

  			var resourcesNode = modelNode.querySelector( 'resources' );

  			if ( resourcesNode ) {

  				modelData[ 'resources' ] = parseResourcesNode( resourcesNode );

  			}

  			var buildNode = modelNode.querySelector( 'build' );

  			if ( buildNode ) {

  				modelData[ 'build' ] = parseBuildNode( buildNode );

  			}

  			return modelData;

  		}

  		function buildMesh( meshData, data3mf ) {

  			var geometry = new BufferGeometry();
  			geometry.setIndex( new BufferAttribute( meshData[ 'triangles' ], 1 ) );
  			geometry.addAttribute( 'position', new BufferAttribute( meshData[ 'vertices' ], 3 ) );

  			if ( meshData[ 'colors' ] ) {

  				geometry.addAttribute( 'color', new BufferAttribute( meshData[ 'colors' ], 3 ) );

  			}

  			geometry.computeBoundingSphere();

  			var materialOpts = {
  				flatShading: true
  			};

  			if ( meshData[ 'colors' ] && 0 < meshData[ 'colors' ].length ) {

  				materialOpts[ 'vertexColors' ] = VertexColors;

  			} else {

  				materialOpts[ 'color' ] = 0xaaaaff;

  			}

  			var material = new MeshPhongMaterial( materialOpts );
  			return new Mesh( geometry, material );

  		}

  		function applyExtensions( extensions, meshData, modelXml, data3mf ) {

  			if ( ! extensions ) {

  				return;

  			}

  			var availableExtensions = [];
  			var keys = Object.keys( extensions );

  			for ( var i = 0; i < keys.length; i ++ ) {

  				var ns = keys[ i ];

  				for ( var j = 0; j < scope.availableExtensions.length; j ++ ) {

  					var extension = scope.availableExtensions[ j ];

  					if ( extension.ns === ns ) {

  						availableExtensions.push( extension );

  					}

  				}

  			}

  			for ( var i = 0; i < availableExtensions.length; i ++ ) {

  				var extension = availableExtensions[ i ];
  				extension.apply( modelXml, extensions[ extension[ 'ns' ] ], meshData );

  			}

  		}

  		function buildMeshes( data3mf ) {

  			var modelsData = data3mf.model;
  			var meshes = {};
  			var modelsKeys = Object.keys( modelsData );

  			for ( var i = 0; i < modelsKeys.length; i ++ ) {

  				var modelsKey = modelsKeys[ i ];
  				var modelData = modelsData[ modelsKey ];
  				var modelXml = modelData[ 'xml' ];
  				var extensions = modelData[ 'extensions' ];

  				var objectIds = Object.keys( modelData[ 'resources' ][ 'object' ] );

  				for ( var j = 0; j < objectIds.length; j ++ ) {

  					var objectId = objectIds[ j ];
  					var objectData = modelData[ 'resources' ][ 'object' ][ objectId ];
  					var meshData = objectData[ 'mesh' ];
  					applyExtensions( extensions, meshData, modelXml, data3mf );
  					meshes[ objectId ] = buildMesh( meshData, data3mf );

  				}

  			}

  			return meshes;

  		}

  		function build( meshes, refs, data3mf ) {

  			var group = new Group();
  			var buildData = data3mf.model[ refs[ 'target' ].substring( 1 ) ][ 'build' ];

  			for ( var i = 0; i < buildData.length; i ++ ) {

  				var buildItem = buildData[ i ];
  				var mesh = meshes[ buildItem[ 'objectid' ] ];

  				if ( buildItem[ 'transform' ] ) {

  					mesh.geometry.applyMatrix( buildItem[ 'transform' ] );

  				}

  				group.add( mesh );

  			}

  			return group;

  		}

  		var data3mf = loadDocument( data );
  		var meshes = buildMeshes( data3mf );

  		return build( meshes, data3mf[ 'rels' ], data3mf );

  	},

  	addExtension: function ( extension ) {

  		this.availableExtensions.push( extension );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AMFLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  AMFLoader.prototype = {

  	constructor: AMFLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data ) {

  		function loadDocument( data ) {

  			var view = new DataView( data );
  			var magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );

  			if ( magic === 'PK' ) {

  				var zip = null;
  				var file = null;

  				console.log( 'AMFLoader: Loading Zip' );

  				try {

  					zip = new JSZip( data ); // eslint-disable-line no-undef

  				} catch ( e ) {

  					if ( e instanceof ReferenceError ) {

  						console.log( 'AMFLoader: jszip missing and file is compressed.' );
  						return null;

  					}

  				}

  				for ( file in zip.files ) {

  					if ( file.toLowerCase().substr( - 4 ) === '.amf' ) {

  						break;

  					}

  				}

  				console.log( 'AMFLoader: Trying to load file asset: ' + file );
  				view = new DataView( zip.file( file ).asArrayBuffer() );

  			}

  			var fileText = LoaderUtils.decodeText( view );
  			var xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );

  			if ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {

  				console.log( 'AMFLoader: Error loading AMF - no AMF document found.' );
  				return null;

  			}

  			return xmlData;

  		}

  		function loadDocumentScale( node ) {

  			var scale = 1.0;
  			var unit = 'millimeter';

  			if ( node.documentElement.attributes.unit !== undefined ) {

  				unit = node.documentElement.attributes.unit.value.toLowerCase();

  			}

  			var scaleUnits = {
  				millimeter: 1.0,
  				inch: 25.4,
  				feet: 304.8,
  				meter: 1000.0,
  				micron: 0.001
  			};

  			if ( scaleUnits[ unit ] !== undefined ) {

  				scale = scaleUnits[ unit ];

  			}

  			console.log( 'AMFLoader: Unit scale: ' + scale );
  			return scale;

  		}

  		function loadMaterials( node ) {

  			var matName = 'AMF Material';
  			var matId = node.attributes.id.textContent;
  			var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

  			var loadedMaterial = null;

  			for ( var i = 0; i < node.childNodes.length; i ++ ) {

  				var matChildEl = node.childNodes[ i ];

  				if ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {

  					if ( matChildEl.attributes.type.value === 'name' ) {

  						matName = matChildEl.textContent;

  					}

  				} else if ( matChildEl.nodeName === 'color' ) {

  					color = loadColor( matChildEl );

  				}

  			}

  			loadedMaterial = new MeshPhongMaterial( {
  				flatShading: true,
  				color: new Color( color.r, color.g, color.b ),
  				name: matName
  			} );

  			if ( color.a !== 1.0 ) {

  				loadedMaterial.transparent = true;
  				loadedMaterial.opacity = color.a;

  			}

  			return { id: matId, material: loadedMaterial };

  		}

  		function loadColor( node ) {

  			var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

  			for ( var i = 0; i < node.childNodes.length; i ++ ) {

  				var matColor = node.childNodes[ i ];

  				if ( matColor.nodeName === 'r' ) {

  					color.r = matColor.textContent;

  				} else if ( matColor.nodeName === 'g' ) {

  					color.g = matColor.textContent;

  				} else if ( matColor.nodeName === 'b' ) {

  					color.b = matColor.textContent;

  				} else if ( matColor.nodeName === 'a' ) {

  					color.a = matColor.textContent;

  				}

  			}

  			return color;

  		}

  		function loadMeshVolume( node ) {

  			var volume = { name: '', triangles: [], materialid: null };

  			var currVolumeNode = node.firstElementChild;

  			if ( node.attributes.materialid !== undefined ) {

  				volume.materialId = node.attributes.materialid.nodeValue;

  			}

  			while ( currVolumeNode ) {

  				if ( currVolumeNode.nodeName === 'metadata' ) {

  					if ( currVolumeNode.attributes.type !== undefined ) {

  						if ( currVolumeNode.attributes.type.value === 'name' ) {

  							volume.name = currVolumeNode.textContent;

  						}

  					}

  				} else if ( currVolumeNode.nodeName === 'triangle' ) {

  					var v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;
  					var v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;
  					var v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;

  					volume.triangles.push( v1, v2, v3 );

  				}

  				currVolumeNode = currVolumeNode.nextElementSibling;

  			}

  			return volume;

  		}

  		function loadMeshVertices( node ) {

  			var vertArray = [];
  			var normalArray = [];
  			var currVerticesNode = node.firstElementChild;

  			while ( currVerticesNode ) {

  				if ( currVerticesNode.nodeName === 'vertex' ) {

  					var vNode = currVerticesNode.firstElementChild;

  					while ( vNode ) {

  						if ( vNode.nodeName === 'coordinates' ) {

  							var x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;
  							var y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;
  							var z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;

  							vertArray.push( x, y, z );

  						} else if ( vNode.nodeName === 'normal' ) {

  							var nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;
  							var ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;
  							var nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;

  							normalArray.push( nx, ny, nz );

  						}

  						vNode = vNode.nextElementSibling;

  					}

  				}
  				currVerticesNode = currVerticesNode.nextElementSibling;

  			}

  			return { 'vertices': vertArray, 'normals': normalArray };

  		}

  		function loadObject( node ) {

  			var objId = node.attributes.id.textContent;
  			var loadedObject = { name: 'amfobject', meshes: [] };
  			var currColor = null;
  			var currObjNode = node.firstElementChild;

  			while ( currObjNode ) {

  				if ( currObjNode.nodeName === 'metadata' ) {

  					if ( currObjNode.attributes.type !== undefined ) {

  						if ( currObjNode.attributes.type.value === 'name' ) {

  							loadedObject.name = currObjNode.textContent;

  						}

  					}

  				} else if ( currObjNode.nodeName === 'color' ) {

  					currColor = loadColor( currObjNode );

  				} else if ( currObjNode.nodeName === 'mesh' ) {

  					var currMeshNode = currObjNode.firstElementChild;
  					var mesh = { vertices: [], normals: [], volumes: [], color: currColor };

  					while ( currMeshNode ) {

  						if ( currMeshNode.nodeName === 'vertices' ) {

  							var loadedVertices = loadMeshVertices( currMeshNode );

  							mesh.normals = mesh.normals.concat( loadedVertices.normals );
  							mesh.vertices = mesh.vertices.concat( loadedVertices.vertices );

  						} else if ( currMeshNode.nodeName === 'volume' ) {

  							mesh.volumes.push( loadMeshVolume( currMeshNode ) );

  						}

  						currMeshNode = currMeshNode.nextElementSibling;

  					}

  					loadedObject.meshes.push( mesh );

  				}

  				currObjNode = currObjNode.nextElementSibling;

  			}

  			return { 'id': objId, 'obj': loadedObject };

  		}

  		var xmlData = loadDocument( data );
  		var amfName = '';
  		var amfAuthor = '';
  		var amfScale = loadDocumentScale( xmlData );
  		var amfMaterials = {};
  		var amfObjects = {};
  		var childNodes = xmlData.documentElement.childNodes;

  		var i, j;

  		for ( i = 0; i < childNodes.length; i ++ ) {

  			var child = childNodes[ i ];

  			if ( child.nodeName === 'metadata' ) {

  				if ( child.attributes.type !== undefined ) {

  					if ( child.attributes.type.value === 'name' ) {

  						amfName = child.textContent;

  					} else if ( child.attributes.type.value === 'author' ) {

  						amfAuthor = child.textContent;

  					}

  				}

  			} else if ( child.nodeName === 'material' ) {

  				var loadedMaterial = loadMaterials( child );

  				amfMaterials[ loadedMaterial.id ] = loadedMaterial.material;

  			} else if ( child.nodeName === 'object' ) {

  				var loadedObject = loadObject( child );

  				amfObjects[ loadedObject.id ] = loadedObject.obj;

  			}

  		}

  		var sceneObject = new Group();
  		var defaultMaterial = new MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );

  		sceneObject.name = amfName;
  		sceneObject.userData.author = amfAuthor;
  		sceneObject.userData.loader = 'AMF';

  		for ( var id in amfObjects ) {

  			var part = amfObjects[ id ];
  			var meshes = part.meshes;
  			var newObject = new Group();
  			newObject.name = part.name || '';

  			for ( i = 0; i < meshes.length; i ++ ) {

  				var objDefaultMaterial = defaultMaterial;
  				var mesh = meshes[ i ];
  				var vertices = new Float32BufferAttribute( mesh.vertices, 3 );
  				var normals = null;

  				if ( mesh.normals.length ) {

  					normals = new Float32BufferAttribute( mesh.normals, 3 );

  				}

  				if ( mesh.color ) {

  					var color = mesh.color;

  					objDefaultMaterial = defaultMaterial.clone();
  					objDefaultMaterial.color = new Color( color.r, color.g, color.b );

  					if ( color.a !== 1.0 ) {

  						objDefaultMaterial.transparent = true;
  						objDefaultMaterial.opacity = color.a;

  					}

  				}

  				var volumes = mesh.volumes;

  				for ( j = 0; j < volumes.length; j ++ ) {

  					var volume = volumes[ j ];
  					var newGeometry = new BufferGeometry();
  					var material = objDefaultMaterial;

  					newGeometry.setIndex( volume.triangles );
  					newGeometry.addAttribute( 'position', vertices.clone() );

  					if ( normals ) {

  						newGeometry.addAttribute( 'normal', normals.clone() );

  					}

  					if ( amfMaterials[ volume.materialId ] !== undefined ) {

  						material = amfMaterials[ volume.materialId ];

  					}

  					newGeometry.scale( amfScale, amfScale, amfScale );
  					newObject.add( new Mesh( newGeometry, material.clone() ) );

  				}

  			}

  			sceneObject.add( newObject );

  		}

  		return sceneObject;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AssimpJSONLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  AssimpJSONLoader.prototype = {

  	constructor: AssimpJSONLoader,

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( scope.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			var json = JSON.parse( text );
  			var metadata = json.__metadata__;

  			// check if __metadata__ meta header is present
  			// this header is used to disambiguate between different JSON-based file formats

  			if ( typeof metadata !== 'undefined' ) {

  				// check if assimp2json at all

  				if ( metadata.format !== 'assimp2json' ) {

  					onError( 'AssimpJSONLoader: Not an assimp2json scene.' );
  					return;

  					// check major format version

  				} else if ( metadata.version < 100 && metadata.version >= 200 ) {

  					onError( 'AssimpJSONLoader: Unsupported assimp2json file format version.' );
  					return;

  				}

  			}

  			onLoad( scope.parse( json, path ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResourcePath: function ( value ) {

  		this.resourcePath = value;
  		return this;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	parse: function ( json, path ) {

  		function parseList( json, handler ) {
  			var this$1 = this;


  			var meshes = new Array( json.length );

  			for ( var i = 0; i < json.length; ++ i ) {

  				meshes[ i ] = handler.call( this$1, json[ i ] );

  			}

  			return meshes;

  		}

  		function parseMesh( json ) {

  			var geometry = new BufferGeometry();

  			var i, l, face;

  			var indices = [];

  			var vertices = json.vertices || [];
  			var normals = json.normals || [];
  			var uvs = json.texturecoords || [];
  			var colors = json.colors || [];

  			uvs = uvs[ 0 ] || []; // only support for a single set of uvs

  			for ( i = 0, l = json.faces.length; i < l; i ++ ) {

  				face = json.faces[ i ];
  				indices.push( face[ 0 ], face[ 1 ], face[ 2 ] );

  			}

  			geometry.setIndex( indices );
  			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  			if ( normals.length > 0 ) {

  				geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  			}

  			if ( uvs.length > 0 ) {

  				geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  			}

  			if ( colors.length > 0 ) {

  				geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  			}

  			geometry.computeBoundingSphere();

  			return geometry;

  		}

  		function parseMaterial( json ) {

  			var material = new MeshPhongMaterial();

  			for ( var i in json.properties ) {

  				var property = json.properties[ i ];
  				var key = property.key;
  				var value = property.value;

  				switch ( key ) {

  					case '$tex.file': {

  						var semantic = property.semantic;

  						// prop.semantic gives the type of the texture
  						// 1: diffuse
  						// 2: specular map
  						// 4: emissive map
  						// 5: height map (bumps)
  						// 6: normal map
  						// more values (i.e. environment, etc) are known by assimp and may be relevant

  						if ( semantic === 1 || semantic === 2 || semantic === 4 || semantic === 5 || semantic === 6 ) {

  							var keyname;

  							switch ( semantic ) {

  								case 1:
  									keyname = 'map';
  									break;
  								case 2:
  									keyname = 'specularMap';
  									break;
  								case 4:
  									keyname = 'emissiveMap';
  									break;
  								case 5:
  									keyname = 'bumpMap';
  									break;
  								case 6:
  									keyname = 'normalMap';
  									break;

  							}

  							var texture = textureLoader.load( value );

  							// TODO: read texture settings from assimp.
  							// Wrapping is the default, though.

  							texture.wrapS = texture.wrapT = RepeatWrapping;

  							material[ keyname ] = texture;

  						}

  						break;

  					}

  					case '?mat.name':
  						material.name = value;
  						break;

  					case '$clr.diffuse':
  						material.color.fromArray( value );
  						break;

  					case '$clr.specular':
  						material.specular.fromArray( value );
  						break;

  					case '$clr.emissive':
  						material.emissive.fromArray( value );
  						break;

  					case '$mat.shininess':
  						material.shininess = value;
  						break;

  					case '$mat.shadingm':
  						// aiShadingMode_Flat
  						material.flatShading = ( value === 1 ) ? true : false;
  						break;

  					case '$mat.opacity':
  						if ( value < 1 ) {

  							material.opacity = value;
  							material.transparent = true;

  						}
  						break;

  				}

  			}

  			return material;

  		}

  		function parseObject( json, node, meshes, materials ) {

  			var obj = new Object3D(),	i, idx;

  			obj.name = node.name || '';
  			obj.matrix = new Matrix4().fromArray( node.transformation ).transpose();
  			obj.matrix.decompose( obj.position, obj.quaternion, obj.scale );

  			for ( i = 0; node.meshes && i < node.meshes.length; i ++ ) {

  				idx = node.meshes[ i ];
  				obj.add( new Mesh( meshes[ idx ], materials[ json.meshes[ idx ].materialindex ] ) );

  			}

  			for ( i = 0; node.children && i < node.children.length; i ++ ) {

  				obj.add( parseObject( json, node.children[ i ], meshes, materials ) );

  			}

  			return obj;

  		}

  		var textureLoader = new TextureLoader( this.manager );
  		textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		var meshes = parseList( json.meshes, parseMesh );
  		var materials = parseList( json.materials, parseMaterial );
  		return parseObject( json, json.rootnode, meshes, materials );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Skeleton( bones, boneInverses ) {
  	var this$1 = this;


  	// copy the bone array

  	bones = bones || [];

  	this.bones = bones.slice( 0 );
  	this.boneMatrices = new Float32Array( this.bones.length * 16 );

  	// use the supplied bone inverses or calculate the inverses

  	if ( boneInverses === undefined ) {

  		this.calculateInverses();

  	} else {

  		if ( this.bones.length === boneInverses.length ) {

  			this.boneInverses = boneInverses.slice( 0 );

  		} else {

  			console.warn( 'Skeleton boneInverses is the wrong length.' );

  			this.boneInverses = [];

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				this$1.boneInverses.push( new Matrix4() );

  			}

  		}

  	}

  }

  Object.assign( Skeleton.prototype, {

  	calculateInverses: function () {
  		var this$1 = this;


  		this.boneInverses = [];

  		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  			var inverse = new Matrix4();

  			if ( this$1.bones[ i ] ) {

  				inverse.getInverse( this$1.bones[ i ].matrixWorld );

  			}

  			this$1.boneInverses.push( inverse );

  		}

  	},

  	pose: function () {
  		var this$1 = this;


  		var bone, i, il;

  		// recover the bind-time world matrices

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.getInverse( this$1.boneInverses[ i ] );

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.getInverse( bone.parent.matrixWorld );
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	},

  	update: ( function () {

  		var offsetMatrix = new Matrix4();
  		var identityMatrix = new Matrix4();

  		return function update() {

  			var bones = this.bones;
  			var boneInverses = this.boneInverses;
  			var boneMatrices = this.boneMatrices;
  			var boneTexture = this.boneTexture;

  			// flatten bone matrices to array

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				// compute the offset between the current and the original transform

  				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

  				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  				offsetMatrix.toArray( boneMatrices, i * 16 );

  			}

  			if ( boneTexture !== undefined ) {

  				boneTexture.needsUpdate = true;

  			}

  		};

  	} )(),

  	clone: function () {

  		return new Skeleton( this.bones, this.boneInverses );

  	},

  	getBoneByName: function ( name ) {
  		var this$1 = this;


  		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  			var bone = this$1.bones[ i ];

  			if ( bone.name === name ) {

  				return bone;

  			}

  		}

  		return undefined;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SkinnedMesh( geometry, material ) {

  	if ( geometry && geometry.isGeometry ) {

  		console.error( 'SkinnedMesh no longer supports Geometry. Use BufferGeometry instead.' );

  	}

  	Mesh.call( this, geometry, material );

  	this.type = 'SkinnedMesh';

  	this.bindMode = 'attached';
  	this.bindMatrix = new Matrix4();
  	this.bindMatrixInverse = new Matrix4();

  }

  SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: SkinnedMesh,

  	isSkinnedMesh: true,

  	bind: function ( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.getInverse( bindMatrix );

  	},

  	pose: function () {

  		this.skeleton.pose();

  	},

  	normalizeSkinWeights: function () {

  		var vector = new Vector4();

  		var skinWeight = this.geometry.attributes.skinWeight;

  		for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

  			vector.x = skinWeight.getX( i );
  			vector.y = skinWeight.getY( i );
  			vector.z = skinWeight.getZ( i );
  			vector.w = skinWeight.getW( i );

  			var scale = 1.0 / vector.manhattanLength();

  			if ( scale !== Infinity ) {

  				vector.multiplyScalar( scale );

  			} else {

  				vector.set( 1, 0, 0, 0 ); // do something reasonable

  			}

  			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

  		}

  	},

  	updateMatrixWorld: function ( force ) {

  		Mesh.prototype.updateMatrixWorld.call( this, force );

  		if ( this.bindMode === 'attached' ) {

  			this.bindMatrixInverse.getInverse( this.matrixWorld );

  		} else if ( this.bindMode === 'detached' ) {

  			this.bindMatrixInverse.getInverse( this.bindMatrix );

  		} else {

  			console.warn( 'SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AssimpLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  AssimpLoader.prototype = {

  	constructor: AssimpLoader,

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( scope.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );

  		loader.load( url, function ( buffer ) {

  			onLoad( scope.parse( buffer, path ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResourcePath: function ( value ) {

  		this.resourcePath = value;
  		return this;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	parse: function ( buffer, path ) {

  		var textureLoader = new TextureLoader( this.manager );
  		textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		var Virtulous = {};

  		Virtulous.KeyFrame = function ( time, matrix ) {

  			this.time = time;
  			this.matrix = matrix.clone();
  			this.position = new Vector3();
  			this.quaternion = new Quaternion();
  			this.scale = new Vector3( 1, 1, 1 );
  			this.matrix.decompose( this.position, this.quaternion, this.scale );
  			this.clone = function () {

  				var n = new Virtulous.KeyFrame( this.time, this.matrix );
  				return n;

  			};
  			this.lerp = function ( nextKey, time ) {

  				time -= this.time;
  				var dist = ( nextKey.time - this.time );
  				var l = time / dist;
  				var l2 = 1 - l;
  				var keypos = this.position;
  				var keyrot = this.quaternion;
  				//      var keyscl =  key.parentspaceScl || key.scl;
  				var key2pos = nextKey.position;
  				var key2rot = nextKey.quaternion;
  				//  var key2scl =  key2.parentspaceScl || key2.scl;
  				Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
  				Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
  				Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
  				//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;
  				//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;
  				//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;
  				Virtulous.KeyFrame.tempAniQuat.set( keyrot.x, keyrot.y, keyrot.z, keyrot.w );
  				Virtulous.KeyFrame.tempAniQuat.slerp( key2rot, l );
  				return Virtulous.KeyFrame.tempAniMatrix.compose( Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale );

  			};

  		};

  		Virtulous.KeyFrame.tempAniPos = new Vector3();
  		Virtulous.KeyFrame.tempAniQuat = new Quaternion();
  		Virtulous.KeyFrame.tempAniScale = new Vector3( 1, 1, 1 );
  		Virtulous.KeyFrame.tempAniMatrix = new Matrix4();
  		Virtulous.KeyFrameTrack = function () {

  			this.keys = [];
  			this.target = null;
  			this.time = 0;
  			this.length = 0;
  			this._accelTable = {};
  			this.fps = 20;
  			this.addKey = function ( key ) {

  				this.keys.push( key );

  			};
  			this.init = function () {
  				var this$1 = this;


  				this.sortKeys();

  				if ( this.keys.length > 0 )
  					{ this.length = this.keys[ this.keys.length - 1 ].time; }
  				else
  					{ this.length = 0; }

  				if ( ! this.fps ) { return; }

  				for ( var j = 0; j < this.length * this.fps; j ++ ) {

  					for ( var i = 0; i < this.keys.length; i ++ ) {

  						if ( this$1.keys[ i ].time == j ) {

  							this$1._accelTable[ j ] = i;
  							break;

  						} else if ( this$1.keys[ i ].time < j / this$1.fps && this$1.keys[ i + 1 ] && this$1.keys[ i + 1 ].time >= j / this$1.fps ) {

  							this$1._accelTable[ j ] = i;
  							break;

  						}

  					}

  				}

  			};

  			this.parseFromThree = function ( data ) {
  				var this$1 = this;


  				var fps = data.fps;
  				this.target = data.node;
  				var track = data.hierarchy[ 0 ].keys;
  				for ( var i = 0; i < track.length; i ++ ) {

  					this$1.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].targets[ 0 ].data ) );

  				}
  				this.init();

  			};

  			this.parseFromCollada = function ( data ) {
  				var this$1 = this;


  				var track = data.keys;
  				var fps = this.fps;

  				for ( var i = 0; i < track.length; i ++ ) {

  					this$1.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].matrix ) );

  				}

  				this.init();

  			};

  			this.sortKeys = function () {

  				this.keys.sort( this.keySortFunc );

  			};

  			this.keySortFunc = function ( a, b ) {

  				return a.time - b.time;

  			};

  			this.clone = function () {
  				var this$1 = this;


  				var t = new Virtulous.KeyFrameTrack();
  				t.target = this.target;
  				t.time = this.time;
  				t.length = this.length;

  				for ( var i = 0; i < this.keys.length; i ++ ) {

  					t.addKey( this$1.keys[ i ].clone() );

  				}

  				t.init();
  				return t;

  			};

  			this.reTarget = function ( root, compareitor ) {

  				if ( ! compareitor ) { compareitor = Virtulous.TrackTargetNodeNameCompare; }
  				this.target = compareitor( root, this.target );

  			};

  			this.keySearchAccel = function ( time ) {

  				time *= this.fps;
  				time = Math.floor( time );
  				return this._accelTable[ time ] || 0;

  			};

  			this.setTime = function ( time ) {
  				var this$1 = this;


  				time = Math.abs( time );
  				if ( this.length )
  					{ time = time % this.length + .05; }
  				var key0 = null;
  				var key1 = null;

  				for ( var i = this.keySearchAccel( time ); i < this.keys.length; i ++ ) {

  					if ( this$1.keys[ i ].time == time ) {

  						key0 = this$1.keys[ i ];
  						key1 = this$1.keys[ i ];
  						break;

  					} else if ( this$1.keys[ i ].time < time && this$1.keys[ i + 1 ] && this$1.keys[ i + 1 ].time > time ) {

  						key0 = this$1.keys[ i ];
  						key1 = this$1.keys[ i + 1 ];
  						break;

  					} else if ( this$1.keys[ i ].time < time && i == this$1.keys.length - 1 ) {

  						key0 = this$1.keys[ i ];
  						key1 = this$1.keys[ 0 ].clone();
  						key1.time += this$1.length + .05;
  						break;

  					}

  				}

  				if ( key0 && key1 && key0 !== key1 ) {

  					this.target.matrixAutoUpdate = false;
  					this.target.matrix.copy( key0.lerp( key1, time ) );
  					this.target.matrixWorldNeedsUpdate = true;
  					return;

  				}

  				if ( key0 && key1 && key0 == key1 ) {

  					this.target.matrixAutoUpdate = false;
  					this.target.matrix.copy( key0.matrix );
  					this.target.matrixWorldNeedsUpdate = true;
  					return;

  				}

  			};

  		};

  		Virtulous.TrackTargetNodeNameCompare = function ( root, target ) {

  			function find( node, name ) {

  				if ( node.name == name )
  					{ return node; }

  				for ( var i = 0; i < node.children.length; i ++ ) {

  					var r = find( node.children[ i ], name );
  					if ( r ) { return r; }

  				}

  				return null;

  			}

  			return find( root, target.name );

  		};

  		Virtulous.Animation = function () {

  			this.tracks = [];
  			this.length = 0;

  			this.addTrack = function ( track ) {

  				this.tracks.push( track );
  				this.length = Math.max( track.length, this.length );

  			};

  			this.setTime = function ( time ) {
  				var this$1 = this;


  				this.time = time;

  				for ( var i = 0; i < this.tracks.length; i ++ )
  					{ this$1.tracks[ i ].setTime( time ); }

  			};

  			this.clone = function ( target, compareitor ) {
  				var this$1 = this;


  				if ( ! compareitor ) { compareitor = Virtulous.TrackTargetNodeNameCompare; }
  				var n = new Virtulous.Animation();
  				n.target = target;
  				for ( var i = 0; i < this.tracks.length; i ++ ) {

  					var track = this$1.tracks[ i ].clone();
  					track.reTarget( target, compareitor );
  					n.addTrack( track );

  				}

  				return n;

  			};

  		};

  		var ASSBIN_CHUNK_AICAMERA = 0x1234;
  		var ASSBIN_CHUNK_AILIGHT = 0x1235;
  		var ASSBIN_CHUNK_AITEXTURE = 0x1236;
  		var ASSBIN_CHUNK_AIMESH = 0x1237;
  		var ASSBIN_CHUNK_AINODEANIM = 0x1238;
  		var ASSBIN_CHUNK_AISCENE = 0x1239;
  		var ASSBIN_CHUNK_AIBONE = 0x123a;
  		var ASSBIN_CHUNK_AIANIMATION = 0x123b;
  		var ASSBIN_CHUNK_AINODE = 0x123c;
  		var ASSBIN_CHUNK_AIMATERIAL = 0x123d;
  		var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;
  		var ASSBIN_MESH_HAS_POSITIONS = 0x1;
  		var ASSBIN_MESH_HAS_NORMALS = 0x2;
  		var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;
  		var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;
  		var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;
  		var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
  		var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
  		//! A directional light source has a well-defined direction
  		//! but is infinitely far away. That's quite a good
  		//! approximation for sun light.
  		var aiLightSource_DIRECTIONAL = 0x1;
  		//! A spot light source emits light in a specific
  		//! angle. It has a position and a direction it is pointing to.
  		//! A good example for a spot light is a light spot in
  		//! sport arenas.
  		var aiLightSource_SPOT = 0x3;
  		
  		var aiTextureType_DIFFUSE = 0x1;
  		
  		var aiTextureType_NORMALS = 0x6;
  		
  		var aiTextureType_OPACITY = 0x8;
  		
  		var aiTextureType_LIGHTMAP = 0xA;
  		var BONESPERVERT = 4;

  		function ASSBIN_MESH_HAS_TEXCOORD( n ) {

  			return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;

  		}

  		function ASSBIN_MESH_HAS_COLOR( n ) {

  			return ASSBIN_MESH_HAS_COLOR_BASE << n;

  		}

  		function markBones( scene ) {

  			for ( var i in scene.mMeshes ) {

  				var mesh = scene.mMeshes[ i ];
  				for ( var k in mesh.mBones ) {

  					var boneNode = scene.findNode( mesh.mBones[ k ].mName );
  					if ( boneNode )
  						{ boneNode.isBone = true; }

  				}

  			}

  		}
  		function cloneTreeToBones( root, scene ) {

  			var rootBone = new Bone();
  			rootBone.matrix.copy( root.matrix );
  			rootBone.matrixWorld.copy( root.matrixWorld );
  			rootBone.position.copy( root.position );
  			rootBone.quaternion.copy( root.quaternion );
  			rootBone.scale.copy( root.scale );
  			scene.nodeCount ++;
  			rootBone.name = "bone_" + root.name + scene.nodeCount.toString();

  			if ( ! scene.nodeToBoneMap[ root.name ] )
  				{ scene.nodeToBoneMap[ root.name ] = []; }
  			scene.nodeToBoneMap[ root.name ].push( rootBone );
  			for ( var i in root.children ) {

  				var child = cloneTreeToBones( root.children[ i ], scene );
  				if ( child )
  					{ rootBone.add( child ); }

  			}

  			return rootBone;

  		}

  		function sortWeights( indexes, weights ) {

  			var pairs = [];

  			for ( var i = 0; i < indexes.length; i ++ ) {

  				pairs.push( {
  					i: indexes[ i ],
  					w: weights[ i ]
  				} );

  			}

  			pairs.sort( function ( a, b ) {

  				return b.w - a.w;

  			 } );

  			while ( pairs.length < 4 ) {

  				pairs.push( {
  					i: 0,
  					w: 0
  				} );

  			}

  			if ( pairs.length > 4 )
  				{ pairs.length = 4; }
  			var sum = 0;

  			for ( var i = 0; i < 4; i ++ ) {

  				sum += pairs[ i ].w * pairs[ i ].w;

  			}

  			sum = Math.sqrt( sum );

  			for ( var i = 0; i < 4; i ++ ) {

  				pairs[ i ].w = pairs[ i ].w / sum;
  				indexes[ i ] = pairs[ i ].i;
  				weights[ i ] = pairs[ i ].w;

  			}

  		}

  		function findMatchingBone( root, name ) {

  			if ( root.name.indexOf( "bone_" + name ) == 0 )
  				{ return root; }

  			for ( var i in root.children ) {

  				var ret = findMatchingBone( root.children[ i ], name );

  				if ( ret )
  					{ return ret; }

  			}

  			return undefined;

  		}

  		function aiMesh() {

  			this.mPrimitiveTypes = 0;
  			this.mNumVertices = 0;
  			this.mNumFaces = 0;
  			this.mNumBones = 0;
  			this.mMaterialIndex = 0;
  			this.mVertices = [];
  			this.mNormals = [];
  			this.mTangents = [];
  			this.mBitangents = [];
  			this.mColors = [
  				[]
  			];
  			this.mTextureCoords = [
  				[]
  			];
  			this.mFaces = [];
  			this.mBones = [];
  			this.hookupSkeletons = function ( scene, threeScene ) {
  				var this$1 = this;


  				if ( this.mBones.length == 0 ) { return; }

  				var allBones = [];
  				var offsetMatrix = [];
  				var skeletonRoot = scene.findNode( this.mBones[ 0 ].mName );

  				while ( skeletonRoot.mParent && skeletonRoot.mParent.isBone ) {

  					skeletonRoot = skeletonRoot.mParent;

  				}

  				var threeSkeletonRoot = skeletonRoot.toTHREE( scene );
  				var threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );
  				this.threeNode.add( threeSkeletonRootBone );

  				for ( var i = 0; i < this.mBones.length; i ++ ) {

  					var bone = findMatchingBone( threeSkeletonRootBone, this$1.mBones[ i ].mName );

  					if ( bone ) {

  						var tbone = bone;
  						allBones.push( tbone );
  						//tbone.matrixAutoUpdate = false;
  						offsetMatrix.push( this$1.mBones[ i ].mOffsetMatrix.toTHREE() );

  					} else {

  						var skeletonRoot = scene.findNode( this$1.mBones[ i ].mName );
  						if ( ! skeletonRoot ) { return; }
  						var threeSkeletonRoot = skeletonRoot.toTHREE( scene );
  						var threeSkeletonRootParent = threeSkeletonRoot.parent;
  						var threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );
  						this$1.threeNode.add( threeSkeletonRootBone );
  						var bone = findMatchingBone( threeSkeletonRootBone, this$1.mBones[ i ].mName );
  						var tbone = bone;
  						allBones.push( tbone );
  						//tbone.matrixAutoUpdate = false;
  						offsetMatrix.push( this$1.mBones[ i ].mOffsetMatrix.toTHREE() );

  					}

  				}
  				var skeleton = new Skeleton( allBones, offsetMatrix );

  				this.threeNode.bind( skeleton, new Matrix4() );
  				this.threeNode.material.skinning = true;

  			};

  			this.toTHREE = function ( scene ) {
  				var this$1 = this;


  				if ( this.threeNode ) { return this.threeNode; }
  				var geometry = new BufferGeometry();
  				var mat;
  				if ( scene.mMaterials[ this.mMaterialIndex ] )
  					{ mat = scene.mMaterials[ this.mMaterialIndex ].toTHREE( scene ); }
  				else
  					{ mat = new MeshLambertMaterial(); }
  				geometry.setIndex( new BufferAttribute( new Uint32Array( this.mIndexArray ), 1 ) );
  				geometry.addAttribute( 'position', new BufferAttribute( this.mVertexBuffer, 3 ) );
  				if ( this.mNormalBuffer && this.mNormalBuffer.length > 0 )
  					{ geometry.addAttribute( 'normal', new BufferAttribute( this.mNormalBuffer, 3 ) ); }
  				if ( this.mColorBuffer && this.mColorBuffer.length > 0 )
  					{ geometry.addAttribute( 'color', new BufferAttribute( this.mColorBuffer, 4 ) ); }
  				if ( this.mTexCoordsBuffers[ 0 ] && this.mTexCoordsBuffers[ 0 ].length > 0 )
  					{ geometry.addAttribute( 'uv', new BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 0 ] ), 2 ) ); }
  				if ( this.mTexCoordsBuffers[ 1 ] && this.mTexCoordsBuffers[ 1 ].length > 0 )
  					{ geometry.addAttribute( 'uv1', new BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 1 ] ), 2 ) ); }
  				if ( this.mTangentBuffer && this.mTangentBuffer.length > 0 )
  					{ geometry.addAttribute( 'tangents', new BufferAttribute( this.mTangentBuffer, 3 ) ); }
  				if ( this.mBitangentBuffer && this.mBitangentBuffer.length > 0 )
  					{ geometry.addAttribute( 'bitangents', new BufferAttribute( this.mBitangentBuffer, 3 ) ); }
  				if ( this.mBones.length > 0 ) {

  					var weights = [];
  					var bones = [];

  					for ( var i = 0; i < this.mBones.length; i ++ ) {

  						for ( var j = 0; j < this.mBones[ i ].mWeights.length; j ++ ) {

  							var weight = this$1.mBones[ i ].mWeights[ j ];
  							if ( weight ) {

  								if ( ! weights[ weight.mVertexId ] ) { weights[ weight.mVertexId ] = []; }
  								if ( ! bones[ weight.mVertexId ] ) { bones[ weight.mVertexId ] = []; }
  								weights[ weight.mVertexId ].push( weight.mWeight );
  								bones[ weight.mVertexId ].push( parseInt( i ) );

  							}

  						}

  					}

  					for ( var i in bones ) {

  						sortWeights( bones[ i ], weights[ i ] );

  					}

  					var _weights = [];
  					var _bones = [];

  					for ( var i = 0; i < weights.length; i ++ ) {

  						for ( var j = 0; j < 4; j ++ ) {

  							if ( weights[ i ] && bones[ i ] ) {

  								_weights.push( weights[ i ][ j ] );
  								_bones.push( bones[ i ][ j ] );

  							} else {

  								_weights.push( 0 );
  								_bones.push( 0 );

  							}

  						}

  					}

  					geometry.addAttribute( 'skinWeight', new BufferAttribute( new Float32Array( _weights ), BONESPERVERT ) );
  					geometry.addAttribute( 'skinIndex', new BufferAttribute( new Float32Array( _bones ), BONESPERVERT ) );

  				}

  				var mesh;

  				if ( this.mBones.length == 0 )
  					{ mesh = new Mesh( geometry, mat ); }

  				if ( this.mBones.length > 0 ) {
  					mesh = new SkinnedMesh( geometry, mat );
  					mesh.normalizeSkinWeights();
  				}

  				this.threeNode = mesh;
  				//mesh.matrixAutoUpdate = false;
  				return mesh;

  			};

  		}

  		function aiFace() {

  			this.mNumIndices = 0;
  			this.mIndices = [];

  		}

  		function aiVector3D() {

  			this.x = 0;
  			this.y = 0;
  			this.z = 0;

  			this.toTHREE = function () {

  				return new Vector3( this.x, this.y, this.z );

  			};

  		}

  		function aiColor3D() {

  			this.r = 0;
  			this.g = 0;
  			this.b = 0;
  			this.a = 0;
  			this.toTHREE = function () {

  				return new Color( this.r, this.g, this.b, 1 );

  			};

  		}

  		function aiQuaternion() {

  			this.x = 0;
  			this.y = 0;
  			this.z = 0;
  			this.w = 0;
  			this.toTHREE = function () {

  				return new Quaternion( this.x, this.y, this.z, this.w );

  			};

  		}

  		function aiVertexWeight() {

  			this.mVertexId = 0;
  			this.mWeight = 0;

  		}

  		function aiString() {

  			this.data = [];
  			this.toString = function () {

  				var str = '';
  				this.data.forEach( function ( i ) {

  					str += ( String.fromCharCode( i ) );

  				} );
  				return str.replace( /[^\x20-\x7E]+/g, '' );

  			};

  		}

  		function aiVectorKey() {

  			this.mTime = 0;
  			this.mValue = null;

  		}

  		function aiQuatKey() {

  			this.mTime = 0;
  			this.mValue = null;

  		}

  		function aiNode() {

  			this.mName = '';
  			this.mTransformation = [];
  			this.mNumChildren = 0;
  			this.mNumMeshes = 0;
  			this.mMeshes = [];
  			this.mChildren = [];
  			this.toTHREE = function ( scene ) {
  				var this$1 = this;


  				if ( this.threeNode ) { return this.threeNode; }
  				var o = new Object3D();
  				o.name = this.mName;
  				o.matrix = this.mTransformation.toTHREE();

  				for ( var i = 0; i < this.mChildren.length; i ++ ) {

  					o.add( this$1.mChildren[ i ].toTHREE( scene ) );

  				}

  				for ( var i = 0; i < this.mMeshes.length; i ++ ) {

  					o.add( scene.mMeshes[ this$1.mMeshes[ i ] ].toTHREE( scene ) );

  				}

  				this.threeNode = o;
  				//o.matrixAutoUpdate = false;
  				o.matrix.decompose( o.position, o.quaternion, o.scale );
  				return o;

  			};

  		}

  		function aiBone() {

  			this.mName = '';
  			this.mNumWeights = 0;
  			this.mOffsetMatrix = 0;

  		}

  		function aiMaterialProperty() {

  			this.mKey = "";
  			this.mSemantic = 0;
  			this.mIndex = 0;
  			this.mData = [];
  			this.mDataLength = 0;
  			this.mType = 0;
  			this.dataAsColor = function () {

  				var array = ( new Uint8Array( this.mData ) ).buffer;
  				var reader = new DataView( array );
  				var r = reader.getFloat32( 0, true );
  				var g = reader.getFloat32( 4, true );
  				var b = reader.getFloat32( 8, true );
  				//var a = reader.getFloat32(12, true);
  				return new Color( r, g, b );

  			};

  			this.dataAsFloat = function () {

  				var array = ( new Uint8Array( this.mData ) ).buffer;
  				var reader = new DataView( array );
  				var r = reader.getFloat32( 0, true );
  				return r;

  			};

  			this.dataAsBool = function () {

  				var array = ( new Uint8Array( this.mData ) ).buffer;
  				var reader = new DataView( array );
  				var r = reader.getFloat32( 0, true );
  				return !! r;

  			};

  			this.dataAsString = function () {

  				var s = new aiString();
  				s.data = this.mData;
  				return s.toString();

  			};

  			this.dataAsMap = function () {

  				var s = new aiString();
  				s.data = this.mData;
  				var path = s.toString();
  				path = path.replace( /\\/g, '/' );

  				if ( path.indexOf( '/' ) != - 1 ) {

  					path = path.substr( path.lastIndexOf( '/' ) + 1 );

  				}

  				return textureLoader.load( path );

  			};

  		}
  		var namePropMapping = {

  			"?mat.name": "name",
  			"$mat.shadingm": "shading",
  			"$mat.twosided": "twoSided",
  			"$mat.wireframe": "wireframe",
  			"$clr.ambient": "ambient",
  			"$clr.diffuse": "color",
  			"$clr.specular": "specular",
  			"$clr.emissive": "emissive",
  			"$clr.transparent": "transparent",
  			"$clr.reflective": "reflect",
  			"$mat.shininess": "shininess",
  			"$mat.reflectivity": "reflectivity",
  			"$mat.refracti": "refraction",
  			"$tex.file": "map"

  		};

  		var nameTypeMapping = {

  			"?mat.name": "string",
  			"$mat.shadingm": "bool",
  			"$mat.twosided": "bool",
  			"$mat.wireframe": "bool",
  			"$clr.ambient": "color",
  			"$clr.diffuse": "color",
  			"$clr.specular": "color",
  			"$clr.emissive": "color",
  			"$clr.transparent": "color",
  			"$clr.reflective": "color",
  			"$mat.shininess": "float",
  			"$mat.reflectivity": "float",
  			"$mat.refracti": "float",
  			"$tex.file": "map"

  		};

  		function aiMaterial() {

  			this.mNumAllocated = 0;
  			this.mNumProperties = 0;
  			this.mProperties = [];
  			this.toTHREE = function ( scene ) {
  				var this$1 = this;


  				var name = this.mProperties[ 0 ].dataAsString();
  				var mat = new MeshPhongMaterial();

  				for ( var i = 0; i < this.mProperties.length; i ++ ) {

  					if ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'float' )
  						{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsFloat(); }
  					if ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'color' )
  						{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsColor(); }
  					if ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'bool' )
  						{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsBool(); }
  					if ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'string' )
  						{ mat[ namePropMapping[ this$1.mProperties[ i ].mKey ] ] = this$1.mProperties[ i ].dataAsString(); }
  					if ( nameTypeMapping[ this$1.mProperties[ i ].mKey ] == 'map' ) {

  						var prop = this$1.mProperties[ i ];
  						if ( prop.mSemantic == aiTextureType_DIFFUSE )
  							{ mat.map = this$1.mProperties[ i ].dataAsMap(); }
  						if ( prop.mSemantic == aiTextureType_NORMALS )
  							{ mat.normalMap = this$1.mProperties[ i ].dataAsMap(); }
  						if ( prop.mSemantic == aiTextureType_LIGHTMAP )
  							{ mat.lightMap = this$1.mProperties[ i ].dataAsMap(); }
  						if ( prop.mSemantic == aiTextureType_OPACITY )
  							{ mat.alphaMap = this$1.mProperties[ i ].dataAsMap(); }

  					}

  				}

  				mat.ambient.r = .53;
  				mat.ambient.g = .53;
  				mat.ambient.b = .53;
  				mat.color.r = 1;
  				mat.color.g = 1;
  				mat.color.b = 1;
  				return mat;

  			};

  		}
  		function veclerp( v1, v2, l ) {

  			var v = new Vector3();
  			var lm1 = 1 - l;
  			v.x = v1.x * l + v2.x * lm1;
  			v.y = v1.y * l + v2.y * lm1;
  			v.z = v1.z * l + v2.z * lm1;
  			return v;

  		}

  		function quatlerp( q1, q2, l ) {

  			return q1.clone().slerp( q2, 1 - l );

  		}

  		function sampleTrack( keys, time, lne, lerp ) {

  			if ( keys.length == 1 ) { return keys[ 0 ].mValue.toTHREE(); }

  			var dist = Infinity;
  			var key = null;
  			var nextKey = null;

  			for ( var i = 0; i < keys.length; i ++ ) {

  				var timeDist = Math.abs( keys[ i ].mTime - time );

  				if ( timeDist < dist && keys[ i ].mTime <= time ) {

  					dist = timeDist;
  					key = keys[ i ];
  					nextKey = keys[ i + 1 ];

  				}

  			}

  			if ( ! key ) {

  				return null;

  			} else if ( nextKey ) {

  				var dT = nextKey.mTime - key.mTime;
  				var T = key.mTime - time;
  				var l = T / dT;

  				return lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );

  			} else {

  				nextKey = keys[ 0 ].clone();
  				nextKey.mTime += lne;

  				var dT = nextKey.mTime - key.mTime;
  				var T = key.mTime - time;
  				var l = T / dT;

  				return lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );

  			}

  		}

  		function aiNodeAnim() {

  			this.mNodeName = "";
  			this.mNumPositionKeys = 0;
  			this.mNumRotationKeys = 0;
  			this.mNumScalingKeys = 0;
  			this.mPositionKeys = [];
  			this.mRotationKeys = [];
  			this.mScalingKeys = [];
  			this.mPreState = "";
  			this.mPostState = "";
  			this.init = function ( tps ) {

  				if ( ! tps ) { tps = 1; }

  				function t( t ) {

  					t.mTime /= tps;

  				}

  				this.mPositionKeys.forEach( t );
  				this.mRotationKeys.forEach( t );
  				this.mScalingKeys.forEach( t );

  			};

  			this.sortKeys = function () {

  				function comp( a, b ) {

  					return a.mTime - b.mTime;

  				}

  				this.mPositionKeys.sort( comp );
  				this.mRotationKeys.sort( comp );
  				this.mScalingKeys.sort( comp );

  			};

  			this.getLength = function () {

  				return Math.max(
  					Math.max.apply( null, this.mPositionKeys.map( function ( a ) {

  						return a.mTime;

  					} ) ),
  					Math.max.apply( null, this.mRotationKeys.map( function ( a ) {

  						return a.mTime;

  					} ) ),
  					Math.max.apply( null, this.mScalingKeys.map( function ( a ) {

  						return a.mTime;

  				 } ) )
  				);

  			};

  			this.toTHREE = function ( o, tps ) {
  				var this$1 = this;


  				this.sortKeys();
  				var length = this.getLength();
  				var track = new Virtulous.KeyFrameTrack();

  				for ( var i = 0; i < length; i += .05 ) {

  					var matrix = new Matrix4();
  					var time = i;
  					var pos = sampleTrack( this$1.mPositionKeys, time, length, veclerp );
  					var scale = sampleTrack( this$1.mScalingKeys, time, length, veclerp );
  					var rotation = sampleTrack( this$1.mRotationKeys, time, length, quatlerp );
  					matrix.compose( pos, rotation, scale );

  					var key = new Virtulous.KeyFrame( time, matrix );
  					track.addKey( key );

  				}

  				track.target = o.findNode( this.mNodeName ).toTHREE();

  				var tracks = [ track ];

  				if ( o.nodeToBoneMap[ this.mNodeName ] ) {

  					for ( var i = 0; i < o.nodeToBoneMap[ this.mNodeName ].length; i ++ ) {

  						var t2 = track.clone();
  						t2.target = o.nodeToBoneMap[ this$1.mNodeName ][ i ];
  						tracks.push( t2 );

  					}

  				}

  				return tracks;

  			};

  		}

  		function aiAnimation() {

  			this.mName = "";
  			this.mDuration = 0;
  			this.mTicksPerSecond = 0;
  			this.mNumChannels = 0;
  			this.mChannels = [];
  			this.toTHREE = function ( root ) {
  				var this$1 = this;


  				var animationHandle = new Virtulous.Animation();

  				for ( var i in this$1.mChannels ) {

  					this$1.mChannels[ i ].init( this$1.mTicksPerSecond );

  					var tracks = this$1.mChannels[ i ].toTHREE( root );

  					for ( var j in tracks ) {

  						tracks[ j ].init();
  						animationHandle.addTrack( tracks[ j ] );

  					}

  				}

  				animationHandle.length = Math.max.apply( null, animationHandle.tracks.map( function ( e ) {

  					return e.length;

  				} ) );
  				return animationHandle;

  			};

  		}

  		function aiTexture() {

  			this.mWidth = 0;
  			this.mHeight = 0;
  			this.texAchFormatHint = [];
  			this.pcData = [];

  		}

  		function aiLight() {

  			this.mName = '';
  			this.mType = 0;
  			this.mAttenuationConstant = 0;
  			this.mAttenuationLinear = 0;
  			this.mAttenuationQuadratic = 0;
  			this.mAngleInnerCone = 0;
  			this.mAngleOuterCone = 0;
  			this.mColorDiffuse = null;
  			this.mColorSpecular = null;
  			this.mColorAmbient = null;

  		}

  		function aiCamera() {

  			this.mName = '';
  			this.mPosition = null;
  			this.mLookAt = null;
  			this.mUp = null;
  			this.mHorizontalFOV = 0;
  			this.mClipPlaneNear = 0;
  			this.mClipPlaneFar = 0;
  			this.mAspect = 0;

  		}

  		function aiScene() {

  			this.mFlags = 0;
  			this.mNumMeshes = 0;
  			this.mNumMaterials = 0;
  			this.mNumAnimations = 0;
  			this.mNumTextures = 0;
  			this.mNumLights = 0;
  			this.mNumCameras = 0;
  			this.mRootNode = null;
  			this.mMeshes = [];
  			this.mMaterials = [];
  			this.mAnimations = [];
  			this.mLights = [];
  			this.mCameras = [];
  			this.nodeToBoneMap = {};
  			this.findNode = function ( name, root ) {
  				var this$1 = this;


  				if ( ! root ) {

  					root = this.mRootNode;

  				}

  				if ( root.mName == name ) {

  					return root;

  				}

  				for ( var i = 0; i < root.mChildren.length; i ++ ) {

  					var ret = this$1.findNode( name, root.mChildren[ i ] );
  					if ( ret ) { return ret; }

  				}

  				return null;

  			};

  			this.toTHREE = function () {
  				var this$1 = this;


  				this.nodeCount = 0;

  				markBones( this );

  				var o = this.mRootNode.toTHREE( this );

  				for ( var i in this$1.mMeshes )
  					{ this$1.mMeshes[ i ].hookupSkeletons( this$1, o ); }

  				if ( this.mAnimations.length > 0 ) {

  					var a = this.mAnimations[ 0 ].toTHREE( this );

  				}

  				return { object: o, animation: a };

  			};

  		}

  		function aiMatrix4() {

  			this.elements = [
  				[],
  				[],
  				[],
  				[]
  			];
  			this.toTHREE = function () {
  				var this$1 = this;


  				var m = new Matrix4();

  				for ( var i = 0; i < 4; ++ i ) {

  					for ( var i2 = 0; i2 < 4; ++ i2 ) {

  						m.elements[ i * 4 + i2 ] = this$1.elements[ i2 ][ i ];

  					}

  				}

  				return m;

  			};

  		}

  		var littleEndian = true;

  		function readFloat( dataview ) {

  			var val = dataview.getFloat32( dataview.readOffset, littleEndian );
  			dataview.readOffset += 4;
  			return val;

  		}

  		function Read_double( dataview ) {

  			var val = dataview.getFloat64( dataview.readOffset, littleEndian );
  			dataview.readOffset += 8;
  			return val;

  		}

  		function Read_uint8_t( dataview ) {

  			var val = dataview.getUint8( dataview.readOffset );
  			dataview.readOffset += 1;
  			return val;

  		}

  		function Read_uint16_t( dataview ) {

  			var val = dataview.getUint16( dataview.readOffset, littleEndian );
  			dataview.readOffset += 2;
  			return val;

  		}

  		function Read_unsigned_int( dataview ) {

  			var val = dataview.getUint32( dataview.readOffset, littleEndian );
  			dataview.readOffset += 4;
  			return val;

  		}

  		function Read_uint32_t( dataview ) {

  			var val = dataview.getUint32( dataview.readOffset, littleEndian );
  			dataview.readOffset += 4;
  			return val;

  		}

  		function Read_aiVector3D( stream ) {

  			var v = new aiVector3D();
  			v.x = readFloat( stream );
  			v.y = readFloat( stream );
  			v.z = readFloat( stream );
  			return v;

  		}

  		function Read_aiColor3D( stream ) {

  			var c = new aiColor3D();
  			c.r = readFloat( stream );
  			c.g = readFloat( stream );
  			c.b = readFloat( stream );
  			return c;

  		}

  		function Read_aiQuaternion( stream ) {

  			var v = new aiQuaternion();
  			v.w = readFloat( stream );
  			v.x = readFloat( stream );
  			v.y = readFloat( stream );
  			v.z = readFloat( stream );
  			return v;

  		}

  		function Read_aiString( stream ) {

  			var s = new aiString();
  			var stringlengthbytes = Read_unsigned_int( stream );
  			stream.ReadBytes( s.data, 1, stringlengthbytes );
  			return s.toString();

  		}

  		function Read_aiVertexWeight( stream ) {

  			var w = new aiVertexWeight();
  			w.mVertexId = Read_unsigned_int( stream );
  			w.mWeight = readFloat( stream );
  			return w;

  		}

  		function Read_aiMatrix4x4( stream ) {

  			var m = new aiMatrix4();

  			for ( var i = 0; i < 4; ++ i ) {

  				for ( var i2 = 0; i2 < 4; ++ i2 ) {

  					m.elements[ i ][ i2 ] = readFloat( stream );

  				}

  			}

  			return m;

  		}

  		function Read_aiVectorKey( stream ) {

  			var v = new aiVectorKey();
  			v.mTime = Read_double( stream );
  			v.mValue = Read_aiVector3D( stream );
  			return v;

  		}

  		function Read_aiQuatKey( stream ) {

  			var v = new aiQuatKey();
  			v.mTime = Read_double( stream );
  			v.mValue = Read_aiQuaternion( stream );
  			return v;

  		}

  		function ReadArray_aiVertexWeight( stream, data, size ) {

  			for ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiVertexWeight( stream ); }

  		}

  		function ReadArray_aiVectorKey( stream, data, size ) {

  			for ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiVectorKey( stream ); }

  		}

  		function ReadArray_aiQuatKey( stream, data, size ) {

  			for ( var i = 0; i < size; i ++ ) { data[ i ] = Read_aiQuatKey( stream ); }

  		}

  		function ReadBounds( stream, T , n ) {

  			// not sure what to do here, the data isn't really useful.
  			return stream.Seek( sizeof( T ) * n, aiOrigin_CUR );

  		}

  		function ai_assert( bool ) {

  			if ( ! bool )
  				{ throw ( "asset failed" ); }

  		}

  		function ReadBinaryNode( stream, parent, depth ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AINODE );
  			
  			Read_uint32_t( stream );
  			var node = new aiNode();
  			node.mParent = parent;
  			node.mDepth = depth;
  			node.mName = Read_aiString( stream );
  			node.mTransformation = Read_aiMatrix4x4( stream );
  			node.mNumChildren = Read_unsigned_int( stream );
  			node.mNumMeshes = Read_unsigned_int( stream );

  			if ( node.mNumMeshes ) {

  				node.mMeshes = [];

  				for ( var i = 0; i < node.mNumMeshes; ++ i ) {

  					node.mMeshes[ i ] = Read_unsigned_int( stream );

  				}

  			}

  			if ( node.mNumChildren ) {

  				node.mChildren = [];

  				for ( var i = 0; i < node.mNumChildren; ++ i ) {

  					var node2 = ReadBinaryNode( stream, node, depth ++ );
  					node.mChildren[ i ] = node2;

  				}

  			}

  			return node;

  		}

  		// -----------------------------------------------------------------------------------

  		function ReadBinaryBone( stream, b ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AIBONE );
  			
  			Read_uint32_t( stream );
  			b.mName = Read_aiString( stream );
  			b.mNumWeights = Read_unsigned_int( stream );
  			b.mOffsetMatrix = Read_aiMatrix4x4( stream );
  			// for the moment we write dumb min/max values for the bones, too.
  			// maybe I'll add a better, hash-like solution later
  			if ( shortened ) {

  				ReadBounds( stream, b.mWeights, b.mNumWeights );

  			} else {

  				// else write as usual

  				b.mWeights = [];
  				ReadArray_aiVertexWeight( stream, b.mWeights, b.mNumWeights );

  			}

  			return b;

  		}

  		function ReadBinaryMesh( stream, mesh ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AIMESH );
  			
  			Read_uint32_t( stream );
  			mesh.mPrimitiveTypes = Read_unsigned_int( stream );
  			mesh.mNumVertices = Read_unsigned_int( stream );
  			mesh.mNumFaces = Read_unsigned_int( stream );
  			mesh.mNumBones = Read_unsigned_int( stream );
  			mesh.mMaterialIndex = Read_unsigned_int( stream );
  			mesh.mNumUVComponents = [];
  			// first of all, write bits for all existent vertex components
  			var c = Read_unsigned_int( stream );

  			if ( c & ASSBIN_MESH_HAS_POSITIONS ) {

  				if ( shortened ) {

  					ReadBounds( stream, mesh.mVertices, mesh.mNumVertices );

  				} else {

  					// else write as usual

  					mesh.mVertices = [];
  					mesh.mVertexBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );
  					stream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );

  				}

  			}

  			if ( c & ASSBIN_MESH_HAS_NORMALS ) {

  				if ( shortened ) {

  					ReadBounds( stream, mesh.mNormals, mesh.mNumVertices );

  				} else {

  					// else write as usual

  					mesh.mNormals = [];
  					mesh.mNormalBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );
  					stream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );

  				}

  			}

  			if ( c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS ) {

  				if ( shortened ) {

  					ReadBounds( stream, mesh.mTangents, mesh.mNumVertices );
  					ReadBounds( stream, mesh.mBitangents, mesh.mNumVertices );

  				} else {

  					// else write as usual

  					mesh.mTangents = [];
  					mesh.mTangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );
  					stream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );
  					mesh.mBitangents = [];
  					mesh.mBitangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );
  					stream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );

  				}

  			}

  			for ( var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++ n ) {

  				if ( ! ( c & ASSBIN_MESH_HAS_COLOR( n ) ) ) { break; }

  				if ( shortened ) {

  					ReadBounds( stream, mesh.mColors[ n ], mesh.mNumVertices );

  				} else {

  					// else write as usual

  					mesh.mColors[ n ] = [];
  					mesh.mColorBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4 );
  					stream.Seek( mesh.mNumVertices * 4 * 4, aiOrigin_CUR );

  				}

  			}

  			mesh.mTexCoordsBuffers = [];

  			for ( var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++ n ) {

  				if ( ! ( c & ASSBIN_MESH_HAS_TEXCOORD( n ) ) ) { break; }

  				// write number of UV components
  				mesh.mNumUVComponents[ n ] = Read_unsigned_int( stream );

  				if ( shortened ) {

  					ReadBounds( stream, mesh.mTextureCoords[ n ], mesh.mNumVertices );

  				} else {

  				// else write as usual

  					mesh.mTextureCoords[ n ] = [];
  					//note that assbin always writes 3d texcoords
  					mesh.mTexCoordsBuffers[ n ] = [];

  					for ( var uv = 0; uv < mesh.mNumVertices; uv ++ ) {

  						mesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );
  						mesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );
  						readFloat( stream );

  					}

  				}

  			}
  			// write faces. There are no floating-point calculations involved
  			// in these, so we can write a simple hash over the face data
  			// to the dump file. We generate a single 32 Bit hash for 512 faces
  			// using Assimp's standard hashing function.
  			if ( shortened ) {

  				Read_unsigned_int( stream );

  			} else {

  				// else write as usual

  				// if there are less than 2^16 vertices, we can simply use 16 bit integers ...
  				mesh.mFaces = [];
  				mesh.mIndexArray = [];

  				for ( var i = 0; i < mesh.mNumFaces; ++ i ) {

  					var f = mesh.mFaces[ i ] = new aiFace();
  					// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);
  					f.mNumIndices = Read_uint16_t( stream );
  					f.mIndices = [];

  					for ( var a = 0; a < f.mNumIndices; ++ a ) {

  						if ( mesh.mNumVertices < ( 1 << 16 ) ) {

  							f.mIndices[ a ] = Read_uint16_t( stream );

  						} else {

  							f.mIndices[ a ] = Read_unsigned_int( stream );

  						}
  					}

  					if ( f.mNumIndices === 3 ) {

  						mesh.mIndexArray.push( f.mIndices[ 0 ] );
  						mesh.mIndexArray.push( f.mIndices[ 1 ] );
  						mesh.mIndexArray.push( f.mIndices[ 2 ] );

  					} else if ( f.mNumIndices === 4 ) {

  						mesh.mIndexArray.push( f.mIndices[ 0 ] );
  						mesh.mIndexArray.push( f.mIndices[ 1 ] );
  						mesh.mIndexArray.push( f.mIndices[ 2 ] );
  						mesh.mIndexArray.push( f.mIndices[ 2 ] );
  						mesh.mIndexArray.push( f.mIndices[ 3 ] );
  						mesh.mIndexArray.push( f.mIndices[ 0 ] );

  					} else {

  						throw ( new Error( "Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp." ) );

  					}
  				}

  			}
  			// write bones
  			if ( mesh.mNumBones ) {

  				mesh.mBones = [];

  				for ( var a = 0; a < mesh.mNumBones; ++ a ) {

  					mesh.mBones[ a ] = new aiBone();
  					ReadBinaryBone( stream, mesh.mBones[ a ] );

  				}

  			}

  		}

  		function ReadBinaryMaterialProperty( stream, prop ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY );
  			
  			Read_uint32_t( stream );
  			prop.mKey = Read_aiString( stream );
  			prop.mSemantic = Read_unsigned_int( stream );
  			prop.mIndex = Read_unsigned_int( stream );
  			prop.mDataLength = Read_unsigned_int( stream );
  			prop.mType = Read_unsigned_int( stream );
  			prop.mData = [];
  			stream.ReadBytes( prop.mData, 1, prop.mDataLength );

  		}

  		// -----------------------------------------------------------------------------------

  		function ReadBinaryMaterial( stream, mat ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AIMATERIAL );
  			
  			Read_uint32_t( stream );
  			mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int( stream );

  			if ( mat.mNumProperties ) {

  				if ( mat.mProperties ) {

  					delete mat.mProperties;

  				}

  				mat.mProperties = [];

  				for ( var i = 0; i < mat.mNumProperties; ++ i ) {

  					mat.mProperties[ i ] = new aiMaterialProperty();
  					ReadBinaryMaterialProperty( stream, mat.mProperties[ i ] );

  				}

  			}

  		}
  		// -----------------------------------------------------------------------------------
  		function ReadBinaryNodeAnim( stream, nd ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AINODEANIM );
  			
  			Read_uint32_t( stream );
  			nd.mNodeName = Read_aiString( stream );
  			nd.mNumPositionKeys = Read_unsigned_int( stream );
  			nd.mNumRotationKeys = Read_unsigned_int( stream );
  			nd.mNumScalingKeys = Read_unsigned_int( stream );
  			nd.mPreState = Read_unsigned_int( stream );
  			nd.mPostState = Read_unsigned_int( stream );

  			if ( nd.mNumPositionKeys ) {

  				if ( shortened ) {

  					ReadBounds( stream, nd.mPositionKeys, nd.mNumPositionKeys );

  				} else {

  					// else write as usual

  					nd.mPositionKeys = [];
  					ReadArray_aiVectorKey( stream, nd.mPositionKeys, nd.mNumPositionKeys );

  				}

  			}

  			if ( nd.mNumRotationKeys ) {

  				if ( shortened ) {

  					ReadBounds( stream, nd.mRotationKeys, nd.mNumRotationKeys );

  				} else {

  		 			// else write as usual

  					nd.mRotationKeys = [];
  					ReadArray_aiQuatKey( stream, nd.mRotationKeys, nd.mNumRotationKeys );

  				}

  			}

  			if ( nd.mNumScalingKeys ) {

  				if ( shortened ) {

  					ReadBounds( stream, nd.mScalingKeys, nd.mNumScalingKeys );

  				} else {

  	 				// else write as usual

  					nd.mScalingKeys = [];
  					ReadArray_aiVectorKey( stream, nd.mScalingKeys, nd.mNumScalingKeys );

  				}

  			}

  		}
  		// -----------------------------------------------------------------------------------
  		function ReadBinaryAnim( stream, anim ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AIANIMATION );
  			
  			Read_uint32_t( stream );
  			anim.mName = Read_aiString( stream );
  			anim.mDuration = Read_double( stream );
  			anim.mTicksPerSecond = Read_double( stream );
  			anim.mNumChannels = Read_unsigned_int( stream );

  			if ( anim.mNumChannels ) {

  				anim.mChannels = [];

  				for ( var a = 0; a < anim.mNumChannels; ++ a ) {

  					anim.mChannels[ a ] = new aiNodeAnim();
  					ReadBinaryNodeAnim( stream, anim.mChannels[ a ] );

  				}

  			}

  		}

  		function ReadBinaryTexture( stream, tex ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AITEXTURE );
  			
  			Read_uint32_t( stream );
  			tex.mWidth = Read_unsigned_int( stream );
  			tex.mHeight = Read_unsigned_int( stream );
  			stream.ReadBytes( tex.achFormatHint, 1, 4 );

  			if ( ! shortened ) {

  				if ( ! tex.mHeight ) {

  					tex.pcData = [];
  					stream.ReadBytes( tex.pcData, 1, tex.mWidth );

  				} else {

  					tex.pcData = [];
  					stream.ReadBytes( tex.pcData, 1, tex.mWidth * tex.mHeight * 4 );

  				}

  			}

  		}
  		// -----------------------------------------------------------------------------------
  		function ReadBinaryLight( stream, l ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AILIGHT );
  			
  			Read_uint32_t( stream );
  			l.mName = Read_aiString( stream );
  			l.mType = Read_unsigned_int( stream );

  			if ( l.mType != aiLightSource_DIRECTIONAL ) {

  				l.mAttenuationConstant = readFloat( stream );
  				l.mAttenuationLinear = readFloat( stream );
  				l.mAttenuationQuadratic = readFloat( stream );

  			}

  			l.mColorDiffuse = Read_aiColor3D( stream );
  			l.mColorSpecular = Read_aiColor3D( stream );
  			l.mColorAmbient = Read_aiColor3D( stream );

  			if ( l.mType == aiLightSource_SPOT ) {

  				l.mAngleInnerCone = readFloat( stream );
  				l.mAngleOuterCone = readFloat( stream );

  			}

  		}
  		// -----------------------------------------------------------------------------------
  		function ReadBinaryCamera( stream, cam ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AICAMERA );
  			
  			Read_uint32_t( stream );
  			cam.mName = Read_aiString( stream );
  			cam.mPosition = Read_aiVector3D( stream );
  			cam.mLookAt = Read_aiVector3D( stream );
  			cam.mUp = Read_aiVector3D( stream );
  			cam.mHorizontalFOV = readFloat( stream );
  			cam.mClipPlaneNear = readFloat( stream );
  			cam.mClipPlaneFar = readFloat( stream );
  			cam.mAspect = readFloat( stream );

  		}

  		function ReadBinaryScene( stream, scene ) {

  			var chunkID = Read_uint32_t( stream );
  			ai_assert( chunkID == ASSBIN_CHUNK_AISCENE );
  			
  			Read_uint32_t( stream );
  			scene.mFlags = Read_unsigned_int( stream );
  			scene.mNumMeshes = Read_unsigned_int( stream );
  			scene.mNumMaterials = Read_unsigned_int( stream );
  			scene.mNumAnimations = Read_unsigned_int( stream );
  			scene.mNumTextures = Read_unsigned_int( stream );
  			scene.mNumLights = Read_unsigned_int( stream );
  			scene.mNumCameras = Read_unsigned_int( stream );
  			// Read node graph
  			scene.mRootNode = new aiNode();
  			scene.mRootNode = ReadBinaryNode( stream, null, 0 );
  			// Read all meshes
  			if ( scene.mNumMeshes ) {

  				scene.mMeshes = [];

  				for ( var i = 0; i < scene.mNumMeshes; ++ i ) {

  					scene.mMeshes[ i ] = new aiMesh();
  					ReadBinaryMesh( stream, scene.mMeshes[ i ] );

  				}

  			}
  			// Read materials
  			if ( scene.mNumMaterials ) {

  				scene.mMaterials = [];

  				for ( var i = 0; i < scene.mNumMaterials; ++ i ) {

  					scene.mMaterials[ i ] = new aiMaterial();
  					ReadBinaryMaterial( stream, scene.mMaterials[ i ] );

  				}

  			}
  			// Read all animations
  			if ( scene.mNumAnimations ) {

  				scene.mAnimations = [];

  				for ( var i = 0; i < scene.mNumAnimations; ++ i ) {

  					scene.mAnimations[ i ] = new aiAnimation();
  					ReadBinaryAnim( stream, scene.mAnimations[ i ] );

  				}

  			}
  			// Read all textures
  			if ( scene.mNumTextures ) {

  				scene.mTextures = [];

  				for ( var i = 0; i < scene.mNumTextures; ++ i ) {

  					scene.mTextures[ i ] = new aiTexture();
  					ReadBinaryTexture( stream, scene.mTextures[ i ] );

  				}

  			}
  			// Read lights
  			if ( scene.mNumLights ) {

  				scene.mLights = [];

  				for ( var i = 0; i < scene.mNumLights; ++ i ) {

  					scene.mLights[ i ] = new aiLight();
  					ReadBinaryLight( stream, scene.mLights[ i ] );

  				}

  			}
  			// Read cameras
  			if ( scene.mNumCameras ) {

  				scene.mCameras = [];

  				for ( var i = 0; i < scene.mNumCameras; ++ i ) {

  					scene.mCameras[ i ] = new aiCamera();
  					ReadBinaryCamera( stream, scene.mCameras[ i ] );

  				}

  			}

  		}
  		var aiOrigin_CUR = 0;
  		var aiOrigin_BEG = 1;

  		function extendStream( stream ) {

  			stream.readOffset = 0;
  			stream.Seek = function ( off, ori ) {

  				if ( ori == aiOrigin_CUR ) {

  					stream.readOffset += off;

  				}
  				if ( ori == aiOrigin_BEG ) {

  					stream.readOffset = off;

  				}

  			};

  			stream.ReadBytes = function ( buff, size, n ) {
  				var this$1 = this;


  				var bytes = size * n;
  				for ( var i = 0; i < bytes; i ++ )
  					{ buff[ i ] = Read_uint8_t( this$1 ); }

  			};

  			stream.subArray32 = function ( start, end ) {

  				var buff = this.buffer;
  				var newbuff = buff.slice( start, end );
  				return new Float32Array( newbuff );

  			};

  			stream.subArrayUint16 = function ( start, end ) {

  				var buff = this.buffer;
  				var newbuff = buff.slice( start, end );
  				return new Uint16Array( newbuff );

  			};

  			stream.subArrayUint8 = function ( start, end ) {

  				var buff = this.buffer;
  				var newbuff = buff.slice( start, end );
  				return new Uint8Array( newbuff );

  			};

  			stream.subArrayUint32 = function ( start, end ) {

  				var buff = this.buffer;
  				var newbuff = buff.slice( start, end );
  				return new Uint32Array( newbuff );

  			};

  		}

  		var shortened, compressed;

  		function InternReadFile( pFiledata ) {

  			var pScene = new aiScene();
  			var stream = new DataView( pFiledata );
  			extendStream( stream );
  			stream.Seek( 44, aiOrigin_CUR ); // signature
  			
  			var versionMajor = Read_unsigned_int( stream );
  			
  			var versionMinor = Read_unsigned_int( stream );
  			
  			var versionRevision = Read_unsigned_int( stream );
  			
  			var compileFlags = Read_unsigned_int( stream );
  			shortened = Read_uint16_t( stream ) > 0;
  			compressed = Read_uint16_t( stream ) > 0;
  			if ( shortened )
  				{ throw "Shortened binaries are not supported!"; }
  			stream.Seek( 256, aiOrigin_CUR ); // original filename
  			stream.Seek( 128, aiOrigin_CUR ); // options
  			stream.Seek( 64, aiOrigin_CUR ); // padding
  			if ( compressed ) {

  				var uncompressedSize = Read_uint32_t( stream );
  				var compressedSize = stream.FileSize() - stream.Tell();
  				var compressedData = [];
  				stream.Read( compressedData, 1, compressedSize );
  				var uncompressedData = [];
  				uncompress( uncompressedData, uncompressedSize, compressedData, compressedSize );
  				var buff = new ArrayBuffer( uncompressedData );
  				ReadBinaryScene( buff, pScene );

  			} else {

  				ReadBinaryScene( stream, pScene );
  				return pScene.toTHREE();

  			}

  		}

  		return InternReadFile( buffer );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  	var AWD_FIELD_INT8 = 1,
  		AWD_FIELD_INT16 = 2,
  		AWD_FIELD_INT32 = 3,
  		AWD_FIELD_UINT8 = 4,
  		AWD_FIELD_UINT16 = 5,
  		AWD_FIELD_UINT32 = 6,
  		AWD_FIELD_FLOAT32 = 7,
  		AWD_FIELD_FLOAT64 = 8,
  		AWD_FIELD_BOOL = 21,
  		AWD_FIELD_BADDR = 23,
  		AWD_FIELD_VECTOR2x1 = 41,
  		AWD_FIELD_VECTOR3x1 = 42,
  		AWD_FIELD_VECTOR4x1 = 43,
  		AWD_FIELD_MTX3x2 = 44,
  		AWD_FIELD_MTX3x3 = 45,
  		AWD_FIELD_MTX4x3 = 46,
  		AWD_FIELD_MTX4x4 = 47,

  		BOOL = 21,
  		BADDR = 23,

  		UINT8 = 4,
  		UINT16 = 5,
  		FLOAT32 = 7,
  		FLOAT64 = 8;

  	var littleEndian = true;

  	function Block() {

  		this.id = 0;
  		this.data = null;

  	}

  	function AWDProperties() {}

  	AWDProperties.prototype = {
  		set: function ( key, value ) {

  			this[ key ] = value;

  		},

  		get: function ( key, fallback ) {

  			if ( this.hasOwnProperty( key ) ) {

  				return this[ key ];

  			} else {

  				return fallback;

  			}

  		}
  	};

  	var AWDLoader = function ( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.trunk = new Object3D();

  		this.materialFactory = undefined;

  		this._url = '';
  		this._baseDir = '';

  		this._data = undefined;
  		this._ptr = 0;

  		this._version = [];
  		this._streaming = false;
  		this._optimized_for_accuracy = false;
  		this._compression = 0;
  		this._bodylen = 0xFFFFFFFF;

  		this._blocks = [ new Block() ];

  		this._accuracyMatrix = false;
  		this._accuracyGeo = false;
  		this._accuracyProps = false;

  	};

  	AWDLoader.prototype = {

  		constructor: AWDLoader,

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			this._url = url;
  			this._baseDir = url.substr( 0, url.lastIndexOf( '/' ) + 1 );

  			var loader = new FileLoader( this.manager );
  			loader.setPath( this.path );
  			loader.setResponseType( 'arraybuffer' );
  			loader.load( url, function ( text ) {

  				onLoad( scope.parse( text ) );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		parse: function ( data ) {
  			var this$1 = this;


  			var blen = data.byteLength;

  			this._ptr = 0;
  			this._data = new DataView( data );

  			this._parseHeader( );

  			if ( this._compression != 0 ) {

  				console.error( 'compressed AWD not supported' );

  			}

  			if ( ! this._streaming && this._bodylen != data.byteLength - this._ptr ) {

  				console.error( 'AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr );

  			}

  			while ( this._ptr < blen ) {

  				this$1.parseNextBlock();

  			}

  			return this.trunk;

  		},

  		parseNextBlock: function () {

  			var assetData,
  				ns, type, len, block,
  				blockId = this.readU32(),
  				ns = this.readU8(),
  				type = this.readU8(),
  				flags = this.readU8(),
  				len = this.readU32();
  			switch ( type ) {

  				case 1:
  					assetData = this.parseMeshData( len );
  					break;

  				case 22:
  					assetData = this.parseContainer( len );
  					break;

  				case 23:
  					assetData = this.parseMeshInstance( len );
  					break;

  				case 81:
  					assetData = this.parseMaterial( len );
  					break;

  				case 82:
  					assetData = this.parseTexture( len );
  					break;

  				case 101:
  					assetData = this.parseSkeleton( len );
  					break;

  	    //  case 111:
  	    //    assetData = this.parseMeshPoseAnimation(len, true);
  	    //    break;

  				case 112:
  					assetData = this.parseMeshPoseAnimation( len, false );
  					break;

  				case 113:
  					assetData = this.parseVertexAnimationSet( len );
  					break;

  				case 102:
  					assetData = this.parseSkeletonPose( len );
  					break;

  				case 103:
  					assetData = this.parseSkeletonAnimation( len );
  					break;

  				case 122:
  					assetData = this.parseAnimatorSet( len );
  					break;

  				// case 121:
  				//  assetData = parseUVAnimation(len);
  				//  break;

  				default:
  					//debug('Ignoring block!',type, len);
  					this._ptr += len;
  					break;

  			}
  			// Store block reference for later use
  			this._blocks[ blockId ] = block = new Block();
  			block.data = assetData;
  			block.id = blockId;
  		},

  		_parseHeader: function () {

  			var version = this._version,
  				awdmagic = ( this.readU8() << 16 ) | ( this.readU8() << 8 ) | this.readU8();

  			if ( awdmagic != 4282180 )
  				{ throw new Error( "AWDLoader - bad magic" ); }

  			version[ 0 ] = this.readU8();
  			version[ 1 ] = this.readU8();

  			var flags = this.readU16();

  			this._streaming = ( flags & 0x1 ) == 0x1;

  			if ( ( version[ 0 ] === 2 ) && ( version[ 1 ] === 1 ) ) {

  				this._accuracyMatrix = ( flags & 0x2 ) === 0x2;
  				this._accuracyGeo = ( flags & 0x4 ) === 0x4;
  				this._accuracyProps = ( flags & 0x8 ) === 0x8;

  			}

  			this._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;
  			this._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;
  			this._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;

  			this._optimized_for_accuracy = ( flags & 0x2 ) === 0x2;

  			this._compression = this.readU8();
  			this._bodylen = this.readU32();

  		},

  		parseContainer: function ( len ) {

  			var parent,
  				ctr = new Object3D(),
  				par_id = this.readU32(),
  				mtx = this.parseMatrix4();

  			ctr.name = this.readUTF();
  			ctr.applyMatrix( mtx );

  			parent = this._blocks[ par_id ].data || this.trunk;
  			parent.add( ctr );

  			this.parseProperties( {
  				1: this._matrixNrType,
  				2: this._matrixNrType,
  				3: this._matrixNrType,
  				4: UINT8
  			} );

  			ctr.extra = this.parseUserAttributes();

  			return ctr;

  		},

  		parseMeshInstance: function ( len ) {
  			var this$1 = this;


  			var name,
  				mesh, geometries, meshLen, meshes,
  				par_id, data_id,
  				mtx,
  				materials, mat, mat_id,
  				num_materials,
  				parent,
  				i;

  			par_id = this.readU32();
  			mtx = this.parseMatrix4();
  			name = this.readUTF();
  			data_id = this.readU32();
  			num_materials = this.readU16();

  			geometries = this.getBlock( data_id );

  			materials = [];

  			for ( i = 0; i < num_materials; i ++ ) {

  				mat_id = this$1.readU32();
  				mat = this$1.getBlock( mat_id );
  				materials.push( mat );

  			}

  			meshLen = geometries.length;
  			meshes = [];

  			// TODO : BufferGeometry don't support "geometryGroups" for now.
  			// so we create sub meshes for each groups
  			if ( meshLen > 1 ) {

  				mesh = new Object3D();
  				for ( i = 0; i < meshLen; i ++ ) {

  					var sm = new Mesh( geometries[ i ] );
  					meshes.push( sm );
  					mesh.add( sm );

  				}

  			} else {

  				mesh = new Mesh( geometries[ 0 ] );
  				meshes.push( mesh );

  			}

  			mesh.applyMatrix( mtx );
  			mesh.name = name;
  			parent = this.getBlock( par_id ) || this.trunk;
  			parent.add( mesh );
  			var matLen = materials.length;
  			var maxLen = Math.max( meshLen, matLen );
  			for ( i = 0; i < maxLen; i ++ )
  				{ meshes[ i % meshLen ].material = materials[ i % matLen ]; }
  			// Ignore for now
  			this.parseProperties( null );
  			mesh.extra = this.parseUserAttributes();

  			return mesh;

  		},

  		parseMaterial: function ( len ) {
  			var this$1 = this;


  			var name,
  				type,
  				props,
  				mat,
  				attributes,
  				num_methods,
  				methods_parsed;

  			name = this.readUTF();
  			type = this.readU8();
  			num_methods = this.readU8();

  			//log( "AWDLoader parseMaterial ",name )

  			// Read material numerical properties
  			// (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
  			props = this.parseProperties( {
  				1: AWD_FIELD_INT32,
  				2: AWD_FIELD_BADDR,
  				11: AWD_FIELD_BOOL,
  				12: AWD_FIELD_FLOAT32,
  				13: AWD_FIELD_BOOL
  			} );

  			methods_parsed = 0;

  			while ( methods_parsed < num_methods ) {

  				var method_type = this$1.readU16();
  				this$1.parseProperties( null );
  				this$1.parseUserAttributes();

  			}

  			attributes = this.parseUserAttributes();

  			if ( this.materialFactory !== undefined ) {

  				mat = this.materialFactory( name );
  				if ( mat ) { return mat; }

  			}

  			mat = new MeshPhongMaterial();

  			if ( type === 1 ) {

  				// Color material
  				mat.color.setHex( props.get( 1, 0xcccccc ) );

  			} else if ( type === 2 ) {

  				// Bitmap material
  				var tex_addr = props.get( 2, 0 );
  				mat.map = this.getBlock( tex_addr );

  			}

  			mat.extra = attributes;
  			mat.alphaThreshold = props.get( 12, 0.0 );
  			mat.repeat = props.get( 13, false );
  			return mat;

  		},

  		parseTexture: function ( len ) {

  			var name = this.readUTF(),
  				type = this.readU8(),
  				asset,
  				data_len;

  			// External
  			if ( type === 0 ) {

  				data_len = this.readU32();
  				var url = this.readUTFBytes( data_len );
  				console.log( url );

  				asset = this.loadTexture( url );

  			}
  			// Ignore for now
  			this.parseProperties( null );

  			this.parseUserAttributes();
  			return asset;

  		},

  		loadTexture: function ( url ) {

  			var tex = new Texture();

  			var loader = new ImageLoader( this.manager );

  			loader.load( this._baseDir + url, function ( image ) {

  				tex.image = image;
  				tex.needsUpdate = true;

  			} );

  			return tex;

  		},

  		parseSkeleton: function ( len ) {
  			var this$1 = this;


  			// Array<Bone>
  			var name = this.readUTF(),
  				num_joints = this.readU16(),
  				skeleton = [],
  				joints_parsed = 0;

  			this.parseProperties( null );

  			while ( joints_parsed < num_joints ) {

  				var joint, ibp;

  				// Ignore joint id
  				this$1.readU16();

  				joint = new Bone();
  				joint.parent = this$1.readU16() - 1; // 0=null in AWD
  				joint.name = this$1.readUTF();

  				ibp = this$1.parseMatrix4();
  				joint.skinMatrix = ibp;

  				// Ignore joint props/attributes for now
  				this$1.parseProperties( null );
  				this$1.parseUserAttributes();

  				skeleton.push( joint );
  				joints_parsed ++;

  			}

  			// Discard attributes for now
  			this.parseUserAttributes();
  			return skeleton;

  		},

  		parseSkeletonPose: function ( blockID ) {
  			var this$1 = this;


  			var name = this.readUTF();

  			var num_joints = this.readU16();
  			this.parseProperties( null );

  			// debug( 'parse Skeleton Pose. joints : ' + num_joints);

  			var pose = [];

  			var joints_parsed = 0;

  			while ( joints_parsed < num_joints ) {

  				var has_transform; //:uint;
  				var mtx_data;

  				has_transform = this$1.readU8();

  				if ( has_transform === 1 ) {

  					mtx_data = this$1.parseMatrix4();

  				} else {

  					mtx_data = new Matrix4();

  				}
  				pose[ joints_parsed ] = mtx_data;
  				joints_parsed ++;

  			}

  			// Skip attributes for now
  			this.parseUserAttributes();

  			return pose;

  		},

  		parseSkeletonAnimation: function ( blockID ) {
  			var this$1 = this;


  			var frame_dur;
  			var pose_addr;
  			var pose;

  			var name = this.readUTF();

  			var clip = [];

  			var num_frames = this.readU16();
  			this.parseProperties( null );

  			var frames_parsed = 0;

  			// debug( 'parse Skeleton Animation. frames : ' + num_frames);

  			while ( frames_parsed < num_frames ) {

  				pose_addr = this$1.readU32();
  				frame_dur = this$1.readU16();

  				pose = this$1._blocks[ pose_addr ].data;
  				// debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );
  				clip.push( {
  					pose: pose,
  					duration: frame_dur
  				} );

  				frames_parsed ++;

  			}

  			if ( clip.length === 0 ) {

  				// debug("Could not this SkeletonClipNode, because no Frames where set.");
  				return;

  			}
  			// Ignore attributes for now
  			this.parseUserAttributes();
  			return clip;

  		},

  		parseVertexAnimationSet: function ( len ) {
  			var this$1 = this;


  			var poseBlockAdress,
  				name = this.readUTF(),
  				num_frames = this.readU16(),
  				props = this.parseProperties( { 1: UINT16 } ),
  				frames_parsed = 0,
  				skeletonFrames = [];

  			while ( frames_parsed < num_frames ) {

  				poseBlockAdress = this$1.readU32();
  				skeletonFrames.push( this$1._blocks[ poseBlockAdress ].data );
  				frames_parsed ++;

  			}

  			this.parseUserAttributes();
  			return skeletonFrames;

  		},

  		parseAnimatorSet: function ( len ) {
  			var this$1 = this;

  			var animSetBlockAdress; //:int

  			var targetAnimationSet; //:AnimationSetBase;
  			var name = this.readUTF();
  			var type = this.readU16();

  			var props = this.parseProperties( { 1: BADDR } );

  			animSetBlockAdress = this.readU32();
  			var targetMeshLength = this.readU16();

  			var meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;

  			for ( var i = 0; i < targetMeshLength; i ++ )
  				{ meshAdresses.push( this$1.readU32() ); }

  			var activeState = this.readU16();
  			var autoplay = Boolean( this.readU8() );
  			this.parseUserAttributes();
  			this.parseUserAttributes();
  			var targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;

  			for ( i = 0; i < meshAdresses.length; i ++ ) {

  				//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);
  				//      if (returnedArray[0])
  				targetMeshes.push( this$1._blocks[ meshAdresses[ i ] ].data );

  			}

  			targetAnimationSet = this._blocks[ animSetBlockAdress ].data;
  			var thisAnimator;

  			if ( type == 1 ) {
  				thisAnimator = {
  					animationSet: targetAnimationSet,
  					skeleton: this._blocks[ props.get( 1, 0 ) ].data
  				};

  			}
  			for ( i = 0; i < targetMeshes.length; i ++ ) {

  				targetMeshes[ i ].animator = thisAnimator;

  			}
  			// debug("Parsed a Animator: Name = " + name);

  			return thisAnimator;

  		},

  		parseMeshData: function ( len ) {
  			var this$1 = this;


  			var name = this.readUTF(),
  				num_subs = this.readU16(),
  				geom,
  				subs_parsed = 0,
  				buffer,
  				geometries = [];

  			// Ignore for now
  			this.parseProperties( { 1: this._geoNrType, 2: this._geoNrType } );

  			// Loop through sub meshes
  			while ( subs_parsed < num_subs ) {

  				var sm_len, sm_end, attrib;

  				geom = new BufferGeometry();
  				geom.name = name;
  				geometries.push( geom );
  				sm_len = this$1.readU32();
  				sm_end = this$1._ptr + sm_len;
  				// Ignore for now
  				this$1.parseProperties( { 1: this$1._geoNrType, 2: this$1._geoNrType } );

  				// Loop through data streams
  				while ( this._ptr < sm_end ) {

  					var idx = 0,
  						str_type = this$1.readU8(),
  						str_ftype = this$1.readU8(),
  						str_len = this$1.readU32(),
  						str_end = str_len + this$1._ptr;

  					if ( str_type === 1 ) {

  						// VERTICES

  						buffer = new Float32Array( ( str_len / 12 ) * 3 );
  						attrib = new BufferAttribute( buffer, 3 );

  						geom.addAttribute( 'position', attrib );
  						idx = 0;

  						while ( this._ptr < str_end ) {

  							buffer[ idx ] = - this$1.readF32();
  							buffer[ idx + 1 ] = this$1.readF32();
  							buffer[ idx + 2 ] = this$1.readF32();
  							idx += 3;

  						}

  					} else if ( str_type === 2 ) {

  						// INDICES

  						buffer = new Uint16Array( str_len / 2 );
  						attrib = new BufferAttribute( buffer, 1 );
  						geom.setIndex( attrib );

  						idx = 0;

  						while ( this._ptr < str_end ) {

  							buffer[ idx + 1 ] = this$1.readU16();
  							buffer[ idx ] = this$1.readU16();
  							buffer[ idx + 2 ] = this$1.readU16();
  							idx += 3;

  						}

  					} else if ( str_type === 3 ) {

  						// UVS

  						buffer = new Float32Array( ( str_len / 8 ) * 2 );
  						attrib = new BufferAttribute( buffer, 2 );

  						geom.addAttribute( 'uv', attrib );
  						idx = 0;

  						while ( this._ptr < str_end ) {

  							buffer[ idx ] = this$1.readF32();
  							buffer[ idx + 1 ] = 1.0 - this$1.readF32();
  							idx += 2;

  						}

  					} else if ( str_type === 4 ) {

  						// NORMALS

  						buffer = new Float32Array( ( str_len / 12 ) * 3 );
  						attrib = new BufferAttribute( buffer, 3 );
  						geom.addAttribute( 'normal', attrib );
  						idx = 0;

  						while ( this._ptr < str_end ) {

  							buffer[ idx ] = - this$1.readF32();
  							buffer[ idx + 1 ] = this$1.readF32();
  							buffer[ idx + 2 ] = this$1.readF32();
  							idx += 3;

  						}

  					} else {

  						this$1._ptr = str_end;

  					}

  				}

  				this$1.parseUserAttributes();

  				geom.computeBoundingSphere();
  				subs_parsed ++;

  			}

  			//geom.computeFaceNormals();

  			this.parseUserAttributes();
  			//finalizeAsset(geom, name);

  			return geometries;

  		},

  		parseMeshPoseAnimation: function ( len, poseOnly ) {
  			var this$1 = this;


  			var num_frames = 1,
  				num_submeshes,
  				frames_parsed,
  				subMeshParsed,
  				frame_dur,
  				str_len,
  				str_end,
  				geom,
  				idx = 0,
  				clip = {},
  				num_Streams,
  				streamsParsed,
  				streamtypes = [],

  				props,
  				name = this.readUTF(),
  				geoAdress = this.readU32();

  			var mesh = this.getBlock( geoAdress );

  			if ( mesh === null ) {

  				console.log( "parseMeshPoseAnimation target mesh not found at:", geoAdress );
  				return;

  			}

  			geom = mesh.geometry;
  			geom.morphTargets = [];

  			if ( ! poseOnly )
  				{ num_frames = this.readU16(); }

  			num_submeshes = this.readU16();
  			num_Streams = this.readU16();

  			// debug("VA num_frames : ", num_frames );
  			// debug("VA num_submeshes : ", num_submeshes );
  			// debug("VA numstreams : ", num_Streams );

  			streamsParsed = 0;
  			while ( streamsParsed < num_Streams ) {

  				streamtypes.push( this$1.readU16() );
  				streamsParsed ++;

  			}
  			props = this.parseProperties( { 1: BOOL, 2: BOOL } );

  			clip.looping = props.get( 1, true );
  			clip.stitchFinalFrame = props.get( 2, false );

  			frames_parsed = 0;

  			while ( frames_parsed < num_frames ) {

  				frame_dur = this$1.readU16();
  				subMeshParsed = 0;

  				while ( subMeshParsed < num_submeshes ) {

  					streamsParsed = 0;
  					str_len = this$1.readU32();
  					str_end = this$1._ptr + str_len;

  					while ( streamsParsed < num_Streams ) {

  						if ( streamtypes[ streamsParsed ] === 1 ) {

  							//geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );
  							var buffer = new Float32Array( str_len / 4 );
  							geom.morphTargets.push( {
  								array: buffer
  							} );

  							//buffer = geom.attributes['morphTarget'+frames_parsed].array
  							idx = 0;

  							while ( this._ptr < str_end ) {

  								buffer[ idx ] = this$1.readF32();
  								buffer[ idx + 1 ] = this$1.readF32();
  								buffer[ idx + 2 ] = this$1.readF32();
  								idx += 3;

  							}
  							subMeshParsed ++;

  						} else
  							{ this$1._ptr = str_end; }
  						streamsParsed ++;

  					}

  				}
  				frames_parsed ++;

  			}

  			this.parseUserAttributes();

  			return null;

  		},

  		getBlock: function ( id ) {

  			return this._blocks[ id ].data;

  		},

  		parseMatrix4: function () {

  			var mtx = new Matrix4();
  			var e = mtx.elements;

  			e[ 0 ] = this.readF32();
  			e[ 1 ] = this.readF32();
  			e[ 2 ] = this.readF32();
  			e[ 3 ] = 0.0;
  			//e[3] = 0.0;

  			e[ 4 ] = this.readF32();
  			e[ 5 ] = this.readF32();
  			e[ 6 ] = this.readF32();
  			//e[7] = this.readF32();
  			e[ 7 ] = 0.0;

  			e[ 8 ] = this.readF32();
  			e[ 9 ] = this.readF32();
  			e[ 10 ] = this.readF32();
  			//e[11] = this.readF32();
  			e[ 11 ] = 0.0;

  			e[ 12 ] = - this.readF32();
  			e[ 13 ] = this.readF32();
  			e[ 14 ] = this.readF32();
  			//e[15] = this.readF32();
  			e[ 15 ] = 1.0;
  			return mtx;

  		},

  		parseProperties: function ( expected ) {
  			var this$1 = this;


  			var list_len = this.readU32();
  			var list_end = this._ptr + list_len;

  			var props = new AWDProperties();

  			if ( expected ) {

  				while ( this._ptr < list_end ) {

  					var key = this$1.readU16();
  					var len = this$1.readU32();
  					var type;

  					if ( expected.hasOwnProperty( key ) ) {

  						type = expected[ key ];
  						props.set( key, this$1.parseAttrValue( type, len ) );

  					} else {

  						this$1._ptr += len;

  					}

  				}

  			}

  			return props;

  		},

  		parseUserAttributes: function () {

  			// skip for now
  			this._ptr = this.readU32() + this._ptr;
  			return null;

  		},

  		parseAttrValue: function ( type, len ) {
  			var this$1 = this;


  			var elem_len;
  			var read_func;

  			switch ( type ) {

  				case AWD_FIELD_INT8:
  					elem_len = 1;
  					read_func = this.readI8;
  					break;

  				case AWD_FIELD_INT16:
  					elem_len = 2;
  					read_func = this.readI16;
  					break;

  				case AWD_FIELD_INT32:
  					elem_len = 4;
  					read_func = this.readI32;
  					break;

  				case AWD_FIELD_BOOL:
  				case AWD_FIELD_UINT8:
  					elem_len = 1;
  					read_func = this.readU8;
  					break;

  				case AWD_FIELD_UINT16:
  					elem_len = 2;
  					read_func = this.readU16;
  					break;

  				case AWD_FIELD_UINT32:
  				case AWD_FIELD_BADDR:
  					elem_len = 4;
  					read_func = this.readU32;
  					break;

  				case AWD_FIELD_FLOAT32:
  					elem_len = 4;
  					read_func = this.readF32;
  					break;

  				case AWD_FIELD_FLOAT64:
  					elem_len = 8;
  					read_func = this.readF64;
  					break;

  				case AWD_FIELD_VECTOR2x1:
  				case AWD_FIELD_VECTOR3x1:
  				case AWD_FIELD_VECTOR4x1:
  				case AWD_FIELD_MTX3x2:
  				case AWD_FIELD_MTX3x3:
  				case AWD_FIELD_MTX4x3:
  				case AWD_FIELD_MTX4x4:
  					elem_len = 8;
  					read_func = this.readF64;
  					break;

  			}

  			if ( elem_len < len ) {

  				var list;
  				var num_read;
  				var num_elems;

  				list = [];
  				num_read = 0;
  				num_elems = len / elem_len;

  				while ( num_read < num_elems ) {

  					list.push( read_func.call( this$1 ) );
  					num_read ++;

  				}

  				return list;

  			} else {

  				return read_func.call( this );

  			}

  		},

  		readU8: function () {

  			return this._data.getUint8( this._ptr ++ );

  		},
  		readI8: function () {

  			return this._data.getInt8( this._ptr ++ );

  		},
  		readU16: function () {

  			var a = this._data.getUint16( this._ptr, littleEndian );
  			this._ptr += 2;
  			return a;

  		},
  		readI16: function () {

  			var a = this._data.getInt16( this._ptr, littleEndian );
  			this._ptr += 2;
  			return a;

  		},
  		readU32: function () {

  			var a = this._data.getUint32( this._ptr, littleEndian );
  			this._ptr += 4;
  			return a;

  		},
  		readI32: function () {

  			var a = this._data.getInt32( this._ptr, littleEndian );
  			this._ptr += 4;
  			return a;

  		},
  		readF32: function () {

  			var a = this._data.getFloat32( this._ptr, littleEndian );
  			this._ptr += 4;
  			return a;

  		},
  		readF64: function () {

  			var a = this._data.getFloat64( this._ptr, littleEndian );
  			this._ptr += 8;
  			return a;

  		},
  		readUTF: function () {

  			var len = this.readU16();
  			return this.readUTFBytes( len );

  		},
  		readUTFBytes: function ( len ) {
  			var this$1 = this;


  			// TODO(user): Use native implementations if/when available
  			var out = [], c = 0;

  			while ( out.length < len ) {

  				var c1 = this$1._data.getUint8( this$1._ptr ++, littleEndian );
  				if ( c1 < 128 ) {

  					out[ c ++ ] = String.fromCharCode( c1 );

  				} else if ( c1 > 191 && c1 < 224 ) {

  					var c2 = this$1._data.getUint8( this$1._ptr ++, littleEndian );
  					out[ c ++ ] = String.fromCharCode( ( c1 & 31 ) << 6 | c2 & 63 );

  				} else {

  					var c2 = this$1._data.getUint8( this$1._ptr ++, littleEndian );
  					var c3 = this$1._data.getUint8( this$1._ptr ++, littleEndian );
  					out[ c ++ ] = String.fromCharCode( ( c1 & 15 ) << 12 | ( c2 & 63 ) << 6 | c3 & 63 );

  				}

  			}
  			return out.join( '' );

  		}

  	};

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Light( color, intensity ) {

  	Object3D.call( this );

  	this.type = 'Light';

  	this.color = new Color( color );
  	this.intensity = intensity !== undefined ? intensity : 1;

  	this.receiveShadow = undefined;

  }

  Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Light,

  	isLight: true,

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }

  		if ( this.distance !== undefined ) { data.object.distance = this.distance; }
  		if ( this.angle !== undefined ) { data.object.angle = this.angle; }
  		if ( this.decay !== undefined ) { data.object.decay = this.decay; }
  		if ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }

  		if ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }

  		return data;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LightShadow( camera ) {

  	this.camera = camera;

  	this.bias = 0;
  	this.radius = 1;

  	this.mapSize = new Vector2( 512, 512 );

  	this.map = null;
  	this.matrix = new Matrix4();

  }

  Object.assign( LightShadow.prototype, {

  	copy: function ( source ) {

  		this.camera = source.camera.clone();

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	toJSON: function () {

  		var object = {};

  		if ( this.bias !== 0 ) { object.bias = this.bias; }
  		if ( this.radius !== 1 ) { object.radius = this.radius; }
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PointLight( color, intensity, distance, decay ) {

  	Light.call( this, color, intensity );

  	this.type = 'PointLight';

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  			return this.intensity * 4 * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  			this.intensity = power / ( 4 * Math.PI );

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  }

  PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: PointLight,

  	isPointLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DirectionalLightShadow( ) {

  	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  }

  DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  	constructor: DirectionalLightShadow

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DirectionalLight( color, intensity ) {

  	Light.call( this, color, intensity );

  	this.type = 'DirectionalLight';

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D();

  	this.shadow = new DirectionalLightShadow();

  }

  DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: DirectionalLight,

  	isDirectionalLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpotLightShadow() {

  	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  }

  SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  	constructor: SpotLightShadow,

  	isSpotLightShadow: true,

  	update: function ( light ) {

  		var camera = this.camera;

  		var fov = _Math.RAD2DEG * 2 * light.angle;
  		var aspect = this.mapSize.width / this.mapSize.height;
  		var far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

  	Light.call( this, color, intensity );

  	this.type = 'SpotLight';

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D();

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  			return this.intensity * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  			this.intensity = power / Math.PI;

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new SpotLightShadow();

  }

  SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: SpotLight,

  	isSpotLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function HemisphereLight( skyColor, groundColor, intensity ) {

  	Light.call( this, skyColor, intensity );

  	this.type = 'HemisphereLight';

  	this.castShadow = undefined;

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.groundColor = new Color( groundColor );

  }

  HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: HemisphereLight,

  	isHemisphereLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BabylonLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  BabylonLoader.prototype = {

  	constructor: BabylonLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( json ) {

  		function parseMaterials( json ) {

  			var materials = {};

  			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

  				var data = json.materials[ i ];

  				var material = new MeshPhongMaterial();
  				material.name = data.name;
  				material.color.fromArray( data.diffuse );
  				material.emissive.fromArray( data.emissive );
  				material.specular.fromArray( data.specular );
  				material.shininess = data.specularPower;
  				material.opacity = data.alpha;

  				materials[ data.id ] = material;

  			}

  			if ( json.multiMaterials ) {

  				for ( var i = 0, l = json.multiMaterials.length; i < l; i ++ ) {

  					var data = json.multiMaterials[ i ];

  					console.warn( 'BabylonLoader: Multi materials not yet supported.' );

  					materials[ data.id ] = new MeshPhongMaterial();

  				}

  			}

  			return materials;

  		}

  		function parseGeometry( json ) {

  			var geometry = new BufferGeometry();

  			var indices = json.indices;
  			var positions = json.positions;
  			var normals = json.normals;
  			var uvs = json.uvs;

  			// indices

  			geometry.setIndex( indices );

  			// positions

  			for ( var j = 2, jl = positions.length; j < jl; j += 3 ) {

  				positions[ j ] = - positions[ j ];

  			}

  			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  			// normals

  			if ( normals ) {

  				for ( var j = 2, jl = normals.length; j < jl; j += 3 ) {

  					normals[ j ] = - normals[ j ];

  				}

  				geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  			}

  			// uvs

  			if ( uvs ) {

  				geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  			}

  			// offsets

  			var subMeshes = json.subMeshes;

  			if ( subMeshes ) {

  				for ( var j = 0, jl = subMeshes.length; j < jl; j ++ ) {

  					var subMesh = subMeshes[ j ];

  					geometry.addGroup( subMesh.indexStart, subMesh.indexCount );

  				}

  			}

  			return geometry;

  		}

  		function parseObjects( json, materials ) {

  			var objects = {};
  			var scene = new Scene();

  			var cameras = json.cameras;

  			for ( var i = 0, l = cameras.length; i < l; i ++ ) {

  				var data = cameras[ i ];

  				var camera = new PerspectiveCamera( ( data.fov / Math.PI ) * 180, 1.33, data.minZ, data.maxZ );

  				camera.name = data.name;
  				camera.position.fromArray( data.position );
  				if ( data.rotation ) { camera.rotation.fromArray( data.rotation ); }

  				objects[ data.id ] = camera;

  			}

  			var lights = json.lights;

  			for ( var i = 0, l = lights.length; i < l; i ++ ) {

  				var data = lights[ i ];

  				var light;

  				switch ( data.type ) {

  					case 0:
  						light = new PointLight();
  						break;

  					case 1:
  						light = new DirectionalLight();
  						break;

  					case 2:
  						light = new SpotLight();
  						break;

  					case 3:
  						light = new HemisphereLight();
  						break;

  				}

  				light.name = data.name;
  				if ( data.position ) { light.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] ); }
  				light.color.fromArray( data.diffuse );
  				if ( data.groundColor ) { light.groundColor.fromArray( data.groundColor ); }
  				if ( data.intensity ) { light.intensity = data.intensity; }

  				objects[ data.id ] = light;

  				scene.add( light );

  			}

  			var meshes = json.meshes;

  			for ( var i = 0, l = meshes.length; i < l; i ++ ) {

  				var data = meshes[ i ];

  				var object;

  				if ( data.indices ) {

  					var geometry = parseGeometry( data );

  					object = new Mesh( geometry, materials[ data.materialId ] );

  				} else {

  					object = new Group();

  				}

  				object.name = data.name;
  				object.position.set( data.position[ 0 ], data.position[ 1 ], - data.position[ 2 ] );
  				object.rotation.fromArray( data.rotation );
  				if ( data.rotationQuaternion ) { object.quaternion.fromArray( data.rotationQuaternion ); }
  				object.scale.fromArray( data.scaling );
  				// object.visible = data.isVisible;

  				if ( data.parentId ) {

  					objects[ data.parentId ].add( object );

  				} else {

  					scene.add( object );

  				}

  				objects[ data.id ] = object;

  			}

  			return scene;

  		}

  		var materials = parseMaterials( json );
  		var scene = parseObjects( json, materials );

  		return scene;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BVHLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	this.animateBonePositions = true;
  	this.animateBoneRotations = true;

  };

  BVHLoader.prototype = {

  	constructor: BVHLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( text ) {
  		function readBvh( lines ) {

  			// read model structure

  			if ( nextLine( lines ) !== 'HIERARCHY' ) {

  				console.error( 'BVHLoader: HIERARCHY expected.' );

  			}

  			var list = []; // collects flat array of all bones
  			var root = readNode( lines, nextLine( lines ), list );

  			// read motion data

  			if ( nextLine( lines ) !== 'MOTION' ) {

  				console.error( 'BVHLoader: MOTION expected.' );

  			}

  			// number of frames

  			var tokens = nextLine( lines ).split( /[\s]+/ );
  			var numFrames = parseInt( tokens[ 1 ] );

  			if ( isNaN( numFrames ) ) {

  				console.error( 'BVHLoader: Failed to read number of frames.' );

  			}

  			// frame time

  			tokens = nextLine( lines ).split( /[\s]+/ );
  			var frameTime = parseFloat( tokens[ 2 ] );

  			if ( isNaN( frameTime ) ) {

  				console.error( 'BVHLoader: Failed to read frame time.' );

  			}

  			// read frame data line by line

  			for ( var i = 0; i < numFrames; i ++ ) {

  				tokens = nextLine( lines ).split( /[\s]+/ );
  				readFrameData( tokens, i * frameTime, root );

  			}

  			return list;

  		}
  		function readFrameData( data, frameTime, bone ) {

  			// end sites have no motion data

  			if ( bone.type === 'ENDSITE' ) { return; }

  			// add keyframe

  			var keyframe = {
  				time: frameTime,
  				position: new Vector3(),
  				rotation: new Quaternion()
  			};

  			bone.frames.push( keyframe );

  			var quat = new Quaternion();

  			var vx = new Vector3( 1, 0, 0 );
  			var vy = new Vector3( 0, 1, 0 );
  			var vz = new Vector3( 0, 0, 1 );

  			// parse values for each channel in node

  			for ( var i = 0; i < bone.channels.length; i ++ ) {

  				switch ( bone.channels[ i ] ) {

  					case 'Xposition':
  						keyframe.position.x = parseFloat( data.shift().trim() );
  						break;
  					case 'Yposition':
  						keyframe.position.y = parseFloat( data.shift().trim() );
  						break;
  					case 'Zposition':
  						keyframe.position.z = parseFloat( data.shift().trim() );
  						break;
  					case 'Xrotation':
  						quat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					case 'Yrotation':
  						quat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					case 'Zrotation':
  						quat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );
  						keyframe.rotation.multiply( quat );
  						break;
  					default:
  						console.warn( 'BVHLoader: Invalid channel type.' );

  				}

  			}

  			// parse child nodes

  			for ( var i = 0; i < bone.children.length; i ++ ) {

  				readFrameData( data, frameTime, bone.children[ i ] );

  			}

  		}
  		function readNode( lines, firstline, list ) {

  			var node = { name: '', type: '', frames: [] };
  			list.push( node );

  			// parse node type and name

  			var tokens = firstline.split( /[\s]+/ );

  			if ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {

  				node.type = 'ENDSITE';
  				node.name = 'ENDSITE'; // bvh end sites have no name

  			} else {

  				node.name = tokens[ 1 ];
  				node.type = tokens[ 0 ].toUpperCase();

  			}

  			if ( nextLine( lines ) !== '{' ) {

  				console.error( 'BVHLoader: Expected opening { after type & name' );

  			}

  			// parse OFFSET

  			tokens = nextLine( lines ).split( /[\s]+/ );

  			if ( tokens[ 0 ] !== 'OFFSET' ) {

  				console.error( 'BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );

  			}

  			if ( tokens.length !== 4 ) {

  				console.error( 'BVHLoader: Invalid number of values for OFFSET.' );

  			}

  			var offset = new Vector3(
  				parseFloat( tokens[ 1 ] ),
  				parseFloat( tokens[ 2 ] ),
  				parseFloat( tokens[ 3 ] )
  			);

  			if ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {

  				console.error( 'BVHLoader: Invalid values of OFFSET.' );

  			}

  			node.offset = offset;

  			// parse CHANNELS definitions

  			if ( node.type !== 'ENDSITE' ) {

  				tokens = nextLine( lines ).split( /[\s]+/ );

  				if ( tokens[ 0 ] !== 'CHANNELS' ) {

  					console.error( 'BVHLoader: Expected CHANNELS definition.' );

  				}

  				var numChannels = parseInt( tokens[ 1 ] );
  				node.channels = tokens.splice( 2, numChannels );
  				node.children = [];

  			}

  			// read children

  			while ( true ) {

  				var line = nextLine( lines );

  				if ( line === '}' ) {

  					return node;

  				} else {

  					node.children.push( readNode( lines, line, list ) );

  				}

  			}

  		}
  		function toTHREEBone( source, list ) {

  			var bone = new Bone();
  			list.push( bone );

  			bone.position.add( source.offset );
  			bone.name = source.name;

  			if ( source.type !== 'ENDSITE' ) {

  				for ( var i = 0; i < source.children.length; i ++ ) {

  					bone.add( toTHREEBone( source.children[ i ], list ) );

  				}

  			}

  			return bone;

  		}
  		function toTHREEAnimation( bones ) {

  			var tracks = [];

  			// create a position and quaternion animation track for each node

  			for ( var i = 0; i < bones.length; i ++ ) {

  				var bone = bones[ i ];

  				if ( bone.type === 'ENDSITE' )
  					{ continue; }

  				// track data

  				var times = [];
  				var positions = [];
  				var rotations = [];

  				for ( var j = 0; j < bone.frames.length; j ++ ) {

  					var frame = bone.frames[ j ];

  					times.push( frame.time );

  					// the animation system animates the position property,
  					// so we have to add the joint offset to all values

  					positions.push( frame.position.x + bone.offset.x );
  					positions.push( frame.position.y + bone.offset.y );
  					positions.push( frame.position.z + bone.offset.z );

  					rotations.push( frame.rotation.x );
  					rotations.push( frame.rotation.y );
  					rotations.push( frame.rotation.z );
  					rotations.push( frame.rotation.w );

  				}

  				if ( scope.animateBonePositions ) {

  					tracks.push( new VectorKeyframeTrack( '.bones[' + bone.name + '].position', times, positions ) );

  				}

  				if ( scope.animateBoneRotations ) {

  					tracks.push( new QuaternionKeyframeTrack( '.bones[' + bone.name + '].quaternion', times, rotations ) );

  				}

  			}

  			return new AnimationClip( 'animation', - 1, tracks );

  		}
  		function nextLine( lines ) {

  			var line;
  			// skip empty lines
  			while ( ( line = lines.shift().trim() ).length === 0 ) { }
  			return line;

  		}

  		var scope = this;

  		var lines = text.split( /[\r\n]+/g );

  		var bones = readBvh( lines );

  		var threeBones = [];
  		toTHREEBone( bones[ 0 ], threeBones );

  		var threeClip = toTHREEAnimation( bones );

  		return {
  			skeleton: new Skeleton( threeBones ),
  			clip: threeClip
  		};

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AmbientLight( color, intensity ) {

  	Light.call( this, color, intensity );

  	this.type = 'AmbientLight';

  	this.castShadow = undefined;

  }

  AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: AmbientLight,

  	isAmbientLight: true

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineSegments( geometry, material ) {

  	Line.call( this, geometry, material );

  	this.type = 'LineSegments';

  }

  LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

  	constructor: LineSegments,

  	isLineSegments: true,

  	computeLineDistances: ( function () {

  		var start = new Vector3();
  		var end = new Vector3();

  		return function computeLineDistances() {

  			var geometry = this.geometry;

  			if ( geometry.isBufferGeometry ) {

  				// we assume non-indexed geometry

  				if ( geometry.index === null ) {

  					var positionAttribute = geometry.attributes.position;
  					var lineDistances = [];

  					for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

  						start.fromBufferAttribute( positionAttribute, i );
  						end.fromBufferAttribute( positionAttribute, i + 1 );

  						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

  					}

  					geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  				} else {

  					console.warn( 'LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var lineDistances = geometry.lineDistances;

  				for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

  					start.copy( vertices[ i ] );
  					end.copy( vertices[ i + 1 ] );

  					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  					lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

  				}

  			}

  			return this;

  		};

  	}() )

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TGALoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  TGALoader.prototype = {

  	constructor: TGALoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texture = new Texture();

  		var loader = new FileLoader( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setPath( this.path );

  		loader.load( url, function ( buffer ) {

  			texture.image = scope.parse( buffer );
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	},

  	parse: function ( buffer ) {

  		// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

  		function tgaCheckHeader( header ) {

  			switch ( header.image_type ) {

  				// check indexed type

  				case TGA_TYPE_INDEXED:
  				case TGA_TYPE_RLE_INDEXED:
  					if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

  						console.error( 'TGALoader: Invalid type colormap data for indexed type.' );

  					}
  					break;

  				// check colormap type

  				case TGA_TYPE_RGB:
  				case TGA_TYPE_GREY:
  				case TGA_TYPE_RLE_RGB:
  				case TGA_TYPE_RLE_GREY:
  					if ( header.colormap_type ) {

  						console.error( 'TGALoader: Invalid type colormap data for colormap type.' );

  					}
  					break;

  				// What the need of a file without data ?

  				case TGA_TYPE_NO_DATA:
  					console.error( 'TGALoader: No data.' );

  				// Invalid type ?

  				default:
  					console.error( 'TGALoader: Invalid type "%s".', header.image_type );

  			}

  			// check image width and height

  			if ( header.width <= 0 || header.height <= 0 ) {

  				console.error( 'TGALoader: Invalid image size.' );

  			}

  			// check image pixel size

  			if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&
  				header.pixel_size !== 24 && header.pixel_size !== 32 ) {

  				console.error( 'TGALoader: Invalid pixel size "%s".', header.pixel_size );

  			}

  		}

  		// parse tga image buffer

  		function tgaParse( use_rle, use_pal, header, offset, data ) {

  			var pixel_data,
  				pixel_size,
  				pixel_total,
  				palettes;

  			pixel_size = header.pixel_size >> 3;
  			pixel_total = header.width * header.height * pixel_size;

  			 // read palettes

  			 if ( use_pal ) {

  				 palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

  			 }

  			 // read RLE

  			 if ( use_rle ) {

  				 pixel_data = new Uint8Array( pixel_total );

  				var c, count, i;
  				var shift = 0;
  				var pixels = new Uint8Array( pixel_size );

  				while ( shift < pixel_total ) {

  					c = data[ offset ++ ];
  					count = ( c & 0x7f ) + 1;

  					// RLE pixels

  					if ( c & 0x80 ) {

  						// bind pixel tmp array

  						for ( i = 0; i < pixel_size; ++ i ) {

  							pixels[ i ] = data[ offset ++ ];

  						}

  						// copy pixel array

  						for ( i = 0; i < count; ++ i ) {

  							pixel_data.set( pixels, shift + i * pixel_size );

  						}

  						shift += pixel_size * count;

  					} else {

  						// raw pixels

  						count *= pixel_size;
  						for ( i = 0; i < count; ++ i ) {

  							pixel_data[ shift + i ] = data[ offset ++ ];

  						}
  						shift += count;

  					}

  				}

  			 } else {

  				// raw pixels

  				pixel_data = data.subarray(
  					 offset, offset += ( use_pal ? header.width * header.height : pixel_total )
  				);

  			 }

  			 return {
  				pixel_data: pixel_data,
  				palettes: palettes
  			 };

  		}

  		function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

  			var colormap = palettes;
  			var color, i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

  					color = image[ i ];
  					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
  					imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];
  					imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];
  					imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];

  				}

  			}

  			return imageData;

  		}

  		function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

  			var color, i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

  					color = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?
  					imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;
  					imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;
  					imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;
  					imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;

  				}

  			}

  			return imageData;

  		}

  		function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

  			var i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

  					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
  					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
  					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
  					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];

  				}

  			}

  			return imageData;

  		}

  		function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

  			var i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

  					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
  					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
  					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];
  					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];

  				}

  			}

  			return imageData;

  		}

  		function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

  			var color, i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

  					color = image[ i ];
  					imageData[ ( x + width * y ) * 4 + 0 ] = color;
  					imageData[ ( x + width * y ) * 4 + 1 ] = color;
  					imageData[ ( x + width * y ) * 4 + 2 ] = color;
  					imageData[ ( x + width * y ) * 4 + 3 ] = 255;

  				}

  			}

  			return imageData;

  		}

  		function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

  			var i = 0, x, y;
  			var width = header.width;

  			for ( y = y_start; y !== y_end; y += y_step ) {

  				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

  					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];
  					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];
  					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
  					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];

  				}

  			}

  			return imageData;

  		}

  		function getTgaRGBA( data, width, height, image, palette ) {

  			var x_start,
  				y_start,
  				x_step,
  				y_step,
  				x_end,
  				y_end;

  			switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {

  				default:
  				case TGA_ORIGIN_UL:
  					x_start = 0;
  					x_step = 1;
  					x_end = width;
  					y_start = 0;
  					y_step = 1;
  					y_end = height;
  					break;

  				case TGA_ORIGIN_BL:
  					x_start = 0;
  					x_step = 1;
  					x_end = width;
  					y_start = height - 1;
  					y_step = - 1;
  					y_end = - 1;
  					break;

  				case TGA_ORIGIN_UR:
  					x_start = width - 1;
  					x_step = - 1;
  					x_end = - 1;
  					y_start = 0;
  					y_step = 1;
  					y_end = height;
  					break;

  				case TGA_ORIGIN_BR:
  					x_start = width - 1;
  					x_step = - 1;
  					x_end = - 1;
  					y_start = height - 1;
  					y_step = - 1;
  					y_end = - 1;
  					break;

  			}

  			if ( use_grey ) {

  				switch ( header.pixel_size ) {

  					case 8:
  						tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
  						break;

  					case 16:
  						tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
  						break;

  					default:
  						console.error( 'TGALoader: Format not supported.' );
  						break;

  				}

  			} else {

  				switch ( header.pixel_size ) {

  					case 8:
  						tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
  						break;

  					case 16:
  						tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
  						break;

  					case 24:
  						tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
  						break;

  					case 32:
  						tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
  						break;

  					default:
  						console.error( 'TGALoader: Format not supported.' );
  						break;

  				}

  			}

  			// Load image data according to specific method
  			// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
  			// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
  			return data;

  		}

  		// TGA constants

  		var TGA_TYPE_NO_DATA = 0,
  			TGA_TYPE_INDEXED = 1,
  			TGA_TYPE_RGB = 2,
  			TGA_TYPE_GREY = 3,
  			TGA_TYPE_RLE_INDEXED = 9,
  			TGA_TYPE_RLE_RGB = 10,
  			TGA_TYPE_RLE_GREY = 11,

  			TGA_ORIGIN_MASK = 0x30,
  			TGA_ORIGIN_SHIFT = 0x04,
  			TGA_ORIGIN_BL = 0x00,
  			TGA_ORIGIN_BR = 0x01,
  			TGA_ORIGIN_UL = 0x02,
  			TGA_ORIGIN_UR = 0x03;

  		if ( buffer.length < 19 ) { console.error( 'TGALoader: Not enough data to contain header.' ); }

  		var content = new Uint8Array( buffer ),
  			offset = 0,
  			header = {
  				id_length: content[ offset ++ ],
  				colormap_type: content[ offset ++ ],
  				image_type: content[ offset ++ ],
  				colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,
  				colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,
  				colormap_size: content[ offset ++ ],
  				origin: [
  					content[ offset ++ ] | content[ offset ++ ] << 8,
  					content[ offset ++ ] | content[ offset ++ ] << 8
  				],
  				width: content[ offset ++ ] | content[ offset ++ ] << 8,
  				height: content[ offset ++ ] | content[ offset ++ ] << 8,
  				pixel_size: content[ offset ++ ],
  				flags: content[ offset ++ ]
  			};

  			// check tga if it is valid format

  		tgaCheckHeader( header );

  		if ( header.id_length + offset > buffer.length ) {

  			console.error( 'TGALoader: No data.' );

  		}

  		// skip the needn't data

  		offset += header.id_length;

  		// get targa information about RLE compression and palette

  		var use_rle = false,
  			use_pal = false,
  			use_grey = false;

  		switch ( header.image_type ) {

  			case TGA_TYPE_RLE_INDEXED:
  				use_rle = true;
  				use_pal = true;
  				break;

  			case TGA_TYPE_INDEXED:
  				use_pal = true;
  				break;

  			case TGA_TYPE_RLE_RGB:
  				use_rle = true;
  				break;

  			case TGA_TYPE_RGB:
  				break;

  			case TGA_TYPE_RLE_GREY:
  				use_rle = true;
  				use_grey = true;
  				break;

  			case TGA_TYPE_GREY:
  				use_grey = true;
  				break;

  		}

  		//

  		var useOffscreen = typeof OffscreenCanvas !== 'undefined';

  		var canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );
  		canvas.width = header.width;
  		canvas.height = header.height;

  		var context = canvas.getContext( '2d' );
  		var imageData = context.createImageData( header.width, header.height );

  		var result = tgaParse( use_rle, use_pal, header, offset, content );
  		var rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );

  		context.putImageData( imageData, 0, 0 );

  		return useOffscreen ? canvas.transferToImageBitmap() : canvas;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColladaLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  ColladaLoader.prototype = {

  	constructor: ColladaLoader,

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( scope.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text, path ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResourcePath: function ( value ) {

  		this.resourcePath = value;
  		return this;

  	},

  	options: {

  		set convertUpAxis( value ) {

  			console.warn( 'ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );

  		}

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	parse: function ( text, path ) {

  		function getElementsByTagName( xml, name ) {

  			// Non recursive xml.getElementsByTagName() ...

  			var array = [];
  			var childNodes = xml.childNodes;

  			for ( var i = 0, l = childNodes.length; i < l; i ++ ) {

  				var child = childNodes[ i ];

  				if ( child.nodeName === name ) {

  					array.push( child );

  				}

  			}

  			return array;

  		}

  		function parseStrings( text ) {

  			if ( text.length === 0 ) { return []; }

  			var parts = text.trim().split( /\s+/ );
  			var array = new Array( parts.length );

  			for ( var i = 0, l = parts.length; i < l; i ++ ) {

  				array[ i ] = parts[ i ];

  			}

  			return array;

  		}

  		function parseFloats( text ) {

  			if ( text.length === 0 ) { return []; }

  			var parts = text.trim().split( /\s+/ );
  			var array = new Array( parts.length );

  			for ( var i = 0, l = parts.length; i < l; i ++ ) {

  				array[ i ] = parseFloat( parts[ i ] );

  			}

  			return array;

  		}

  		function parseInts( text ) {

  			if ( text.length === 0 ) { return []; }

  			var parts = text.trim().split( /\s+/ );
  			var array = new Array( parts.length );

  			for ( var i = 0, l = parts.length; i < l; i ++ ) {

  				array[ i ] = parseInt( parts[ i ] );

  			}

  			return array;

  		}

  		function parseId( text ) {

  			return text.substring( 1 );

  		}

  		function generateId() {

  			return 'three_default_' + ( count ++ );

  		}

  		function isEmpty( object ) {

  			return Object.keys( object ).length === 0;

  		}

  		// asset

  		function parseAsset( xml ) {

  			return {
  				unit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),
  				upAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )
  			};

  		}

  		function parseAssetUnit( xml ) {

  			if ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {

  				return parseFloat( xml.getAttribute( 'meter' ) );

  			} else {

  				return 1; // default 1 meter

  			}

  		}

  		function parseAssetUpAxis( xml ) {

  			return xml !== undefined ? xml.textContent : 'Y_UP';

  		}

  		// library

  		function parseLibrary( xml, libraryName, nodeName, parser ) {

  			var library = getElementsByTagName( xml, libraryName )[ 0 ];

  			if ( library !== undefined ) {

  				var elements = getElementsByTagName( library, nodeName );

  				for ( var i = 0; i < elements.length; i ++ ) {

  					parser( elements[ i ] );

  				}

  			}

  		}

  		function buildLibrary( data, builder ) {

  			for ( var name in data ) {

  				var object = data[ name ];
  				object.build = builder( data[ name ] );

  			}

  		}

  		// get

  		function getBuild( data, builder ) {

  			if ( data.build !== undefined ) { return data.build; }

  			data.build = builder( data );

  			return data.build;

  		}

  		// animation

  		function parseAnimation( xml ) {

  			var data = {
  				sources: {},
  				samplers: {},
  				channels: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				var id;

  				switch ( child.nodeName ) {

  					case 'source':
  						id = child.getAttribute( 'id' );
  						data.sources[ id ] = parseSource( child );
  						break;

  					case 'sampler':
  						id = child.getAttribute( 'id' );
  						data.samplers[ id ] = parseAnimationSampler( child );
  						break;

  					case 'channel':
  						id = child.getAttribute( 'target' );
  						data.channels[ id ] = parseAnimationChannel( child );
  						break;

  					default:
  						console.log( child );

  				}

  			}

  			library.animations[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseAnimationSampler( xml ) {

  			var data = {
  				inputs: {},
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'input':
  						var id = parseId( child.getAttribute( 'source' ) );
  						var semantic = child.getAttribute( 'semantic' );
  						data.inputs[ semantic ] = id;
  						break;

  				}

  			}

  			return data;

  		}

  		function parseAnimationChannel( xml ) {

  			var data = {};

  			var target = xml.getAttribute( 'target' );

  			// parsing SID Addressing Syntax

  			var parts = target.split( '/' );

  			var id = parts.shift();
  			var sid = parts.shift();

  			// check selection syntax

  			var arraySyntax = ( sid.indexOf( '(' ) !== - 1 );
  			var memberSyntax = ( sid.indexOf( '.' ) !== - 1 );

  			if ( memberSyntax ) {

  				//  member selection access

  				parts = sid.split( '.' );
  				sid = parts.shift();
  				data.member = parts.shift();

  			} else if ( arraySyntax ) {

  				// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.

  				var indices = sid.split( '(' );
  				sid = indices.shift();

  				for ( var i = 0; i < indices.length; i ++ ) {

  					indices[ i ] = parseInt( indices[ i ].replace( /\)/, '' ) );

  				}

  				data.indices = indices;

  			}

  			data.id = id;
  			data.sid = sid;

  			data.arraySyntax = arraySyntax;
  			data.memberSyntax = memberSyntax;

  			data.sampler = parseId( xml.getAttribute( 'source' ) );

  			return data;

  		}

  		function buildAnimation( data ) {

  			var tracks = [];

  			var channels = data.channels;
  			var samplers = data.samplers;
  			var sources = data.sources;

  			for ( var target in channels ) {

  				if ( channels.hasOwnProperty( target ) ) {

  					var channel = channels[ target ];
  					var sampler = samplers[ channel.sampler ];

  					var inputId = sampler.inputs.INPUT;
  					var outputId = sampler.inputs.OUTPUT;

  					var inputSource = sources[ inputId ];
  					var outputSource = sources[ outputId ];

  					var animation = buildAnimationChannel( channel, inputSource, outputSource );

  					createKeyframeTracks( animation, tracks );

  				}

  			}

  			return tracks;

  		}

  		function getAnimation( id ) {

  			return getBuild( library.animations[ id ], buildAnimation );

  		}

  		function buildAnimationChannel( channel, inputSource, outputSource ) {

  			var node = library.nodes[ channel.id ];
  			var object3D = getNode( node.id );

  			var transform = node.transforms[ channel.sid ];
  			var defaultMatrix = node.matrix.clone().transpose();

  			var time, stride;
  			var i, il, j, jl;

  			var data = {};

  			// the collada spec allows the animation of data in various ways.
  			// depending on the transform type (matrix, translate, rotate, scale), we execute different logic

  			switch ( transform ) {

  				case 'matrix':

  					for ( i = 0, il = inputSource.array.length; i < il; i ++ ) {

  						time = inputSource.array[ i ];
  						stride = i * outputSource.stride;

  						if ( data[ time ] === undefined ) { data[ time ] = {}; }

  						if ( channel.arraySyntax === true ) {

  							var value = outputSource.array[ stride ];
  							var index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];

  							data[ time ][ index ] = value;

  						} else {

  							for ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {

  								data[ time ][ j ] = outputSource.array[ stride + j ];

  							}

  						}

  					}

  					break;

  				case 'translate':
  					console.warn( 'ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
  					break;

  				case 'rotate':
  					console.warn( 'ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
  					break;

  				case 'scale':
  					console.warn( 'ColladaLoader: Animation transform type "%s" not yet implemented.', transform );
  					break;

  			}

  			var keyframes = prepareAnimationData( data, defaultMatrix );

  			var animation = {
  				name: object3D.uuid,
  				keyframes: keyframes
  			};

  			return animation;

  		}

  		function prepareAnimationData( data, defaultMatrix ) {

  			var keyframes = [];

  			// transfer data into a sortable array

  			for ( var time in data ) {

  				keyframes.push( { time: parseFloat( time ), value: data[ time ] } );

  			}

  			// ensure keyframes are sorted by time

  			keyframes.sort( ascending );

  			// now we clean up all animation data, so we can use them for keyframe tracks

  			for ( var i = 0; i < 16; i ++ ) {

  				transformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );

  			}

  			return keyframes;

  			// array sort function

  			function ascending( a, b ) {

  				return a.time - b.time;

  			}

  		}

  		var position = new Vector3();
  		var scale = new Vector3();
  		var quaternion = new Quaternion();

  		function createKeyframeTracks( animation, tracks ) {

  			var keyframes = animation.keyframes;
  			var name = animation.name;

  			var times = [];
  			var positionData = [];
  			var quaternionData = [];
  			var scaleData = [];

  			for ( var i = 0, l = keyframes.length; i < l; i ++ ) {

  				var keyframe = keyframes[ i ];

  				var time = keyframe.time;
  				var value = keyframe.value;

  				matrix.fromArray( value ).transpose();
  				matrix.decompose( position, quaternion, scale );

  				times.push( time );
  				positionData.push( position.x, position.y, position.z );
  				quaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );
  				scaleData.push( scale.x, scale.y, scale.z );

  			}

  			if ( positionData.length > 0 ) { tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) ); }
  			if ( quaternionData.length > 0 ) { tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) ); }
  			if ( scaleData.length > 0 ) { tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) ); }

  			return tracks;

  		}

  		function transformAnimationData( keyframes, property, defaultValue ) {

  			var keyframe;

  			var empty = true;
  			var i, l;

  			// check, if values of a property are missing in our keyframes

  			for ( i = 0, l = keyframes.length; i < l; i ++ ) {

  				keyframe = keyframes[ i ];

  				if ( keyframe.value[ property ] === undefined ) {

  					keyframe.value[ property ] = null; // mark as missing

  				} else {

  					empty = false;

  				}

  			}

  			if ( empty === true ) {

  				// no values at all, so we set a default value

  				for ( i = 0, l = keyframes.length; i < l; i ++ ) {

  					keyframe = keyframes[ i ];

  					keyframe.value[ property ] = defaultValue;

  				}

  			} else {

  				// filling gaps

  				createMissingKeyframes( keyframes, property );

  			}

  		}

  		function createMissingKeyframes( keyframes, property ) {

  			var prev, next;

  			for ( var i = 0, l = keyframes.length; i < l; i ++ ) {

  				var keyframe = keyframes[ i ];

  				if ( keyframe.value[ property ] === null ) {

  					prev = getPrev( keyframes, i, property );
  					next = getNext( keyframes, i, property );

  					if ( prev === null ) {

  						keyframe.value[ property ] = next.value[ property ];
  						continue;

  					}

  					if ( next === null ) {

  						keyframe.value[ property ] = prev.value[ property ];
  						continue;

  					}

  					interpolate( keyframe, prev, next, property );

  				}

  			}

  		}

  		function getPrev( keyframes, i, property ) {

  			while ( i >= 0 ) {

  				var keyframe = keyframes[ i ];

  				if ( keyframe.value[ property ] !== null ) { return keyframe; }

  				i --;

  			}

  			return null;

  		}

  		function getNext( keyframes, i, property ) {

  			while ( i < keyframes.length ) {

  				var keyframe = keyframes[ i ];

  				if ( keyframe.value[ property ] !== null ) { return keyframe; }

  				i ++;

  			}

  			return null;

  		}

  		function interpolate( key, prev, next, property ) {

  			if ( ( next.time - prev.time ) === 0 ) {

  				key.value[ property ] = prev.value[ property ];
  				return;

  			}

  			key.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];

  		}

  		// animation clips

  		function parseAnimationClip( xml ) {

  			var data = {
  				name: xml.getAttribute( 'id' ) || 'default',
  				start: parseFloat( xml.getAttribute( 'start' ) || 0 ),
  				end: parseFloat( xml.getAttribute( 'end' ) || 0 ),
  				animations: []
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'instance_animation':
  						data.animations.push( parseId( child.getAttribute( 'url' ) ) );
  						break;

  				}

  			}

  			library.clips[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function buildAnimationClip( data ) {

  			var tracks = [];

  			var name = data.name;
  			var duration = ( data.end - data.start ) || - 1;
  			var animations = data.animations;

  			for ( var i = 0, il = animations.length; i < il; i ++ ) {

  				var animationTracks = getAnimation( animations[ i ] );

  				for ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {

  					tracks.push( animationTracks[ j ] );

  				}

  			}

  			return new AnimationClip( name, duration, tracks );

  		}

  		function getAnimationClip( id ) {

  			return getBuild( library.clips[ id ], buildAnimationClip );

  		}

  		// controller

  		function parseController( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'skin':
  						// there is exactly one skin per controller
  						data.id = parseId( child.getAttribute( 'source' ) );
  						data.skin = parseSkin( child );
  						break;

  					case 'morph':
  						data.id = parseId( child.getAttribute( 'source' ) );
  						console.warn( 'ColladaLoader: Morph target animation not supported yet.' );
  						break;

  				}

  			}

  			library.controllers[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseSkin( xml ) {

  			var data = {
  				sources: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'bind_shape_matrix':
  						data.bindShapeMatrix = parseFloats( child.textContent );
  						break;

  					case 'source':
  						var id = child.getAttribute( 'id' );
  						data.sources[ id ] = parseSource( child );
  						break;

  					case 'joints':
  						data.joints = parseJoints( child );
  						break;

  					case 'vertex_weights':
  						data.vertexWeights = parseVertexWeights( child );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseJoints( xml ) {

  			var data = {
  				inputs: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'input':
  						var semantic = child.getAttribute( 'semantic' );
  						var id = parseId( child.getAttribute( 'source' ) );
  						data.inputs[ semantic ] = id;
  						break;

  				}

  			}

  			return data;

  		}

  		function parseVertexWeights( xml ) {

  			var data = {
  				inputs: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'input':
  						var semantic = child.getAttribute( 'semantic' );
  						var id = parseId( child.getAttribute( 'source' ) );
  						var offset = parseInt( child.getAttribute( 'offset' ) );
  						data.inputs[ semantic ] = { id: id, offset: offset };
  						break;

  					case 'vcount':
  						data.vcount = parseInts( child.textContent );
  						break;

  					case 'v':
  						data.v = parseInts( child.textContent );
  						break;

  				}

  			}

  			return data;

  		}

  		function buildController( data ) {

  			var build = {
  				id: data.id
  			};

  			var geometry = library.geometries[ build.id ];

  			if ( data.skin !== undefined ) {

  				build.skin = buildSkin( data.skin );

  				// we enhance the 'sources' property of the corresponding geometry with our skin data

  				geometry.sources.skinIndices = build.skin.indices;
  				geometry.sources.skinWeights = build.skin.weights;

  			}

  			return build;

  		}

  		function buildSkin( data ) {

  			var BONE_LIMIT = 4;

  			var build = {
  				joints: [], // this must be an array to preserve the joint order
  				indices: {
  					array: [],
  					stride: BONE_LIMIT
  				},
  				weights: {
  					array: [],
  					stride: BONE_LIMIT
  				}
  			};

  			var sources = data.sources;
  			var vertexWeights = data.vertexWeights;

  			var vcount = vertexWeights.vcount;
  			var v = vertexWeights.v;
  			var jointOffset = vertexWeights.inputs.JOINT.offset;
  			var weightOffset = vertexWeights.inputs.WEIGHT.offset;

  			var jointSource = data.sources[ data.joints.inputs.JOINT ];
  			var inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];

  			var weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;
  			var stride = 0;

  			var i, j, l;

  			// procces skin data for each vertex

  			for ( i = 0, l = vcount.length; i < l; i ++ ) {

  				var jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex
  				var vertexSkinData = [];

  				for ( j = 0; j < jointCount; j ++ ) {

  					var skinIndex = v[ stride + jointOffset ];
  					var weightId = v[ stride + weightOffset ];
  					var skinWeight = weights[ weightId ];

  					vertexSkinData.push( { index: skinIndex, weight: skinWeight } );

  					stride += 2;

  				}

  				// we sort the joints in descending order based on the weights.
  				// this ensures, we only procced the most important joints of the vertex

  				vertexSkinData.sort( descending );

  				// now we provide for each vertex a set of four index and weight values.
  				// the order of the skin data matches the order of vertices

  				for ( j = 0; j < BONE_LIMIT; j ++ ) {

  					var d = vertexSkinData[ j ];

  					if ( d !== undefined ) {

  						build.indices.array.push( d.index );
  						build.weights.array.push( d.weight );

  					} else {

  						build.indices.array.push( 0 );
  						build.weights.array.push( 0 );

  					}

  				}

  			}

  			// setup bind matrix

  			if ( data.bindShapeMatrix ) {

  				build.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();

  			} else {

  				build.bindMatrix = new Matrix4().identity();

  			}

  			// process bones and inverse bind matrix data

  			for ( i = 0, l = jointSource.array.length; i < l; i ++ ) {

  				var name = jointSource.array[ i ];
  				var boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();

  				build.joints.push( { name: name, boneInverse: boneInverse } );

  			}

  			return build;

  			// array sort function

  			function descending( a, b ) {

  				return b.weight - a.weight;

  			}

  		}

  		function getController( id ) {

  			return getBuild( library.controllers[ id ], buildController );

  		}

  		// image

  		function parseImage( xml ) {

  			var data = {
  				init_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent
  			};

  			library.images[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function buildImage( data ) {

  			if ( data.build !== undefined ) { return data.build; }

  			return data.init_from;

  		}

  		function getImage( id ) {

  			var data = library.images[ id ];

  			if ( data !== undefined ) {

  				return getBuild( data, buildImage );

  			}

  			console.warn( 'ColladaLoader: Couldn\'t find image with ID:', id );

  			return null;

  		}

  		// effect

  		function parseEffect( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'profile_COMMON':
  						data.profile = parseEffectProfileCOMMON( child );
  						break;

  				}

  			}

  			library.effects[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseEffectProfileCOMMON( xml ) {

  			var data = {
  				surfaces: {},
  				samplers: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'newparam':
  						parseEffectNewparam( child, data );
  						break;

  					case 'technique':
  						data.technique = parseEffectTechnique( child );
  						break;

  					case 'extra':
  						data.extra = parseEffectExtra( child );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectNewparam( xml, data ) {

  			var sid = xml.getAttribute( 'sid' );

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'surface':
  						data.surfaces[ sid ] = parseEffectSurface( child );
  						break;

  					case 'sampler2D':
  						data.samplers[ sid ] = parseEffectSampler( child );
  						break;

  				}

  			}

  		}

  		function parseEffectSurface( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'init_from':
  						data.init_from = child.textContent;
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectSampler( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'source':
  						data.source = child.textContent;
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectTechnique( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'constant':
  					case 'lambert':
  					case 'blinn':
  					case 'phong':
  						data.type = child.nodeName;
  						data.parameters = parseEffectParameters( child );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectParameters( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'emission':
  					case 'diffuse':
  					case 'specular':
  					case 'bump':
  					case 'ambient':
  					case 'shininess':
  					case 'transparency':
  						data[ child.nodeName ] = parseEffectParameter( child );
  						break;
  					case 'transparent':
  						data[ child.nodeName ] = {
  							opaque: child.getAttribute( 'opaque' ),
  							data: parseEffectParameter( child )
  						};
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectParameter( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'color':
  						data[ child.nodeName ] = parseFloats( child.textContent );
  						break;

  					case 'float':
  						data[ child.nodeName ] = parseFloat( child.textContent );
  						break;

  					case 'texture':
  						data[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectParameterTexture( xml ) {

  			var data = {
  				technique: {}
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'extra':
  						parseEffectParameterTextureExtra( child, data );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectParameterTextureExtra( xml, data ) {

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'technique':
  						parseEffectParameterTextureExtraTechnique( child, data );
  						break;

  				}

  			}

  		}

  		function parseEffectParameterTextureExtraTechnique( xml, data ) {

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'repeatU':
  					case 'repeatV':
  					case 'offsetU':
  					case 'offsetV':
  						data.technique[ child.nodeName ] = parseFloat( child.textContent );
  						break;

  					case 'wrapU':
  					case 'wrapV':

  						// some files have values for wrapU/wrapV which become NaN via parseInt

  						if ( child.textContent.toUpperCase() === 'TRUE' ) {

  							data.technique[ child.nodeName ] = 1;

  						} else if ( child.textContent.toUpperCase() === 'FALSE' ) {

  							data.technique[ child.nodeName ] = 0;

  						} else {

  							data.technique[ child.nodeName ] = parseInt( child.textContent );

  						}

  						break;

  				}

  			}

  		}

  		function parseEffectExtra( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'technique':
  						data.technique = parseEffectExtraTechnique( child );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseEffectExtraTechnique( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'double_sided':
  						data[ child.nodeName ] = parseInt( child.textContent );
  						break;

  				}

  			}

  			return data;

  		}

  		function buildEffect( data ) {

  			return data;

  		}

  		function getEffect( id ) {

  			return getBuild( library.effects[ id ], buildEffect );

  		}

  		// material

  		function parseMaterial( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' )
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'instance_effect':
  						data.url = parseId( child.getAttribute( 'url' ) );
  						break;

  				}

  			}

  			library.materials[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function getTextureLoader( image ) {

  			var loader;

  			var extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/
  			extension = extension.toLowerCase();

  			switch ( extension ) {

  				case 'tga':
  					loader = tgaLoader;
  					break;

  				default:
  					loader = textureLoader;

  			}

  			return loader;

  		}

  		function buildMaterial( data ) {

  			var effect = getEffect( data.url );
  			var technique = effect.profile.technique;
  			var extra = effect.profile.extra;

  			var material;

  			switch ( technique.type ) {

  				case 'phong':
  				case 'blinn':
  					material = new MeshPhongMaterial();
  					break;

  				case 'lambert':
  					material = new MeshLambertMaterial();
  					break;

  				default:
  					material = new MeshBasicMaterial();
  					break;

  			}

  			material.name = data.name || '';

  			function getTexture( textureObject ) {

  				var sampler = effect.profile.samplers[ textureObject.id ];
  				var image = null;

  				// get image

  				if ( sampler !== undefined ) {

  					var surface = effect.profile.surfaces[ sampler.source ];
  					image = getImage( surface.init_from );

  				} else {

  					console.warn( 'ColladaLoader: Undefined sampler. Access image directly (see #12530).' );
  					image = getImage( textureObject.id );

  				}

  				// create texture if image is avaiable

  				if ( image !== null ) {

  					var loader = getTextureLoader( image );

  					if ( loader !== undefined ) {

  						var texture = loader.load( image );

  						var extra = textureObject.extra;

  						if ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {

  							var technique = extra.technique;

  							texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;
  							texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;

  							texture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );
  							texture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );

  						} else {

  							texture.wrapS = RepeatWrapping;
  							texture.wrapT = RepeatWrapping;

  						}

  						return texture;

  					} else {

  						console.warn( 'ColladaLoader: Loader for texture %s not found.', image );

  						return null;

  					}

  				} else {

  					console.warn( 'ColladaLoader: Couldn\'t create texture with ID:', textureObject.id );

  					return null;

  				}

  			}

  			var parameters = technique.parameters;

  			for ( var key in parameters ) {

  				var parameter = parameters[ key ];

  				switch ( key ) {

  					case 'diffuse':
  						if ( parameter.color ) { material.color.fromArray( parameter.color ); }
  						if ( parameter.texture ) { material.map = getTexture( parameter.texture ); }
  						break;
  					case 'specular':
  						if ( parameter.color && material.specular ) { material.specular.fromArray( parameter.color ); }
  						if ( parameter.texture ) { material.specularMap = getTexture( parameter.texture ); }
  						break;
  					case 'bump':
  						if ( parameter.texture ) { material.normalMap = getTexture( parameter.texture ); }
  						break;
  					case 'ambient':
  						if ( parameter.texture ) { material.lightMap = getTexture( parameter.texture ); }
  						break;
  					case 'shininess':
  						if ( parameter.float && material.shininess ) { material.shininess = parameter.float; }
  						break;
  					case 'emission':
  						if ( parameter.color && material.emissive ) { material.emissive.fromArray( parameter.color ); }
  						if ( parameter.texture ) { material.emissiveMap = getTexture( parameter.texture ); }
  						break;

  				}

  			}

  			//

  			var transparent = parameters[ 'transparent' ];
  			var transparency = parameters[ 'transparency' ];

  			// <transparency> does not exist but <transparent>

  			if ( transparency === undefined && transparent ) {

  				transparency = {
  					float: 1
  				};

  			}

  			// <transparent> does not exist but <transparency>

  			if ( transparent === undefined && transparency ) {

  				transparent = {
  					opaque: 'A_ONE',
  					data: {
  						color: [ 1, 1, 1, 1 ]
  					} };

  			}

  			if ( transparent && transparency ) {

  				// handle case if a texture exists but no color

  				if ( transparent.data.texture ) {

  					// we do not set an alpha map (see #13792)

  					material.transparent = true;

  				} else {

  					var color = transparent.data.color;

  					switch ( transparent.opaque ) {

  						case 'A_ONE':
  							material.opacity = color[ 3 ] * transparency.float;
  							break;
  						case 'RGB_ZERO':
  							material.opacity = 1 - ( color[ 0 ] * transparency.float );
  							break;
  						case 'A_ZERO':
  							material.opacity = 1 - ( color[ 3 ] * transparency.float );
  							break;
  						case 'RGB_ONE':
  							material.opacity = color[ 0 ] * transparency.float;
  							break;
  						default:
  							console.warn( 'ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque );

  					}

  					if ( material.opacity < 1 ) { material.transparent = true; }

  				}

  			}

  			//

  			if ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {

  				material.side = DoubleSide;

  			}

  			return material;

  		}

  		function getMaterial( id ) {

  			return getBuild( library.materials[ id ], buildMaterial );

  		}

  		// camera

  		function parseCamera( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' )
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'optics':
  						data.optics = parseCameraOptics( child );
  						break;

  				}

  			}

  			library.cameras[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseCameraOptics( xml ) {

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				switch ( child.nodeName ) {

  					case 'technique_common':
  						return parseCameraTechnique( child );

  				}

  			}

  			return {};

  		}

  		function parseCameraTechnique( xml ) {

  			var data = {};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				switch ( child.nodeName ) {

  					case 'perspective':
  					case 'orthographic':

  						data.technique = child.nodeName;
  						data.parameters = parseCameraParameters( child );

  						break;

  				}

  			}

  			return data;

  		}

  		function parseCameraParameters( xml ) {

  			var data = {};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				switch ( child.nodeName ) {

  					case 'xfov':
  					case 'yfov':
  					case 'xmag':
  					case 'ymag':
  					case 'znear':
  					case 'zfar':
  					case 'aspect_ratio':
  						data[ child.nodeName ] = parseFloat( child.textContent );
  						break;

  				}

  			}

  			return data;

  		}

  		function buildCamera( data ) {

  			var camera;

  			switch ( data.optics.technique ) {

  				case 'perspective':
  					camera = new PerspectiveCamera(
  						data.optics.parameters.yfov,
  						data.optics.parameters.aspect_ratio,
  						data.optics.parameters.znear,
  						data.optics.parameters.zfar
  					);
  					break;

  				case 'orthographic':
  					var ymag = data.optics.parameters.ymag;
  					var xmag = data.optics.parameters.xmag;
  					var aspectRatio = data.optics.parameters.aspect_ratio;

  					xmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;
  					ymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;

  					xmag *= 0.5;
  					ymag *= 0.5;

  					camera = new OrthographicCamera(
  						- xmag, xmag, ymag, - ymag, // left, right, top, bottom
  						data.optics.parameters.znear,
  						data.optics.parameters.zfar
  					);
  					break;

  				default:
  					camera = new PerspectiveCamera();
  					break;

  			}

  			camera.name = data.name || '';

  			return camera;

  		}

  		function getCamera( id ) {

  			var data = library.cameras[ id ];

  			if ( data !== undefined ) {

  				return getBuild( data, buildCamera );

  			}

  			console.warn( 'ColladaLoader: Couldn\'t find camera with ID:', id );

  			return null;

  		}

  		// light

  		function parseLight( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'technique_common':
  						data = parseLightTechnique( child );
  						break;

  				}

  			}

  			library.lights[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseLightTechnique( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'directional':
  					case 'point':
  					case 'spot':
  					case 'ambient':

  						data.technique = child.nodeName;
  						data.parameters = parseLightParameters( child );

  				}

  			}

  			return data;

  		}

  		function parseLightParameters( xml ) {

  			var data = {};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'color':
  						var array = parseFloats( child.textContent );
  						data.color = new Color().fromArray( array );
  						break;

  					case 'falloff_angle':
  						data.falloffAngle = parseFloat( child.textContent );
  						break;

  					case 'quadratic_attenuation':
  						var f = parseFloat( child.textContent );
  						data.distance = f ? Math.sqrt( 1 / f ) : 0;
  						break;

  				}

  			}

  			return data;

  		}

  		function buildLight( data ) {

  			var light;

  			switch ( data.technique ) {

  				case 'directional':
  					light = new DirectionalLight();
  					break;

  				case 'point':
  					light = new PointLight();
  					break;

  				case 'spot':
  					light = new SpotLight();
  					break;

  				case 'ambient':
  					light = new AmbientLight();
  					break;

  			}

  			if ( data.parameters.color ) { light.color.copy( data.parameters.color ); }
  			if ( data.parameters.distance ) { light.distance = data.parameters.distance; }

  			return light;

  		}

  		function getLight( id ) {

  			var data = library.lights[ id ];

  			if ( data !== undefined ) {

  				return getBuild( data, buildLight );

  			}

  			console.warn( 'ColladaLoader: Couldn\'t find light with ID:', id );

  			return null;

  		}

  		// geometry

  		function parseGeometry( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' ),
  				sources: {},
  				vertices: {},
  				primitives: []
  			};

  			var mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];

  			// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep
  			if ( mesh === undefined ) { return; }

  			for ( var i = 0; i < mesh.childNodes.length; i ++ ) {

  				var child = mesh.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				var id = child.getAttribute( 'id' );

  				switch ( child.nodeName ) {

  					case 'source':
  						data.sources[ id ] = parseSource( child );
  						break;

  					case 'vertices':
  						// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
  						data.vertices = parseGeometryVertices( child );
  						break;

  					case 'polygons':
  						console.warn( 'ColladaLoader: Unsupported primitive type: ', child.nodeName );
  						break;

  					case 'lines':
  					case 'linestrips':
  					case 'polylist':
  					case 'triangles':
  						data.primitives.push( parseGeometryPrimitive( child ) );
  						break;

  					default:
  						console.log( child );

  				}

  			}

  			library.geometries[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parseSource( xml ) {

  			var data = {
  				array: [],
  				stride: 3
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'float_array':
  						data.array = parseFloats( child.textContent );
  						break;

  					case 'Name_array':
  						data.array = parseStrings( child.textContent );
  						break;

  					case 'technique_common':
  						var accessor = getElementsByTagName( child, 'accessor' )[ 0 ];

  						if ( accessor !== undefined ) {

  							data.stride = parseInt( accessor.getAttribute( 'stride' ) );

  						}
  						break;

  				}

  			}

  			return data;

  		}

  		function parseGeometryVertices( xml ) {

  			var data = {};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				data[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );

  			}

  			return data;

  		}

  		function parseGeometryPrimitive( xml ) {

  			var primitive = {
  				type: xml.nodeName,
  				material: xml.getAttribute( 'material' ),
  				count: parseInt( xml.getAttribute( 'count' ) ),
  				inputs: {},
  				stride: 0,
  				hasUV: false
  			};

  			for ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'input':
  						var id = parseId( child.getAttribute( 'source' ) );
  						var semantic = child.getAttribute( 'semantic' );
  						var offset = parseInt( child.getAttribute( 'offset' ) );
  						var set = parseInt( child.getAttribute( 'set' ) );
  						var inputname = ( set > 0 ? semantic + set : semantic );
  						primitive.inputs[ inputname ] = { id: id, offset: offset };
  						primitive.stride = Math.max( primitive.stride, offset + 1 );
  						if ( semantic === 'TEXCOORD' ) { primitive.hasUV = true; }
  						break;

  					case 'vcount':
  						primitive.vcount = parseInts( child.textContent );
  						break;

  					case 'p':
  						primitive.p = parseInts( child.textContent );
  						break;

  				}

  			}

  			return primitive;

  		}

  		function groupPrimitives( primitives ) {

  			var build = {};

  			for ( var i = 0; i < primitives.length; i ++ ) {

  				var primitive = primitives[ i ];

  				if ( build[ primitive.type ] === undefined ) { build[ primitive.type ] = []; }

  				build[ primitive.type ].push( primitive );

  			}

  			return build;

  		}

  		function checkUVCoordinates( primitives ) {

  			var count = 0;

  			for ( var i = 0, l = primitives.length; i < l; i ++ ) {

  				var primitive = primitives[ i ];

  				if ( primitive.hasUV === true ) {

  					count ++;

  				}

  			}

  			if ( count > 0 && count < primitives.length ) {

  				primitives.uvsNeedsFix = true;

  			}

  		}

  		function buildGeometry( data ) {

  			var build = {};

  			var sources = data.sources;
  			var vertices = data.vertices;
  			var primitives = data.primitives;

  			if ( primitives.length === 0 ) { return {}; }

  			// our goal is to create one buffer geometry for a single type of primitives
  			// first, we group all primitives by their type

  			var groupedPrimitives = groupPrimitives( primitives );

  			for ( var type in groupedPrimitives ) {

  				var primitiveType = groupedPrimitives[ type ];

  				// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)

  				checkUVCoordinates( primitiveType );

  				// third, create a buffer geometry for each type of primitives

  				build[ type ] = buildGeometryType( primitiveType, sources, vertices );

  			}

  			return build;

  		}

  		function buildGeometryType( primitives, sources, vertices ) {

  			var build = {};

  			var position = { array: [], stride: 0 };
  			var normal = { array: [], stride: 0 };
  			var uv = { array: [], stride: 0 };
  			var uv2 = { array: [], stride: 0 };
  			var color = { array: [], stride: 0 };

  			var skinIndex = { array: [], stride: 4 };
  			var skinWeight = { array: [], stride: 4 };

  			var geometry = new BufferGeometry();

  			var materialKeys = [];

  			var start = 0;

  			for ( var p = 0; p < primitives.length; p ++ ) {

  				var primitive = primitives[ p ];
  				var inputs = primitive.inputs;

  				// groups

  				var count = 0;

  				switch ( primitive.type ) {

  					case 'lines':
  					case 'linestrips':
  						count = primitive.count * 2;
  						break;

  					case 'triangles':
  						count = primitive.count * 3;
  						break;

  					case 'polylist':

  						for ( var g = 0; g < primitive.count; g ++ ) {

  							var vc = primitive.vcount[ g ];

  							switch ( vc ) {

  								case 3:
  									count += 3; // single triangle
  									break;

  								case 4:
  									count += 6; // quad, subdivided into two triangles
  									break;

  								default:
  									count += ( vc - 2 ) * 3; // polylist with more than four vertices
  									break;

  							}

  						}

  						break;

  					default:
  						console.warn( 'ColladaLoader: Unknow primitive type:', primitive.type );

  				}

  				geometry.addGroup( start, count, p );
  				start += count;

  				// material

  				if ( primitive.material ) {

  					materialKeys.push( primitive.material );

  				}

  				// geometry data

  				for ( var name in inputs ) {

  					var input = inputs[ name ];

  					switch ( name )	{

  						case 'VERTEX':
  							for ( var key in vertices ) {

  								var id = vertices[ key ];

  								switch ( key ) {

  									case 'POSITION':
  										var prevLength = position.array.length;
  										buildGeometryData( primitive, sources[ id ], input.offset, position.array );
  										position.stride = sources[ id ].stride;

  										if ( sources.skinWeights && sources.skinIndices ) {

  											buildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );
  											buildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );

  										}

  										// see #3803

  										if ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {

  											var count = ( position.array.length - prevLength ) / position.stride;

  											for ( var i = 0; i < count; i ++ ) {

  												// fill missing uv coordinates

  												uv.array.push( 0, 0 );

  											}

  										}
  										break;

  									case 'NORMAL':
  										buildGeometryData( primitive, sources[ id ], input.offset, normal.array );
  										normal.stride = sources[ id ].stride;
  										break;

  									case 'COLOR':
  										buildGeometryData( primitive, sources[ id ], input.offset, color.array );
  										color.stride = sources[ id ].stride;
  										break;

  									case 'TEXCOORD':
  										buildGeometryData( primitive, sources[ id ], input.offset, uv.array );
  										uv.stride = sources[ id ].stride;
  										break;

  									case 'TEXCOORD1':
  										buildGeometryData( primitive, sources[ id ], input.offset, uv2.array );
  										uv.stride = sources[ id ].stride;
  										break;

  									default:
  										console.warn( 'ColladaLoader: Semantic "%s" not handled in geometry build process.', key );

  								}

  							}
  							break;

  						case 'NORMAL':
  							buildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );
  							normal.stride = sources[ input.id ].stride;
  							break;

  						case 'COLOR':
  							buildGeometryData( primitive, sources[ input.id ], input.offset, color.array );
  							color.stride = sources[ input.id ].stride;
  							break;

  						case 'TEXCOORD':
  							buildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );
  							uv.stride = sources[ input.id ].stride;
  							break;

  						case 'TEXCOORD1':
  							buildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );
  							uv2.stride = sources[ input.id ].stride;
  							break;

  					}

  				}

  			}

  			// build geometry

  			if ( position.array.length > 0 ) { geometry.addAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) ); }
  			if ( normal.array.length > 0 ) { geometry.addAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) ); }
  			if ( color.array.length > 0 ) { geometry.addAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) ); }
  			if ( uv.array.length > 0 ) { geometry.addAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) ); }
  			if ( uv2.array.length > 0 ) { geometry.addAttribute( 'uv2', new Float32BufferAttribute( uv2.array, uv2.stride ) ); }

  			if ( skinIndex.array.length > 0 ) { geometry.addAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) ); }
  			if ( skinWeight.array.length > 0 ) { geometry.addAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) ); }

  			build.data = geometry;
  			build.type = primitives[ 0 ].type;
  			build.materialKeys = materialKeys;

  			return build;

  		}

  		function buildGeometryData( primitive, source, offset, array ) {

  			var indices = primitive.p;
  			var stride = primitive.stride;
  			var vcount = primitive.vcount;

  			function pushVector( i ) {

  				var index = indices[ i + offset ] * sourceStride;
  				var length = index + sourceStride;

  				for ( ; index < length; index ++ ) {

  					array.push( sourceArray[ index ] );

  				}

  			}

  			var sourceArray = source.array;
  			var sourceStride = source.stride;

  			if ( primitive.vcount !== undefined ) {

  				var index = 0;

  				for ( var i = 0, l = vcount.length; i < l; i ++ ) {

  					var count = vcount[ i ];

  					if ( count === 4 ) {

  						var a = index + stride * 0;
  						var b = index + stride * 1;
  						var c = index + stride * 2;
  						var d = index + stride * 3;

  						pushVector( a ); pushVector( b ); pushVector( d );
  						pushVector( b ); pushVector( c ); pushVector( d );

  					} else if ( count === 3 ) {

  						var a = index + stride * 0;
  						var b = index + stride * 1;
  						var c = index + stride * 2;

  						pushVector( a ); pushVector( b ); pushVector( c );

  					} else if ( count > 4 ) {

  						for ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {

  							var a = index + stride * 0;
  							var b = index + stride * k;
  							var c = index + stride * ( k + 1 );

  							pushVector( a ); pushVector( b ); pushVector( c );

  						}

  					}

  					index += stride * count;

  				}

  			} else {

  				for ( var i = 0, l = indices.length; i < l; i += stride ) {

  					pushVector( i );

  				}

  			}

  		}

  		function getGeometry( id ) {

  			return getBuild( library.geometries[ id ], buildGeometry );

  		}

  		// kinematics

  		function parseKinematicsModel( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' ) || '',
  				joints: {},
  				links: []
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'technique_common':
  						parseKinematicsTechniqueCommon( child, data );
  						break;

  				}

  			}

  			library.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function buildKinematicsModel( data ) {

  			if ( data.build !== undefined ) { return data.build; }

  			return data;

  		}

  		function getKinematicsModel( id ) {

  			return getBuild( library.kinematicsModels[ id ], buildKinematicsModel );

  		}

  		function parseKinematicsTechniqueCommon( xml, data ) {

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'joint':
  						data.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );
  						break;

  					case 'link':
  						data.links.push( parseKinematicsLink( child ) );
  						break;

  				}

  			}

  		}

  		function parseKinematicsJoint( xml ) {

  			var data;

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'prismatic':
  					case 'revolute':
  						data = parseKinematicsJointParameter( child );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseKinematicsJointParameter( xml, data ) {

  			var data = {
  				sid: xml.getAttribute( 'sid' ),
  				name: xml.getAttribute( 'name' ) || '',
  				axis: new Vector3(),
  				limits: {
  					min: 0,
  					max: 0
  				},
  				type: xml.nodeName,
  				static: false,
  				zeroPosition: 0,
  				middlePosition: 0
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'axis':
  						var array = parseFloats( child.textContent );
  						data.axis.fromArray( array );
  						break;
  					case 'limits':
  						var max = child.getElementsByTagName( 'max' )[ 0 ];
  						var min = child.getElementsByTagName( 'min' )[ 0 ];

  						data.limits.max = parseFloat( max.textContent );
  						data.limits.min = parseFloat( min.textContent );
  						break;

  				}

  			}

  			// if min is equal to or greater than max, consider the joint static

  			if ( data.limits.min >= data.limits.max ) {

  				data.static = true;

  			}

  			// calculate middle position

  			data.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;

  			return data;

  		}

  		function parseKinematicsLink( xml ) {

  			var data = {
  				sid: xml.getAttribute( 'sid' ),
  				name: xml.getAttribute( 'name' ) || '',
  				attachments: [],
  				transforms: []
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'attachment_full':
  						data.attachments.push( parseKinematicsAttachment( child ) );
  						break;

  					case 'matrix':
  					case 'translate':
  					case 'rotate':
  						data.transforms.push( parseKinematicsTransform( child ) );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseKinematicsAttachment( xml ) {

  			var data = {
  				joint: xml.getAttribute( 'joint' ).split( '/' ).pop(),
  				transforms: [],
  				links: []
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'link':
  						data.links.push( parseKinematicsLink( child ) );
  						break;

  					case 'matrix':
  					case 'translate':
  					case 'rotate':
  						data.transforms.push( parseKinematicsTransform( child ) );
  						break;

  				}

  			}

  			return data;

  		}

  		function parseKinematicsTransform( xml ) {

  			var data = {
  				type: xml.nodeName
  			};

  			var array = parseFloats( xml.textContent );

  			switch ( data.type ) {

  				case 'matrix':
  					data.obj = new Matrix4();
  					data.obj.fromArray( array ).transpose();
  					break;

  				case 'translate':
  					data.obj = new Vector3();
  					data.obj.fromArray( array );
  					break;

  				case 'rotate':
  					data.obj = new Vector3();
  					data.obj.fromArray( array );
  					data.angle = _Math.degToRad( array[ 3 ] );
  					break;

  			}

  			return data;

  		}

  		// physics

  		function parsePhysicsModel( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' ) || '',
  				rigidBodies: {}
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'rigid_body':
  						data.rigidBodies[ child.getAttribute( 'name' ) ] = {};
  						parsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );
  						break;

  				}

  			}

  			library.physicsModels[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function parsePhysicsRigidBody( xml, data ) {

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'technique_common':
  						parsePhysicsTechniqueCommon( child, data );
  						break;

  				}

  			}

  		}

  		function parsePhysicsTechniqueCommon( xml, data ) {

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'inertia':
  						data.inertia = parseFloats( child.textContent );
  						break;

  					case 'mass':
  						data.mass = parseFloats( child.textContent )[ 0 ];
  						break;

  				}

  			}

  		}

  		// scene

  		function parseKinematicsScene( xml ) {

  			var data = {
  				bindJointAxis: []
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'bind_joint_axis':
  						data.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );
  						break;

  				}

  			}

  			library.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;

  		}

  		function parseKinematicsBindJointAxis( xml ) {

  			var data = {
  				target: xml.getAttribute( 'target' ).split( '/' ).pop()
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'axis':
  						var param = child.getElementsByTagName( 'param' )[ 0 ];
  						data.axis = param.textContent;
  						var tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];
  						data.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );
  						break;

  				}

  			}

  			return data;

  		}

  		function buildKinematicsScene( data ) {

  			if ( data.build !== undefined ) { return data.build; }

  			return data;

  		}

  		function getKinematicsScene( id ) {

  			return getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );

  		}

  		function setupKinematics() {

  			var kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];
  			var kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];
  			var visualSceneId = Object.keys( library.visualScenes )[ 0 ];

  			if ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) { return; }

  			var kinematicsModel = getKinematicsModel( kinematicsModelId );
  			var kinematicsScene = getKinematicsScene( kinematicsSceneId );
  			var visualScene = getVisualScene( visualSceneId );

  			var bindJointAxis = kinematicsScene.bindJointAxis;
  			var jointMap = {};

  			for ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {

  				var axis = bindJointAxis[ i ];

  				// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'

  				var targetElement = collada.querySelector( '[sid="' + axis.target + '"]' );

  				if ( targetElement ) {

  					// get the parent of the transfrom element

  					var parentVisualElement = targetElement.parentElement;

  					// connect the joint of the kinematics model with the element in the visual scene

  					connect( axis.jointIndex, parentVisualElement );

  				}

  			}

  			function connect( jointIndex, visualElement ) {

  				var visualElementName = visualElement.getAttribute( 'name' );
  				var joint = kinematicsModel.joints[ jointIndex ];

  				visualScene.traverse( function ( object ) {

  					if ( object.name === visualElementName ) {

  						jointMap[ jointIndex ] = {
  							object: object,
  							transforms: buildTransformList( visualElement ),
  							joint: joint,
  							position: joint.zeroPosition
  						};

  					}

  				} );

  			}

  			var m0 = new Matrix4();

  			kinematics = {

  				joints: kinematicsModel && kinematicsModel.joints,

  				getJointValue: function ( jointIndex ) {

  					var jointData = jointMap[ jointIndex ];

  					if ( jointData ) {

  						return jointData.position;

  					} else {

  						console.warn( 'ColladaLoader: Joint ' + jointIndex + ' doesn\'t exist.' );

  					}

  				},

  				setJointValue: function ( jointIndex, value ) {

  					var jointData = jointMap[ jointIndex ];

  					if ( jointData ) {

  						var joint = jointData.joint;

  						if ( value > joint.limits.max || value < joint.limits.min ) {

  							console.warn( 'ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );

  						} else if ( joint.static ) {

  							console.warn( 'ColladaLoader: Joint ' + jointIndex + ' is static.' );

  						} else {

  							var object = jointData.object;
  							var axis = joint.axis;
  							var transforms = jointData.transforms;

  							matrix.identity();

  							// each update, we have to apply all transforms in the correct order

  							for ( var i = 0; i < transforms.length; i ++ ) {

  								var transform = transforms[ i ];

  								// if there is a connection of the transform node with a joint, apply the joint value

  								if ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {

  									switch ( joint.type ) {

  										case 'revolute':
  											matrix.multiply( m0.makeRotationAxis( axis, _Math.degToRad( value ) ) );
  											break;

  										case 'prismatic':
  											matrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );
  											break;

  										default:
  											console.warn( 'ColladaLoader: Unknown joint type: ' + joint.type );
  											break;

  									}

  								} else {

  									switch ( transform.type ) {

  										case 'matrix':
  											matrix.multiply( transform.obj );
  											break;

  										case 'translate':
  											matrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );
  											break;

  										case 'scale':
  											matrix.scale( transform.obj );
  											break;

  										case 'rotate':
  											matrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );
  											break;

  									}

  								}

  							}

  							object.matrix.copy( matrix );
  							object.matrix.decompose( object.position, object.quaternion, object.scale );

  							jointMap[ jointIndex ].position = value;

  						}

  					} else {

  						console.log( 'ColladaLoader: ' + jointIndex + ' does not exist.' );

  					}

  				}

  			};

  		}

  		function buildTransformList( node ) {

  			var transforms = [];

  			var xml = collada.querySelector( '[id="' + node.id + '"]' );

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'matrix':
  						var array = parseFloats( child.textContent );
  						var matrix = new Matrix4().fromArray( array ).transpose();
  						transforms.push( {
  							sid: child.getAttribute( 'sid' ),
  							type: child.nodeName,
  							obj: matrix
  						} );
  						break;

  					case 'translate':
  					case 'scale':
  						var array = parseFloats( child.textContent );
  						var vector = new Vector3().fromArray( array );
  						transforms.push( {
  							sid: child.getAttribute( 'sid' ),
  							type: child.nodeName,
  							obj: vector
  						} );
  						break;

  					case 'rotate':
  						var array = parseFloats( child.textContent );
  						var vector = new Vector3().fromArray( array );
  						var angle = _Math.degToRad( array[ 3 ] );
  						transforms.push( {
  							sid: child.getAttribute( 'sid' ),
  							type: child.nodeName,
  							obj: vector,
  							angle: angle
  						} );
  						break;

  				}

  			}

  			return transforms;

  		}

  		// nodes

  		function prepareNodes( xml ) {

  			var elements = xml.getElementsByTagName( 'node' );

  			// ensure all node elements have id attributes

  			for ( var i = 0; i < elements.length; i ++ ) {

  				var element = elements[ i ];

  				if ( element.hasAttribute( 'id' ) === false ) {

  					element.setAttribute( 'id', generateId() );

  				}

  			}

  		}

  		var matrix = new Matrix4();
  		var vector = new Vector3();

  		function parseNode( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' ) || '',
  				type: xml.getAttribute( 'type' ),
  				id: xml.getAttribute( 'id' ),
  				sid: xml.getAttribute( 'sid' ),
  				matrix: new Matrix4(),
  				nodes: [],
  				instanceCameras: [],
  				instanceControllers: [],
  				instanceLights: [],
  				instanceGeometries: [],
  				instanceNodes: [],
  				transforms: {}
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				if ( child.nodeType !== 1 ) { continue; }

  				switch ( child.nodeName ) {

  					case 'node':
  						data.nodes.push( child.getAttribute( 'id' ) );
  						parseNode( child );
  						break;

  					case 'instance_camera':
  						data.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );
  						break;

  					case 'instance_controller':
  						data.instanceControllers.push( parseNodeInstance( child ) );
  						break;

  					case 'instance_light':
  						data.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );
  						break;

  					case 'instance_geometry':
  						data.instanceGeometries.push( parseNodeInstance( child ) );
  						break;

  					case 'instance_node':
  						data.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );
  						break;

  					case 'matrix':
  						var array = parseFloats( child.textContent );
  						data.matrix.multiply( matrix.fromArray( array ).transpose() );
  						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
  						break;

  					case 'translate':
  						var array = parseFloats( child.textContent );
  						vector.fromArray( array );
  						data.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );
  						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
  						break;

  					case 'rotate':
  						var array = parseFloats( child.textContent );
  						var angle = _Math.degToRad( array[ 3 ] );
  						data.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );
  						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
  						break;

  					case 'scale':
  						var array = parseFloats( child.textContent );
  						data.matrix.scale( vector.fromArray( array ) );
  						data.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;
  						break;

  					case 'extra':
  						break;

  					default:
  						console.log( child );

  				}

  			}

  			if ( hasNode( data.id ) ) {

  				console.warn( 'ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );

  			} else {

  				library.nodes[ data.id ] = data;

  			}

  			return data;

  		}

  		function parseNodeInstance( xml ) {

  			var data = {
  				id: parseId( xml.getAttribute( 'url' ) ),
  				materials: {},
  				skeletons: []
  			};

  			for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  				var child = xml.childNodes[ i ];

  				switch ( child.nodeName ) {

  					case 'bind_material':
  						var instances = child.getElementsByTagName( 'instance_material' );

  						for ( var j = 0; j < instances.length; j ++ ) {

  							var instance = instances[ j ];
  							var symbol = instance.getAttribute( 'symbol' );
  							var target = instance.getAttribute( 'target' );

  							data.materials[ symbol ] = parseId( target );

  						}

  						break;

  					case 'skeleton':
  						data.skeletons.push( parseId( child.textContent ) );
  						break;

  					default:
  						break;

  				}

  			}

  			return data;

  		}

  		function buildSkeleton( skeletons, joints ) {

  			var boneData = [];
  			var sortedBoneData = [];

  			var i, j, data;

  			// a skeleton can have multiple root bones. collada expresses this
  			// situtation with multiple "skeleton" tags per controller instance

  			for ( i = 0; i < skeletons.length; i ++ ) {

  				var skeleton = skeletons[ i ];

  				var root;

  				if ( hasNode( skeleton ) ) {

  					root = getNode( skeleton );
  					buildBoneHierarchy( root, joints, boneData );

  				} else if ( hasVisualScene( skeleton ) ) {

  					// handle case where the skeleton refers to the visual scene (#13335)

  					var visualScene = library.visualScenes[ skeleton ];
  					var children = visualScene.children;

  					for ( var j = 0; j < children.length; j ++ ) {

  						var child = children[ j ];

  						if ( child.type === 'JOINT' ) {

  							var root = getNode( child.id );
  							buildBoneHierarchy( root, joints, boneData );

  						}

  					}

  				} else {

  					console.error( 'ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );

  				}

  			}

  			// sort bone data (the order is defined in the corresponding controller)

  			for ( i = 0; i < joints.length; i ++ ) {

  				for ( j = 0; j < boneData.length; j ++ ) {

  					data = boneData[ j ];

  					if ( data.bone.name === joints[ i ].name ) {

  						sortedBoneData[ i ] = data;
  						data.processed = true;
  						break;

  					}

  				}

  			}

  			// add unprocessed bone data at the end of the list

  			for ( i = 0; i < boneData.length; i ++ ) {

  				data = boneData[ i ];

  				if ( data.processed === false ) {

  					sortedBoneData.push( data );
  					data.processed = true;

  				}

  			}

  			// setup arrays for skeleton creation

  			var bones = [];
  			var boneInverses = [];

  			for ( i = 0; i < sortedBoneData.length; i ++ ) {

  				data = sortedBoneData[ i ];

  				bones.push( data.bone );
  				boneInverses.push( data.boneInverse );

  			}

  			return new Skeleton( bones, boneInverses );

  		}

  		function buildBoneHierarchy( root, joints, boneData ) {

  			// setup bone data from visual scene

  			root.traverse( function ( object ) {

  				if ( object.isBone === true ) {

  					var boneInverse;

  					// retrieve the boneInverse from the controller data

  					for ( var i = 0; i < joints.length; i ++ ) {

  						var joint = joints[ i ];

  						if ( joint.name === object.name ) {

  							boneInverse = joint.boneInverse;
  							break;

  						}

  					}

  					if ( boneInverse === undefined ) {

  						// Unfortunately, there can be joints in the visual scene that are not part of the
  						// corresponding controller. In this case, we have to create a dummy boneInverse matrix
  						// for the respective bone. This bone won't affect any vertices, because there are no skin indices
  						// and weights defined for it. But we still have to add the bone to the sorted bone list in order to
  						// ensure a correct animation of the model.

  						boneInverse = new Matrix4();

  					}

  					boneData.push( { bone: object, boneInverse: boneInverse, processed: false } );

  				}

  			} );

  		}

  		function buildNode( data ) {

  			var objects = [];

  			var matrix = data.matrix;
  			var nodes = data.nodes;
  			var type = data.type;
  			var instanceCameras = data.instanceCameras;
  			var instanceControllers = data.instanceControllers;
  			var instanceLights = data.instanceLights;
  			var instanceGeometries = data.instanceGeometries;
  			var instanceNodes = data.instanceNodes;

  			// nodes

  			for ( var i = 0, l = nodes.length; i < l; i ++ ) {

  				objects.push( getNode( nodes[ i ] ) );

  			}

  			// instance cameras

  			for ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {

  				var instanceCamera = getCamera( instanceCameras[ i ] );

  				if ( instanceCamera !== null ) {

  					objects.push( instanceCamera.clone() );

  				}

  			}

  			// instance controllers

  			for ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {

  				var instance = instanceControllers[ i ];
  				var controller = getController( instance.id );
  				var geometries = getGeometry( controller.id );
  				var newObjects = buildObjects( geometries, instance.materials );

  				var skeletons = instance.skeletons;
  				var joints = controller.skin.joints;

  				var skeleton = buildSkeleton( skeletons, joints );

  				for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {

  					var object = newObjects[ j ];

  					if ( object.isSkinnedMesh ) {

  						object.bind( skeleton, controller.skin.bindMatrix );
  						object.normalizeSkinWeights();

  					}

  					objects.push( object );

  				}

  			}

  			// instance lights

  			for ( var i = 0, l = instanceLights.length; i < l; i ++ ) {

  				var instanceLight = getLight( instanceLights[ i ] );

  				if ( instanceLight !== null ) {

  					objects.push( instanceLight.clone() );

  				}

  			}

  			// instance geometries

  			for ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {

  				var instance = instanceGeometries[ i ];

  				// a single geometry instance in collada can lead to multiple object3Ds.
  				// this is the case when primitives are combined like triangles and lines

  				var geometries = getGeometry( instance.id );
  				var newObjects = buildObjects( geometries, instance.materials );

  				for ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {

  					objects.push( newObjects[ j ] );

  				}

  			}

  			// instance nodes

  			for ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {

  				objects.push( getNode( instanceNodes[ i ] ).clone() );

  			}

  			var object;

  			if ( nodes.length === 0 && objects.length === 1 ) {

  				object = objects[ 0 ];

  			} else {

  				object = ( type === 'JOINT' ) ? new Bone() : new Group();

  				for ( var i = 0; i < objects.length; i ++ ) {

  					object.add( objects[ i ] );

  				}

  			}

  			if ( object.name === '' ) {

  				object.name = ( type === 'JOINT' ) ? data.sid : data.name;

  			}

  			object.matrix.copy( matrix );
  			object.matrix.decompose( object.position, object.quaternion, object.scale );

  			return object;

  		}

  		var fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );

  		function resolveMaterialBinding( keys, instanceMaterials ) {

  			var materials = [];

  			for ( var i = 0, l = keys.length; i < l; i ++ ) {

  				var id = instanceMaterials[ keys[ i ] ];

  				if ( id === undefined ) {

  					console.warn( 'ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );
  					materials.push( fallbackMaterial );

  				} else {

  					materials.push( getMaterial( id ) );

  				}

  			}

  			return materials;

  		}

  		function buildObjects( geometries, instanceMaterials ) {

  			var objects = [];

  			for ( var type in geometries ) {

  				var geometry = geometries[ type ];

  				var materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );

  				// handle case if no materials are defined

  				if ( materials.length === 0 ) {

  					if ( type === 'lines' || type === 'linestrips' ) {

  						materials.push( new LineBasicMaterial() );

  					} else {

  						materials.push( new MeshPhongMaterial() );

  					}

  				}

  				// regard skinning

  				var skinning = ( geometry.data.attributes.skinIndex !== undefined );

  				if ( skinning ) {

  					for ( var i = 0, l = materials.length; i < l; i ++ ) {

  						materials[ i ].skinning = true;

  					}

  				}

  				// choose between a single or multi materials (material array)

  				var material = ( materials.length === 1 ) ? materials[ 0 ] : materials;

  				// now create a specific 3D object

  				var object;

  				switch ( type ) {

  					case 'lines':
  						object = new LineSegments( geometry.data, material );
  						break;

  					case 'linestrips':
  						object = new Line( geometry.data, material );
  						break;

  					case 'triangles':
  					case 'polylist':
  						if ( skinning ) {

  							object = new SkinnedMesh( geometry.data, material );

  						} else {

  							object = new Mesh( geometry.data, material );

  						}
  						break;

  				}

  				objects.push( object );

  			}

  			return objects;

  		}

  		function hasNode( id ) {

  			return library.nodes[ id ] !== undefined;

  		}

  		function getNode( id ) {

  			return getBuild( library.nodes[ id ], buildNode );

  		}

  		// visual scenes

  		function parseVisualScene( xml ) {

  			var data = {
  				name: xml.getAttribute( 'name' ),
  				children: []
  			};

  			prepareNodes( xml );

  			var elements = getElementsByTagName( xml, 'node' );

  			for ( var i = 0; i < elements.length; i ++ ) {

  				data.children.push( parseNode( elements[ i ] ) );

  			}

  			library.visualScenes[ xml.getAttribute( 'id' ) ] = data;

  		}

  		function buildVisualScene( data ) {

  			var group = new Group();
  			group.name = data.name;

  			var children = data.children;

  			for ( var i = 0; i < children.length; i ++ ) {

  				var child = children[ i ];

  				group.add( getNode( child.id ) );

  			}

  			return group;

  		}

  		function hasVisualScene( id ) {

  			return library.visualScenes[ id ] !== undefined;

  		}

  		function getVisualScene( id ) {

  			return getBuild( library.visualScenes[ id ], buildVisualScene );

  		}

  		// scenes

  		function parseScene( xml ) {

  			var instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];
  			return getVisualScene( parseId( instance.getAttribute( 'url' ) ) );

  		}

  		function setupAnimations() {

  			var clips = library.clips;

  			if ( isEmpty( clips ) === true ) {

  				if ( isEmpty( library.animations ) === false ) {

  					// if there are animations but no clips, we create a default clip for playback

  					var tracks = [];

  					for ( var id in library.animations ) {

  						var animationTracks = getAnimation( id );

  						for ( var i = 0, l = animationTracks.length; i < l; i ++ ) {

  							tracks.push( animationTracks[ i ] );

  						}

  					}

  					animations.push( new AnimationClip( 'default', - 1, tracks ) );

  				}

  			} else {

  				for ( var id in clips ) {

  					animations.push( getAnimationClip( id ) );

  				}

  			}

  		}

  		if ( text.length === 0 ) {

  			return { scene: new Scene() };

  		}

  		var xml = new DOMParser().parseFromString( text, 'application/xml' );

  		var collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];

  		// metadata

  		var version = collada.getAttribute( 'version' );
  		console.log( 'ColladaLoader: File version', version );

  		var asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );
  		var textureLoader = new TextureLoader( this.manager );
  		textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		var tgaLoader;

  		if ( TGALoader ) {

  			tgaLoader = new TGALoader( this.manager );
  			tgaLoader.setPath( this.resourcePath || path );

  		}

  		//

  		var animations = [];
  		var kinematics = {};
  		var count = 0;

  		//

  		var library = {
  			animations: {},
  			clips: {},
  			controllers: {},
  			images: {},
  			effects: {},
  			materials: {},
  			cameras: {},
  			lights: {},
  			geometries: {},
  			nodes: {},
  			visualScenes: {},
  			kinematicsModels: {},
  			physicsModels: {},
  			kinematicsScenes: {}
  		};

  		parseLibrary( collada, 'library_animations', 'animation', parseAnimation );
  		parseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );
  		parseLibrary( collada, 'library_controllers', 'controller', parseController );
  		parseLibrary( collada, 'library_images', 'image', parseImage );
  		parseLibrary( collada, 'library_effects', 'effect', parseEffect );
  		parseLibrary( collada, 'library_materials', 'material', parseMaterial );
  		parseLibrary( collada, 'library_cameras', 'camera', parseCamera );
  		parseLibrary( collada, 'library_lights', 'light', parseLight );
  		parseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );
  		parseLibrary( collada, 'library_nodes', 'node', parseNode );
  		parseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );
  		parseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );
  		parseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );
  		parseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );

  		buildLibrary( library.animations, buildAnimation );
  		buildLibrary( library.clips, buildAnimationClip );
  		buildLibrary( library.controllers, buildController );
  		buildLibrary( library.images, buildImage );
  		buildLibrary( library.effects, buildEffect );
  		buildLibrary( library.materials, buildMaterial );
  		buildLibrary( library.cameras, buildCamera );
  		buildLibrary( library.lights, buildLight );
  		buildLibrary( library.geometries, buildGeometry );
  		buildLibrary( library.visualScenes, buildVisualScene );

  		setupAnimations();
  		setupKinematics();

  		var scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );

  		if ( asset.upAxis === 'Z_UP' ) {

  			scene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );

  		}

  		scene.scale.multiplyScalar( asset.unit );

  		return {
  			animations: animations,
  			kinematics: kinematics,
  			library: library,
  			scene: scene
  		};

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { width: width, height: height };
  	this.mipmaps = mipmaps;

  	// no flipping for cube textures
  	// (also flipping doesn't work for compressed textures )

  	this.flipY = false;

  	// can't generate mipmaps for compressed textures
  	// mips must be embedded in DDS files

  	this.generateMipmaps = false;

  }

  CompressedTexture.prototype = Object.create( Texture.prototype );
  CompressedTexture.prototype.constructor = CompressedTexture;

  CompressedTexture.prototype.isCompressedTexture = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CompressedTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( CompressedTextureLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var images = [];

  		var texture = new CompressedTexture();
  		texture.image = images;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );

  		function loadTexture( i ) {

  			loader.load( url[ i ], function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				images[ i ] = {
  					width: texDatas.width,
  					height: texDatas.height,
  					format: texDatas.format,
  					mipmaps: texDatas.mipmaps
  				};

  				loaded += 1;

  				if ( loaded === 6 ) {

  					if ( texDatas.mipmapCount === 1 )
  						{ texture.minFilter = LinearFilter; }

  					texture.format = texDatas.format;
  					texture.needsUpdate = true;

  					if ( onLoad ) { onLoad( texture ); }

  				}

  			}, onProgress, onError );

  		}

  		if ( Array.isArray( url ) ) {

  			var loaded = 0;

  			for ( var i = 0, il = url.length; i < il; ++ i ) {

  				loadTexture( i );

  			}

  		} else {

  			// compressed cubemap texture stored in a single DDS file

  			loader.load( url, function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				if ( texDatas.isCubemap ) {

  					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

  					for ( var f = 0; f < faces; f ++ ) {

  						images[ f ] = { mipmaps: [] };

  						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

  							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
  							images[ f ].format = texDatas.format;
  							images[ f ].width = texDatas.width;
  							images[ f ].height = texDatas.height;

  						}

  					}

  				} else {

  					texture.image.width = texDatas.width;
  					texture.image.height = texDatas.height;
  					texture.mipmaps = texDatas.mipmaps;

  				}

  				if ( texDatas.mipmapCount === 1 ) {

  					texture.minFilter = LinearFilter;

  				}

  				texture.format = texDatas.format;
  				texture.needsUpdate = true;

  				if ( onLoad ) { onLoad( texture ); }

  			}, onProgress, onError );

  		}

  		return texture;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DDSLoader = function ( manager ) {

  	CompressedTextureLoader.call( this, manager );

  	this._parser = DDSLoader.parse;

  };

  DDSLoader.prototype = Object.create( CompressedTextureLoader.prototype );
  DDSLoader.prototype.constructor = DDSLoader;

  DDSLoader.parse = function ( buffer, loadMipmaps ) {

  	var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

  	// Adapted from @toji's DDS utils
  	// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

  	// All values and structures referenced from:
  	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

  	var DDS_MAGIC = 0x20534444;

  	var DDSD_MIPMAPCOUNT = 0x20000;

  	var DDSCAPS2_CUBEMAP = 0x200,
  		DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
  		DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
  		DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
  		DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
  		DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
  		DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;

  	var DDPF_FOURCC = 0x4;

  	function fourCCToInt32( value ) {

  		return value.charCodeAt( 0 ) +
  			( value.charCodeAt( 1 ) << 8 ) +
  			( value.charCodeAt( 2 ) << 16 ) +
  			( value.charCodeAt( 3 ) << 24 );

  	}

  	function int32ToFourCC( value ) {

  		return String.fromCharCode(
  			value & 0xff,
  			( value >> 8 ) & 0xff,
  			( value >> 16 ) & 0xff,
  			( value >> 24 ) & 0xff
  		);

  	}

  	function loadARGBMip( buffer, dataOffset, width, height ) {

  		var dataLength = width * height * 4;
  		var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
  		var byteArray = new Uint8Array( dataLength );
  		var dst = 0;
  		var src = 0;
  		for ( var y = 0; y < height; y ++ ) {

  			for ( var x = 0; x < width; x ++ ) {

  				var b = srcBuffer[ src ]; src ++;
  				var g = srcBuffer[ src ]; src ++;
  				var r = srcBuffer[ src ]; src ++;
  				var a = srcBuffer[ src ]; src ++;
  				byteArray[ dst ] = r; dst ++;	//r
  				byteArray[ dst ] = g; dst ++;	//g
  				byteArray[ dst ] = b; dst ++;	//b
  				byteArray[ dst ] = a; dst ++;	//a

  			}

  		}
  		return byteArray;

  	}

  	var FOURCC_DXT1 = fourCCToInt32( "DXT1" );
  	var FOURCC_DXT3 = fourCCToInt32( "DXT3" );
  	var FOURCC_DXT5 = fourCCToInt32( "DXT5" );
  	var FOURCC_ETC1 = fourCCToInt32( "ETC1" );

  	var headerLengthInt = 31; // The header length in 32 bit ints

  	// Offsets into the header array

  	var off_magic = 0;

  	var off_size = 1;
  	var off_flags = 2;
  	var off_height = 3;
  	var off_width = 4;

  	var off_mipmapCount = 7;

  	var off_pfFlags = 20;
  	var off_pfFourCC = 21;
  	var off_RGBBitCount = 22;
  	var off_RBitMask = 23;
  	var off_GBitMask = 24;
  	var off_BBitMask = 25;
  	var off_ABitMask = 26;
  	var off_caps2 = 28;

  	// Parse header

  	var header = new Int32Array( buffer, 0, headerLengthInt );

  	if ( header[ off_magic ] !== DDS_MAGIC ) {

  		console.error( 'DDSLoader.parse: Invalid magic number in DDS header.' );
  		return dds;

  	}

  	if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

  		console.error( 'DDSLoader.parse: Unsupported format, must contain a FourCC code.' );
  		return dds;

  	}

  	var blockBytes;

  	var fourCC = header[ off_pfFourCC ];

  	var isRGBAUncompressed = false;

  	switch ( fourCC ) {

  		case FOURCC_DXT1:

  			blockBytes = 8;
  			dds.format = RGB_S3TC_DXT1_Format;
  			break;

  		case FOURCC_DXT3:

  			blockBytes = 16;
  			dds.format = RGBA_S3TC_DXT3_Format;
  			break;

  		case FOURCC_DXT5:

  			blockBytes = 16;
  			dds.format = RGBA_S3TC_DXT5_Format;
  			break;

  		case FOURCC_ETC1:

  			blockBytes = 8;
  			dds.format = RGB_ETC1_Format;
  			break;

  		default:

  			if ( header[ off_RGBBitCount ] === 32
  				&& header[ off_RBitMask ] & 0xff0000
  				&& header[ off_GBitMask ] & 0xff00
  				&& header[ off_BBitMask ] & 0xff
  				&& header[ off_ABitMask ] & 0xff000000 ) {

  				isRGBAUncompressed = true;
  				blockBytes = 64;
  				dds.format = RGBAFormat;

  			} else {

  				console.error( 'DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
  				return dds;

  			}

  	}

  	dds.mipmapCount = 1;

  	if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

  		dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

  	}

  	var caps2 = header[ off_caps2 ];
  	dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
  	if ( dds.isCubemap && (
  		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||
  		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||
  		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||
  		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||
  		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||
  		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )
  	) ) {

  		console.error( 'DDSLoader.parse: Incomplete cubemap faces' );
  		return dds;

  	}

  	dds.width = header[ off_width ];
  	dds.height = header[ off_height ];

  	var dataOffset = header[ off_size ] + 4;

  	// Extract mipmaps buffers

  	var faces = dds.isCubemap ? 6 : 1;

  	for ( var face = 0; face < faces; face ++ ) {

  		var width = dds.width;
  		var height = dds.height;

  		for ( var i = 0; i < dds.mipmapCount; i ++ ) {

  			if ( isRGBAUncompressed ) {

  				var byteArray = loadARGBMip( buffer, dataOffset, width, height );
  				var dataLength = byteArray.length;

  			} else {

  				var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
  				var byteArray = new Uint8Array( buffer, dataOffset, dataLength );

  			}

  			var mipmap = { "data": byteArray, "width": width, "height": height };
  			dds.mipmaps.push( mipmap );

  			dataOffset += dataLength;

  			width = Math.max( width >> 1, 1 );
  			height = Math.max( height >> 1, 1 );

  		}

  	}

  	return dds;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RawShaderMaterial( parameters ) {

  	ShaderMaterial.call( this, parameters );

  	this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;

  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineLoop( geometry, material ) {

  	Line.call( this, geometry, material );

  	this.type = 'LineLoop';

  }

  LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

  	constructor: LineLoop,

  	isLineLoop: true,

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineDashedMaterial( parameters ) {

  	LineBasicMaterial.call( this );

  	this.type = 'LineDashedMaterial';

  	this.scale = 1;
  	this.dashSize = 3;
  	this.gapSize = 1;

  	this.setValues( parameters );

  }

  LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;

  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  LineDashedMaterial.prototype.copy = function ( source ) {

  	LineBasicMaterial.prototype.copy.call( this, source );

  	this.scale = source.scale;
  	this.dashSize = source.dashSize;
  	this.gapSize = source.gapSize;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshDepthMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshDepthMaterial';

  	this.depthPacking = BasicDepthPacking;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDepthMaterial.prototype = Object.create( Material$1.prototype );
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.depthPacking = source.depthPacking;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshDistanceMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshDistanceMaterial';

  	this.referencePosition = new Vector3();
  	this.nearDistance = 1;
  	this.farDistance = 1000;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDistanceMaterial.prototype = Object.create( Material$1.prototype );
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.referencePosition.copy( source.referencePosition );
  	this.nearDistance = source.nearDistance;
  	this.farDistance = source.farDistance;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshNormalMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshNormalMaterial';

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalMapType = TangentSpaceNormalMap;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshNormalMaterial.prototype = Object.create( Material$1.prototype );
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalMapType = source.normalMapType;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshStandardMaterial( parameters ) {

  	Material$1.call( this );

  	this.defines = { 'STANDARD': '' };

  	this.type = 'MeshStandardMaterial';

  	this.color = new Color( 0xffffff ); // diffuse
  	this.roughness = 0.5;
  	this.metalness = 0.5;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalMapType = TangentSpaceNormalMap;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.roughnessMap = null;

  	this.metalnessMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.envMapIntensity = 1.0;

  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshStandardMaterial.prototype = Object.create( Material$1.prototype );
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.defines = { 'STANDARD': '' };

  	this.color.copy( source.color );
  	this.roughness = source.roughness;
  	this.metalness = source.metalness;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalMapType = source.normalMapType;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.roughnessMap = source.roughnessMap;

  	this.metalnessMap = source.metalnessMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.envMapIntensity = source.envMapIntensity;

  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshPhysicalMaterial( parameters ) {

  	MeshStandardMaterial.call( this );

  	this.defines = { 'PHYSICAL': '' };

  	this.type = 'MeshPhysicalMaterial';

  	this.reflectivity = 0.5; // maps to F0 = 0.04

  	this.clearCoat = 0.0;
  	this.clearCoatRoughness = 0.0;

  	this.setValues( parameters );

  }

  MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial.prototype.copy = function ( source ) {

  	MeshStandardMaterial.prototype.copy.call( this, source );

  	this.defines = { 'PHYSICAL': '' };

  	this.reflectivity = source.reflectivity;

  	this.clearCoat = source.clearCoat;
  	this.clearCoatRoughness = source.clearCoatRoughness;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshToonMaterial( parameters ) {

  	MeshPhongMaterial.call( this );

  	this.defines = { 'TOON': '' };

  	this.type = 'MeshToonMaterial';

  	this.gradientMap = null;

  	this.setValues( parameters );

  }

  MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;

  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  MeshToonMaterial.prototype.copy = function ( source ) {

  	MeshPhongMaterial.prototype.copy.call( this, source );

  	this.gradientMap = source.gradientMap;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ShadowMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'ShadowMaterial';

  	this.color = new Color( 0x000000 );
  	this.transparent = true;

  	this.setValues( parameters );

  }

  ShadowMaterial.prototype = Object.create( Material$1.prototype );
  ShadowMaterial.prototype.constructor = ShadowMaterial;

  ShadowMaterial.prototype.isShadowMaterial = true;

  ShadowMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpriteMaterial( parameters ) {

  	Material$1.call( this );

  	this.type = 'SpriteMaterial';

  	this.color = new Color( 0xffffff );
  	this.map = null;

  	this.rotation = 0;

  	this.sizeAttenuation = true;

  	this.lights = false;
  	this.transparent = true;

  	this.setValues( parameters );

  }

  SpriteMaterial.prototype = Object.create( Material$1.prototype );
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;

  SpriteMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.map = source.map;

  	this.rotation = source.rotation;

  	this.sizeAttenuation = source.sizeAttenuation;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MaterialLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.textures = {};

  }

  Object.assign( MaterialLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		var textures = this.textures;

  		function getTexture( name ) {

  			if ( textures[ name ] === undefined ) {

  				console.warn( 'MaterialLoader: Undefined texture', name );

  			}

  			return textures[ name ];

  		}

  		var Materials = {
              LineBasicMaterial: LineBasicMaterial,
              LineDashedMaterial: LineDashedMaterial,
              MeshBasicMaterial: MeshBasicMaterial,
              MeshDepthMaterial: MeshDepthMaterial,
              MeshDistanceMaterial: MeshDistanceMaterial,
              MeshLambertMaterial: MeshLambertMaterial,
              MeshNormalMaterial: MeshNormalMaterial,
              MeshPhongMaterial: MeshPhongMaterial,
              MeshPhysicalMaterial: MeshPhysicalMaterial,
              MeshStandardMaterial: MeshStandardMaterial,
              MeshToonMaterial: MeshToonMaterial,
              PointsMaterial: PointsMaterial,
              RawShaderMaterial: RawShaderMaterial,
              ShaderMaterial: ShaderMaterial,
              ShadowMaterial: ShadowMaterial,
              SpriteMaterial: SpriteMaterial
  		};
  		var material = new Materials[ json.type ]();

  		if ( json.uuid !== undefined ) { material.uuid = json.uuid; }
  		if ( json.name !== undefined ) { material.name = json.name; }
  		if ( json.color !== undefined ) { material.color.setHex( json.color ); }
  		if ( json.roughness !== undefined ) { material.roughness = json.roughness; }
  		if ( json.metalness !== undefined ) { material.metalness = json.metalness; }
  		if ( json.emissive !== undefined ) { material.emissive.setHex( json.emissive ); }
  		if ( json.specular !== undefined ) { material.specular.setHex( json.specular ); }
  		if ( json.shininess !== undefined ) { material.shininess = json.shininess; }
  		if ( json.clearCoat !== undefined ) { material.clearCoat = json.clearCoat; }
  		if ( json.clearCoatRoughness !== undefined ) { material.clearCoatRoughness = json.clearCoatRoughness; }
  		if ( json.vertexColors !== undefined ) { material.vertexColors = json.vertexColors; }
  		if ( json.fog !== undefined ) { material.fog = json.fog; }
  		if ( json.flatShading !== undefined ) { material.flatShading = json.flatShading; }
  		if ( json.blending !== undefined ) { material.blending = json.blending; }
  		if ( json.combine !== undefined ) { material.combine = json.combine; }
  		if ( json.side !== undefined ) { material.side = json.side; }
  		if ( json.opacity !== undefined ) { material.opacity = json.opacity; }
  		if ( json.transparent !== undefined ) { material.transparent = json.transparent; }
  		if ( json.alphaTest !== undefined ) { material.alphaTest = json.alphaTest; }
  		if ( json.depthTest !== undefined ) { material.depthTest = json.depthTest; }
  		if ( json.depthWrite !== undefined ) { material.depthWrite = json.depthWrite; }
  		if ( json.colorWrite !== undefined ) { material.colorWrite = json.colorWrite; }
  		if ( json.wireframe !== undefined ) { material.wireframe = json.wireframe; }
  		if ( json.wireframeLinewidth !== undefined ) { material.wireframeLinewidth = json.wireframeLinewidth; }
  		if ( json.wireframeLinecap !== undefined ) { material.wireframeLinecap = json.wireframeLinecap; }
  		if ( json.wireframeLinejoin !== undefined ) { material.wireframeLinejoin = json.wireframeLinejoin; }

  		if ( json.rotation !== undefined ) { material.rotation = json.rotation; }

  		if ( json.linewidth !== 1 ) { material.linewidth = json.linewidth; }
  		if ( json.dashSize !== undefined ) { material.dashSize = json.dashSize; }
  		if ( json.gapSize !== undefined ) { material.gapSize = json.gapSize; }
  		if ( json.scale !== undefined ) { material.scale = json.scale; }

  		if ( json.polygonOffset !== undefined ) { material.polygonOffset = json.polygonOffset; }
  		if ( json.polygonOffsetFactor !== undefined ) { material.polygonOffsetFactor = json.polygonOffsetFactor; }
  		if ( json.polygonOffsetUnits !== undefined ) { material.polygonOffsetUnits = json.polygonOffsetUnits; }

  		if ( json.skinning !== undefined ) { material.skinning = json.skinning; }
  		if ( json.morphTargets !== undefined ) { material.morphTargets = json.morphTargets; }
  		if ( json.dithering !== undefined ) { material.dithering = json.dithering; }

  		if ( json.visible !== undefined ) { material.visible = json.visible; }
  		if ( json.userData !== undefined ) { material.userData = json.userData; }

  		// Shader Material

  		if ( json.uniforms !== undefined ) {

  			for ( var name in json.uniforms ) {

  				var uniform = json.uniforms[ name ];

  				material.uniforms[ name ] = {};

  				switch ( uniform.type ) {

  					case 't':
  						material.uniforms[ name ].value = getTexture( uniform.value );
  						break;

  					case 'c':
  						material.uniforms[ name ].value = new Color().setHex( uniform.value );
  						break;

  					case 'v2':
  						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
  						break;

  					case 'v3':
  						material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
  						break;

  					case 'v4':
  						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
  						break;

  					case 'm3':
  						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

  					case 'm4':
  						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
  						break;

  					default:
  						material.uniforms[ name ].value = uniform.value;

  				}

  			}

  		}

  		if ( json.defines !== undefined ) { material.defines = json.defines; }
  		if ( json.vertexShader !== undefined ) { material.vertexShader = json.vertexShader; }
  		if ( json.fragmentShader !== undefined ) { material.fragmentShader = json.fragmentShader; }

  		if ( json.extensions !== undefined ) {

  			for ( var key in json.extensions ) {

  				material.extensions[ key ] = json.extensions[ key ];

  			}

  		}

  		// Deprecated

  		if ( json.shading !== undefined ) { material.flatShading = json.shading === 1; } // FlatShading

  		// for PointsMaterial

  		if ( json.size !== undefined ) { material.size = json.size; }
  		if ( json.sizeAttenuation !== undefined ) { material.sizeAttenuation = json.sizeAttenuation; }

  		// maps

  		if ( json.map !== undefined ) { material.map = getTexture( json.map ); }

  		if ( json.alphaMap !== undefined ) {

  			material.alphaMap = getTexture( json.alphaMap );
  			material.transparent = true;

  		}

  		if ( json.bumpMap !== undefined ) { material.bumpMap = getTexture( json.bumpMap ); }
  		if ( json.bumpScale !== undefined ) { material.bumpScale = json.bumpScale; }

  		if ( json.normalMap !== undefined ) { material.normalMap = getTexture( json.normalMap ); }
  		if ( json.normalMapType !== undefined ) { material.normalMapType = json.normalMapType; }
  		if ( json.normalScale !== undefined ) {

  			var normalScale = json.normalScale;

  			if ( Array.isArray( normalScale ) === false ) {

  				// Blender exporter used to export a scalar. See #7459

  				normalScale = [ normalScale, normalScale ];

  			}

  			material.normalScale = new Vector2().fromArray( normalScale );

  		}

  		if ( json.displacementMap !== undefined ) { material.displacementMap = getTexture( json.displacementMap ); }
  		if ( json.displacementScale !== undefined ) { material.displacementScale = json.displacementScale; }
  		if ( json.displacementBias !== undefined ) { material.displacementBias = json.displacementBias; }

  		if ( json.roughnessMap !== undefined ) { material.roughnessMap = getTexture( json.roughnessMap ); }
  		if ( json.metalnessMap !== undefined ) { material.metalnessMap = getTexture( json.metalnessMap ); }

  		if ( json.emissiveMap !== undefined ) { material.emissiveMap = getTexture( json.emissiveMap ); }
  		if ( json.emissiveIntensity !== undefined ) { material.emissiveIntensity = json.emissiveIntensity; }

  		if ( json.specularMap !== undefined ) { material.specularMap = getTexture( json.specularMap ); }

  		if ( json.envMap !== undefined ) { material.envMap = getTexture( json.envMap ); }
  		if ( json.envMapIntensity !== undefined ) { material.envMapIntensity = json.envMapIntensity; }

  		if ( json.reflectivity !== undefined ) { material.reflectivity = json.reflectivity; }

  		if ( json.lightMap !== undefined ) { material.lightMap = getTexture( json.lightMap ); }
  		if ( json.lightMapIntensity !== undefined ) { material.lightMapIntensity = json.lightMapIntensity; }

  		if ( json.aoMap !== undefined ) { material.aoMap = getTexture( json.aoMap ); }
  		if ( json.aoMapIntensity !== undefined ) { material.aoMapIntensity = json.aoMapIntensity; }

  		if ( json.gradientMap !== undefined ) { material.gradientMap = getTexture( json.gradientMap ); }

  		return material;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setTextures: function ( value ) {

  		this.textures = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Loader$1() {}

  Loader$1.Handlers = {

  	handlers: [],

  	add: function ( regex, loader ) {

  		this.handlers.push( regex, loader );

  	},

  	get: function ( file ) {

  		var handlers = this.handlers;

  		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

  			var regex = handlers[ i ];
  			var loader = handlers[ i + 1 ];

  			if ( regex.test( file ) ) {

  				return loader;

  			}

  		}

  		return null;

  	}

  };

  Object.assign( Loader$1.prototype, {

  	crossOrigin: 'anonymous',

  	onLoadStart: function () {},

  	onLoadProgress: function () {},

  	onLoadComplete: function () {},

  	initMaterials: function ( materials, texturePath, crossOrigin ) {
  		var this$1 = this;


  		var array = [];

  		for ( var i = 0; i < materials.length; ++ i ) {

  			array[ i ] = this$1.createMaterial( materials[ i ], texturePath, crossOrigin );

  		}

  		return array;

  	},

  	createMaterial: ( function () {

  		var BlendingMode = {
  			NoBlending: NoBlending,
  			NormalBlending: NormalBlending,
  			AdditiveBlending: AdditiveBlending,
  			SubtractiveBlending: SubtractiveBlending,
  			MultiplyBlending: MultiplyBlending,
  			CustomBlending: CustomBlending
  		};

  		var color = new Color();
  		var textureLoader = new TextureLoader();
  		var materialLoader = new MaterialLoader();

  		return function createMaterial( m, texturePath, crossOrigin ) {

  			// convert from old material format

  			var textures = {};

  			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

  				var fullPath = texturePath + path;
  				var loader = Loader$1.Handlers.get( fullPath );

  				var texture;

  				if ( loader !== null ) {

  					texture = loader.load( fullPath );

  				} else {

  					textureLoader.setCrossOrigin( crossOrigin );
  					texture = textureLoader.load( fullPath );

  				}

  				if ( repeat !== undefined ) {

  					texture.repeat.fromArray( repeat );

  					if ( repeat[ 0 ] !== 1 ) { texture.wrapS = RepeatWrapping; }
  					if ( repeat[ 1 ] !== 1 ) { texture.wrapT = RepeatWrapping; }

  				}

  				if ( offset !== undefined ) {

  					texture.offset.fromArray( offset );

  				}

  				if ( wrap !== undefined ) {

  					if ( wrap[ 0 ] === 'repeat' ) { texture.wrapS = RepeatWrapping; }
  					if ( wrap[ 0 ] === 'mirror' ) { texture.wrapS = MirroredRepeatWrapping; }

  					if ( wrap[ 1 ] === 'repeat' ) { texture.wrapT = RepeatWrapping; }
  					if ( wrap[ 1 ] === 'mirror' ) { texture.wrapT = MirroredRepeatWrapping; }

  				}

  				if ( anisotropy !== undefined ) {

  					texture.anisotropy = anisotropy;

  				}

  				var uuid = _Math.generateUUID();

  				textures[ uuid ] = texture;

  				return uuid;

  			}

  			//

  			var json = {
  				uuid: _Math.generateUUID(),
  				type: 'MeshLambertMaterial'
  			};

  			for ( var name in m ) {

  				var value = m[ name ];

  				switch ( name ) {

  					case 'DbgColor':
  					case 'DbgIndex':
  					case 'opticalDensity':
  					case 'illumination':
  						break;
  					case 'DbgName':
  						json.name = value;
  						break;
  					case 'blending':
  						json.blending = BlendingMode[ value ];
  						break;
  					case 'colorAmbient':
  					case 'mapAmbient':
  						console.warn( 'Loader.createMaterial:', name, 'is no longer supported.' );
  						break;
  					case 'colorDiffuse':
  						json.color = color.fromArray( value ).getHex();
  						break;
  					case 'colorSpecular':
  						json.specular = color.fromArray( value ).getHex();
  						break;
  					case 'colorEmissive':
  						json.emissive = color.fromArray( value ).getHex();
  						break;
  					case 'specularCoef':
  						json.shininess = value;
  						break;
  					case 'shading':
  						if ( value.toLowerCase() === 'basic' ) { json.type = 'MeshBasicMaterial'; }
  						if ( value.toLowerCase() === 'phong' ) { json.type = 'MeshPhongMaterial'; }
  						if ( value.toLowerCase() === 'standard' ) { json.type = 'MeshStandardMaterial'; }
  						break;
  					case 'mapDiffuse':
  						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
  						break;
  					case 'mapDiffuseRepeat':
  					case 'mapDiffuseOffset':
  					case 'mapDiffuseWrap':
  					case 'mapDiffuseAnisotropy':
  						break;
  					case 'mapEmissive':
  						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
  						break;
  					case 'mapEmissiveRepeat':
  					case 'mapEmissiveOffset':
  					case 'mapEmissiveWrap':
  					case 'mapEmissiveAnisotropy':
  						break;
  					case 'mapLight':
  						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
  						break;
  					case 'mapLightRepeat':
  					case 'mapLightOffset':
  					case 'mapLightWrap':
  					case 'mapLightAnisotropy':
  						break;
  					case 'mapAO':
  						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
  						break;
  					case 'mapAORepeat':
  					case 'mapAOOffset':
  					case 'mapAOWrap':
  					case 'mapAOAnisotropy':
  						break;
  					case 'mapBump':
  						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
  						break;
  					case 'mapBumpScale':
  						json.bumpScale = value;
  						break;
  					case 'mapBumpRepeat':
  					case 'mapBumpOffset':
  					case 'mapBumpWrap':
  					case 'mapBumpAnisotropy':
  						break;
  					case 'mapNormal':
  						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
  						break;
  					case 'mapNormalFactor':
  						json.normalScale = value;
  						break;
  					case 'mapNormalRepeat':
  					case 'mapNormalOffset':
  					case 'mapNormalWrap':
  					case 'mapNormalAnisotropy':
  						break;
  					case 'mapSpecular':
  						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
  						break;
  					case 'mapSpecularRepeat':
  					case 'mapSpecularOffset':
  					case 'mapSpecularWrap':
  					case 'mapSpecularAnisotropy':
  						break;
  					case 'mapMetalness':
  						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
  						break;
  					case 'mapMetalnessRepeat':
  					case 'mapMetalnessOffset':
  					case 'mapMetalnessWrap':
  					case 'mapMetalnessAnisotropy':
  						break;
  					case 'mapRoughness':
  						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
  						break;
  					case 'mapRoughnessRepeat':
  					case 'mapRoughnessOffset':
  					case 'mapRoughnessWrap':
  					case 'mapRoughnessAnisotropy':
  						break;
  					case 'mapAlpha':
  						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
  						break;
  					case 'mapAlphaRepeat':
  					case 'mapAlphaOffset':
  					case 'mapAlphaWrap':
  					case 'mapAlphaAnisotropy':
  						break;
  					case 'flipSided':
  						json.side = BackSide;
  						break;
  					case 'doubleSided':
  						json.side = DoubleSide;
  						break;
  					case 'transparency':
  						console.warn( 'Loader.createMaterial: transparency has been renamed to opacity' );
  						json.opacity = value;
  						break;
  					case 'depthTest':
  					case 'depthWrite':
  					case 'colorWrite':
  					case 'opacity':
  					case 'reflectivity':
  					case 'transparent':
  					case 'visible':
  					case 'wireframe':
  						json[ name ] = value;
  						break;
  					case 'vertexColors':
  						if ( value === true ) { json.vertexColors = VertexColors; }
  						if ( value === 'face' ) { json.vertexColors = FaceColors; }
  						break;
  					default:
  						console.error( 'Loader.createMaterial: Unsupported', name, value );
  						break;

  				}

  			}

  			if ( json.type === 'MeshBasicMaterial' ) { delete json.emissive; }
  			if ( json.type !== 'MeshPhongMaterial' ) { delete json.specular; }

  			if ( json.opacity < 1 ) { json.transparent = true; }

  			materialLoader.setTextures( textures );

  			return materialLoader.parse( json );

  		};

  	} )()

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LegacyGLTFLoader = ( function () {

  	function LegacyGLTFLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	LegacyGLTFLoader.prototype = {

  		constructor: LegacyGLTFLoader,

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var resourcePath;

  			if ( this.resourcePath !== undefined ) {

  				resourcePath = this.resourcePath;

  			} else if ( this.path !== undefined ) {

  				resourcePath = this.path;

  			} else {

  				resourcePath = LoaderUtils.extractUrlBase( url );

  			}

  			var loader = new FileLoader( scope.manager );

  			loader.setPath( this.path );
  			loader.setResponseType( 'arraybuffer' );

  			loader.load( url, function ( data ) {

  				scope.parse( data, resourcePath, onLoad );

  			}, onProgress, onError );

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;

  		},

  		setResourcePath: function ( value ) {

  			this.resourcePath = value;
  			return this;

  		},

  		parse: function ( data, path, callback ) {

  			var content;
  			var extensions = {};

  			var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

  			if ( magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic ) {

  				extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );
  				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

  			} else {

  				content = LoaderUtils.decodeText( new Uint8Array( data ) );

  			}

  			var json = JSON.parse( content );

  			if ( json.extensionsUsed && json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_COMMON ) >= 0 ) {

  				extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] = new GLTFMaterialsCommonExtension( json );

  			}

  			var parser = new GLTFParser( json, extensions, {

  				crossOrigin: this.crossOrigin,
  				manager: this.manager,
  				path: path || this.resourcePath || ''

  			} );

  			parser.parse( function ( scene, scenes, cameras, animations ) {

  				var glTF = {
  					"scene": scene,
  					"scenes": scenes,
  					"cameras": cameras,
  					"animations": animations
  				};

  				callback( glTF );

  			} );

  		}

  	};
  	function GLTFRegistry() {

  		var objects = {};

  		return	{

  			get: function ( key ) {

  				return objects[ key ];

  			},

  			add: function ( key, object ) {

  				objects[ key ] = object;

  			},

  			remove: function ( key ) {

  				delete objects[ key ];

  			},

  			removeAll: function () {

  				objects = {};

  			},

  			update: function ( scene, camera ) {

  				for ( var name in objects ) {

  					var object = objects[ name ];

  					if ( object.update ) {

  						object.update( scene, camera );

  					}

  				}

  			}

  		};

  	}
  	LegacyGLTFLoader.Shaders = {

  		update: function () {

  			console.warn( 'LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.' );

  		}

  	};
  	function GLTFShader( targetNode, allNodes ) {

  		var boundUniforms = {};

  		// bind each uniform to its source node

  		var uniforms = targetNode.material.uniforms;

  		for ( var uniformId in uniforms ) {

  			var uniform = uniforms[ uniformId ];

  			if ( uniform.semantic ) {

  				var sourceNodeRef = uniform.node;

  				var sourceNode = targetNode;

  				if ( sourceNodeRef ) {

  					sourceNode = allNodes[ sourceNodeRef ];

  				}

  				boundUniforms[ uniformId ] = {
  					semantic: uniform.semantic,
  					sourceNode: sourceNode,
  					targetNode: targetNode,
  					uniform: uniform
  				};

  			}

  		}

  		this.boundUniforms = boundUniforms;
  		this._m4 = new Matrix4();

  	}

  	// Update - update all the uniform values
  	GLTFShader.prototype.update = function ( scene, camera ) {
  		var this$1 = this;


  		var boundUniforms = this.boundUniforms;

  		for ( var name in boundUniforms ) {

  			var boundUniform = boundUniforms[ name ];

  			switch ( boundUniform.semantic ) {

  				case "MODELVIEW":

  					var m4 = boundUniform.uniform.value;
  					m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
  					break;

  				case "MODELVIEWINVERSETRANSPOSE":

  					var m3 = boundUniform.uniform.value;
  					this$1._m4.multiplyMatrices( camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld );
  					m3.getNormalMatrix( this$1._m4 );
  					break;

  				case "PROJECTION":

  					var m4 = boundUniform.uniform.value;
  					m4.copy( camera.projectionMatrix );
  					break;

  				case "JOINTMATRIX":

  					var m4v = boundUniform.uniform.value;

  					for ( var mi = 0; mi < m4v.length; mi ++ ) {

  						// So it goes like this:
  						// SkinnedMesh world matrix is already baked into MODELVIEW;
  						// transform joints to local space,
  						// then transform using joint's inverse
  						m4v[ mi ]
  							.getInverse( boundUniform.sourceNode.matrixWorld )
  							.multiply( boundUniform.targetNode.skeleton.bones[ mi ].matrixWorld )
  							.multiply( boundUniform.targetNode.skeleton.boneInverses[ mi ] )
  							.multiply( boundUniform.targetNode.bindMatrix );

  					}

  					break;

  				default :

  					console.warn( "Unhandled shader semantic: " + boundUniform.semantic );
  					break;

  			}

  		}

  	};
  	LegacyGLTFLoader.Animations = {

  		update: function () {

  			console.warn( 'LegacyGLTFLoader.Animation has been deprecated. Use AnimationMixer instead.' );

  		}

  	};
  	var EXTENSIONS = {
  		KHR_BINARY_GLTF: 'KHR_binary_glTF',
  		KHR_MATERIALS_COMMON: 'KHR_materials_common'
  	};
  	function GLTFMaterialsCommonExtension( json ) {
  		var this$1 = this;


  		this.name = EXTENSIONS.KHR_MATERIALS_COMMON;

  		this.lights = {};

  		var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) || {};
  		var lights = extension.lights || {};

  		for ( var lightId in lights ) {

  			var light = lights[ lightId ];
  			var lightNode;

  			var lightParams = light[ light.type ];
  			var color = new Color().fromArray( lightParams.color );

  			switch ( light.type ) {

  				case "directional":
  					lightNode = new DirectionalLight( color );
  					lightNode.position.set( 0, 0, 1 );
  					break;

  				case "point":
  					lightNode = new PointLight( color );
  					break;

  				case "spot":
  					lightNode = new SpotLight( color );
  					lightNode.position.set( 0, 0, 1 );
  					break;

  				case "ambient":
  					lightNode = new AmbientLight( color );
  					break;

  			}

  			if ( lightNode ) {

  				this$1.lights[ lightId ] = lightNode;

  			}

  		}

  	}
  	var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';

  	var BINARY_EXTENSION_HEADER_DEFAULTS = { magic: 'glTF', version: 1, contentFormat: 0 };

  	var BINARY_EXTENSION_HEADER_LENGTH = 20;

  	function GLTFBinaryExtension( data ) {

  		this.name = EXTENSIONS.KHR_BINARY_GLTF;

  		var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

  		var header = {
  			magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
  			version: headerView.getUint32( 4, true ),
  			length: headerView.getUint32( 8, true ),
  			contentLength: headerView.getUint32( 12, true ),
  			contentFormat: headerView.getUint32( 16, true )
  		};

  		for ( var key in BINARY_EXTENSION_HEADER_DEFAULTS ) {

  			var value = BINARY_EXTENSION_HEADER_DEFAULTS[ key ];

  			if ( header[ key ] !== value ) {

  				throw new Error( 'Unsupported glTF-Binary header: Expected "%s" to be "%s".', key, value );

  			}

  		}

  		var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH, header.contentLength );

  		this.header = header;
  		this.content = LoaderUtils.decodeText( contentArray );
  		this.body = data.slice( BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length );

  	}

  	GLTFBinaryExtension.prototype.loadShader = function ( shader, bufferViews ) {

  		var bufferView = bufferViews[ shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].bufferView ];
  		var array = new Uint8Array( bufferView );

  		return LoaderUtils.decodeText( array );

  	};
  	var WEBGL_CONSTANTS = {
  		FLOAT: 5126,
  		//FLOAT_MAT2: 35674,
  		FLOAT_MAT3: 35675,
  		FLOAT_MAT4: 35676,
  		FLOAT_VEC2: 35664,
  		FLOAT_VEC3: 35665,
  		FLOAT_VEC4: 35666,
  		LINEAR: 9729,
  		REPEAT: 10497,
  		SAMPLER_2D: 35678,
  		TRIANGLES: 4,
  		LINES: 1,
  		UNSIGNED_BYTE: 5121,
  		UNSIGNED_SHORT: 5123,

  		VERTEX_SHADER: 35633,
  		FRAGMENT_SHADER: 35632
  	};

  	var WEBGL_TYPE = {
  		5126: Number,
  		//35674: Matrix2,
  		35675: Matrix3,
  		35676: Matrix4,
  		35664: Vector2,
  		35665: Vector3,
  		35666: Vector4,
  		35678: Texture
  	};

  	var WEBGL_COMPONENT_TYPES = {
  		5120: Int8Array,
  		5121: Uint8Array,
  		5122: Int16Array,
  		5123: Uint16Array,
  		5125: Uint32Array,
  		5126: Float32Array
  	};

  	var WEBGL_FILTERS = {
  		9728: NearestFilter,
  		9729: LinearFilter,
  		9984: NearestMipMapNearestFilter,
  		9985: LinearMipMapNearestFilter,
  		9986: NearestMipMapLinearFilter,
  		9987: LinearMipMapLinearFilter
  	};

  	var WEBGL_WRAPPINGS = {
  		33071: ClampToEdgeWrapping,
  		33648: MirroredRepeatWrapping,
  		10497: RepeatWrapping
  	};

  	var WEBGL_TEXTURE_FORMATS = {
  		6406: AlphaFormat,
  		6407: RGBFormat,
  		6408: RGBAFormat,
  		6409: LuminanceFormat,
  		6410: LuminanceAlphaFormat
  	};

  	var WEBGL_TEXTURE_DATATYPES = {
  		5121: UnsignedByteType,
  		32819: UnsignedShort4444Type,
  		32820: UnsignedShort5551Type,
  		33635: UnsignedShort565Type
  	};

  	var WEBGL_SIDES = {
  		1028: BackSide, // Culling front
  		1029: FrontSide // Culling back
  		//1032: NoSide   // Culling front and back, what to do?
  	};

  	var WEBGL_DEPTH_FUNCS = {
  		512: NeverDepth,
  		513: LessDepth,
  		514: EqualDepth,
  		515: LessEqualDepth,
  		516: GreaterEqualDepth,
  		517: NotEqualDepth,
  		518: GreaterEqualDepth,
  		519: AlwaysDepth
  	};

  	var WEBGL_BLEND_EQUATIONS = {
  		32774: AddEquation,
  		32778: SubtractEquation,
  		32779: ReverseSubtractEquation
  	};

  	var WEBGL_BLEND_FUNCS = {
  		0: ZeroFactor,
  		1: OneFactor,
  		768: SrcColorFactor,
  		769: OneMinusSrcColorFactor,
  		770: SrcAlphaFactor,
  		771: OneMinusSrcAlphaFactor,
  		772: DstAlphaFactor,
  		773: OneMinusDstAlphaFactor,
  		774: DstColorFactor,
  		775: OneMinusDstColorFactor,
  		776: SrcAlphaSaturateFactor
  		// The followings are not supported by Three.js yet
  		//32769: CONSTANT_COLOR,
  		//32770: ONE_MINUS_CONSTANT_COLOR,
  		//32771: CONSTANT_ALPHA,
  		//32772: ONE_MINUS_CONSTANT_COLOR
  	};

  	var WEBGL_TYPE_SIZES = {
  		'SCALAR': 1,
  		'VEC2': 2,
  		'VEC3': 3,
  		'VEC4': 4,
  		'MAT2': 4,
  		'MAT3': 9,
  		'MAT4': 16
  	};

  	var PATH_PROPERTIES = {
  		scale: 'scale',
  		translation: 'position',
  		rotation: 'quaternion'
  	};

  	var INTERPOLATION = {
  		LINEAR: InterpolateLinear,
  		STEP: InterpolateDiscrete
  	};

  	var STATES_ENABLES = {
  		2884: 'CULL_FACE',
  		2929: 'DEPTH_TEST',
  		3042: 'BLEND',
  		3089: 'SCISSOR_TEST',
  		32823: 'POLYGON_OFFSET_FILL',
  		32926: 'SAMPLE_ALPHA_TO_COVERAGE'
  	};
  	function _each( object, callback, thisObj ) {
  		var this$1 = this;


  		if ( ! object ) {

  			return Promise.resolve();

  		}

  		var results;
  		var fns = [];

  		if ( Object.prototype.toString.call( object ) === '[object Array]' ) {

  			results = [];

  			var length = object.length;

  			for ( var idx = 0; idx < length; idx ++ ) {

  				var value = callback.call( thisObj || this$1, object[ idx ], idx );

  				if ( value ) {

  					fns.push( value );

  					if ( value instanceof Promise ) {

  						value.then( function ( key, value ) {

  							results[ key ] = value;

  						}.bind( this$1, idx ) );

  					} else {

  						results[ idx ] = value;

  					}

  				}

  			}

  		} else {

  			results = {};

  			for ( var key in object ) {

  				if ( object.hasOwnProperty( key ) ) {

  					var value = callback.call( thisObj || this$1, object[ key ], key );

  					if ( value ) {

  						fns.push( value );

  						if ( value instanceof Promise ) {

  							value.then( function ( key, value ) {

  								results[ key ] = value;

  							}.bind( this$1, key ) );

  						} else {

  							results[ key ] = value;

  						}

  					}

  				}

  			}

  		}

  		return Promise.all( fns ).then( function () {

  			return results;

  		} );

  	}

  	function resolveURL( url, path ) {

  		// Invalid URL
  		if ( typeof url !== 'string' || url === '' )
  			{ return ''; }

  		// Absolute URL http://,https://,//
  		if ( /^(https?:)?\/\//i.test( url ) ) {

  			return url;

  		}

  		// Data URI
  		if ( /^data:.*,.*$/i.test( url ) ) {

  			return url;

  		}

  		// Blob URL
  		if ( /^blob:.*$/i.test( url ) ) {

  			return url;

  		}

  		// Relative URL
  		return ( path || '' ) + url;

  	}

  	// Three.js seems too dependent on attribute names so globally
  	// replace those in the shader code
  	function replaceTHREEShaderAttributes( shaderText, technique ) {

  		// Expected technique attributes
  		var attributes = {};

  		for ( var attributeId in technique.attributes ) {

  			var pname = technique.attributes[ attributeId ];

  			var param = technique.parameters[ pname ];
  			var atype = param.type;
  			var semantic = param.semantic;

  			attributes[ attributeId ] = {
  				type: atype,
  				semantic: semantic
  			};

  		}

  		// Figure out which attributes to change in technique

  		var shaderParams = technique.parameters;
  		var shaderAttributes = technique.attributes;
  		var params = {};

  		for ( var attributeId in attributes ) {

  			var pname = shaderAttributes[ attributeId ];
  			var shaderParam = shaderParams[ pname ];
  			var semantic = shaderParam.semantic;
  			if ( semantic ) {

  				params[ attributeId ] = shaderParam;

  			}

  		}

  		for ( var pname in params ) {

  			var param = params[ pname ];
  			var semantic = param.semantic;

  			var regEx = new RegExp( "\\b" + pname + "\\b", "g" );

  			switch ( semantic ) {

  				case "POSITION":

  					shaderText = shaderText.replace( regEx, 'position' );
  					break;

  				case "NORMAL":

  					shaderText = shaderText.replace( regEx, 'normal' );
  					break;

  				case 'TEXCOORD_0':
  				case 'TEXCOORD0':
  				case 'TEXCOORD':

  					shaderText = shaderText.replace( regEx, 'uv' );
  					break;

  				case 'TEXCOORD_1':

  					shaderText = shaderText.replace( regEx, 'uv2' );
  					break;

  				case 'COLOR_0':
  				case 'COLOR0':
  				case 'COLOR':

  					shaderText = shaderText.replace( regEx, 'color' );
  					break;

  				case "WEIGHT":

  					shaderText = shaderText.replace( regEx, 'skinWeight' );
  					break;

  				case "JOINT":

  					shaderText = shaderText.replace( regEx, 'skinIndex' );
  					break;

  			}

  		}

  		return shaderText;

  	}

  	function createDefaultMaterial() {

  		return new MeshPhongMaterial( {
  			color: 0x00000,
  			emissive: 0x888888,
  			specular: 0x000000,
  			shininess: 0,
  			transparent: false,
  			depthTest: true,
  			side: FrontSide
  		} );

  	}

  	// Deferred constructor for RawShaderMaterial types
  	function DeferredShaderMaterial( params ) {

  		this.isDeferredShaderMaterial = true;

  		this.params = params;

  	}

  	DeferredShaderMaterial.prototype.create = function () {
  		var this$1 = this;


  		var uniforms = UniformsUtils.clone( this.params.uniforms );

  		for ( var uniformId in this$1.params.uniforms ) {

  			var originalUniform = this$1.params.uniforms[ uniformId ];

  			if ( originalUniform.value instanceof Texture ) {

  				uniforms[ uniformId ].value = originalUniform.value;
  				uniforms[ uniformId ].value.needsUpdate = true;

  			}

  			uniforms[ uniformId ].semantic = originalUniform.semantic;
  			uniforms[ uniformId ].node = originalUniform.node;

  		}

  		this.params.uniforms = uniforms;

  		return new RawShaderMaterial( this.params );

  	};
  	function GLTFParser( json, extensions, options ) {

  		this.json = json || {};
  		this.extensions = extensions || {};
  		this.options = options || {};

  		// loader object cache
  		this.cache = new GLTFRegistry();

  	}

  	GLTFParser.prototype._withDependencies = function ( dependencies ) {
  		var this$1 = this;


  		var _dependencies = {};

  		for ( var i = 0; i < dependencies.length; i ++ ) {

  			var dependency = dependencies[ i ];
  			var fnName = "load" + dependency.charAt( 0 ).toUpperCase() + dependency.slice( 1 );

  			var cached = this$1.cache.get( dependency );

  			if ( cached !== undefined ) {

  				_dependencies[ dependency ] = cached;

  			} else if ( this$1[ fnName ] ) {

  				var fn = this$1[ fnName ]();
  				this$1.cache.add( dependency, fn );

  				_dependencies[ dependency ] = fn;

  			}

  		}

  		return _each( _dependencies, function ( dependency ) {

  			return dependency;

  		} );

  	};

  	GLTFParser.prototype.parse = function ( callback ) {

  		var json = this.json;

  		// Clear the loader cache
  		this.cache.removeAll();

  		// Fire the callback on complete
  		this._withDependencies( [

  			"scenes",
  			"cameras",
  			"animations"

  		] ).then( function ( dependencies ) {

  			var scenes = [];

  			for ( var name in dependencies.scenes ) {

  				scenes.push( dependencies.scenes[ name ] );

  			}

  			var scene = json.scene !== undefined ? dependencies.scenes[ json.scene ] : scenes[ 0 ];

  			var cameras = [];

  			for ( var name in dependencies.cameras ) {

  				var camera = dependencies.cameras[ name ];
  				cameras.push( camera );

  			}

  			var animations = [];

  			for ( var name in dependencies.animations ) {

  				animations.push( dependencies.animations[ name ] );

  			}

  			callback( scene, scenes, cameras, animations );

  		} );

  	};

  	GLTFParser.prototype.loadShaders = function () {

  		var json = this.json;
  		var extensions = this.extensions;
  		var options = this.options;

  		return this._withDependencies( [

  			"bufferViews"

  		] ).then( function ( dependencies ) {

  			return _each( json.shaders, function ( shader ) {

  				if ( shader.extensions && shader.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {

  					return extensions[ EXTENSIONS.KHR_BINARY_GLTF ].loadShader( shader, dependencies.bufferViews );

  				}

  				return new Promise( function ( resolve ) {

  					var loader = new FileLoader( options.manager );
  					loader.setResponseType( 'text' );
  					loader.load( resolveURL( shader.uri, options.path ), function ( shaderText ) {

  						resolve( shaderText );

  					} );

  				} );

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadBuffers = function () {

  		var json = this.json;
  		var extensions = this.extensions;
  		var options = this.options;

  		return _each( json.buffers, function ( buffer, name ) {

  			if ( name === BINARY_EXTENSION_BUFFER_NAME ) {

  				return extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body;

  			}

  			if ( buffer.type === 'arraybuffer' || buffer.type === undefined ) {

  				return new Promise( function ( resolve ) {

  					var loader = new FileLoader( options.manager );
  					loader.setResponseType( 'arraybuffer' );
  					loader.load( resolveURL( buffer.uri, options.path ), function ( buffer ) {

  						resolve( buffer );

  					} );

  				} );

  			} else {

  				console.warn( 'LegacyGLTFLoader: ' + buffer.type + ' buffer type is not supported' );

  			}

  		} );

  	};

  	GLTFParser.prototype.loadBufferViews = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"buffers"

  		] ).then( function ( dependencies ) {

  			return _each( json.bufferViews, function ( bufferView ) {

  				var arraybuffer = dependencies.buffers[ bufferView.buffer ];

  				var byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;

  				return arraybuffer.slice( bufferView.byteOffset, bufferView.byteOffset + byteLength );

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadAccessors = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"bufferViews"

  		] ).then( function ( dependencies ) {

  			return _each( json.accessors, function ( accessor ) {

  				var arraybuffer = dependencies.bufferViews[ accessor.bufferView ];
  				var itemSize = WEBGL_TYPE_SIZES[ accessor.type ];
  				var TypedArray = WEBGL_COMPONENT_TYPES[ accessor.componentType ];

  				// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
  				var elementBytes = TypedArray.BYTES_PER_ELEMENT;
  				var itemBytes = elementBytes * itemSize;

  				// The buffer is not interleaved if the stride is the item size in bytes.
  				if ( accessor.byteStride && accessor.byteStride !== itemBytes ) {

  					// Use the full buffer if it's interleaved.
  					var array = new TypedArray( arraybuffer );

  					// Integer parameters to IB/IBA are in array elements, not bytes.
  					var ib = new InterleavedBuffer( array, accessor.byteStride / elementBytes );

  					return new InterleavedBufferAttribute( ib, itemSize, accessor.byteOffset / elementBytes );

  				} else {

  					array = new TypedArray( arraybuffer, accessor.byteOffset, accessor.count * itemSize );

  					return new BufferAttribute( array, itemSize );

  				}

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadTextures = function () {

  		var json = this.json;
  		var extensions = this.extensions;
  		var options = this.options;

  		return this._withDependencies( [

  			"bufferViews"

  		] ).then( function ( dependencies ) {

  			return _each( json.textures, function ( texture ) {

  				if ( texture.source ) {

  					return new Promise( function ( resolve ) {

  						var source = json.images[ texture.source ];
  						var sourceUri = source.uri;
  						var isObjectURL = false;

  						if ( source.extensions && source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ] ) {

  							var metadata = source.extensions[ EXTENSIONS.KHR_BINARY_GLTF ];
  							var bufferView = dependencies.bufferViews[ metadata.bufferView ];
  							var blob = new Blob( [ bufferView ], { type: metadata.mimeType } );
  							sourceUri = URL.createObjectURL( blob );
  							isObjectURL = true;

  						}

  						var textureLoader = Loader$1.Handlers.get( sourceUri );

  						if ( textureLoader === null ) {

  							textureLoader = new TextureLoader( options.manager );

  						}

  						textureLoader.setCrossOrigin( options.crossOrigin );

  						textureLoader.load( resolveURL( sourceUri, options.path ), function ( _texture ) {

  							if ( isObjectURL ) { URL.revokeObjectURL( sourceUri ); }

  							_texture.flipY = false;

  							if ( texture.name !== undefined ) { _texture.name = texture.name; }

  							_texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[ texture.format ] : RGBAFormat;

  							if ( texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[ texture.internalFormat ] ) {

  								console.warn( 'LegacyGLTFLoader: Three.js doesn\'t support texture internalFormat which is different from texture format. ' +
  															'internalFormat will be forced to be the same value as format.' );

  							}

  							_texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ texture.type ] : UnsignedByteType;

  							if ( texture.sampler ) {

  								var sampler = json.samplers[ texture.sampler ];

  								_texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
  								_texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || NearestMipMapLinearFilter;
  								_texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
  								_texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

  							}

  							resolve( _texture );

  						}, undefined, function () {

  							if ( isObjectURL ) { URL.revokeObjectURL( sourceUri ); }

  							resolve();

  						} );

  					} );

  				}

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadMaterials = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"shaders",
  			"textures"

  		] ).then( function ( dependencies ) {

  			return _each( json.materials, function ( material ) {

  				var materialType;
  				var materialValues = {};
  				var materialParams = {};

  				var khr_material;

  				if ( material.extensions && material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ] ) {

  					khr_material = material.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ];

  				}

  				if ( khr_material ) {

  					// don't copy over unused values to avoid material warning spam
  					var keys = [ 'ambient', 'emission', 'transparent', 'transparency', 'doubleSided' ];

  					switch ( khr_material.technique ) {

  						case 'BLINN' :
  						case 'PHONG' :
  							materialType = MeshPhongMaterial;
  							keys.push( 'diffuse', 'specular', 'shininess' );
  							break;

  						case 'LAMBERT' :
  							materialType = MeshLambertMaterial;
  							keys.push( 'diffuse' );
  							break;

  						case 'CONSTANT' :
  						default :
  							materialType = MeshBasicMaterial;
  							break;

  					}

  					keys.forEach( function ( v ) {

  						if ( khr_material.values[ v ] !== undefined ) { materialValues[ v ] = khr_material.values[ v ]; }

  					} );

  					if ( khr_material.doubleSided || materialValues.doubleSided ) {

  						materialParams.side = DoubleSide;

  					}

  					if ( khr_material.transparent || materialValues.transparent ) {

  						materialParams.transparent = true;
  						materialParams.opacity = ( materialValues.transparency !== undefined ) ? materialValues.transparency : 1;

  					}

  				} else if ( material.technique === undefined ) {

  					materialType = MeshPhongMaterial;

  					Object.assign( materialValues, material.values );

  				} else {

  					materialType = DeferredShaderMaterial;

  					var technique = json.techniques[ material.technique ];

  					materialParams.uniforms = {};

  					var program = json.programs[ technique.program ];

  					if ( program ) {

  						materialParams.fragmentShader = dependencies.shaders[ program.fragmentShader ];

  						if ( ! materialParams.fragmentShader ) {

  							console.warn( "ERROR: Missing fragment shader definition:", program.fragmentShader );
  							materialType = MeshPhongMaterial;

  						}

  						var vertexShader = dependencies.shaders[ program.vertexShader ];

  						if ( ! vertexShader ) {

  							console.warn( "ERROR: Missing vertex shader definition:", program.vertexShader );
  							materialType = MeshPhongMaterial;

  						}

  						// IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS
  						materialParams.vertexShader = replaceTHREEShaderAttributes( vertexShader, technique );

  						var uniforms = technique.uniforms;

  						for ( var uniformId in uniforms ) {

  							var pname = uniforms[ uniformId ];
  							var shaderParam = technique.parameters[ pname ];

  							var ptype = shaderParam.type;

  							if ( WEBGL_TYPE[ ptype ] ) {

  								var pcount = shaderParam.count;
  								var value;

  								if ( material.values !== undefined ) { value = material.values[ pname ]; }

  								var uvalue = new WEBGL_TYPE[ ptype ]();
  								var usemantic = shaderParam.semantic;
  								var unode = shaderParam.node;

  								switch ( ptype ) {

  									case WEBGL_CONSTANTS.FLOAT:

  										uvalue = shaderParam.value;

  										if ( pname == "transparency" ) {

  											materialParams.transparent = true;

  										}

  										if ( value !== undefined ) {

  											uvalue = value;

  										}

  										break;

  									case WEBGL_CONSTANTS.FLOAT_VEC2:
  									case WEBGL_CONSTANTS.FLOAT_VEC3:
  									case WEBGL_CONSTANTS.FLOAT_VEC4:
  									case WEBGL_CONSTANTS.FLOAT_MAT3:

  										if ( shaderParam && shaderParam.value ) {

  											uvalue.fromArray( shaderParam.value );

  										}

  										if ( value ) {

  											uvalue.fromArray( value );

  										}

  										break;

  									case WEBGL_CONSTANTS.FLOAT_MAT2:

  										// what to do?
  										console.warn( "FLOAT_MAT2 is not a supported uniform type" );
  										break;

  									case WEBGL_CONSTANTS.FLOAT_MAT4:

  										if ( pcount ) {

  											uvalue = new Array( pcount );

  											for ( var mi = 0; mi < pcount; mi ++ ) {

  												uvalue[ mi ] = new WEBGL_TYPE[ ptype ]();

  											}

  											if ( shaderParam && shaderParam.value ) {

  												var m4v = shaderParam.value;
  												uvalue.fromArray( m4v );

  											}

  											if ( value ) {

  												uvalue.fromArray( value );

  											}

  										} else {

  											if ( shaderParam && shaderParam.value ) {

  												var m4 = shaderParam.value;
  												uvalue.fromArray( m4 );

  											}

  											if ( value ) {

  												uvalue.fromArray( value );

  											}

  										}

  										break;

  									case WEBGL_CONSTANTS.SAMPLER_2D:

  										if ( value !== undefined ) {

  											uvalue = dependencies.textures[ value ];

  										} else if ( shaderParam.value !== undefined ) {

  											uvalue = dependencies.textures[ shaderParam.value ];

  										} else {

  											uvalue = null;

  										}

  										break;

  								}

  								materialParams.uniforms[ uniformId ] = {
  									value: uvalue,
  									semantic: usemantic,
  									node: unode
  								};

  							} else {

  								throw new Error( "Unknown shader uniform param type: " + ptype );

  							}

  						}

  						var states = technique.states || {};
  						var enables = states.enable || [];
  						var functions = states.functions || {};

  						var enableCullFace = false;
  						var enableDepthTest = false;
  						var enableBlend = false;

  						for ( var i = 0, il = enables.length; i < il; i ++ ) {

  							var enable = enables[ i ];

  							switch ( STATES_ENABLES[ enable ] ) {

  								case 'CULL_FACE':

  									enableCullFace = true;

  									break;

  								case 'DEPTH_TEST':

  									enableDepthTest = true;

  									break;

  								case 'BLEND':

  									enableBlend = true;

  									break;

  								// TODO: implement
  								case 'SCISSOR_TEST':
  								case 'POLYGON_OFFSET_FILL':
  								case 'SAMPLE_ALPHA_TO_COVERAGE':

  									break;

  								default:

  									throw new Error( "Unknown technique.states.enable: " + enable );

  							}

  						}

  						if ( enableCullFace ) {

  							materialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[ functions.cullFace ] : FrontSide;

  						} else {

  							materialParams.side = DoubleSide;

  						}

  						materialParams.depthTest = enableDepthTest;
  						materialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[ functions.depthFunc ] : LessDepth;
  						materialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[ 0 ] : true;

  						materialParams.blending = enableBlend ? CustomBlending : NoBlending;
  						materialParams.transparent = enableBlend;

  						var blendEquationSeparate = functions.blendEquationSeparate;

  						if ( blendEquationSeparate !== undefined ) {

  							materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 0 ] ];
  							materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[ blendEquationSeparate[ 1 ] ];

  						} else {

  							materialParams.blendEquation = AddEquation;
  							materialParams.blendEquationAlpha = AddEquation;

  						}

  						var blendFuncSeparate = functions.blendFuncSeparate;

  						if ( blendFuncSeparate !== undefined ) {

  							materialParams.blendSrc = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 0 ] ];
  							materialParams.blendDst = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 1 ] ];
  							materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 2 ] ];
  							materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[ blendFuncSeparate[ 3 ] ];

  						} else {

  							materialParams.blendSrc = OneFactor;
  							materialParams.blendDst = ZeroFactor;
  							materialParams.blendSrcAlpha = OneFactor;
  							materialParams.blendDstAlpha = ZeroFactor;

  						}

  					}

  				}

  				if ( Array.isArray( materialValues.diffuse ) ) {

  					materialParams.color = new Color().fromArray( materialValues.diffuse );

  				} else if ( typeof ( materialValues.diffuse ) === 'string' ) {

  					materialParams.map = dependencies.textures[ materialValues.diffuse ];

  				}

  				delete materialParams.diffuse;

  				if ( typeof ( materialValues.reflective ) === 'string' ) {

  					materialParams.envMap = dependencies.textures[ materialValues.reflective ];

  				}

  				if ( typeof ( materialValues.bump ) === 'string' ) {

  					materialParams.bumpMap = dependencies.textures[ materialValues.bump ];

  				}

  				if ( Array.isArray( materialValues.emission ) ) {

  					if ( materialType === MeshBasicMaterial ) {

  						materialParams.color = new Color().fromArray( materialValues.emission );

  					} else {

  						materialParams.emissive = new Color().fromArray( materialValues.emission );

  					}

  				} else if ( typeof ( materialValues.emission ) === 'string' ) {

  					if ( materialType === MeshBasicMaterial ) {

  						materialParams.map = dependencies.textures[ materialValues.emission ];

  					} else {

  						materialParams.emissiveMap = dependencies.textures[ materialValues.emission ];

  					}

  				}

  				if ( Array.isArray( materialValues.specular ) ) {

  					materialParams.specular = new Color().fromArray( materialValues.specular );

  				} else if ( typeof ( materialValues.specular ) === 'string' ) {

  					materialParams.specularMap = dependencies.textures[ materialValues.specular ];

  				}

  				if ( materialValues.shininess !== undefined ) {

  					materialParams.shininess = materialValues.shininess;

  				}

  				var _material = new materialType( materialParams );
  				if ( material.name !== undefined ) { _material.name = material.name; }

  				return _material;

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadMeshes = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"accessors",
  			"materials"

  		] ).then( function ( dependencies ) {

  			return _each( json.meshes, function ( mesh ) {

  				var group = new Group();
  				if ( mesh.name !== undefined ) { group.name = mesh.name; }

  				if ( mesh.extras ) { group.userData = mesh.extras; }

  				var primitives = mesh.primitives || [];

  				for ( var name in primitives ) {

  					var primitive = primitives[ name ];

  					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined ) {

  						var geometry = new BufferGeometry();

  						var attributes = primitive.attributes;

  						for ( var attributeId in attributes ) {

  							var attributeEntry = attributes[ attributeId ];

  							if ( ! attributeEntry ) { return; }

  							var bufferAttribute = dependencies.accessors[ attributeEntry ];

  							switch ( attributeId ) {

  								case 'POSITION':
  									geometry.addAttribute( 'position', bufferAttribute );
  									break;

  								case 'NORMAL':
  									geometry.addAttribute( 'normal', bufferAttribute );
  									break;

  								case 'TEXCOORD_0':
  								case 'TEXCOORD0':
  								case 'TEXCOORD':
  									geometry.addAttribute( 'uv', bufferAttribute );
  									break;

  								case 'TEXCOORD_1':
  									geometry.addAttribute( 'uv2', bufferAttribute );
  									break;

  								case 'COLOR_0':
  								case 'COLOR0':
  								case 'COLOR':
  									geometry.addAttribute( 'color', bufferAttribute );
  									break;

  								case 'WEIGHT':
  									geometry.addAttribute( 'skinWeight', bufferAttribute );
  									break;

  								case 'JOINT':
  									geometry.addAttribute( 'skinIndex', bufferAttribute );
  									break;

  								default:

  									if ( ! primitive.material ) { break; }

  									var material = json.materials[ primitive.material ];

  									if ( ! material.technique ) { break; }

  									var parameters = json.techniques[ material.technique ].parameters || {};

  									for ( var attributeName in parameters ) {

  										if ( parameters[ attributeName ][ 'semantic' ] === attributeId ) {

  											geometry.addAttribute( attributeName, bufferAttribute );

  										}

  									}

  							}

  						}

  						if ( primitive.indices ) {

  							geometry.setIndex( dependencies.accessors[ primitive.indices ] );

  						}

  						var material = dependencies.materials !== undefined ? dependencies.materials[ primitive.material ] : createDefaultMaterial();

  						var meshNode = new Mesh( geometry, material );
  						meshNode.castShadow = true;
  						meshNode.name = ( name === "0" ? group.name : group.name + name );

  						if ( primitive.extras ) { meshNode.userData = primitive.extras; }

  						group.add( meshNode );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

  						var geometry = new BufferGeometry();

  						var attributes = primitive.attributes;

  						for ( var attributeId in attributes ) {

  							var attributeEntry = attributes[ attributeId ];

  							if ( ! attributeEntry ) { return; }

  							var bufferAttribute = dependencies.accessors[ attributeEntry ];

  							switch ( attributeId ) {

  								case 'POSITION':
  									geometry.addAttribute( 'position', bufferAttribute );
  									break;

  								case 'COLOR_0':
  								case 'COLOR0':
  								case 'COLOR':
  									geometry.addAttribute( 'color', bufferAttribute );
  									break;

  							}

  						}

  						var material = dependencies.materials[ primitive.material ];

  						var meshNode;

  						if ( primitive.indices ) {

  							geometry.setIndex( dependencies.accessors[ primitive.indices ] );

  							meshNode = new LineSegments( geometry, material );

  						} else {

  							meshNode = new Line( geometry, material );

  						}

  						meshNode.name = ( name === "0" ? group.name : group.name + name );

  						if ( primitive.extras ) { meshNode.userData = primitive.extras; }

  						group.add( meshNode );

  					} else {

  						console.warn( "Only triangular and line primitives are supported" );

  					}

  				}

  				return group;

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadCameras = function () {

  		var json = this.json;

  		return _each( json.cameras, function ( camera ) {

  			if ( camera.type == "perspective" && camera.perspective ) {

  				var yfov = camera.perspective.yfov;
  				var aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1;

  				// According to COLLADA spec...
  				// aspectRatio = xfov / yfov
  				var xfov = yfov * aspectRatio;

  				var _camera = new PerspectiveCamera( _Math.radToDeg( xfov ), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6 );
  				if ( camera.name !== undefined ) { _camera.name = camera.name; }

  				if ( camera.extras ) { _camera.userData = camera.extras; }

  				return _camera;

  			} else if ( camera.type == "orthographic" && camera.orthographic ) {

  				var _camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, camera.orthographic.znear, camera.orthographic.zfar );
  				if ( camera.name !== undefined ) { _camera.name = camera.name; }

  				if ( camera.extras ) { _camera.userData = camera.extras; }

  				return _camera;

  			}

  		} );

  	};

  	GLTFParser.prototype.loadSkins = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"accessors"

  		] ).then( function ( dependencies ) {

  			return _each( json.skins, function ( skin ) {

  				var bindShapeMatrix = new Matrix4();

  				if ( skin.bindShapeMatrix !== undefined ) { bindShapeMatrix.fromArray( skin.bindShapeMatrix ); }

  				var _skin = {
  					bindShapeMatrix: bindShapeMatrix,
  					jointNames: skin.jointNames,
  					inverseBindMatrices: dependencies.accessors[ skin.inverseBindMatrices ]
  				};

  				return _skin;

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadAnimations = function () {

  		var json = this.json;

  		return this._withDependencies( [

  			"accessors",
  			"nodes"

  		] ).then( function ( dependencies ) {

  			return _each( json.animations, function ( animation, animationId ) {

  				var tracks = [];

  				for ( var channelId in animation.channels ) {

  					var channel = animation.channels[ channelId ];
  					var sampler = animation.samplers[ channel.sampler ];

  					if ( sampler ) {

  						var target = channel.target;
  						var name = target.id;
  						var input = animation.parameters !== undefined ? animation.parameters[ sampler.input ] : sampler.input;
  						var output = animation.parameters !== undefined ? animation.parameters[ sampler.output ] : sampler.output;

  						var inputAccessor = dependencies.accessors[ input ];
  						var outputAccessor = dependencies.accessors[ output ];

  						var node = dependencies.nodes[ name ];

  						if ( node ) {

  							node.updateMatrix();
  							node.matrixAutoUpdate = true;

  							var TypedKeyframeTrack = PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.rotation
  								? QuaternionKeyframeTrack
  								: VectorKeyframeTrack;

  							var targetName = node.name ? node.name : node.uuid;
  							var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

  							// KeyframeTrack.optimize() will modify given 'times' and 'values'
  							// buffers before creating a truncated copy to keep. Because buffers may
  							// be reused by other tracks, make copies here.
  							tracks.push( new TypedKeyframeTrack(
  								targetName + '.' + PATH_PROPERTIES[ target.path ],
  								AnimationUtils.arraySlice( inputAccessor.array, 0 ),
  								AnimationUtils.arraySlice( outputAccessor.array, 0 ),
  								interpolation
  							) );

  						}

  					}

  				}

  				var name = animation.name !== undefined ? animation.name : "animation_" + animationId;

  				return new AnimationClip( name, undefined, tracks );

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadNodes = function () {

  		var json = this.json;
  		var extensions = this.extensions;
  		var scope = this;

  		return _each( json.nodes, function ( node ) {

  			var matrix = new Matrix4();

  			var _node;

  			if ( node.jointName ) {

  				_node = new Bone();
  				_node.name = node.name !== undefined ? node.name : node.jointName;
  				_node.jointName = node.jointName;

  			} else {

  				_node = new Object3D();
  				if ( node.name !== undefined ) { _node.name = node.name; }

  			}

  			if ( node.extras ) { _node.userData = node.extras; }

  			if ( node.matrix !== undefined ) {

  				matrix.fromArray( node.matrix );
  				_node.applyMatrix( matrix );

  			} else {

  				if ( node.translation !== undefined ) {

  					_node.position.fromArray( node.translation );

  				}

  				if ( node.rotation !== undefined ) {

  					_node.quaternion.fromArray( node.rotation );

  				}

  				if ( node.scale !== undefined ) {

  					_node.scale.fromArray( node.scale );

  				}

  			}

  			return _node;

  		} ).then( function ( __nodes ) {

  			return scope._withDependencies( [

  				"meshes",
  				"skins",
  				"cameras"

  			] ).then( function ( dependencies ) {

  				return _each( __nodes, function ( _node, nodeId ) {

  					var node = json.nodes[ nodeId ];

  					if ( node.meshes !== undefined ) {

  						for ( var meshId in node.meshes ) {

  							var mesh = node.meshes[ meshId ];
  							var group = dependencies.meshes[ mesh ];

  							if ( group === undefined ) {

  								console.warn( 'LegacyGLTFLoader: Couldn\'t find node "' + mesh + '".' );
  								continue;

  							}

  							for ( var childrenId in group.children ) {

  								var child = group.children[ childrenId ];

  								// clone Mesh to add to _node

  								var originalMaterial = child.material;
  								var originalGeometry = child.geometry;
  								var originalUserData = child.userData;
  								var originalName = child.name;

  								var material;

  								if ( originalMaterial.isDeferredShaderMaterial ) {

  									originalMaterial = material = originalMaterial.create();

  								} else {

  									material = originalMaterial;

  								}

  								switch ( child.type ) {

  									case 'LineSegments':
  										child = new LineSegments( originalGeometry, material );
  										break;

  									case 'LineLoop':
  										child = new LineLoop( originalGeometry, material );
  										break;

  									case 'Line':
  										child = new Line( originalGeometry, material );
  										break;

  									default:
  										child = new Mesh( originalGeometry, material );

  								}

  								child.castShadow = true;
  								child.userData = originalUserData;
  								child.name = originalName;

  								var skinEntry;

  								if ( node.skin ) {

  									skinEntry = dependencies.skins[ node.skin ];

  								}

  								// Replace Mesh with SkinnedMesh in library
  								if ( skinEntry ) {

  									var getJointNode = function ( jointId ) {

  										var keys = Object.keys( __nodes );

  										for ( var i = 0, il = keys.length; i < il; i ++ ) {

  											var n = __nodes[ keys[ i ] ];

  											if ( n.jointName === jointId ) { return n; }

  										}

  										return null;

  									};

  									var geometry = originalGeometry;
  									var material = originalMaterial;
  									material.skinning = true;

  									child = new SkinnedMesh( geometry, material );
  									child.castShadow = true;
  									child.userData = originalUserData;
  									child.name = originalName;

  									var bones = [];
  									var boneInverses = [];

  									for ( var i = 0, l = skinEntry.jointNames.length; i < l; i ++ ) {

  										var jointId = skinEntry.jointNames[ i ];
  										var jointNode = getJointNode( jointId );

  										if ( jointNode ) {

  											bones.push( jointNode );

  											var m = skinEntry.inverseBindMatrices.array;
  											var mat = new Matrix4().fromArray( m, i * 16 );
  											boneInverses.push( mat );

  										} else {

  											console.warn( "WARNING: joint: '" + jointId + "' could not be found" );

  										}

  									}

  									child.bind( new Skeleton( bones, boneInverses ), skinEntry.bindShapeMatrix );

  									var buildBoneGraph = function ( parentJson, parentObject, property ) {

  										var children = parentJson[ property ];

  										if ( children === undefined ) { return; }

  										for ( var i = 0, il = children.length; i < il; i ++ ) {

  											var nodeId = children[ i ];
  											var bone = __nodes[ nodeId ];
  											var boneJson = json.nodes[ nodeId ];

  											if ( bone !== undefined && bone.isBone === true && boneJson !== undefined ) {

  												parentObject.add( bone );
  												buildBoneGraph( boneJson, bone, 'children' );

  											}

  										}

  									};

  									buildBoneGraph( node, child, 'skeletons' );

  								}

  								_node.add( child );

  							}

  						}

  					}

  					if ( node.camera !== undefined ) {

  						var camera = dependencies.cameras[ node.camera ];

  						_node.add( camera );

  					}

  					if ( node.extensions
  							 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ]
  							 && node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ) {

  						var extensionLights = extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].lights;
  						var light = extensionLights[ node.extensions[ EXTENSIONS.KHR_MATERIALS_COMMON ].light ];

  						_node.add( light );

  					}

  					return _node;

  				} );

  			} );

  		} );

  	};

  	GLTFParser.prototype.loadScenes = function () {

  		var json = this.json;

  		// scene node hierachy builder

  		function buildNodeHierachy( nodeId, parentObject, allNodes ) {

  			var _node = allNodes[ nodeId ];
  			parentObject.add( _node );

  			var node = json.nodes[ nodeId ];

  			if ( node.children ) {

  				var children = node.children;

  				for ( var i = 0, l = children.length; i < l; i ++ ) {

  					var child = children[ i ];
  					buildNodeHierachy( child, _node, allNodes );

  				}

  			}

  		}

  		return this._withDependencies( [

  			"nodes"

  		] ).then( function ( dependencies ) {

  			return _each( json.scenes, function ( scene ) {

  				var _scene = new Scene();
  				if ( scene.name !== undefined ) { _scene.name = scene.name; }

  				if ( scene.extras ) { _scene.userData = scene.extras; }

  				var nodes = scene.nodes || [];

  				for ( var i = 0, l = nodes.length; i < l; i ++ ) {

  					var nodeId = nodes[ i ];
  					buildNodeHierachy( nodeId, _scene, dependencies.nodes );

  				}

  				_scene.traverse( function ( child ) {

  					// Register raw material meshes with LegacyGLTFLoader.Shaders
  					if ( child.material && child.material.isRawShaderMaterial ) {

  						child.gltfShader = new GLTFShader( child, dependencies.nodes );
  						child.onBeforeRender = function ( renderer, scene, camera ) {

  							this.gltfShader.update( scene, camera );

  						};

  					}

  				} );

  				return _scene;

  			} );

  		} );

  	};

  	return LegacyGLTFLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LegacyJSONLoader = ( function () {

  	function LegacyJSONLoader( manager ) {

  		if ( typeof manager === 'boolean' ) {

  			console.warn( 'JSONLoader: showStatus parameter has been removed from constructor.' );
  			manager = undefined;

  		}

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.withCredentials = false;

  	}

  	Object.assign( LegacyJSONLoader.prototype, {

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;

  			var loader = new FileLoader( this.manager );
  			loader.setPath( this.path );
  			loader.setWithCredentials( this.withCredentials );
  			loader.load( url, function ( text ) {

  				var json = JSON.parse( text );
  				var metadata = json.metadata;

  				if ( metadata !== undefined ) {

  					var type = metadata.type;

  					if ( type !== undefined ) {

  						if ( type.toLowerCase() === 'object' ) {

  							console.error( 'JSONLoader: ' + url + ' should be loaded with ObjectLoader instead.' );
  							return;

  						}

  					}

  				}

  				var object = scope.parse( json, path );
  				onLoad( object.geometry, object.materials );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setResourcePath: function ( value ) {

  			this.resourcePath = value;
  			return this;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		parse: ( function () {

  			function parseModel( json, geometry ) {

  				function isBitSet( value, position ) {

  					return value & ( 1 << position );

  				}

  				var i, j, fi,

  					offset, zLength,

  					colorIndex, normalIndex, uvIndex, materialIndex,

  					type,
  					isQuad,
  					hasMaterial,
  					hasFaceVertexUv,
  					hasFaceNormal, hasFaceVertexNormal,
  					hasFaceColor, hasFaceVertexColor,

  					vertex, face, faceA, faceB, hex, normal,

  					uvLayer, uv, u, v,

  					faces = json.faces,
  					vertices = json.vertices,
  					normals = json.normals,
  					colors = json.colors,

  					scale = json.scale,

  					nUvLayers = 0;
  				if ( json.uvs !== undefined ) {

  					// disregard empty arrays

  					for ( i = 0; i < json.uvs.length; i ++ ) {

  						if ( json.uvs[ i ].length ) { nUvLayers ++; }

  					}

  					for ( i = 0; i < nUvLayers; i ++ ) {

  						geometry.faceVertexUvs[ i ] = [];

  					}

  				}

  				offset = 0;
  				zLength = vertices.length;

  				while ( offset < zLength ) {

  					vertex = new Vector3();

  					vertex.x = vertices[ offset ++ ] * scale;
  					vertex.y = vertices[ offset ++ ] * scale;
  					vertex.z = vertices[ offset ++ ] * scale;

  					geometry.vertices.push( vertex );

  				}

  				offset = 0;
  				zLength = faces.length;

  				while ( offset < zLength ) {

  					type = faces[ offset ++ ];

  					isQuad = isBitSet( type, 0 );
  					hasMaterial = isBitSet( type, 1 );
  					hasFaceVertexUv = isBitSet( type, 3 );
  					hasFaceNormal = isBitSet( type, 4 );
  					hasFaceVertexNormal = isBitSet( type, 5 );
  					hasFaceColor = isBitSet( type, 6 );
  					hasFaceVertexColor = isBitSet( type, 7 );

  					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

  					if ( isQuad ) {

  						faceA = new Face3();
  						faceA.a = faces[ offset ];
  						faceA.b = faces[ offset + 1 ];
  						faceA.c = faces[ offset + 3 ];

  						faceB = new Face3();
  						faceB.a = faces[ offset + 1 ];
  						faceB.b = faces[ offset + 2 ];
  						faceB.c = faces[ offset + 3 ];

  						offset += 4;

  						if ( hasMaterial ) {

  							materialIndex = faces[ offset ++ ];
  							faceA.materialIndex = materialIndex;
  							faceB.materialIndex = materialIndex;

  						}

  						// to get face <=> uv index correspondence

  						fi = geometry.faces.length;

  						if ( hasFaceVertexUv ) {

  							for ( i = 0; i < nUvLayers; i ++ ) {

  								uvLayer = json.uvs[ i ];

  								geometry.faceVertexUvs[ i ][ fi ] = [];
  								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

  								for ( j = 0; j < 4; j ++ ) {

  									uvIndex = faces[ offset ++ ];

  									u = uvLayer[ uvIndex * 2 ];
  									v = uvLayer[ uvIndex * 2 + 1 ];

  									uv = new Vector2( u, v );

  									if ( j !== 2 ) { geometry.faceVertexUvs[ i ][ fi ].push( uv ); }
  									if ( j !== 0 ) { geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv ); }

  								}

  							}

  						}

  						if ( hasFaceNormal ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							faceA.normal.set(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);

  							faceB.normal.copy( faceA.normal );

  						}

  						if ( hasFaceVertexNormal ) {

  							for ( i = 0; i < 4; i ++ ) {

  								normalIndex = faces[ offset ++ ] * 3;

  								normal = new Vector3(
  									normals[ normalIndex ++ ],
  									normals[ normalIndex ++ ],
  									normals[ normalIndex ]
  								);
  								if ( i !== 2 ) { faceA.vertexNormals.push( normal ); }
  								if ( i !== 0 ) { faceB.vertexNormals.push( normal ); }

  							}

  						}
  						if ( hasFaceColor ) {

  							colorIndex = faces[ offset ++ ];
  							hex = colors[ colorIndex ];

  							faceA.color.setHex( hex );
  							faceB.color.setHex( hex );

  						}
  						if ( hasFaceVertexColor ) {

  							for ( i = 0; i < 4; i ++ ) {

  								colorIndex = faces[ offset ++ ];
  								hex = colors[ colorIndex ];

  								if ( i !== 2 ) { faceA.vertexColors.push( new Color( hex ) ); }
  								if ( i !== 0 ) { faceB.vertexColors.push( new Color( hex ) ); }

  							}

  						}

  						geometry.faces.push( faceA );
  						geometry.faces.push( faceB );

  					} else {

  						face = new Face3();
  						face.a = faces[ offset ++ ];
  						face.b = faces[ offset ++ ];
  						face.c = faces[ offset ++ ];

  						if ( hasMaterial ) {

  							materialIndex = faces[ offset ++ ];
  							face.materialIndex = materialIndex;

  						}

  						// to get face <=> uv index correspondence

  						fi = geometry.faces.length;

  						if ( hasFaceVertexUv ) {

  							for ( i = 0; i < nUvLayers; i ++ ) {

  								uvLayer = json.uvs[ i ];

  								geometry.faceVertexUvs[ i ][ fi ] = [];

  								for ( j = 0; j < 3; j ++ ) {

  									uvIndex = faces[ offset ++ ];

  									u = uvLayer[ uvIndex * 2 ];
  									v = uvLayer[ uvIndex * 2 + 1 ];

  									uv = new Vector2( u, v );

  									geometry.faceVertexUvs[ i ][ fi ].push( uv );

  								}

  							}

  						}

  						if ( hasFaceNormal ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							face.normal.set(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);

  						}

  						if ( hasFaceVertexNormal ) {

  							for ( i = 0; i < 3; i ++ ) {

  								normalIndex = faces[ offset ++ ] * 3;

  								normal = new Vector3(
  									normals[ normalIndex ++ ],
  									normals[ normalIndex ++ ],
  									normals[ normalIndex ]
  								);

  								face.vertexNormals.push( normal );

  							}

  						}
  						if ( hasFaceColor ) {

  							colorIndex = faces[ offset ++ ];
  							face.color.setHex( colors[ colorIndex ] );

  						}
  						if ( hasFaceVertexColor ) {

  							for ( i = 0; i < 3; i ++ ) {

  								colorIndex = faces[ offset ++ ];
  								face.vertexColors.push( new Color( colors[ colorIndex ] ) );

  							}

  						}

  						geometry.faces.push( face );

  					}

  				}

  			}

  			function parseSkin( json, geometry ) {

  				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

  				if ( json.skinWeights ) {

  					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

  						var x = json.skinWeights[ i ];
  						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
  						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
  						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

  						geometry.skinWeights.push( new Vector4( x, y, z, w ) );

  					}

  				}

  				if ( json.skinIndices ) {

  					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

  						var a = json.skinIndices[ i ];
  						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
  						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
  						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

  						geometry.skinIndices.push( new Vector4( a, b, c, d ) );

  					}

  				}

  				geometry.bones = json.bones;

  				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

  					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
  						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

  				}

  			}

  			function parseMorphing( json, geometry ) {

  				var scale = json.scale;

  				if ( json.morphTargets !== undefined ) {

  					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

  						geometry.morphTargets[ i ] = {};
  						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
  						geometry.morphTargets[ i ].vertices = [];

  						var dstVertices = geometry.morphTargets[ i ].vertices;
  						var srcVertices = json.morphTargets[ i ].vertices;

  						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

  							var vertex = new Vector3();
  							vertex.x = srcVertices[ v ] * scale;
  							vertex.y = srcVertices[ v + 1 ] * scale;
  							vertex.z = srcVertices[ v + 2 ] * scale;

  							dstVertices.push( vertex );

  						}

  					}

  				}

  				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

  					console.warn( 'JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

  					var faces = geometry.faces;
  					var morphColors = json.morphColors[ 0 ].colors;

  					for ( var i = 0, l = faces.length; i < l; i ++ ) {

  						faces[ i ].color.fromArray( morphColors, i * 3 );

  					}

  				}

  			}

  			function parseAnimations( json, geometry ) {

  				var outputAnimations = [];

  				// parse old style Bone/Hierarchy animations
  				var animations = [];

  				if ( json.animation !== undefined ) {

  					animations.push( json.animation );

  				}

  				if ( json.animations !== undefined ) {

  					if ( json.animations.length ) {

  						animations = animations.concat( json.animations );

  					} else {

  						animations.push( json.animations );

  					}

  				}

  				for ( var i = 0; i < animations.length; i ++ ) {

  					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
  					if ( clip ) { outputAnimations.push( clip ); }

  				}

  				// parse implicit morph animations
  				if ( geometry.morphTargets ) {

  					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
  					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
  					outputAnimations = outputAnimations.concat( morphAnimationClips );

  				}

  				if ( outputAnimations.length > 0 ) { geometry.animations = outputAnimations; }

  			}

  			return function parse( json, path ) {

  				if ( json.data !== undefined ) {

  					// Geometry 4.0 spec
  					json = json.data;

  				}

  				if ( json.scale !== undefined ) {

  					json.scale = 1.0 / json.scale;

  				} else {

  					json.scale = 1.0;

  				}

  				var geometry = new Geometry();

  				parseModel( json, geometry );
  				parseSkin( json, geometry );
  				parseMorphing( json, geometry );
  				parseAnimations( json, geometry );

  				geometry.computeFaceNormals();
  				geometry.computeBoundingSphere();

  				if ( json.materials === undefined || json.materials.length === 0 ) {

  					return { geometry: geometry };

  				} else {

  					var materials = Loader$1.prototype.initMaterials( json.materials, this.resourcePath || path, this.crossOrigin );

  					return { geometry: geometry, materials: materials };

  				}

  			};

  		} )()

  	} );

  	return LegacyJSONLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DRACOLoader$1 = function(manager) {
      this.timeLoaded = 0;
      this.manager = manager || DefaultLoadingManager;
      this.materials = null;
      this.verbosity = 0;
      this.attributeOptions = {};
      this.drawMode = TrianglesDrawMode;
      // Native Draco attribute type to Three.JS attribute type.
      this.nativeAttributeMap = {
        'position' : 'POSITION',
        'normal' : 'NORMAL',
        'color' : 'COLOR',
        'uv' : 'TEX_COORD'
      };
  };

  DRACOLoader$1.prototype = {

      constructor: DRACOLoader$1,

      load: function(url, onLoad, onProgress, onError) {
          var scope = this;
          var loader = new FileLoader(scope.manager);
          loader.setPath(this.path);
          loader.setResponseType('arraybuffer');
          loader.load(url, function(blob) {
              scope.decodeDracoFile(blob, onLoad);
          }, onProgress, onError);
      },

      setPath: function(value) {
          this.path = value;
          return this;
      },

      setVerbosity: function(level) {
          this.verbosity = level;
          return this;
      },
      setDrawMode: function(drawMode) {
          this.drawMode = drawMode;
          return this;
      },
      setSkipDequantization: function(attributeName, skip) {
          var skipDequantization = true;
          if (typeof skip !== 'undefined')
            { skipDequantization = skip; }
          this.getAttributeOptions(attributeName).skipDequantization =
              skipDequantization;
          return this;
      },
      decodeDracoFile: function(rawBuffer, callback, attributeUniqueIdMap,
                                attributeTypeMap) {
        var scope = this;
        DRACOLoader$1.getDecoderModule()
            .then( function ( module ) {
              scope.decodeDracoFileInternal( rawBuffer, module.decoder, callback,
                attributeUniqueIdMap, attributeTypeMap);
            });
      },

      decodeDracoFileInternal: function(rawBuffer, dracoDecoder, callback,
                                        attributeUniqueIdMap, attributeTypeMap) {
        
        var buffer = new dracoDecoder.DecoderBuffer();
        buffer.Init(new Int8Array(rawBuffer), rawBuffer.byteLength);
        var decoder = new dracoDecoder.Decoder();
        var geometryType = decoder.GetEncodedGeometryType(buffer);
        if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
          if (this.verbosity > 0) {
            console.log('Loaded a mesh.');
          }
        } else if (geometryType == dracoDecoder.POINT_CLOUD) {
          if (this.verbosity > 0) {
            console.log('Loaded a point cloud.');
          }
        } else {
          var errorMsg = 'DRACOLoader: Unknown geometry type.';
          console.error(errorMsg);
          throw new Error(errorMsg);
        }
        callback(this.convertDracoGeometryTo3JS(dracoDecoder, decoder,
            geometryType, buffer, attributeUniqueIdMap, attributeTypeMap));
      },

      addAttributeToGeometry: function(dracoDecoder, decoder, dracoGeometry,
                                       attributeName, attributeType, attribute,
                                       geometry, geometryBuffer) {
        if (attribute.ptr === 0) {
          var errorMsg = 'DRACOLoader: No attribute ' + attributeName;
          console.error(errorMsg);
          throw new Error(errorMsg);
        }

        var numComponents = attribute.num_components();
        var numPoints = dracoGeometry.num_points();
        var numValues = numPoints * numComponents;
        var attributeData;
        var TypedBufferAttribute;

        switch ( attributeType ) {

          case Float32Array:
            attributeData = new dracoDecoder.DracoFloat32Array();
            decoder.GetAttributeFloatForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Float32Array( numValues );
            TypedBufferAttribute = Float32BufferAttribute;
            break;

          case Int8Array:
            attributeData = new dracoDecoder.DracoInt8Array();
            decoder.GetAttributeInt8ForAllPoints(
              dracoGeometry, attribute, attributeData );
            geometryBuffer[ attributeName ] = new Int8Array( numValues );
            TypedBufferAttribute = Int8BufferAttribute;
            break;

          case Int16Array:
            attributeData = new dracoDecoder.DracoInt16Array();
            decoder.GetAttributeInt16ForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Int16Array( numValues );
            TypedBufferAttribute = Int16BufferAttribute;
            break;

          case Int32Array:
            attributeData = new dracoDecoder.DracoInt32Array();
            decoder.GetAttributeInt32ForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Int32Array( numValues );
            TypedBufferAttribute = Int32BufferAttribute;
            break;

          case Uint8Array:
            attributeData = new dracoDecoder.DracoUInt8Array();
            decoder.GetAttributeUInt8ForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Uint8Array( numValues );
            TypedBufferAttribute = Uint8BufferAttribute;
            break;

          case Uint16Array:
            attributeData = new dracoDecoder.DracoUInt16Array();
            decoder.GetAttributeUInt16ForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Uint16Array( numValues );
            TypedBufferAttribute = Uint16BufferAttribute;
            break;

          case Uint32Array:
            attributeData = new dracoDecoder.DracoUInt32Array();
            decoder.GetAttributeUInt32ForAllPoints(
              dracoGeometry, attribute, attributeData);
            geometryBuffer[ attributeName ] = new Uint32Array( numValues );
            TypedBufferAttribute = Uint32BufferAttribute;
            break;

          default:
            var errorMsg = 'DRACOLoader: Unexpected attribute type.';
            console.error( errorMsg );
            throw new Error( errorMsg );

        }

        // Copy data from decoder.
        for (var i = 0; i < numValues; i++) {
          geometryBuffer[attributeName][i] = attributeData.GetValue(i);
        }
        // Add attribute to THREEJS geometry for rendering.
        geometry.addAttribute(attributeName,
            new TypedBufferAttribute(geometryBuffer[attributeName],
              numComponents));
        dracoDecoder.destroy(attributeData);
      },

      convertDracoGeometryTo3JS: function(dracoDecoder, decoder, geometryType,
                                          buffer, attributeUniqueIdMap,
                                          attributeTypeMap) {
          var this$1 = this;

          // TODO: Should not assume native Draco attribute IDs apply.
          if (this.getAttributeOptions('position').skipDequantization === true) {
            decoder.SkipAttributeTransform(dracoDecoder.POSITION);
          }
          var dracoGeometry;
          var decodingStatus;
          var start_time = performance.now();
          if (geometryType === dracoDecoder.TRIANGULAR_MESH) {
            dracoGeometry = new dracoDecoder.Mesh();
            decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          } else {
            dracoGeometry = new dracoDecoder.PointCloud();
            decodingStatus =
                decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          }
          if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {
            var errorMsg = 'DRACOLoader: Decoding failed: ';
            errorMsg += decodingStatus.error_msg();
            console.error(errorMsg);
            dracoDecoder.destroy(decoder);
            dracoDecoder.destroy(dracoGeometry);
            throw new Error(errorMsg);
          }

          var decode_end = performance.now();
          dracoDecoder.destroy(buffer);
          
          var numFaces;
          if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
            numFaces = dracoGeometry.num_faces();
            if (this.verbosity > 0) {
              console.log('Number of faces loaded: ' + numFaces.toString());
            }
          } else {
            numFaces = 0;
          }

          var numPoints = dracoGeometry.num_points();
          var numAttributes = dracoGeometry.num_attributes();
          if (this.verbosity > 0) {
            console.log('Number of points loaded: ' + numPoints.toString());
            console.log('Number of attributes loaded: ' +
                numAttributes.toString());
          }

          // Verify if there is position attribute.
          // TODO: Should not assume native Draco attribute IDs apply.
          var posAttId = decoder.GetAttributeId(dracoGeometry,
                                                dracoDecoder.POSITION);
          if (posAttId == -1) {
            var errorMsg = 'DRACOLoader: No position attribute found.';
            console.error(errorMsg);
            dracoDecoder.destroy(decoder);
            dracoDecoder.destroy(dracoGeometry);
            throw new Error(errorMsg);
          }
          var posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);

          // Structure for converting to THREEJS geometry later.
          var geometryBuffer = {};
          // Import data to Three JS geometry.
          var geometry = new BufferGeometry();

          // Do not use both the native attribute map and a provided (e.g. glTF) map.
          if ( attributeUniqueIdMap ) {

            // Add attributes of user specified unique id. E.g. GLTF models.
            for (var attributeName in attributeUniqueIdMap) {
              var attributeType = attributeTypeMap[attributeName];
              var attributeId = attributeUniqueIdMap[attributeName];
              var attribute = decoder.GetAttributeByUniqueId(dracoGeometry,
                                                             attributeId);
              this$1.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry,
                  attributeName, attributeType, attribute, geometry, geometryBuffer);
            }

          } else {

            // Add native Draco attribute type to geometry.
            for (var attributeName in this$1.nativeAttributeMap) {
              var attId = decoder.GetAttributeId(dracoGeometry,
                  dracoDecoder[this$1.nativeAttributeMap[attributeName]]);
              if (attId !== -1) {
                if (this$1.verbosity > 0) {
                  console.log('Loaded ' + attributeName + ' attribute.');
                }
                var attribute = decoder.GetAttribute(dracoGeometry, attId);
                this$1.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry,
                    attributeName, Float32Array, attribute, geometry, geometryBuffer);
              }
            }

          }

          // For mesh, we need to generate the faces.
          if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
            if (this.drawMode === TriangleStripDrawMode) {
              var stripsArray = new dracoDecoder.DracoInt32Array();
              var numStrips = decoder.GetTriangleStripsFromMesh(
                  dracoGeometry, stripsArray);
              geometryBuffer.indices = new Uint32Array(stripsArray.size());
              for (var i = 0; i < stripsArray.size(); ++i) {
                geometryBuffer.indices[i] = stripsArray.GetValue(i);
              }
              dracoDecoder.destroy(stripsArray);
            } else {
              var numIndices = numFaces * 3;
              geometryBuffer.indices = new Uint32Array(numIndices);
              var ia = new dracoDecoder.DracoInt32Array();
              for (var i = 0; i < numFaces; ++i) {
                decoder.GetFaceFromMesh(dracoGeometry, i, ia);
                var index = i * 3;
                geometryBuffer.indices[index] = ia.GetValue(0);
                geometryBuffer.indices[index + 1] = ia.GetValue(1);
                geometryBuffer.indices[index + 2] = ia.GetValue(2);
              }
              dracoDecoder.destroy(ia);
           }
          }

          geometry.drawMode = this.drawMode;
          if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
            geometry.setIndex(new(geometryBuffer.indices.length > 65535 ?
                  Uint32BufferAttribute : Uint16BufferAttribute)
                (geometryBuffer.indices, 1));
          }

          // TODO: Should not assume native Draco attribute IDs apply.
          // TODO: Can other attribute types be quantized?
          var posTransform = new dracoDecoder.AttributeQuantizationTransform();
          if (posTransform.InitFromAttribute(posAttribute)) {
            // Quantized attribute. Store the quantization parameters into the
            // js attribute.
            geometry.attributes['position'].isQuantized = true;
            geometry.attributes['position'].maxRange = posTransform.range();
            geometry.attributes['position'].numQuantizationBits =
                posTransform.quantization_bits();
            geometry.attributes['position'].minValues = new Float32Array(3);
            for (var i = 0; i < 3; ++i) {
              geometry.attributes['position'].minValues[i] =
                  posTransform.min_value(i);
            }
          }
          dracoDecoder.destroy(posTransform);
          dracoDecoder.destroy(decoder);
          dracoDecoder.destroy(dracoGeometry);

          this.decode_time = decode_end - start_time;
          this.import_time = performance.now() - decode_end;

          if (this.verbosity > 0) {
            console.log('Decode time: ' + this.decode_time);
            console.log('Import time: ' + this.import_time);
          }
          return geometry;
      },

      isVersionSupported: function(version, callback) {
          DRACOLoader$1.getDecoderModule()
              .then( function ( module ) {
                callback( module.decoder.isVersionSupported( version ) );
              });
      },

      getAttributeOptions: function(attributeName) {
          if (typeof this.attributeOptions[attributeName] === 'undefined')
            { this.attributeOptions[attributeName] = {}; }
          return this.attributeOptions[attributeName];
      }
  };

  DRACOLoader$1.decoderPath = './';
  DRACOLoader$1.decoderConfig = {};
  DRACOLoader$1.decoderModulePromise = null;
  DRACOLoader$1.setDecoderPath = function ( path ) {
    DRACOLoader$1.decoderPath = path;
  };
  DRACOLoader$1.setDecoderConfig = function ( config ) {
    var wasmBinary = DRACOLoader$1.decoderConfig.wasmBinary;
    DRACOLoader$1.decoderConfig = config || {};
    DRACOLoader$1.releaseDecoderModule();

    // Reuse WASM binary.
    if ( wasmBinary ) { DRACOLoader$1.decoderConfig.wasmBinary = wasmBinary; }
  };
  DRACOLoader$1.releaseDecoderModule = function () {
    DRACOLoader$1.decoderModulePromise = null;
  };
  DRACOLoader$1.getDecoderModule = function () {
    var scope = this;
    var path = DRACOLoader$1.decoderPath;
    var config = DRACOLoader$1.decoderConfig;
    var promise = DRACOLoader$1.decoderModulePromise;

    if ( promise ) { return promise; }

    // Load source files.
    if ( typeof DracoDecoderModule !== 'undefined' ) {
      // Loaded externally.
      promise = Promise.resolve();
    } else if ( typeof WebAssembly !== 'object' || config.type === 'js' ) {
      // Load with asm.js.
      promise = DRACOLoader$1._loadScript( path + 'draco_decoder.js' );
    } else {
      // Load with WebAssembly.
      config.wasmBinaryFile = path + 'draco_decoder.wasm';
      promise = DRACOLoader$1._loadScript( path + 'draco_wasm_wrapper.js' )
          .then( function () {
            return DRACOLoader$1._loadArrayBuffer( config.wasmBinaryFile );
          } )
          .then( function ( wasmBinary ) {
            config.wasmBinary = wasmBinary;
          } );
    }

    // Wait for source files, then create and return a decoder.
    promise = promise.then( function () {
      return new Promise( function ( resolve ) {
        config.onModuleLoaded = function ( decoder ) {
          scope.timeLoaded = performance.now();
          // Module is Promise-like. Wrap before resolving to avoid loop.
          resolve( { decoder: decoder } );
        };
        DracoDecoderModule( config );
      } );
    } );

    DRACOLoader$1.decoderModulePromise = promise;
    return promise;
  };
  DRACOLoader$1._loadScript = function ( src ) {
    var prevScript = document.getElementById( 'decoder_script' );
    if ( prevScript !== null ) {
      prevScript.parentNode.removeChild( prevScript );
    }
    var head = document.getElementsByTagName( 'head' )[ 0 ];
    var script = document.createElement( 'script' );
    script.id = 'decoder_script';
    script.type = 'text/javascript';
    script.src = src;
    return new Promise( function ( resolve ) {
      script.onload = resolve;
      head.appendChild( script );
    });
  };
  DRACOLoader$1._loadArrayBuffer = function ( src ) {
    var loader = new FileLoader();
    loader.setResponseType( 'arraybuffer' );
    return new Promise( function( resolve, reject ) {
      loader.load( src, resolve, undefined, reject );
    });
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLRenderTargetCube( width, height, options ) {

  	WebGLRenderTarget.call( this, width, height, options );

  }

  WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
  WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

  WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubeCamera( near, far, cubeResolution, options ) {

  	Object3D.call( this );

  	this.type = 'CubeCamera';

  	var fov = 90, aspect = 1;

  	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  	cameraPX.up.set( 0, - 1, 0 );
  	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
  	this.add( cameraPX );

  	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  	cameraNX.up.set( 0, - 1, 0 );
  	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
  	this.add( cameraNX );

  	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  	cameraPY.up.set( 0, 0, 1 );
  	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
  	this.add( cameraPY );

  	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  	cameraNY.up.set( 0, 0, - 1 );
  	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
  	this.add( cameraNY );

  	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  	cameraPZ.up.set( 0, - 1, 0 );
  	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
  	this.add( cameraPZ );

  	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  	cameraNZ.up.set( 0, - 1, 0 );
  	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
  	this.add( cameraNZ );

  	options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

  	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
  	this.renderTarget.texture.name = "CubeCamera";

  	this.update = function ( renderer, scene ) {

  		if ( this.parent === null ) { this.updateMatrixWorld(); }

  		var currentRenderTarget = renderer.getRenderTarget();

  		var renderTarget = this.renderTarget;
  		var generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderer.setRenderTarget( renderTarget, 0 );
  		renderer.render( scene, cameraPX );

  		renderer.setRenderTarget( renderTarget, 1 );
  		renderer.render( scene, cameraNX );

  		renderer.setRenderTarget( renderTarget, 2 );
  		renderer.render( scene, cameraPY );

  		renderer.setRenderTarget( renderTarget, 3 );
  		renderer.render( scene, cameraNY );

  		renderer.setRenderTarget( renderTarget, 4 );
  		renderer.render( scene, cameraPZ );

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderer.setRenderTarget( renderTarget, 5 );
  		renderer.render( scene, cameraNZ );

  		renderer.setRenderTarget( currentRenderTarget );

  	};

  	this.clear = function ( renderer, color, depth, stencil ) {

  		var currentRenderTarget = renderer.getRenderTarget();

  		var renderTarget = this.renderTarget;

  		for ( var i = 0; i < 6; i ++ ) {

  			renderer.setRenderTarget( renderTarget, i );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( currentRenderTarget );

  	};

  }

  CubeCamera.prototype = Object.create( Object3D.prototype );
  CubeCamera.prototype.constructor = CubeCamera;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CubemapGenerator = function ( renderer ) {

  	this.renderer = renderer;

  };

  CubemapGenerator.prototype.fromEquirectangular = function ( texture, options ) {

  	options = options || {};

  	var scene = new Scene();

  	var shader = {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader:

  			"\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t//include <common>\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t\t",

  		fragmentShader:

  			"\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t//include <common>\n\t\t\t#define RECIPROCAL_PI 0.31830988618\n\t\t\t#define RECIPROCAL_PI2 0.15915494\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV;\n\n\t\t\t\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\t\t\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t\t"
  	};

  	var material = new ShaderMaterial( {

  		type: 'CubemapFromEquirect',

  		uniforms: UniformsUtils.clone( shader.uniforms ),
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		side: BackSide,
  		blending: NoBlending

  	} );

  	material.uniforms.tEquirect.value = texture;

  	var mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );

  	scene.add( mesh );

  	var resolution = options.resolution || 512;

  	var params = {
  		type: texture.type,
  		format: texture.format,
  		encoding: texture.encoding,
  		generateMipmaps: ( options.generateMipmaps !== undefined ) ? options.generateMipmaps : texture.generateMipmaps,
  		minFilter: ( options.minFilter !== undefined ) ? options.minFilter : texture.minFilter,
  		magFilter: ( options.magFilter !== undefined ) ? options.magFilter : texture.magFilter
  	};

  	var camera = new CubeCamera( 1, 10, resolution, params );

  	camera.update( this.renderer, scene );

  	mesh.geometry.dispose();
  	mesh.material.dispose();

  	return camera.renderTarget;

  };

  //

  var EquirectangularToCubeGenerator = ( function () {

  	var camera = new PerspectiveCamera( 90, 1, 0.1, 10 );
  	var scene = new Scene();
  	var boxMesh = new Mesh( new BoxBufferGeometry( 1, 1, 1 ), getShader() );
  	boxMesh.material.side = BackSide;
  	scene.add( boxMesh );

  	var EquirectangularToCubeGenerator = function ( sourceTexture, options ) {

  		options = options || {};

  		this.sourceTexture = sourceTexture;
  		this.resolution = options.resolution || 512;

  		this.views = [
  			{ t: [ 1, 0, 0 ], u: [ 0, - 1, 0 ] },
  			{ t: [ - 1, 0, 0 ], u: [ 0, - 1, 0 ] },
  			{ t: [ 0, 1, 0 ], u: [ 0, 0, 1 ] },
  			{ t: [ 0, - 1, 0 ], u: [ 0, 0, - 1 ] },
  			{ t: [ 0, 0, 1 ], u: [ 0, - 1, 0 ] },
  			{ t: [ 0, 0, - 1 ], u: [ 0, - 1, 0 ] } ];

  		var params = {
  			format: options.format || this.sourceTexture.format,
  			magFilter: this.sourceTexture.magFilter,
  			minFilter: this.sourceTexture.minFilter,
  			type: options.type || this.sourceTexture.type,
  			generateMipmaps: this.sourceTexture.generateMipmaps,
  			anisotropy: this.sourceTexture.anisotropy,
  			encoding: this.sourceTexture.encoding
  		};

  		this.renderTarget = new WebGLRenderTargetCube( this.resolution, this.resolution, params );

  	};

  	EquirectangularToCubeGenerator.prototype = {

  		constructor: EquirectangularToCubeGenerator,

  		update: function ( renderer ) {
  			var this$1 = this;


  			var currentRenderTarget = renderer.getRenderTarget();

  			boxMesh.material.uniforms.equirectangularMap.value = this.sourceTexture;

  			for ( var i = 0; i < 6; i ++ ) {

  				var v = this$1.views[ i ];

  				camera.position.set( 0, 0, 0 );
  				camera.up.set( v.u[ 0 ], v.u[ 1 ], v.u[ 2 ] );
  				camera.lookAt( v.t[ 0 ], v.t[ 1 ], v.t[ 2 ] );

  				renderer.setRenderTarget( this$1.renderTarget, i );
  				renderer.clear();
  				renderer.render( scene, camera );

  			}

  			renderer.setRenderTarget( currentRenderTarget );

  			return this.renderTarget.texture;

  		},

  		dispose: function () {

  			this.renderTarget.dispose();

  		}

  	};

  	function getShader() {

  		var shaderMaterial = new ShaderMaterial( {

  			uniforms: {
  				"equirectangularMap": { value: null },
  			},

  			vertexShader:
          "varying vec3 localPosition;\n\
        \n\
        void main() {\n\
          localPosition = position;\n\
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
        }",

  			fragmentShader:
          "#include <common>\n\
        varying vec3 localPosition;\n\
        uniform sampler2D equirectangularMap;\n\
        \n\
        vec2 EquirectangularSampleUV(vec3 v) {\n\
          vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n\
          uv *= vec2(0.1591, 0.3183); // inverse atan\n\
          uv += 0.5;\n\
          return uv;\n\
        }\n\
        \n\
        void main() {\n\
          vec2 uv = EquirectangularSampleUV(normalize(localPosition));\n\
          gl_FragColor = texture2D(equirectangularMap, uv);\n\
        }",

  			blending: NoBlending

  		} );

  		shaderMaterial.type = 'EquirectangularToCubeGenerator';

  		return shaderMaterial;

  	}

  	return EquirectangularToCubeGenerator;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DataTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( DataTextureLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texture = new DataTexture();

  		var loader = new FileLoader( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setPath( this.path );
  		loader.load( url, function ( buffer ) {

  			var texData = scope._parser( buffer );

  			if ( ! texData ) { return; }

  			if ( texData.image !== undefined ) {

  				texture.image = texData.image;

  			} else if ( texData.data !== undefined ) {

  				texture.image.width = texData.width;
  				texture.image.height = texData.height;
  				texture.image.data = texData.data;

  			}

  			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
  			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

  			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
  			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;

  			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

  			if ( texData.format !== undefined ) {

  				texture.format = texData.format;

  			}
  			if ( texData.type !== undefined ) {

  				texture.type = texData.type;

  			}

  			if ( texData.mipmaps !== undefined ) {

  				texture.mipmaps = texData.mipmaps;

  			}

  			if ( texData.mipmapCount === 1 ) {

  				texture.minFilter = LinearFilter;

  			}

  			texture.needsUpdate = true;

  			if ( onLoad ) { onLoad( texture, texData ); }

  		}, onProgress, onError );
  		return texture;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // 

  // // TinyEXR contains some OpenEXR code, which is licensed under ------------

  // ///////////////////////////////////////////////////////////////////////////
  // //
  // // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
  // // Digital Ltd. LLC
  // //
  // // All rights reserved.
  // //
  // // Redistribution and use in source and binary forms, with or without
  // // modification, are permitted provided that the following conditions are
  // // met:
  // // *       Redistributions of source code must retain the above copyright
  // // notice, this list of conditions and the following disclaimer.
  // // *       Redistributions in binary form must reproduce the above
  // // copyright notice, this list of conditions and the following disclaimer
  // // in the documentation and/or other materials provided with the
  // // distribution.
  // // *       Neither the name of Industrial Light & Magic nor the names of
  // // its contributors may be used to endorse or promote products derived
  // // from this software without specific prior written permission.
  // //
  // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  // //
  // ///////////////////////////////////////////////////////////////////////////

  // // End of OpenEXR license -------------------------------------------------

  var EXRLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  EXRLoader.prototype = Object.create( DataTextureLoader.prototype );

  EXRLoader.prototype._parser = function ( buffer ) {

  	var USHORT_RANGE = (1 << 16);
  	var BITMAP_SIZE = (USHORT_RANGE >> 3);

  	var HUF_ENCBITS = 16;  // literal (value) bit length
  	var HUF_DECBITS = 14;  // decoding bit size (>= 8)

  	var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;  // encoding table size
  	var HUF_DECSIZE = 1 << HUF_DECBITS;        // decoding table size
  	var HUF_DECMASK = HUF_DECSIZE - 1;

  	var SHORT_ZEROCODE_RUN = 59;
  	var LONG_ZEROCODE_RUN = 63;
  	var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

  	var BYTES_PER_HALF = 2;

  	var ULONG_SIZE = 8;
  	var FLOAT32_SIZE = 4;
  	var INT32_SIZE = 4;
  	var INT16_SIZE = 2;
  	var INT8_SIZE = 1;

  	function reverseLutFromBitmap( bitmap, lut ) {

  		var k = 0;

  		for ( var i = 0; i < USHORT_RANGE; ++ i ) {

  			if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {

  				lut[ k ++ ] = i;

  			}

  		}

  		var n = k - 1;

  		while ( k < USHORT_RANGE ) { lut[ k ++ ] = 0; }

  		return n;

  	}

  	function hufClearDecTable( hdec ) {

  		for ( var i = 0; i < HUF_DECSIZE; i ++ ) {

  			hdec[ i ] = {};
  			hdec[ i ].len = 0;
  			hdec[ i ].lit = 0;
  			hdec[ i ].p = null;

  		}

  	}

  	var getBitsReturn = { l: 0, c: 0, lc: 0 };

  	function getBits( nBits, c, lc, uInt8Array, inOffset ) {

  		while ( lc < nBits ) {

  			c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
  			lc += 8;

  		}

  		lc -= nBits;

  		getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );
  		getBitsReturn.c = c;
  		getBitsReturn.lc = lc;
  	}

  	var hufTableBuffer = new Array( 59 );

  	function hufCanonicalCodeTable( hcode ) {

  		for ( var i = 0; i <= 58; ++ i ) { hufTableBuffer[ i ] = 0; }
  		for ( var i = 0; i < HUF_ENCSIZE; ++ i ) { hufTableBuffer[ hcode[ i ] ] += 1; }

  		var c = 0;

  		for ( var i = 58; i > 0; -- i ) {

  			var nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
  			hufTableBuffer[ i ] = c;
  			c = nc;

  		}

  		for ( var i = 0; i < HUF_ENCSIZE; ++ i ) {

  			var l = hcode[ i ];
  			if ( l > 0 ) { hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 ); }

  		}

  	}

  	function hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, hcode ) {

  		var p = inOffset;
  		var c = 0;
  		var lc = 0;

  		for ( ; im <= iM; im ++ ) {

  			if ( p.value - inOffset.value > ni ) { return false; }

  			getBits( 6, c, lc, uInt8Array, p );

  			var l = getBitsReturn.l;
  			c = getBitsReturn.c;
  			lc = getBitsReturn.lc;

  			hcode[ im ] = l;

  			if ( l == LONG_ZEROCODE_RUN ) {

  				if ( p.value - inOffset.value > ni ) {

  					throw 'Something wrong with hufUnpackEncTable';

  				}

  				getBits( 8, c, lc, uInt8Array, p );

  				var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
  				c = getBitsReturn.c;
  				lc = getBitsReturn.lc;

  				if ( im + zerun > iM + 1 ) {

  					throw 'Something wrong with hufUnpackEncTable';

  				}

  				while ( zerun -- ) { hcode[ im ++ ] = 0; }

  				im --;

  			} else if ( l >= SHORT_ZEROCODE_RUN ) {

  				var zerun = l - SHORT_ZEROCODE_RUN + 2;

  				if ( im + zerun > iM + 1 ) {

  					throw 'Something wrong with hufUnpackEncTable';

  				}

  				while ( zerun -- ) { hcode[ im ++ ] = 0; }

  				im --;

  			}

  		}

  		hufCanonicalCodeTable( hcode );

  	}

  	function hufLength( code ) { return code & 63; }

  	function hufCode( code ) { return code >> 6; }

  	function hufBuildDecTable( hcode, im, iM, hdecod ) {

  		for ( ; im <= iM; im ++ ) {

  			var c = hufCode( hcode[ im ] );
  			var l = hufLength( hcode[ im ] );

  			if ( c >> l ) {

  				throw 'Invalid table entry';

  			}

  			if ( l > HUF_DECBITS ) {

  				var pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

  				if ( pl.len ) {

  					throw 'Invalid table entry';

  				}

  				pl.lit ++;

  				if ( pl.p ) {

  					var p = pl.p;
  					pl.p = new Array( pl.lit );

  					for ( var i = 0; i < pl.lit - 1; ++ i ) {

  						pl.p[ i ] = p[ i ];

  					}

  				} else {

  					pl.p = new Array( 1 );

  				}

  				pl.p[ pl.lit - 1 ] = im;

  			} else if ( l ) {

  				var plOffset = 0;

  				for ( var i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {

  					var pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];

  					if ( pl.len || pl.p ) {

  						throw 'Invalid table entry';

  					}

  					pl.len = l;
  					pl.lit = im;

  					plOffset ++;

  				}

  			}

  		}

  		return true;

  	}

  	var getCharReturn = { c: 0, lc: 0 };

  	function getChar( c, lc, uInt8Array, inOffset ) {

  		c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
  		lc += 8;

  		getCharReturn.c = c;
  		getCharReturn.lc = lc;

  	}

  	var getCodeReturn = { c: 0, lc: 0 };

  	function getCode( po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

  		if ( po == rlc ) {

  			if ( lc < 8 ) {

  				getChar( c, lc, uInt8Array, inOffset );
  				c = getCharReturn.c;
  				lc = getCharReturn.lc;

  			}

  			lc -= 8;

  			var cs = ( c >> lc );
  			var cs = new Uint8Array([cs])[0];

  			if ( outBufferOffset.value + cs > outBufferEndOffset ) {

  				return false;

  			}

  			var s = outBuffer[ outBufferOffset.value - 1 ];

  			while ( cs-- > 0 ) {

  				outBuffer[ outBufferOffset.value ++ ] = s;

  			}

  		} else if ( outBufferOffset.value < outBufferEndOffset ) {

  			outBuffer[ outBufferOffset.value ++ ] = po;

  		} else {

  			return false;

  		}

  		getCodeReturn.c = c;
  		getCodeReturn.lc = lc;

  	}

  	function UInt16( value ) {

  		return ( value & 0xFFFF );

  	}

  	function Int16( value ) {

  		var ref = UInt16( value );
  		return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

  	}

  	var wdec14Return = { a: 0, b: 0 };

  	function wdec14( l, h ) {

  		var ls = Int16( l );
  		var hs = Int16( h );

  		var hi = hs;
  		var ai = ls + ( hi & 1 ) + ( hi >> 1 );

  		var as = ai;
  		var bs = ai - hi;

  		wdec14Return.a = as;
  		wdec14Return.b = bs;

  	}

  	function wav2Decode( j, buffer, nx, ox, ny, oy, mx ) {

  		var n = ( nx > ny ) ? ny : nx;
  		var p = 1;
  		var p2;

  		while ( p <= n ) { p <<= 1; }

  		p >>= 1;
  		p2 = p;
  		p >>= 1;

  		while ( p >= 1 ) {

  			var py = 0;
  			var ey = py + oy * ( ny - p2 );
  			var oy1 = oy * p;
  			var oy2 = oy * p2;
  			var ox1 = ox * p;
  			var ox2 = ox * p2;
  			var i00, i01, i10, i11;

  			for ( ; py <= ey; py += oy2 ) {

  				var px = py;
  				var ex = py + ox * ( nx - p2 );

  				for ( ; px <= ex; px += ox2 ) {

  					var p01 = px + ox1;
  					var p10 = px + oy1;
  					var p11 = p10 + ox1;

  					wdec14( buffer[ px + j ], buffer[ p10 + j ] );

  					i00 = wdec14Return.a;
  					i10 = wdec14Return.b;

  					wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

  					i01 = wdec14Return.a;
  					i11 = wdec14Return.b;

  					wdec14( i00, i01 );

  					buffer[ px + j ] = wdec14Return.a;
  					buffer[ p01 + j ] = wdec14Return.b;

  					wdec14( i10, i11 );

  					buffer[ p10 + j ] = wdec14Return.a;
  					buffer[ p11 + j ] = wdec14Return.b;

  				}

  				if ( nx & p ) {

  					var p10 = px + oy1;

  					wdec14( buffer[ px + j ], buffer[ p10 + j ] );

  					i00 = wdec14Return.a;
  					buffer[ p10 + j ] = wdec14Return.b;

  					buffer[ px + j ] = i00;

  				}

  			}

  			if ( ny & p ) {

  				var px = py;
  				var ex = py + ox * ( nx - p2 );

  				for ( ; px <= ex; px += ox2 ) {

  					var p01 = px + ox1;

  					wdec14( buffer[ px + j ], buffer[ p01 + j ] );

  					i00 = wdec14Return.a;
  					buffer[ p01 + j ] = wdec14Return.b;

  					buffer[ px + j ] = i00;

  				}

  			}

  			p2 = p;
  			p >>= 1;

  		}

  		return py;

  	}

  	function hufDecode( encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset ) {

  		var c = 0;
  		var lc = 0;
  		var outBufferEndOffset = no;
  		var inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

  		while ( inOffset.value < inOffsetEnd ) {

  			getChar( c, lc, uInt8Array, inOffset );

  			c = getCharReturn.c;
  			lc = getCharReturn.lc;

  			while ( lc >= HUF_DECBITS ) {

  				var index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;
  				var pl = decodingTable[ index ];

  				if ( pl.len ) {

  					lc -= pl.len;

  					getCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );

  					c = getCodeReturn.c;
  					lc = getCodeReturn.lc;

  				} else {

  					if ( ! pl.p ) {

  						throw 'hufDecode issues';

  					}

  					var j;

  					for ( j = 0; j < pl.lit; j ++ ) {

  						var l = hufLength( encodingTable[ pl.p[ j ] ] );

  						while ( lc < l && inOffset.value < inOffsetEnd ) {

  							getChar( c, lc, uInt8Array, inOffset );

  							c = getCharReturn.c;
  							lc = getCharReturn.lc;

  						}

  						if ( lc >= l ) {

  							if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {

  								lc -= l;

  								getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );

  								c = getCodeReturn.c;
  								lc = getCodeReturn.lc;

  								break;

  							}

  						}

  					}

  					if ( j == pl.lit ) {

  						throw 'hufDecode issues';

  					}

  				}

  			}

  		}

  		var i = ( 8 - ni ) & 7;

  		c >>= i;
  		lc -= i;

  		while ( lc > 0 ) {

  			var pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];

  			if ( pl.len ) {

  				lc -= pl.len;

  				getCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );

  				c = getCodeReturn.c;
  				lc = getCodeReturn.lc;

  			} else {

  				throw 'hufDecode issues';

  			}

  		}

  		return true;

  	}

  	function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw ) {

  		var initialInOffset = inOffset.value;

  		var im = parseUint32( inDataView, inOffset );
  		var iM = parseUint32( inDataView, inOffset );

  		inOffset.value += 4;

  		var nBits = parseUint32( inDataView, inOffset );

  		inOffset.value += 4;

  		if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {

  			throw 'Something wrong with HUF_ENCSIZE';

  		}

  		var freq = new Array( HUF_ENCSIZE );
  		var hdec = new Array( HUF_DECSIZE );

  		hufClearDecTable( hdec );

  		var ni = nCompressed - ( inOffset.value - initialInOffset );

  		hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, freq );

  		if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

  			throw 'Something wrong with hufUncompress';

  		}

  		hufBuildDecTable( freq, im, iM, hdec );

  		hufDecode( freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

  	}

  	function applyLut( lut, data, nData ) {

  		for ( var i = 0; i < nData; ++ i ) {

  			data[ i ] = lut[ data[ i ] ];

  		}

  	}

  	function decompressPIZ( outBuffer, outOffset, uInt8Array, inDataView, inOffset, tmpBufSize, num_channels, exrChannelInfos, dataWidth, num_lines ) {

  		var bitmap = new Uint8Array( BITMAP_SIZE );

  		var minNonZero = parseUint16( inDataView, inOffset );
  		var maxNonZero = parseUint16( inDataView, inOffset );

  		if ( maxNonZero >= BITMAP_SIZE ) {

  			throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';

  		}

  		if ( minNonZero <= maxNonZero ) {

  			for ( var i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {

  				bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

  			}

  		}

  		var lut = new Uint16Array( USHORT_RANGE );
  		var maxValue = reverseLutFromBitmap( bitmap, lut );

  		var length = parseUint32( inDataView, inOffset );

  		hufUncompress( uInt8Array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize );

  		var pizChannelData = new Array( num_channels );

  		var outBufferEnd = 0;

  		for ( var i = 0; i < num_channels; i ++ ) {

  			var exrChannelInfo = exrChannelInfos[ i ];

  			pizChannelData[ i ] = {};
  			pizChannelData[ i ][ 'start' ] = outBufferEnd;
  			pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
  			pizChannelData[ i ][ 'nx' ] = dataWidth;
  			pizChannelData[ i ][ 'ny' ] = num_lines;
  			pizChannelData[ i ][ 'size' ] = 1;

  			outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

  		}

  		var fooOffset = 0;

  		for ( var i = 0; i < num_channels; i ++ ) {

  			for ( var j = 0; j < pizChannelData[ i ].size; ++ j ) {

  				fooOffset += wav2Decode(
  					j + fooOffset,
  					outBuffer,
  					pizChannelData[ i ].nx,
  					pizChannelData[ i ].size,
  					pizChannelData[ i ].ny,
  					pizChannelData[ i ].nx * pizChannelData[ i ].size,
  					maxValue
  				);

  			}

  		}

  		applyLut( lut, outBuffer, outBufferEnd );

  		return true;

  	}

  	function parseNullTerminatedString( buffer, offset ) {

  		var uintBuffer = new Uint8Array( buffer );
  		var endOffset = 0;

  		while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

  			endOffset += 1;

  		}

  		var stringValue = new TextDecoder().decode(
  			uintBuffer.slice( offset.value, offset.value + endOffset )
  		);

  		offset.value = offset.value + endOffset + 1;

  		return stringValue;

  	}

  	function parseFixedLengthString( buffer, offset, size ) {

  		var stringValue = new TextDecoder().decode(
  			new Uint8Array( buffer ).slice( offset.value, offset.value + size )
  		);

  		offset.value = offset.value + size;

  		return stringValue;

  	}

  	function parseUlong( dataView, offset ) {

  		var uLong = dataView.getUint32( 0, true );

  		offset.value = offset.value + ULONG_SIZE;

  		return uLong;

  	}

  	function parseUint32( dataView, offset ) {

  		var Uint32 = dataView.getUint32(offset.value, true);

  		offset.value = offset.value + INT32_SIZE;

  		return Uint32;

  	}

  	function parseUint8Array( uInt8Array, offset ) {

  		var Uint8 = uInt8Array[offset.value];

  		offset.value = offset.value + INT8_SIZE;

  		return Uint8;

  	}

  	function parseUint8( dataView, offset ) {

  		var Uint8 = dataView.getUint8(offset.value);

  		offset.value = offset.value + INT8_SIZE;

  		return Uint8;

  	}

  	function parseFloat32( dataView, offset ) {

  		var float = dataView.getFloat32(offset.value, true);

  		offset.value += FLOAT32_SIZE;

  		return float;

  	}

  	// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
  	function decodeFloat16( binary ) {

  		var exponent = ( binary & 0x7C00 ) >> 10,
  			fraction = binary & 0x03FF;

  		return ( binary >> 15 ? - 1 : 1 ) * (
  			exponent ?
  				(
  					exponent === 0x1F ?
  						fraction ? NaN : Infinity :
  						Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
  				) :
  				6.103515625e-5 * ( fraction / 0x400 )
  		);

  	}

  	function parseUint16( dataView, offset ) {

  		var Uint16 = dataView.getUint16( offset.value, true );

  		offset.value += INT16_SIZE;

  		return Uint16;

  	}

  	function parseFloat16( buffer, offset ) {

  		return decodeFloat16( parseUint16( buffer, offset) );

  	}

  	function parseChlist( dataView, buffer, offset, size ) {

  		var startOffset = offset.value;
  		var channels = [];

  		while ( offset.value < ( startOffset + size - 1 ) ) {

  			var name = parseNullTerminatedString( buffer, offset );
  			var pixelType = parseUint32( dataView, offset ); // TODO: Cast this to UINT, HALF or FLOAT
  			var pLinear = parseUint8( dataView, offset );
  			offset.value += 3; // reserved, three chars
  			var xSampling = parseUint32( dataView, offset );
  			var ySampling = parseUint32( dataView, offset );

  			channels.push( {
  				name: name,
  				pixelType: pixelType,
  				pLinear: pLinear,
  				xSampling: xSampling,
  				ySampling: ySampling
  			} );

  		}

  		offset.value += 1;

  		return channels;

  	}

  	function parseChromaticities( dataView, offset ) {

  		var redX = parseFloat32( dataView, offset );
  		var redY = parseFloat32( dataView, offset );
  		var greenX = parseFloat32( dataView, offset );
  		var greenY = parseFloat32( dataView, offset );
  		var blueX = parseFloat32( dataView, offset );
  		var blueY = parseFloat32( dataView, offset );
  		var whiteX = parseFloat32( dataView, offset );
  		var whiteY = parseFloat32( dataView, offset );

  		return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

  	}

  	function parseCompression( dataView, offset ) {

  		var compressionCodes = [
  			'NO_COMPRESSION',
  			'RLE_COMPRESSION',
  			'ZIPS_COMPRESSION',
  			'ZIP_COMPRESSION',
  			'PIZ_COMPRESSION',
  			'PXR24_COMPRESSION',
  			'B44_COMPRESSION',
  			'B44A_COMPRESSION',
  			'DWAA_COMPRESSION',
  			'DWAB_COMPRESSION'
  		];

  		var compression = parseUint8( dataView, offset );

  		return compressionCodes[ compression ];

  	}

  	function parseBox2i( dataView, offset ) {

  		var xMin = parseUint32( dataView, offset );
  		var yMin = parseUint32( dataView, offset );
  		var xMax = parseUint32( dataView, offset );
  		var yMax = parseUint32( dataView, offset );

  		return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

  	}

  	function parseLineOrder( dataView, offset ) {

  		var lineOrders = [
  			'INCREASING_Y'
  		];

  		var lineOrder = parseUint8( dataView, offset );

  		return lineOrders[ lineOrder ];

  	}

  	function parseV2f( dataView, offset ) {

  		var x = parseFloat32( dataView, offset );
  		var y = parseFloat32( dataView, offset );

  		return [ x, y ];

  	}

  	function parseValue( dataView, buffer, offset, type, size ) {

  		if ( type === 'string' || type === 'iccProfile' ) {

  			return parseFixedLengthString( buffer, offset, size );

  		} else if ( type === 'chlist' ) {

  			return parseChlist( dataView, buffer, offset, size );

  		} else if ( type === 'chromaticities' ) {

  			return parseChromaticities( dataView, offset );

  		} else if ( type === 'compression' ) {

  			return parseCompression( dataView, offset );

  		} else if ( type === 'box2i' ) {

  			return parseBox2i( dataView, offset );

  		} else if ( type === 'lineOrder' ) {

  			return parseLineOrder( dataView, offset );

  		} else if ( type === 'float' ) {

  			return parseFloat32( dataView, offset );

  		} else if ( type === 'v2f' ) {

  			return parseV2f( dataView, offset );

  		} else if ( type === 'int' ) {

  			return parseUint32( dataView, offset );

  		} else {

  			throw 'Cannot parse value for unsupported type: ' + type;

  		}

  	}

  	var bufferDataView = new DataView(buffer);
  	var uInt8Array = new Uint8Array(buffer);

  	var EXRHeader = {};

  	var magic = bufferDataView.getUint32( 0, true );
  	var versionByteZero = bufferDataView.getUint8( 4, true );
  	var fullMask = bufferDataView.getUint8( 5, true );

  	// start of header

  	var offset = { value: 8 }; // start at 8, after magic stuff

  	var keepReading = true;

  	while ( keepReading ) {

  		var attributeName = parseNullTerminatedString( buffer, offset );

  		if ( attributeName == 0 ) {

  			keepReading = false;

  		} else {

  			var attributeType = parseNullTerminatedString( buffer, offset );
  			var attributeSize = parseUint32( bufferDataView, offset );
  			var attributeValue = parseValue( bufferDataView, buffer, offset, attributeType, attributeSize );

  			EXRHeader[ attributeName ] = attributeValue;

  		}

  	}

  	// offsets

  	var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;
  	var scanlineBlockSize = 1; // 1 for NO_COMPRESSION

  	if ( EXRHeader.compression === 'PIZ_COMPRESSION' ) {

  		scanlineBlockSize = 32;

  	}

  	var numBlocks = dataWindowHeight / scanlineBlockSize;

  	for ( var i = 0; i < numBlocks; i ++ ) {

  		var scanlineOffset = parseUlong( bufferDataView, offset );

  	}

  	// we should be passed the scanline offset table, start reading pixel data

  	var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;
  	var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;
  	var numChannels = EXRHeader.channels.length;

  	var byteArray = new Float32Array( width * height * numChannels );

  	var channelOffsets = {
  		R: 0,
  		G: 1,
  		B: 2,
  		A: 3
  	};

  	if ( EXRHeader.compression === 'NO_COMPRESSION' ) {

  		for ( var y = 0; y < height; y ++ ) {

  			var y_scanline = parseUint32( bufferDataView, offset );
  			var dataSize = parseUint32( bufferDataView, offset );

  			for ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {

  				var cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];

  				if ( EXRHeader.channels[ channelID ].pixelType === 1 ) {

  					// HALF
  					for ( var x = 0; x < width; x ++ ) {

  						var val = parseFloat16( bufferDataView, offset );

  						byteArray[ ( ( ( height - y_scanline ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;

  					}

  				} else {

  					throw 'EXRLoader._parser: unsupported pixelType ' + EXRHeader.channels[ channelID ].pixelType + '. Only pixelType is 1 (HALF) is supported.';

  				}

  			}

  		}

  	} else if ( EXRHeader.compression === 'PIZ_COMPRESSION' ) {

  		for ( var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx ++ ) {

  			var line_no = parseUint32( bufferDataView, offset );
  			var data_len = parseUint32( bufferDataView, offset );

  			var tmpBufferSize = width * scanlineBlockSize * ( EXRHeader.channels.length * BYTES_PER_HALF );
  			var tmpBuffer = new Uint16Array( tmpBufferSize );
  			var tmpOffset = { value: 0 };

  			decompressPIZ( tmpBuffer, tmpOffset, uInt8Array, bufferDataView, offset, tmpBufferSize, numChannels, EXRHeader.channels, width, scanlineBlockSize );

  			for ( var line_y = 0; line_y < scanlineBlockSize; line_y ++ ) {

  				for ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {

  					var cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];

  					if ( EXRHeader.channels[ channelID ].pixelType === 1 ) {

  						// HALF
  						for ( var x = 0; x < width; x ++ ) {

  							var val = decodeFloat16( tmpBuffer[ ( channelID * ( scanlineBlockSize * width ) ) + ( line_y * width ) + x ] );

  							var true_y = line_y + ( scanlineBlockIdx * scanlineBlockSize );

  							byteArray[ ( ( ( height - true_y ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;

  						}

  					} else {

  						throw 'EXRLoader._parser: unsupported pixelType ' + EXRHeader.channels[ channelID ].pixelType + '. Only pixelType is 1 (HALF) is supported.';

  					}

  				}

  			}

  		}

  	} else {

  		throw 'EXRLoader._parser: ' + EXRHeader.compression + ' is unsupported';

  	}

  	return {
  		header: EXRHeader,
  		width: width,
  		height: height,
  		data: byteArray,
  		format: EXRHeader.channels.length == 4 ? RGBAFormat : RGBFormat,
  		type: FloatType
  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FBXLoader = ( function () {

  	var fbxTree;
  	var connections;
  	var sceneGraph;

  	function FBXLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	FBXLoader.prototype = {

  		constructor: FBXLoader,

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var self = this;

  			var path = ( self.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : self.path;

  			var loader = new FileLoader( this.manager );
  			loader.setPath( self.path );
  			loader.setResponseType( 'arraybuffer' );

  			loader.load( url, function ( buffer ) {

  				try {

  					onLoad( self.parse( buffer, path ) );

  				} catch ( error ) {

  					setTimeout( function () {

  						if ( onError ) { onError( error ); }

  						self.manager.itemError( url );

  					}, 0 );

  				}

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setResourcePath: function ( value ) {

  			this.resourcePath = value;
  			return this;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		parse: function ( FBXBuffer, path ) {

  			if ( isFbxFormatBinary( FBXBuffer ) ) {

  				fbxTree = new BinaryParser().parse( FBXBuffer );

  			} else {

  				var FBXText = convertArrayBufferToString( FBXBuffer );

  				if ( ! isFbxFormatASCII( FBXText ) ) {

  					throw new Error( 'FBXLoader: Unknown format.' );

  				}

  				if ( getFbxVersion( FBXText ) < 7000 ) {

  					throw new Error( 'FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );

  				}

  				fbxTree = new TextParser().parse( FBXText );

  			}

  			// console.log( fbxTree );

  			var textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  			return new FBXTreeParser( textureLoader ).parse( fbxTree );

  		}

  	};

  	// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
  	function FBXTreeParser( textureLoader ) {

  		this.textureLoader = textureLoader;

  	}

  	FBXTreeParser.prototype = {

  		constructor: FBXTreeParser,

  		parse: function () {

  			connections = this.parseConnections();

  			var images = this.parseImages();
  			var textures = this.parseTextures( images );
  			var materials = this.parseMaterials( textures );
  			var deformers = this.parseDeformers();
  			var geometryMap = new GeometryParser().parse( deformers );

  			this.parseScene( deformers, geometryMap, materials );

  			return sceneGraph;

  		},

  		// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  		// and details the connection type
  		parseConnections: function () {

  			var connectionMap = new Map();

  			if ( 'Connections' in fbxTree ) {

  				var rawConnections = fbxTree.Connections.connections;

  				rawConnections.forEach( function ( rawConnection ) {

  					var fromID = rawConnection[ 0 ];
  					var toID = rawConnection[ 1 ];
  					var relationship = rawConnection[ 2 ];

  					if ( ! connectionMap.has( fromID ) ) {

  						connectionMap.set( fromID, {
  							parents: [],
  							children: []
  						} );

  					}

  					var parentRelationship = { ID: toID, relationship: relationship };
  					connectionMap.get( fromID ).parents.push( parentRelationship );

  					if ( ! connectionMap.has( toID ) ) {

  						connectionMap.set( toID, {
  							parents: [],
  							children: []
  						} );

  					}

  					var childRelationship = { ID: fromID, relationship: relationship };
  					connectionMap.get( toID ).children.push( childRelationship );

  				} );

  			}

  			return connectionMap;

  		},

  		// Parse FBXTree.Objects.Video for embedded image data
  		// These images are connected to textures in FBXTree.Objects.Textures
  		// via FBXTree.Connections.
  		parseImages: function () {
  			var this$1 = this;


  			var images = {};
  			var blobs = {};

  			if ( 'Video' in fbxTree.Objects ) {

  				var videoNodes = fbxTree.Objects.Video;

  				for ( var nodeID in videoNodes ) {

  					var videoNode = videoNodes[ nodeID ];

  					var id = parseInt( nodeID );

  					images[ id ] = videoNode.RelativeFilename || videoNode.Filename;

  					// raw image data is in videoNode.Content
  					if ( 'Content' in videoNode ) {

  						var arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
  						var base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );

  						if ( arrayBufferContent || base64Content ) {

  							var image = this$1.parseImage( videoNodes[ nodeID ] );

  							blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;

  						}

  					}

  				}

  			}

  			for ( var id in images ) {

  				var filename = images[ id ];

  				if ( blobs[ filename ] !== undefined ) { images[ id ] = blobs[ filename ]; }
  				else { images[ id ] = images[ id ].split( '\\' ).pop(); }

  			}

  			return images;

  		},

  		// Parse embedded image data in FBXTree.Video.Content
  		parseImage: function ( videoNode ) {

  			var content = videoNode.Content;
  			var fileName = videoNode.RelativeFilename || videoNode.Filename;
  			var extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

  			var type;

  			switch ( extension ) {

  				case 'bmp':

  					type = 'image/bmp';
  					break;

  				case 'jpg':
  				case 'jpeg':

  					type = 'image/jpeg';
  					break;

  				case 'png':

  					type = 'image/png';
  					break;

  				case 'tif':

  					type = 'image/tiff';
  					break;

  				case 'tga':

  					if ( typeof TGALoader !== 'function' ) {

  						console.warn( 'FBXLoader: TGALoader is required to load TGA textures' );
  						return;

  					} else {

  						if ( Loader.Handlers.get( '.tga' ) === null ) {

  							var tgaLoader = new TGALoader();
  							tgaLoader.setPath( this.textureLoader.path );

  							Loader.Handlers.add( /\.tga$/i, tgaLoader );

  						}

  						type = 'image/tga';
  						break;

  					}

  				default:

  					console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );
  					return;

  			}

  			if ( typeof content === 'string' ) { // ASCII format

  				return 'data:' + type + ';base64,' + content;

  			} else { // Binary Format

  				var array = new Uint8Array( content );
  				return window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );

  			}

  		},

  		// Parse nodes in FBXTree.Objects.Texture
  		// These contain details such as UV scaling, cropping, rotation etc and are connected
  		// to images in FBXTree.Objects.Video
  		parseTextures: function ( images ) {
  			var this$1 = this;


  			var textureMap = new Map();

  			if ( 'Texture' in fbxTree.Objects ) {

  				var textureNodes = fbxTree.Objects.Texture;
  				for ( var nodeID in textureNodes ) {

  					var texture = this$1.parseTexture( textureNodes[ nodeID ], images );
  					textureMap.set( parseInt( nodeID ), texture );

  				}

  			}

  			return textureMap;

  		},

  		// Parse individual node in FBXTree.Objects.Texture
  		parseTexture: function ( textureNode, images ) {

  			var texture = this.loadTexture( textureNode, images );

  			texture.ID = textureNode.id;

  			texture.name = textureNode.attrName;

  			var wrapModeU = textureNode.WrapModeU;
  			var wrapModeV = textureNode.WrapModeV;

  			var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
  			var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

  			// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
  			// 0: repeat(default), 1: clamp

  			texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
  			texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

  			if ( 'Scaling' in textureNode ) {

  				var values = textureNode.Scaling.value;

  				texture.repeat.x = values[ 0 ];
  				texture.repeat.y = values[ 1 ];

  			}

  			return texture;

  		},

  		// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  		loadTexture: function ( textureNode, images ) {

  			var fileName;

  			var currentPath = this.textureLoader.path;

  			var children = connections.get( textureNode.id ).children;

  			if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {

  				fileName = images[ children[ 0 ].ID ];

  				if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

  					this.textureLoader.setPath( undefined );

  				}

  			}

  			var texture;

  			var extension = textureNode.FileName.slice( - 3 ).toLowerCase();

  			if ( extension === 'tga' ) {

  				var loader = Loader.Handlers.get( '.tga' );

  				if ( loader === null ) {

  					console.warn( 'FBXLoader: TGALoader not found, creating empty placeholder texture for', fileName );
  					texture = new Texture();

  				} else {

  					texture = loader.load( fileName );

  				}

  			} else if ( extension === 'psd' ) {

  				console.warn( 'FBXLoader: PSD textures are not supported, creating empty placeholder texture for', fileName );
  				texture = new Texture();

  			} else {

  				texture = this.textureLoader.load( fileName );

  			}

  			this.textureLoader.setPath( currentPath );

  			return texture;

  		},

  		// Parse nodes in FBXTree.Objects.Material
  		parseMaterials: function ( textureMap ) {
  			var this$1 = this;


  			var materialMap = new Map();

  			if ( 'Material' in fbxTree.Objects ) {

  				var materialNodes = fbxTree.Objects.Material;

  				for ( var nodeID in materialNodes ) {

  					var material = this$1.parseMaterial( materialNodes[ nodeID ], textureMap );

  					if ( material !== null ) { materialMap.set( parseInt( nodeID ), material ); }

  				}

  			}

  			return materialMap;

  		},

  		// Parse single node in FBXTree.Objects.Material
  		// Materials are connected to texture maps in FBXTree.Objects.Textures
  		// FBX format currently only supports Lambert and Phong shading models
  		parseMaterial: function ( materialNode, textureMap ) {

  			var ID = materialNode.id;
  			var name = materialNode.attrName;
  			var type = materialNode.ShadingModel;

  			// Case where FBX wraps shading model in property object.
  			if ( typeof type === 'object' ) {

  				type = type.value;

  			}

  			// Ignore unused materials which don't have any connections.
  			if ( ! connections.has( ID ) ) { return null; }

  			var parameters = this.parseParameters( materialNode, textureMap, ID );

  			var material;

  			switch ( type.toLowerCase() ) {

  				case 'phong':
  					material = new MeshPhongMaterial();
  					break;
  				case 'lambert':
  					material = new MeshLambertMaterial();
  					break;
  				default:
  					console.warn( 'FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type );
  					material = new MeshPhongMaterial();
  					break;

  			}

  			material.setValues( parameters );
  			material.name = name;

  			return material;

  		},

  		// Parse FBX material and return parameters suitable for a three.js material
  		// Also parse the texture map and return any textures associated with the material
  		parseParameters: function ( materialNode, textureMap, ID ) {

  			var parameters = {};

  			if ( materialNode.BumpFactor ) {

  				parameters.bumpScale = materialNode.BumpFactor.value;

  			}
  			if ( materialNode.Diffuse ) {

  				parameters.color = new Color().fromArray( materialNode.Diffuse.value );

  			} else if ( materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color' ) {

  				// The blender exporter exports diffuse here instead of in materialNode.Diffuse
  				parameters.color = new Color().fromArray( materialNode.DiffuseColor.value );

  			}

  			if ( materialNode.DisplacementFactor ) {

  				parameters.displacementScale = materialNode.DisplacementFactor.value;

  			}

  			if ( materialNode.Emissive ) {

  				parameters.emissive = new Color().fromArray( materialNode.Emissive.value );

  			} else if ( materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color' ) {

  				// The blender exporter exports emissive color here instead of in materialNode.Emissive
  				parameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value );

  			}

  			if ( materialNode.EmissiveFactor ) {

  				parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );

  			}

  			if ( materialNode.Opacity ) {

  				parameters.opacity = parseFloat( materialNode.Opacity.value );

  			}

  			if ( parameters.opacity < 1.0 ) {

  				parameters.transparent = true;

  			}

  			if ( materialNode.ReflectionFactor ) {

  				parameters.reflectivity = materialNode.ReflectionFactor.value;

  			}

  			if ( materialNode.Shininess ) {

  				parameters.shininess = materialNode.Shininess.value;

  			}

  			if ( materialNode.Specular ) {

  				parameters.specular = new Color().fromArray( materialNode.Specular.value );

  			} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {

  				// The blender exporter exports specular color here instead of in materialNode.Specular
  				parameters.specular = new Color().fromArray( materialNode.SpecularColor.value );

  			}

  			var self = this;
  			connections.get( ID ).children.forEach( function ( child ) {

  				var type = child.relationship;

  				switch ( type ) {

  					case 'Bump':
  						parameters.bumpMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'Maya|TEX_ao_map':
  						parameters.aoMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'DiffuseColor':
  					case 'Maya|TEX_color_map':
  						parameters.map = self.getTexture( textureMap, child.ID );
  						break;

  					case 'DisplacementColor':
  						parameters.displacementMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'EmissiveColor':
  						parameters.emissiveMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'NormalMap':
  					case 'Maya|TEX_normal_map':
  						parameters.normalMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'ReflectionColor':
  						parameters.envMap = self.getTexture( textureMap, child.ID );
  						parameters.envMap.mapping = EquirectangularReflectionMapping;
  						break;

  					case 'SpecularColor':
  						parameters.specularMap = self.getTexture( textureMap, child.ID );
  						break;

  					case 'TransparentColor':
  						parameters.alphaMap = self.getTexture( textureMap, child.ID );
  						parameters.transparent = true;
  						break;

  					case 'AmbientColor':
  					case 'ShininessExponent': // AKA glossiness map
  					case 'SpecularFactor': // AKA specularLevel
  					case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
  					default:
  						console.warn( 'FBXLoader: %s map is not supported in three.js, skipping texture.', type );
  						break;

  				}

  			} );

  			return parameters;

  		},

  		// get a texture from the textureMap for use by a material.
  		getTexture: function ( textureMap, id ) {

  			// if the texture is a layered texture, just use the first layer and issue a warning
  			if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {

  				console.warn( 'FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );
  				id = connections.get( id ).children[ 0 ].ID;

  			}

  			return textureMap.get( id );

  		},

  		// Parse nodes in FBXTree.Objects.Deformer
  		// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  		// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  		parseDeformers: function () {
  			var this$1 = this;


  			var skeletons = {};
  			var morphTargets = {};

  			if ( 'Deformer' in fbxTree.Objects ) {

  				var DeformerNodes = fbxTree.Objects.Deformer;

  				for ( var nodeID in DeformerNodes ) {

  					var deformerNode = DeformerNodes[ nodeID ];

  					var relationships = connections.get( parseInt( nodeID ) );

  					if ( deformerNode.attrType === 'Skin' ) {

  						var skeleton = this$1.parseSkeleton( relationships, DeformerNodes );
  						skeleton.ID = nodeID;

  						if ( relationships.parents.length > 1 ) { console.warn( 'FBXLoader: skeleton attached to more than one geometry is not supported.' ); }
  						skeleton.geometryID = relationships.parents[ 0 ].ID;

  						skeletons[ nodeID ] = skeleton;

  					} else if ( deformerNode.attrType === 'BlendShape' ) {

  						var morphTarget = {
  							id: nodeID,
  						};

  						morphTarget.rawTargets = this$1.parseMorphTargets( relationships, DeformerNodes );
  						morphTarget.id = nodeID;

  						if ( relationships.parents.length > 1 ) { console.warn( 'FBXLoader: morph target attached to more than one geometry is not supported.' ); }

  						morphTargets[ nodeID ] = morphTarget;

  					}

  				}

  			}

  			return {

  				skeletons: skeletons,
  				morphTargets: morphTargets,

  			};

  		},

  		// Parse single nodes in FBXTree.Objects.Deformer
  		// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  		// Each skin node represents a skeleton and each cluster node represents a bone
  		parseSkeleton: function ( relationships, deformerNodes ) {

  			var rawBones = [];

  			relationships.children.forEach( function ( child ) {

  				var boneNode = deformerNodes[ child.ID ];

  				if ( boneNode.attrType !== 'Cluster' ) { return; }

  				var rawBone = {

  					ID: child.ID,
  					indices: [],
  					weights: [],
  					transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),
  					// transform: new Matrix4().fromArray( boneNode.Transform.a ),
  					// linkMode: boneNode.Mode,

  				};

  				if ( 'Indexes' in boneNode ) {

  					rawBone.indices = boneNode.Indexes.a;
  					rawBone.weights = boneNode.Weights.a;

  				}

  				rawBones.push( rawBone );

  			} );

  			return {

  				rawBones: rawBones,
  				bones: []

  			};

  		},

  		// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  		parseMorphTargets: function ( relationships, deformerNodes ) {

  			var rawMorphTargets = [];

  			for ( var i = 0; i < relationships.children.length; i ++ ) {

  				var child = relationships.children[ i ];

  				var morphTargetNode = deformerNodes[ child.ID ];

  				var rawMorphTarget = {

  					name: morphTargetNode.attrName,
  					initialWeight: morphTargetNode.DeformPercent,
  					id: morphTargetNode.id,
  					fullWeights: morphTargetNode.FullWeights.a

  				};

  				if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) { return; }

  				rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {

  					return child.relationship === undefined;

  				} )[ 0 ].ID;

  				rawMorphTargets.push( rawMorphTarget );

  			}

  			return rawMorphTargets;

  		},

  		// create the main Group() to be returned by the loader
  		parseScene: function ( deformers, geometryMap, materialMap ) {

  			sceneGraph = new Group();

  			var modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );

  			var modelNodes = fbxTree.Objects.Model;

  			var self = this;
  			modelMap.forEach( function ( model ) {

  				var modelNode = modelNodes[ model.ID ];
  				self.setLookAtProperties( model, modelNode );

  				var parentConnections = connections.get( model.ID ).parents;

  				parentConnections.forEach( function ( connection ) {

  					var parent = modelMap.get( connection.ID );
  					if ( parent !== undefined ) { parent.add( model ); }

  				} );

  				if ( model.parent === null ) {

  					sceneGraph.add( model );

  				}
  			} );

  			this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );

  			this.createAmbientLight();

  			this.setupMorphMaterials();

  			sceneGraph.traverse( function ( node ) {

  				if ( node.userData.transformData ) {

  					if ( node.parent ) { node.userData.transformData.parentMatrixWorld = node.parent.matrix; }

  					var transform = generateTransform( node.userData.transformData );

  					node.applyMatrix( transform );

  				}

  			} );

  			var animations = new AnimationParser().parse();

  			// if all the models where already combined in a single group, just return that
  			if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {

  				sceneGraph.children[ 0 ].animations = animations;
  				sceneGraph = sceneGraph.children[ 0 ];

  			}

  			sceneGraph.animations = animations;

  		},

  		// parse nodes in FBXTree.Objects.Model
  		parseModels: function ( skeletons, geometryMap, materialMap ) {
  			var this$1 = this;


  			var modelMap = new Map();
  			var modelNodes = fbxTree.Objects.Model;

  			for ( var nodeID in modelNodes ) {

  				var id = parseInt( nodeID );
  				var node = modelNodes[ nodeID ];
  				var relationships = connections.get( id );

  				var model = this$1.buildSkeleton( relationships, skeletons, id, node.attrName );

  				if ( ! model ) {

  					switch ( node.attrType ) {

  						case 'Camera':
  							model = this$1.createCamera( relationships );
  							break;
  						case 'Light':
  							model = this$1.createLight( relationships );
  							break;
  						case 'Mesh':
  							model = this$1.createMesh( relationships, geometryMap, materialMap );
  							break;
  						case 'NurbsCurve':
  							model = this$1.createCurve( relationships, geometryMap );
  							break;
  						case 'LimbNode':
  						case 'Root':
  							model = new Bone();
  							break;
  						case 'Null':
  						default:
  							model = new Group();
  							break;

  					}

  					model.name = PropertyBinding.sanitizeNodeName( node.attrName );
  					model.ID = id;

  				}

  				this$1.getTransformData( model, node );
  				modelMap.set( id, model );

  			}

  			return modelMap;

  		},

  		buildSkeleton: function ( relationships, skeletons, id, name ) {

  			var bone = null;

  			relationships.parents.forEach( function ( parent ) {

  				for ( var ID in skeletons ) {

  					var skeleton = skeletons[ ID ];

  					skeleton.rawBones.forEach( function ( rawBone, i ) {

  						if ( rawBone.ID === parent.ID ) {

  							var subBone = bone;
  							bone = new Bone();

  							bone.matrixWorld.copy( rawBone.transformLink );

  							// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id
  							bone.name = PropertyBinding.sanitizeNodeName( name );
  							bone.ID = id;

  							skeleton.bones[ i ] = bone;

  							// In cases where a bone is shared between multiple meshes
  							// duplicate the bone here and and it as a child of the first bone
  							if ( subBone !== null ) {

  								bone.add( subBone );

  							}

  						}

  					} );

  				}

  			} );

  			return bone;

  		},

  		// create a PerspectiveCamera or OrthographicCamera
  		createCamera: function ( relationships ) {

  			var model;
  			var cameraAttribute;

  			relationships.children.forEach( function ( child ) {

  				var attr = fbxTree.Objects.NodeAttribute[ child.ID ];

  				if ( attr !== undefined ) {

  					cameraAttribute = attr;

  				}

  			} );

  			if ( cameraAttribute === undefined ) {

  				model = new Object3D();

  			} else {

  				var type = 0;
  				if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {

  					type = 1;

  				}

  				var nearClippingPlane = 1;
  				if ( cameraAttribute.NearPlane !== undefined ) {

  					nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

  				}

  				var farClippingPlane = 1000;
  				if ( cameraAttribute.FarPlane !== undefined ) {

  					farClippingPlane = cameraAttribute.FarPlane.value / 1000;

  				}
  				var width = window.innerWidth;
  				var height = window.innerHeight;

  				if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

  					width = cameraAttribute.AspectWidth.value;
  					height = cameraAttribute.AspectHeight.value;

  				}

  				var aspect = width / height;

  				var fov = 45;
  				if ( cameraAttribute.FieldOfView !== undefined ) {

  					fov = cameraAttribute.FieldOfView.value;

  				}

  				var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

  				switch ( type ) {

  					case 0: // Perspective
  						model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
  						if ( focalLength !== null ) { model.setFocalLength( focalLength ); }
  						break;

  					case 1: // Orthographic
  						model = new OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );
  						break;

  					default:
  						console.warn( 'FBXLoader: Unknown camera type ' + type + '.' );
  						model = new Object3D();
  						break;

  				}

  			}

  			return model;

  		},

  		// Create a DirectionalLight, PointLight or SpotLight
  		createLight: function ( relationships ) {

  			var model;
  			var lightAttribute;

  			relationships.children.forEach( function ( child ) {

  				var attr = fbxTree.Objects.NodeAttribute[ child.ID ];

  				if ( attr !== undefined ) {

  					lightAttribute = attr;

  				}

  			} );

  			if ( lightAttribute === undefined ) {

  				model = new Object3D();

  			} else {

  				var type;

  				// LightType can be undefined for Point lights
  				if ( lightAttribute.LightType === undefined ) {

  					type = 0;

  				} else {

  					type = lightAttribute.LightType.value;

  				}

  				var color = 0xffffff;

  				if ( lightAttribute.Color !== undefined ) {

  					color = new Color().fromArray( lightAttribute.Color.value );

  				}

  				var intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

  				// light disabled
  				if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {

  					intensity = 0;

  				}

  				var distance = 0;
  				if ( lightAttribute.FarAttenuationEnd !== undefined ) {

  					if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {

  						distance = 0;

  					} else {

  						distance = lightAttribute.FarAttenuationEnd.value;

  					}

  				}

  				// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
  				var decay = 1;

  				switch ( type ) {

  					case 0: // Point
  						model = new PointLight( color, intensity, distance, decay );
  						break;

  					case 1: // Directional
  						model = new DirectionalLight( color, intensity );
  						break;

  					case 2: // Spot
  						var angle = Math.PI / 3;

  						if ( lightAttribute.InnerAngle !== undefined ) {

  							angle = _Math.degToRad( lightAttribute.InnerAngle.value );

  						}

  						var penumbra = 0;
  						if ( lightAttribute.OuterAngle !== undefined ) {

  							// TODO: this is not correct - FBX calculates outer and inner angle in degrees
  							// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
  							// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
  							penumbra = _Math.degToRad( lightAttribute.OuterAngle.value );
  							penumbra = Math.max( penumbra, 1 );

  						}

  						model = new SpotLight( color, intensity, distance, angle, penumbra, decay );
  						break;

  					default:
  						console.warn( 'FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );
  						model = new PointLight( color, intensity );
  						break;

  				}

  				if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {

  					model.castShadow = true;

  				}

  			}

  			return model;

  		},

  		createMesh: function ( relationships, geometryMap, materialMap ) {

  			var model;
  			var geometry = null;
  			var material = null;
  			var materials = [];

  			// get geometry and materials(s) from connections
  			relationships.children.forEach( function ( child ) {

  				if ( geometryMap.has( child.ID ) ) {

  					geometry = geometryMap.get( child.ID );

  				}

  				if ( materialMap.has( child.ID ) ) {

  					materials.push( materialMap.get( child.ID ) );

  				}

  			} );

  			if ( materials.length > 1 ) {

  				material = materials;

  			} else if ( materials.length > 0 ) {

  				material = materials[ 0 ];

  			} else {

  				material = new MeshPhongMaterial( { color: 0xcccccc } );
  				materials.push( material );

  			}

  			if ( 'color' in geometry.attributes ) {

  				materials.forEach( function ( material ) {

  					material.vertexColors = VertexColors;

  				} );

  			}

  			if ( geometry.FBX_Deformer ) {

  				materials.forEach( function ( material ) {

  					material.skinning = true;

  				} );

  				model = new SkinnedMesh( geometry, material );
  				model.normalizeSkinWeights();

  			} else {

  				model = new Mesh( geometry, material );

  			}

  			return model;

  		},

  		createCurve: function ( relationships, geometryMap ) {

  			var geometry = relationships.children.reduce( function ( geo, child ) {

  				if ( geometryMap.has( child.ID ) ) { geo = geometryMap.get( child.ID ); }

  				return geo;

  			}, null );

  			// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
  			var material = new LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );
  			return new Line( geometry, material );

  		},

  		// parse the model node for transform data
  		getTransformData: function ( model, modelNode ) {

  			var transformData = {};

  			if ( 'InheritType' in modelNode ) { transformData.inheritType = parseInt( modelNode.InheritType.value ); }

  			if ( 'RotationOrder' in modelNode ) { transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value ); }
  			else { transformData.eulerOrder = 'ZYX'; }

  			if ( 'Lcl_Translation' in modelNode ) { transformData.translation = modelNode.Lcl_Translation.value; }

  			if ( 'PreRotation' in modelNode ) { transformData.preRotation = modelNode.PreRotation.value; }
  			if ( 'Lcl_Rotation' in modelNode ) { transformData.rotation = modelNode.Lcl_Rotation.value; }
  			if ( 'PostRotation' in modelNode ) { transformData.postRotation = modelNode.PostRotation.value; }

  			if ( 'Lcl_Scaling' in modelNode ) { transformData.scale = modelNode.Lcl_Scaling.value; }

  			if ( 'ScalingOffset' in modelNode ) { transformData.scalingOffset = modelNode.ScalingOffset.value; }
  			if ( 'ScalingPivot' in modelNode ) { transformData.scalingPivot = modelNode.ScalingPivot.value; }

  			if ( 'RotationOffset' in modelNode ) { transformData.rotationOffset = modelNode.RotationOffset.value; }
  			if ( 'RotationPivot' in modelNode ) { transformData.rotationPivot = modelNode.RotationPivot.value; }

  			model.userData.transformData = transformData;

  		},

  		setLookAtProperties: function ( model, modelNode ) {

  			if ( 'LookAtProperty' in modelNode ) {

  				var children = connections.get( model.ID ).children;

  				children.forEach( function ( child ) {

  					if ( child.relationship === 'LookAtProperty' ) {

  						var lookAtTarget = fbxTree.Objects.Model[ child.ID ];

  						if ( 'Lcl_Translation' in lookAtTarget ) {

  							var pos = lookAtTarget.Lcl_Translation.value;

  							// DirectionalLight, SpotLight
  							if ( model.target !== undefined ) {

  								model.target.position.fromArray( pos );
  								sceneGraph.add( model.target );

  							} else { // Cameras and other Object3Ds

  								model.lookAt( new Vector3().fromArray( pos ) );

  							}

  						}

  					}

  				} );

  			}

  		},

  		bindSkeleton: function ( skeletons, geometryMap, modelMap ) {

  			var bindMatrices = this.parsePoseNodes();

  			for ( var ID in skeletons ) {

  				var skeleton = skeletons[ ID ];

  				var parents = connections.get( parseInt( skeleton.ID ) ).parents;

  				parents.forEach( function ( parent ) {

  					if ( geometryMap.has( parent.ID ) ) {

  						var geoID = parent.ID;
  						var geoRelationships = connections.get( geoID );

  						geoRelationships.parents.forEach( function ( geoConnParent ) {

  							if ( modelMap.has( geoConnParent.ID ) ) {

  								var model = modelMap.get( geoConnParent.ID );

  								model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );

  							}

  						} );

  					}

  				} );

  			}

  		},

  		parsePoseNodes: function () {

  			var bindMatrices = {};

  			if ( 'Pose' in fbxTree.Objects ) {

  				var BindPoseNode = fbxTree.Objects.Pose;

  				for ( var nodeID in BindPoseNode ) {

  					if ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {

  						var poseNodes = BindPoseNode[ nodeID ].PoseNode;

  						if ( Array.isArray( poseNodes ) ) {

  							poseNodes.forEach( function ( poseNode ) {

  								bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );

  							} );

  						} else {

  							bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );

  						}

  					}

  				}

  			}

  			return bindMatrices;

  		},

  		// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  		createAmbientLight: function () {

  			if ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {

  				var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
  				var r = ambientColor[ 0 ];
  				var g = ambientColor[ 1 ];
  				var b = ambientColor[ 2 ];

  				if ( r !== 0 || g !== 0 || b !== 0 ) {

  					var color = new Color( r, g, b );
  					sceneGraph.add( new AmbientLight( color, 1 ) );

  				}

  			}

  		},

  		setupMorphMaterials: function () {

  			var self = this;
  			sceneGraph.traverse( function ( child ) {

  				if ( child.isMesh ) {

  					if ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {

  						if ( Array.isArray( child.material ) ) {

  							child.material.forEach( function ( material, i ) {

  								self.setupMorphMaterial( child, material, i );

  							} );

  						} else {

  							self.setupMorphMaterial( child, child.material );

  						}

  					}

  				}

  			} );

  		},

  		setupMorphMaterial: function ( child, material, index ) {

  			var uuid = child.uuid;
  			var matUuid = material.uuid;

  			// if a geometry has morph targets, it cannot share the material with other geometries
  			var sharedMat = false;

  			sceneGraph.traverse( function ( node ) {

  				if ( node.isMesh ) {

  					if ( Array.isArray( node.material ) ) {

  						node.material.forEach( function ( mat ) {

  							if ( mat.uuid === matUuid && node.uuid !== uuid ) { sharedMat = true; }

  						} );

  					} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) { sharedMat = true; }

  				}

  			} );

  			if ( sharedMat === true ) {

  				var clonedMat = material.clone();
  				clonedMat.morphTargets = true;

  				if ( index === undefined ) { child.material = clonedMat; }
  				else { child.material[ index ] = clonedMat; }

  			} else { material.morphTargets = true; }

  		}

  	};

  	// parse Geometry data from FBXTree and return map of BufferGeometries
  	function GeometryParser() {}

  	GeometryParser.prototype = {

  		constructor: GeometryParser,

  		// Parse nodes in FBXTree.Objects.Geometry
  		parse: function ( deformers ) {
  			var this$1 = this;


  			var geometryMap = new Map();

  			if ( 'Geometry' in fbxTree.Objects ) {

  				var geoNodes = fbxTree.Objects.Geometry;

  				for ( var nodeID in geoNodes ) {

  					var relationships = connections.get( parseInt( nodeID ) );
  					var geo = this$1.parseGeometry( relationships, geoNodes[ nodeID ], deformers );

  					geometryMap.set( parseInt( nodeID ), geo );

  				}

  			}

  			return geometryMap;

  		},

  		// Parse single node in FBXTree.Objects.Geometry
  		parseGeometry: function ( relationships, geoNode, deformers ) {

  			switch ( geoNode.attrType ) {

  				case 'Mesh':
  					return this.parseMeshGeometry( relationships, geoNode, deformers );
  					break;

  				case 'NurbsCurve':
  					return this.parseNurbsGeometry( geoNode );
  					break;

  			}

  		},

  		// Parse single node mesh geometry in FBXTree.Objects.Geometry
  		parseMeshGeometry: function ( relationships, geoNode, deformers ) {

  			var skeletons = deformers.skeletons;
  			var morphTargets = deformers.morphTargets;

  			var modelNodes = relationships.parents.map( function ( parent ) {

  				return fbxTree.Objects.Model[ parent.ID ];

  			} );

  			// don't create geometry if it is not associated with any models
  			if ( modelNodes.length === 0 ) { return; }

  			var skeleton = relationships.children.reduce( function ( skeleton, child ) {

  				if ( skeletons[ child.ID ] !== undefined ) { skeleton = skeletons[ child.ID ]; }

  				return skeleton;

  			}, null );

  			var morphTarget = relationships.children.reduce( function ( morphTarget, child ) {

  				if ( morphTargets[ child.ID ] !== undefined ) { morphTarget = morphTargets[ child.ID ]; }

  				return morphTarget;

  			}, null );

  			// Assume one model and get the preRotation from that
  			// if there is more than one model associated with the geometry this may cause problems
  			var modelNode = modelNodes[ 0 ];

  			var transformData = {};

  			if ( 'RotationOrder' in modelNode ) { transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value ); }
  			if ( 'InheritType' in modelNode ) { transformData.inheritType = parseInt( modelNode.InheritType.value ); }

  			if ( 'GeometricTranslation' in modelNode ) { transformData.translation = modelNode.GeometricTranslation.value; }
  			if ( 'GeometricRotation' in modelNode ) { transformData.rotation = modelNode.GeometricRotation.value; }
  			if ( 'GeometricScaling' in modelNode ) { transformData.scale = modelNode.GeometricScaling.value; }

  			var transform = generateTransform( transformData );

  			return this.genGeometry( geoNode, skeleton, morphTarget, transform );

  		},

  		// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  		genGeometry: function ( geoNode, skeleton, morphTarget, preTransform ) {

  			var geo = new BufferGeometry();
  			if ( geoNode.attrName ) { geo.name = geoNode.attrName; }

  			var geoInfo = this.parseGeoNode( geoNode, skeleton );
  			var buffers = this.genBuffers( geoInfo );

  			var positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );

  			preTransform.applyToBufferAttribute( positionAttribute );

  			geo.addAttribute( 'position', positionAttribute );

  			if ( buffers.colors.length > 0 ) {

  				geo.addAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );

  			}

  			if ( skeleton ) {

  				geo.addAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );

  				geo.addAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );

  				// used later to bind the skeleton to the model
  				geo.FBX_Deformer = skeleton;

  			}

  			if ( buffers.normal.length > 0 ) {

  				var normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );

  				var normalMatrix = new Matrix3().getNormalMatrix( preTransform );
  				normalMatrix.applyToBufferAttribute( normalAttribute );

  				geo.addAttribute( 'normal', normalAttribute );

  			}

  			buffers.uvs.forEach( function ( uvBuffer, i ) {

  				// subsequent uv buffers are called 'uv1', 'uv2', ...
  				var name = 'uv' + ( i + 1 ).toString();

  				// the first uv buffer is just called 'uv'
  				if ( i === 0 ) {

  					name = 'uv';

  				}

  				geo.addAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );

  			} );

  			if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  				// Convert the material indices of each vertex into rendering groups on the geometry.
  				var prevMaterialIndex = buffers.materialIndex[ 0 ];
  				var startIndex = 0;

  				buffers.materialIndex.forEach( function ( currentIndex, i ) {

  					if ( currentIndex !== prevMaterialIndex ) {

  						geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

  						prevMaterialIndex = currentIndex;
  						startIndex = i;

  					}

  				} );

  				// the loop above doesn't add the last group, do that here.
  				if ( geo.groups.length > 0 ) {

  					var lastGroup = geo.groups[ geo.groups.length - 1 ];
  					var lastIndex = lastGroup.start + lastGroup.count;

  					if ( lastIndex !== buffers.materialIndex.length ) {

  						geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );

  					}

  				}

  				// case where there are multiple materials but the whole geometry is only
  				// using one of them
  				if ( geo.groups.length === 0 ) {

  					geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );

  				}

  			}

  			this.addMorphTargets( geo, geoNode, morphTarget, preTransform );

  			return geo;

  		},

  		parseGeoNode: function ( geoNode, skeleton ) {
  			var this$1 = this;


  			var geoInfo = {};

  			geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
  			geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];

  			if ( geoNode.LayerElementColor ) {

  				geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );

  			}

  			if ( geoNode.LayerElementMaterial ) {

  				geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );

  			}

  			if ( geoNode.LayerElementNormal ) {

  				geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );

  			}

  			if ( geoNode.LayerElementUV ) {

  				geoInfo.uv = [];

  				var i = 0;
  				while ( geoNode.LayerElementUV[ i ] ) {

  					geoInfo.uv.push( this$1.parseUVs( geoNode.LayerElementUV[ i ] ) );
  					i ++;

  				}

  			}

  			geoInfo.weightTable = {};

  			if ( skeleton !== null ) {

  				geoInfo.skeleton = skeleton;

  				skeleton.rawBones.forEach( function ( rawBone, i ) {

  					// loop over the bone's vertex indices and weights
  					rawBone.indices.forEach( function ( index, j ) {

  						if ( geoInfo.weightTable[ index ] === undefined ) { geoInfo.weightTable[ index ] = []; }

  						geoInfo.weightTable[ index ].push( {

  							id: i,
  							weight: rawBone.weights[ j ],

  						} );

  					} );

  				} );

  			}

  			return geoInfo;

  		},

  		genBuffers: function ( geoInfo ) {

  			var buffers = {
  				vertex: [],
  				normal: [],
  				colors: [],
  				uvs: [],
  				materialIndex: [],
  				vertexWeights: [],
  				weightsIndices: [],
  			};

  			var polygonIndex = 0;
  			var faceLength = 0;
  			var displayedWeightsWarning = false;

  			// these will hold data for a single face
  			var facePositionIndexes = [];
  			var faceNormals = [];
  			var faceColors = [];
  			var faceUVs = [];
  			var faceWeights = [];
  			var faceWeightIndices = [];

  			var self = this;
  			geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {

  				var endOfFace = false;

  				// Face index and vertex index arrays are combined in a single array
  				// A cube with quad faces looks like this:
  				// PolygonVertexIndex: *24 {
  				//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
  				//  }
  				// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
  				// to find index of last vertex bit shift the index: ^ - 1
  				if ( vertexIndex < 0 ) {

  					vertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1
  					endOfFace = true;

  				}

  				var weightIndices = [];
  				var weights = [];

  				facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

  				if ( geoInfo.color ) {

  					var data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );

  					faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );

  				}

  				if ( geoInfo.skeleton ) {

  					if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {

  						geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {

  							weights.push( wt.weight );
  							weightIndices.push( wt.id );

  						} );
  					}

  					if ( weights.length > 4 ) {

  						if ( ! displayedWeightsWarning ) {

  							console.warn( 'FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
  							displayedWeightsWarning = true;

  						}

  						var wIndex = [ 0, 0, 0, 0 ];
  						var Weight = [ 0, 0, 0, 0 ];

  						weights.forEach( function ( weight, weightIndex ) {

  							var currentWeight = weight;
  							var currentIndex = weightIndices[ weightIndex ];

  							Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

  								if ( currentWeight > comparedWeight ) {

  									comparedWeightArray[ comparedWeightIndex ] = currentWeight;
  									currentWeight = comparedWeight;

  									var tmp = wIndex[ comparedWeightIndex ];
  									wIndex[ comparedWeightIndex ] = currentIndex;
  									currentIndex = tmp;

  								}

  							} );

  						} );

  						weightIndices = wIndex;
  						weights = Weight;

  					}

  					// if the weight array is shorter than 4 pad with 0s
  					while ( weights.length < 4 ) {

  						weights.push( 0 );
  						weightIndices.push( 0 );

  					}

  					for ( var i = 0; i < 4; ++ i ) {

  						faceWeights.push( weights[ i ] );
  						faceWeightIndices.push( weightIndices[ i ] );

  					}

  				}

  				if ( geoInfo.normal ) {

  					var data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );

  					faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

  				}

  				if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  					var materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];

  				}

  				if ( geoInfo.uv ) {

  					geoInfo.uv.forEach( function ( uv, i ) {

  						var data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );

  						if ( faceUVs[ i ] === undefined ) {

  							faceUVs[ i ] = [];

  						}

  						faceUVs[ i ].push( data[ 0 ] );
  						faceUVs[ i ].push( data[ 1 ] );

  					} );

  				}

  				faceLength ++;

  				if ( endOfFace ) {

  					self.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

  					polygonIndex ++;
  					faceLength = 0;

  					// reset arrays for the next face
  					facePositionIndexes = [];
  					faceNormals = [];
  					faceColors = [];
  					faceUVs = [];
  					faceWeights = [];
  					faceWeightIndices = [];

  				}

  			} );

  			return buffers;

  		},

  		// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  		genFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

  			for ( var i = 2; i < faceLength; i ++ ) {

  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );

  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );

  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );
  				buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );

  				if ( geoInfo.skeleton ) {

  					buffers.vertexWeights.push( faceWeights[ 0 ] );
  					buffers.vertexWeights.push( faceWeights[ 1 ] );
  					buffers.vertexWeights.push( faceWeights[ 2 ] );
  					buffers.vertexWeights.push( faceWeights[ 3 ] );

  					buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );
  					buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );
  					buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );
  					buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );

  					buffers.vertexWeights.push( faceWeights[ i * 4 ] );
  					buffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );
  					buffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );
  					buffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );

  					buffers.weightsIndices.push( faceWeightIndices[ 0 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ 1 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ 2 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ 3 ] );

  					buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );

  					buffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );
  					buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );

  				}

  				if ( geoInfo.color ) {

  					buffers.colors.push( faceColors[ 0 ] );
  					buffers.colors.push( faceColors[ 1 ] );
  					buffers.colors.push( faceColors[ 2 ] );

  					buffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );
  					buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );
  					buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );

  					buffers.colors.push( faceColors[ i * 3 ] );
  					buffers.colors.push( faceColors[ i * 3 + 1 ] );
  					buffers.colors.push( faceColors[ i * 3 + 2 ] );

  				}

  				if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

  					buffers.materialIndex.push( materialIndex );
  					buffers.materialIndex.push( materialIndex );
  					buffers.materialIndex.push( materialIndex );

  				}

  				if ( geoInfo.normal ) {

  					buffers.normal.push( faceNormals[ 0 ] );
  					buffers.normal.push( faceNormals[ 1 ] );
  					buffers.normal.push( faceNormals[ 2 ] );

  					buffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );
  					buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );
  					buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );

  					buffers.normal.push( faceNormals[ i * 3 ] );
  					buffers.normal.push( faceNormals[ i * 3 + 1 ] );
  					buffers.normal.push( faceNormals[ i * 3 + 2 ] );

  				}

  				if ( geoInfo.uv ) {

  					geoInfo.uv.forEach( function ( uv, j ) {

  						if ( buffers.uvs[ j ] === undefined ) { buffers.uvs[ j ] = []; }

  						buffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );
  						buffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );

  						buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );
  						buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );

  						buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );
  						buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );

  					} );

  				}

  			}

  		},

  		addMorphTargets: function ( parentGeo, parentGeoNode, morphTarget, preTransform ) {

  			if ( morphTarget === null ) { return; }

  			parentGeo.morphAttributes.position = [];
  			// parentGeo.morphAttributes.normal = []; // not implemented

  			var self = this;
  			morphTarget.rawTargets.forEach( function ( rawTarget ) {

  				var morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];

  				if ( morphGeoNode !== undefined ) {

  					self.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );

  				}

  			} );

  		},

  		// a morph geometry node is similar to a standard  node, and the node is also contained
  		// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  		// and a special attribute Index defining which vertices of the original geometry are affected
  		// Normal and position attributes only have data for the vertices that are affected by the morph
  		genMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

  			var morphGeo = new BufferGeometry();
  			if ( morphGeoNode.attrName ) { morphGeo.name = morphGeoNode.attrName; }

  			var vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];

  			// make a copy of the parent's vertex positions
  			var vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];

  			var morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];
  			var indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];

  			for ( var i = 0; i < indices.length; i ++ ) {

  				var morphIndex = indices[ i ] * 3;

  				// FBX format uses blend shapes rather than morph targets. This can be converted
  				// by additively combining the blend shape positions with the original geometry's positions
  				vertexPositions[ morphIndex ] += morphPositions[ i * 3 ];
  				vertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];
  				vertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];

  			}

  			// TODO: add morph normal support
  			var morphGeoInfo = {
  				vertexIndices: vertexIndices,
  				vertexPositions: vertexPositions,
  			};

  			var morphBuffers = this.genBuffers( morphGeoInfo );

  			var positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );
  			positionAttribute.name = name || morphGeoNode.attrName;

  			preTransform.applyToBufferAttribute( positionAttribute );

  			parentGeo.morphAttributes.position.push( positionAttribute );

  		},

  		// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  		parseNormals: function ( NormalNode ) {

  			var mappingType = NormalNode.MappingInformationType;
  			var referenceType = NormalNode.ReferenceInformationType;
  			var buffer = NormalNode.Normals.a;
  			var indexBuffer = [];
  			if ( referenceType === 'IndexToDirect' ) {

  				if ( 'NormalIndex' in NormalNode ) {

  					indexBuffer = NormalNode.NormalIndex.a;

  				} else if ( 'NormalsIndex' in NormalNode ) {

  					indexBuffer = NormalNode.NormalsIndex.a;

  				}

  			}

  			return {
  				dataSize: 3,
  				buffer: buffer,
  				indices: indexBuffer,
  				mappingType: mappingType,
  				referenceType: referenceType
  			};

  		},

  		// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  		parseUVs: function ( UVNode ) {

  			var mappingType = UVNode.MappingInformationType;
  			var referenceType = UVNode.ReferenceInformationType;
  			var buffer = UVNode.UV.a;
  			var indexBuffer = [];
  			if ( referenceType === 'IndexToDirect' ) {

  				indexBuffer = UVNode.UVIndex.a;

  			}

  			return {
  				dataSize: 2,
  				buffer: buffer,
  				indices: indexBuffer,
  				mappingType: mappingType,
  				referenceType: referenceType
  			};

  		},

  		// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  		parseVertexColors: function ( ColorNode ) {

  			var mappingType = ColorNode.MappingInformationType;
  			var referenceType = ColorNode.ReferenceInformationType;
  			var buffer = ColorNode.Colors.a;
  			var indexBuffer = [];
  			if ( referenceType === 'IndexToDirect' ) {

  				indexBuffer = ColorNode.ColorIndex.a;

  			}

  			return {
  				dataSize: 4,
  				buffer: buffer,
  				indices: indexBuffer,
  				mappingType: mappingType,
  				referenceType: referenceType
  			};

  		},

  		// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  		parseMaterialIndices: function ( MaterialNode ) {

  			var mappingType = MaterialNode.MappingInformationType;
  			var referenceType = MaterialNode.ReferenceInformationType;

  			if ( mappingType === 'NoMappingInformation' ) {

  				return {
  					dataSize: 1,
  					buffer: [ 0 ],
  					indices: [ 0 ],
  					mappingType: 'AllSame',
  					referenceType: referenceType
  				};

  			}

  			var materialIndexBuffer = MaterialNode.Materials.a;

  			// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
  			// we expect.So we create an intermediate buffer that points to the index in the buffer,
  			// for conforming with the other functions we've written for other data.
  			var materialIndices = [];

  			for ( var i = 0; i < materialIndexBuffer.length; ++ i ) {

  				materialIndices.push( i );

  			}

  			return {
  				dataSize: 1,
  				buffer: materialIndexBuffer,
  				indices: materialIndices,
  				mappingType: mappingType,
  				referenceType: referenceType
  			};

  		},

  		// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  		parseNurbsGeometry: function ( geoNode ) {

  			if ( NURBSCurve === undefined ) {

  				console.error( 'FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );
  				return new BufferGeometry();

  			}

  			var order = parseInt( geoNode.Order );

  			if ( isNaN( order ) ) {

  				console.error( 'FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
  				return new BufferGeometry();

  			}

  			var degree = order - 1;

  			var knots = geoNode.KnotVector.a;
  			var controlPoints = [];
  			var pointsValues = geoNode.Points.a;

  			for ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {

  				controlPoints.push( new Vector4().fromArray( pointsValues, i ) );

  			}

  			var startKnot, endKnot;

  			if ( geoNode.Form === 'Closed' ) {

  				controlPoints.push( controlPoints[ 0 ] );

  			} else if ( geoNode.Form === 'Periodic' ) {

  				startKnot = degree;
  				endKnot = knots.length - 1 - startKnot;

  				for ( var i = 0; i < degree; ++ i ) {

  					controlPoints.push( controlPoints[ i ] );

  				}

  			}

  			var curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
  			var vertices = curve.getPoints( controlPoints.length * 7 );

  			var positions = new Float32Array( vertices.length * 3 );

  			vertices.forEach( function ( vertex, i ) {

  				vertex.toArray( positions, i * 3 );

  			} );

  			var geometry = new BufferGeometry();
  			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  			return geometry;

  		},

  	};

  	// parse animation data from FBXTree
  	function AnimationParser() {}

  	AnimationParser.prototype = {

  		constructor: AnimationParser,

  		// take raw animation clips and turn them into three.js animation clips
  		parse: function () {
  			var this$1 = this;


  			var animationClips = [];

  			var rawClips = this.parseClips();

  			if ( rawClips !== undefined ) {

  				for ( var key in rawClips ) {

  					var rawClip = rawClips[ key ];

  					var clip = this$1.addClip( rawClip );

  					animationClips.push( clip );

  				}

  			}

  			return animationClips;

  		},

  		parseClips: function () {

  			// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
  			// if this is undefined we can safely assume there are no animations
  			if ( fbxTree.Objects.AnimationCurve === undefined ) { return undefined; }

  			var curveNodesMap = this.parseAnimationCurveNodes();

  			this.parseAnimationCurves( curveNodesMap );

  			var layersMap = this.parseAnimationLayers( curveNodesMap );
  			var rawClips = this.parseAnimStacks( layersMap );

  			return rawClips;

  		},

  		// parse nodes in FBXTree.Objects.AnimationCurveNode
  		// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  		// and is referenced by an AnimationLayer
  		parseAnimationCurveNodes: function () {

  			var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;

  			var curveNodesMap = new Map();

  			for ( var nodeID in rawCurveNodes ) {

  				var rawCurveNode = rawCurveNodes[ nodeID ];

  				if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {

  					var curveNode = {

  						id: rawCurveNode.id,
  						attr: rawCurveNode.attrName,
  						curves: {},

  					};

  					curveNodesMap.set( curveNode.id, curveNode );

  				}

  			}

  			return curveNodesMap;

  		},

  		// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  		// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  		// axis ( e.g. times and values of x rotation)
  		parseAnimationCurves: function ( curveNodesMap ) {

  			var rawCurves = fbxTree.Objects.AnimationCurve;

  			// TODO: Many values are identical up to roundoff error, but won't be optimised
  			// e.g. position times: [0, 0.4, 0. 8]
  			// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
  			// clearly, this should be optimised to
  			// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
  			// this shows up in nearly every FBX file, and generally time array is length > 100

  			for ( var nodeID in rawCurves ) {

  				var animationCurve = {

  					id: rawCurves[ nodeID ].id,
  					times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),
  					values: rawCurves[ nodeID ].KeyValueFloat.a,

  				};

  				var relationships = connections.get( animationCurve.id );

  				if ( relationships !== undefined ) {

  					var animationCurveID = relationships.parents[ 0 ].ID;
  					var animationCurveRelationship = relationships.parents[ 0 ].relationship;

  					if ( animationCurveRelationship.match( /X/ ) ) {

  						curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;

  					} else if ( animationCurveRelationship.match( /Y/ ) ) {

  						curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;

  					} else if ( animationCurveRelationship.match( /Z/ ) ) {

  						curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;

  					} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {

  						curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;

  					}

  				}

  			}

  		},

  		// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  		// to various AnimationCurveNodes and is referenced by an AnimationStack node
  		// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  		parseAnimationLayers: function ( curveNodesMap ) {

  			var rawLayers = fbxTree.Objects.AnimationLayer;

  			var layersMap = new Map();

  			for ( var nodeID in rawLayers ) {

  				var layerCurveNodes = [];

  				var connection = connections.get( parseInt( nodeID ) );

  				if ( connection !== undefined ) {

  					// all the animationCurveNodes used in the layer
  					var children = connection.children;

  					children.forEach( function ( child, i ) {

  						if ( curveNodesMap.has( child.ID ) ) {

  							var curveNode = curveNodesMap.get( child.ID );

  							// check that the curves are defined for at least one axis, otherwise ignore the curveNode
  							if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {

  								if ( layerCurveNodes[ i ] === undefined ) {

  									var modelID = connections.get( child.ID ).parents.filter( function ( parent ) {

  										return parent.relationship !== undefined;

  									} )[ 0 ].ID;

  									if ( modelID !== undefined ) {

  										var rawModel = fbxTree.Objects.Model[ modelID.toString() ];

  										var node = {

  											modelName: PropertyBinding.sanitizeNodeName( rawModel.attrName ),
  											ID: rawModel.id,
  											initialPosition: [ 0, 0, 0 ],
  											initialRotation: [ 0, 0, 0 ],
  											initialScale: [ 1, 1, 1 ],

  										};

  										sceneGraph.traverse( function ( child ) {

  											if ( child.ID === rawModel.id ) {

  												node.transform = child.matrix;

  												if ( child.userData.transformData ) { node.eulerOrder = child.userData.transformData.eulerOrder; }

  											}

  										} );

  										if ( ! node.transform ) { node.transform = new Matrix4(); }

  										// if the animated model is pre rotated, we'll have to apply the pre rotations to every
  										// animation value as well
  										if ( 'PreRotation' in rawModel ) { node.preRotation = rawModel.PreRotation.value; }
  										if ( 'PostRotation' in rawModel ) { node.postRotation = rawModel.PostRotation.value; }

  										layerCurveNodes[ i ] = node;

  									}

  								}

  								if ( layerCurveNodes[ i ] ) { layerCurveNodes[ i ][ curveNode.attr ] = curveNode; }

  							} else if ( curveNode.curves.morph !== undefined ) {

  								if ( layerCurveNodes[ i ] === undefined ) {

  									var deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {

  										return parent.relationship !== undefined;

  									} )[ 0 ].ID;

  									var morpherID = connections.get( deformerID ).parents[ 0 ].ID;
  									var geoID = connections.get( morpherID ).parents[ 0 ].ID;

  									// assuming geometry is not used in more than one model
  									var modelID = connections.get( geoID ).parents[ 0 ].ID;

  									var rawModel = fbxTree.Objects.Model[ modelID ];

  									var node = {

  										modelName: PropertyBinding.sanitizeNodeName( rawModel.attrName ),
  										morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,

  									};

  									layerCurveNodes[ i ] = node;

  								}

  								layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

  							}

  						}

  					} );

  					layersMap.set( parseInt( nodeID ), layerCurveNodes );

  				}

  			}

  			return layersMap;

  		},

  		// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  		// hierarchy. Each Stack node will be used to create a AnimationClip
  		parseAnimStacks: function ( layersMap ) {

  			var rawStacks = fbxTree.Objects.AnimationStack;

  			// connect the stacks (clips) up to the layers
  			var rawClips = {};

  			for ( var nodeID in rawStacks ) {

  				var children = connections.get( parseInt( nodeID ) ).children;

  				if ( children.length > 1 ) {

  					// it seems like stacks will always be associated with a single layer. But just in case there are files
  					// where there are multiple layers per stack, we'll display a warning
  					console.warn( 'FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );

  				}

  				var layer = layersMap.get( children[ 0 ].ID );

  				rawClips[ nodeID ] = {

  					name: rawStacks[ nodeID ].attrName,
  					layer: layer,

  				};

  			}

  			return rawClips;

  		},

  		addClip: function ( rawClip ) {

  			var tracks = [];

  			var self = this;
  			rawClip.layer.forEach( function ( rawTracks ) {

  				tracks = tracks.concat( self.generateTracks( rawTracks ) );

  			} );

  			return new AnimationClip( rawClip.name, - 1, tracks );

  		},

  		generateTracks: function ( rawTracks ) {

  			var tracks = [];

  			var initialPosition = new Vector3();
  			var initialRotation = new Quaternion();
  			var initialScale = new Vector3();

  			if ( rawTracks.transform ) { rawTracks.transform.decompose( initialPosition, initialRotation, initialScale ); }

  			initialPosition = initialPosition.toArray();
  			initialRotation = new Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();
  			initialScale = initialScale.toArray();

  			if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {

  				var positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );
  				if ( positionTrack !== undefined ) { tracks.push( positionTrack ); }

  			}

  			if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {

  				var rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );
  				if ( rotationTrack !== undefined ) { tracks.push( rotationTrack ); }

  			}

  			if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {

  				var scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );
  				if ( scaleTrack !== undefined ) { tracks.push( scaleTrack ); }

  			}

  			if ( rawTracks.DeformPercent !== undefined ) {

  				var morphTrack = this.generateMorphTrack( rawTracks );
  				if ( morphTrack !== undefined ) { tracks.push( morphTrack ); }

  			}

  			return tracks;

  		},

  		generateVectorTrack: function ( modelName, curves, initialValue, type ) {

  			var times = this.getTimesForAllAxes( curves );
  			var values = this.getKeyframeTrackValues( times, curves, initialValue );

  			return new VectorKeyframeTrack( modelName + '.' + type, times, values );

  		},

  		generateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {

  			if ( curves.x !== undefined ) {

  				this.interpolateRotations( curves.x );
  				curves.x.values = curves.x.values.map( _Math.degToRad );

  			}
  			if ( curves.y !== undefined ) {

  				this.interpolateRotations( curves.y );
  				curves.y.values = curves.y.values.map( _Math.degToRad );

  			}
  			if ( curves.z !== undefined ) {

  				this.interpolateRotations( curves.z );
  				curves.z.values = curves.z.values.map( _Math.degToRad );

  			}

  			var times = this.getTimesForAllAxes( curves );
  			var values = this.getKeyframeTrackValues( times, curves, initialValue );

  			if ( preRotation !== undefined ) {

  				preRotation = preRotation.map( _Math.degToRad );
  				preRotation.push( eulerOrder );

  				preRotation = new Euler().fromArray( preRotation );
  				preRotation = new Quaternion().setFromEuler( preRotation );

  			}

  			if ( postRotation !== undefined ) {

  				postRotation = postRotation.map( _Math.degToRad );
  				postRotation.push( eulerOrder );

  				postRotation = new Euler().fromArray( postRotation );
  				postRotation = new Quaternion().setFromEuler( postRotation ).inverse();

  			}

  			var quaternion = new Quaternion();
  			var euler = new Euler();

  			var quaternionValues = [];

  			for ( var i = 0; i < values.length; i += 3 ) {

  				euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );

  				quaternion.setFromEuler( euler );

  				if ( preRotation !== undefined ) { quaternion.premultiply( preRotation ); }
  				if ( postRotation !== undefined ) { quaternion.multiply( postRotation ); }

  				quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );

  			}

  			return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );

  		},

  		generateMorphTrack: function ( rawTracks ) {

  			var curves = rawTracks.DeformPercent.curves.morph;
  			var values = curves.values.map( function ( val ) {

  				return val / 100;

  			} );

  			var morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];

  			return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );

  		},

  		// For all animated objects, times are defined separately for each axis
  		// Here we'll combine the times into one sorted array without duplicates
  		getTimesForAllAxes: function ( curves ) {

  			var times = [];

  			// first join together the times for each axis, if defined
  			if ( curves.x !== undefined ) { times = times.concat( curves.x.times ); }
  			if ( curves.y !== undefined ) { times = times.concat( curves.y.times ); }
  			if ( curves.z !== undefined ) { times = times.concat( curves.z.times ); }

  			// then sort them and remove duplicates
  			times = times.sort( function ( a, b ) {

  				return a - b;

  			} ).filter( function ( elem, index, array ) {

  				return array.indexOf( elem ) == index;

  			} );

  			return times;

  		},

  		getKeyframeTrackValues: function ( times, curves, initialValue ) {

  			var prevValue = initialValue;

  			var values = [];

  			var xIndex = - 1;
  			var yIndex = - 1;
  			var zIndex = - 1;

  			times.forEach( function ( time ) {

  				if ( curves.x ) { xIndex = curves.x.times.indexOf( time ); }
  				if ( curves.y ) { yIndex = curves.y.times.indexOf( time ); }
  				if ( curves.z ) { zIndex = curves.z.times.indexOf( time ); }

  				// if there is an x value defined for this frame, use that
  				if ( xIndex !== - 1 ) {

  					var xValue = curves.x.values[ xIndex ];
  					values.push( xValue );
  					prevValue[ 0 ] = xValue;

  				} else {

  					// otherwise use the x value from the previous frame
  					values.push( prevValue[ 0 ] );

  				}

  				if ( yIndex !== - 1 ) {

  					var yValue = curves.y.values[ yIndex ];
  					values.push( yValue );
  					prevValue[ 1 ] = yValue;

  				} else {

  					values.push( prevValue[ 1 ] );

  				}

  				if ( zIndex !== - 1 ) {

  					var zValue = curves.z.values[ zIndex ];
  					values.push( zValue );
  					prevValue[ 2 ] = zValue;

  				} else {

  					values.push( prevValue[ 2 ] );

  				}

  			} );

  			return values;

  		},

  		// Rotations are defined as Euler angles which can have values  of any size
  		// These will be converted to quaternions which don't support values greater than
  		// PI, so we'll interpolate large rotations
  		interpolateRotations: function ( curve ) {

  			for ( var i = 1; i < curve.values.length; i ++ ) {

  				var initialValue = curve.values[ i - 1 ];
  				var valuesSpan = curve.values[ i ] - initialValue;

  				var absoluteSpan = Math.abs( valuesSpan );

  				if ( absoluteSpan >= 180 ) {

  					var numSubIntervals = absoluteSpan / 180;

  					var step = valuesSpan / numSubIntervals;
  					var nextValue = initialValue + step;

  					var initialTime = curve.times[ i - 1 ];
  					var timeSpan = curve.times[ i ] - initialTime;
  					var interval = timeSpan / numSubIntervals;
  					var nextTime = initialTime + interval;

  					var interpolatedTimes = [];
  					var interpolatedValues = [];

  					while ( nextTime < curve.times[ i ] ) {

  						interpolatedTimes.push( nextTime );
  						nextTime += interval;

  						interpolatedValues.push( nextValue );
  						nextValue += step;

  					}

  					curve.times = inject( curve.times, i, interpolatedTimes );
  					curve.values = inject( curve.values, i, interpolatedValues );

  				}

  			}

  		},

  	};

  	// parse an FBX file in ASCII format
  	function TextParser() {}

  	TextParser.prototype = {

  		constructor: TextParser,

  		getPrevNode: function () {

  			return this.nodeStack[ this.currentIndent - 2 ];

  		},

  		getCurrentNode: function () {

  			return this.nodeStack[ this.currentIndent - 1 ];

  		},

  		getCurrentProp: function () {

  			return this.currentProp;

  		},

  		pushStack: function ( node ) {

  			this.nodeStack.push( node );
  			this.currentIndent += 1;

  		},

  		popStack: function () {

  			this.nodeStack.pop();
  			this.currentIndent -= 1;

  		},

  		setCurrentProp: function ( val, name ) {

  			this.currentProp = val;
  			this.currentPropName = name;

  		},

  		parse: function ( text ) {

  			this.currentIndent = 0;

  			this.allNodes = new FBXTree();
  			this.nodeStack = [];
  			this.currentProp = [];
  			this.currentPropName = '';

  			var self = this;

  			var split = text.split( /[\r\n]+/ );

  			split.forEach( function ( line, i ) {

  				var matchComment = line.match( /^[\s\t]*;/ );
  				var matchEmpty = line.match( /^[\s\t]*$/ );

  				if ( matchComment || matchEmpty ) { return; }

  				var matchBeginning = line.match( '^\\t{' + self.currentIndent + '}(\\w+):(.*){', '' );
  				var matchProperty = line.match( '^\\t{' + ( self.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
  				var matchEnd = line.match( '^\\t{' + ( self.currentIndent - 1 ) + '}}' );

  				if ( matchBeginning ) {

  					self.parseNodeBegin( line, matchBeginning );

  				} else if ( matchProperty ) {

  					self.parseNodeProperty( line, matchProperty, split[ ++ i ] );

  				} else if ( matchEnd ) {

  					self.popStack();

  				} else if ( line.match( /^[^\s\t}]/ ) ) {

  					// large arrays are split over multiple lines terminated with a ',' character
  					// if this is encountered the line needs to be joined to the previous line
  					self.parseNodePropertyContinued( line );

  				}

  			} );

  			return this.allNodes;

  		},

  		parseNodeBegin: function ( line, property ) {

  			var nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );

  			var nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {

  				return attr.trim().replace( /^"/, '' ).replace( /"$/, '' );

  			} );

  			var node = { name: nodeName };
  			var attrs = this.parseNodeAttr( nodeAttrs );

  			var currentNode = this.getCurrentNode();

  			// a top node
  			if ( this.currentIndent === 0 ) {

  				this.allNodes.add( nodeName, node );

  			} else { // a subnode

  				// if the subnode already exists, append it
  				if ( nodeName in currentNode ) {

  					// special case Pose needs PoseNodes as an array
  					if ( nodeName === 'PoseNode' ) {

  						currentNode.PoseNode.push( node );

  					} else if ( currentNode[ nodeName ].id !== undefined ) {

  						currentNode[ nodeName ] = {};
  						currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];

  					}

  					if ( attrs.id !== '' ) { currentNode[ nodeName ][ attrs.id ] = node; }

  				} else if ( typeof attrs.id === 'number' ) {

  					currentNode[ nodeName ] = {};
  					currentNode[ nodeName ][ attrs.id ] = node;

  				} else if ( nodeName !== 'Properties70' ) {

  					if ( nodeName === 'PoseNode' )	{ currentNode[ nodeName ] = [ node ]; }
  					else { currentNode[ nodeName ] = node; }

  				}

  			}

  			if ( typeof attrs.id === 'number' ) { node.id = attrs.id; }
  			if ( attrs.name !== '' ) { node.attrName = attrs.name; }
  			if ( attrs.type !== '' ) { node.attrType = attrs.type; }

  			this.pushStack( node );

  		},

  		parseNodeAttr: function ( attrs ) {

  			var id = attrs[ 0 ];

  			if ( attrs[ 0 ] !== '' ) {

  				id = parseInt( attrs[ 0 ] );

  				if ( isNaN( id ) ) {

  					id = attrs[ 0 ];

  				}

  			}

  			var name = '', type = '';

  			if ( attrs.length > 1 ) {

  				name = attrs[ 1 ].replace( /^(\w+)::/, '' );
  				type = attrs[ 2 ];

  			}

  			return { id: id, name: name, type: type };

  		},

  		parseNodeProperty: function ( line, property, contentLine ) {

  			var propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
  			var propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

  			// for special case: base64 image data follows "Content: ," line
  			//	Content: ,
  			//	 "/9j/4RDaRXhpZgAATU0A..."
  			if ( propName === 'Content' && propValue === ',' ) {

  				propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();

  			}

  			var currentNode = this.getCurrentNode();
  			var parentName = currentNode.name;

  			if ( parentName === 'Properties70' ) {

  				this.parseNodeSpecialProperty( line, propName, propValue );
  				return;

  			}

  			// Connections
  			if ( propName === 'C' ) {

  				var connProps = propValue.split( ',' ).slice( 1 );
  				var from = parseInt( connProps[ 0 ] );
  				var to = parseInt( connProps[ 1 ] );

  				var rest = propValue.split( ',' ).slice( 3 );

  				rest = rest.map( function ( elem ) {

  					return elem.trim().replace( /^"/, '' );

  				} );

  				propName = 'connections';
  				propValue = [ from, to ];
  				append( propValue, rest );

  				if ( currentNode[ propName ] === undefined ) {

  					currentNode[ propName ] = [];

  				}

  			}

  			// Node
  			if ( propName === 'Node' ) { currentNode.id = propValue; }

  			// connections
  			if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {

  				currentNode[ propName ].push( propValue );

  			} else {

  				if ( propName !== 'a' ) { currentNode[ propName ] = propValue; }
  				else { currentNode.a = propValue; }

  			}

  			this.setCurrentProp( currentNode, propName );

  			// convert string to array, unless it ends in ',' in which case more will be added to it
  			if ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {

  				currentNode.a = parseNumberArray( propValue );

  			}

  		},

  		parseNodePropertyContinued: function ( line ) {

  			var currentNode = this.getCurrentNode();

  			currentNode.a += line;

  			// if the line doesn't end in ',' we have reached the end of the property value
  			// so convert the string to an array
  			if ( line.slice( - 1 ) !== ',' ) {

  				currentNode.a = parseNumberArray( currentNode.a );

  			}

  		},

  		// parse "Property70"
  		parseNodeSpecialProperty: function ( line, propName, propValue ) {

  			// split this
  			// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
  			// into array like below
  			// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
  			var props = propValue.split( '",' ).map( function ( prop ) {

  				return prop.trim().replace( /^\"/, '' ).replace( /\s/, '_' );

  			} );

  			var innerPropName = props[ 0 ];
  			var innerPropType1 = props[ 1 ];
  			var innerPropType2 = props[ 2 ];
  			var innerPropFlag = props[ 3 ];
  			var innerPropValue = props[ 4 ];

  			// cast values where needed, otherwise leave as strings
  			switch ( innerPropType1 ) {

  				case 'int':
  				case 'enum':
  				case 'bool':
  				case 'ULongLong':
  				case 'double':
  				case 'Number':
  				case 'FieldOfView':
  					innerPropValue = parseFloat( innerPropValue );
  					break;

  				case 'Color':
  				case 'ColorRGB':
  				case 'Vector3D':
  				case 'Lcl_Translation':
  				case 'Lcl_Rotation':
  				case 'Lcl_Scaling':
  					innerPropValue = parseNumberArray( innerPropValue );
  					break;

  			}

  			// CAUTION: these props must append to parent's parent
  			this.getPrevNode()[ innerPropName ] = {

  				'type': innerPropType1,
  				'type2': innerPropType2,
  				'flag': innerPropFlag,
  				'value': innerPropValue

  			};

  			this.setCurrentProp( this.getPrevNode(), innerPropName );

  		},

  	};

  	// Parse an FBX file in Binary format
  	function BinaryParser() {}

  	BinaryParser.prototype = {

  		constructor: BinaryParser,

  		parse: function ( buffer ) {
  			var this$1 = this;


  			var reader = new BinaryReader( buffer );
  			reader.skip( 23 ); // skip magic 23 bytes

  			var version = reader.getUint32();

  			console.log( 'FBXLoader: FBX binary version: ' + version );

  			var allNodes = new FBXTree();

  			while ( ! this.endOfContent( reader ) ) {

  				var node = this$1.parseNode( reader, version );
  				if ( node !== null ) { allNodes.add( node.name, node ); }

  			}

  			return allNodes;

  		},

  		// Check if reader has reached the end of content.
  		endOfContent: function ( reader ) {

  			// footer size: 160bytes + 16-byte alignment padding
  			// - 16bytes: magic
  			// - padding til 16-byte alignment (at least 1byte?)
  			//	(seems like some exporters embed fixed 15 or 16bytes?)
  			// - 4bytes: magic
  			// - 4bytes: version
  			// - 120bytes: zero
  			// - 16bytes: magic
  			if ( reader.size() % 16 === 0 ) {

  				return ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();

  			} else {

  				return reader.getOffset() + 160 + 16 >= reader.size();

  			}

  		},

  		// recursively parse nodes until the end of the file is reached
  		parseNode: function ( reader, version ) {
  			var this$1 = this;


  			var node = {};

  			// The first three data sizes depends on version.
  			var endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
  			var numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

  			// note: do not remove this even if you get a linter warning as it moves the buffer forward
  			var propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

  			var nameLen = reader.getUint8();
  			var name = reader.getString( nameLen );

  			// Regards this node as NULL-record if endOffset is zero
  			if ( endOffset === 0 ) { return null; }

  			var propertyList = [];

  			for ( var i = 0; i < numProperties; i ++ ) {

  				propertyList.push( this$1.parseProperty( reader ) );

  			}

  			// Regards the first three elements in propertyList as id, attrName, and attrType
  			var id = propertyList.length > 0 ? propertyList[ 0 ] : '';
  			var attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
  			var attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

  			// check if this node represents just a single property
  			// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
  			node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

  			while ( endOffset > reader.getOffset() ) {

  				var subNode = this$1.parseNode( reader, version );

  				if ( subNode !== null ) { this$1.parseSubNode( name, node, subNode ); }

  			}

  			node.propertyList = propertyList; // raw property list used by parent

  			if ( typeof id === 'number' ) { node.id = id; }
  			if ( attrName !== '' ) { node.attrName = attrName; }
  			if ( attrType !== '' ) { node.attrType = attrType; }
  			if ( name !== '' ) { node.name = name; }

  			return node;

  		},

  		parseSubNode: function ( name, node, subNode ) {

  			// special case: child node is single property
  			if ( subNode.singleProperty === true ) {

  				var value = subNode.propertyList[ 0 ];

  				if ( Array.isArray( value ) ) {

  					node[ subNode.name ] = subNode;

  					subNode.a = value;

  				} else {

  					node[ subNode.name ] = value;

  				}

  			} else if ( name === 'Connections' && subNode.name === 'C' ) {

  				var array = [];

  				subNode.propertyList.forEach( function ( property, i ) {

  					// first Connection is FBX type (OO, OP, etc.). We'll discard these
  					if ( i !== 0 ) { array.push( property ); }

  				} );

  				if ( node.connections === undefined ) {

  					node.connections = [];

  				}

  				node.connections.push( array );

  			} else if ( subNode.name === 'Properties70' ) {

  				var keys = Object.keys( subNode );

  				keys.forEach( function ( key ) {

  					node[ key ] = subNode[ key ];

  				} );

  			} else if ( name === 'Properties70' && subNode.name === 'P' ) {

  				var innerPropName = subNode.propertyList[ 0 ];
  				var innerPropType1 = subNode.propertyList[ 1 ];
  				var innerPropType2 = subNode.propertyList[ 2 ];
  				var innerPropFlag = subNode.propertyList[ 3 ];
  				var innerPropValue;

  				if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) { innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' ); }
  				if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) { innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' ); }

  				if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

  					innerPropValue = [
  						subNode.propertyList[ 4 ],
  						subNode.propertyList[ 5 ],
  						subNode.propertyList[ 6 ]
  					];

  				} else {

  					innerPropValue = subNode.propertyList[ 4 ];

  				}

  				// this will be copied to parent, see above
  				node[ innerPropName ] = {

  					'type': innerPropType1,
  					'type2': innerPropType2,
  					'flag': innerPropFlag,
  					'value': innerPropValue

  				};

  			} else if ( node[ subNode.name ] === undefined ) {

  				if ( typeof subNode.id === 'number' ) {

  					node[ subNode.name ] = {};
  					node[ subNode.name ][ subNode.id ] = subNode;

  				} else {

  					node[ subNode.name ] = subNode;

  				}

  			} else {

  				if ( subNode.name === 'PoseNode' ) {

  					if ( ! Array.isArray( node[ subNode.name ] ) ) {

  						node[ subNode.name ] = [ node[ subNode.name ] ];

  					}

  					node[ subNode.name ].push( subNode );

  				} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {

  					node[ subNode.name ][ subNode.id ] = subNode;

  				}

  			}

  		},

  		parseProperty: function ( reader ) {

  			var type = reader.getString( 1 );

  			switch ( type ) {

  				case 'C':
  					return reader.getBoolean();

  				case 'D':
  					return reader.getFloat64();

  				case 'F':
  					return reader.getFloat32();

  				case 'I':
  					return reader.getInt32();

  				case 'L':
  					return reader.getInt64();

  				case 'R':
  					var length = reader.getUint32();
  					return reader.getArrayBuffer( length );

  				case 'S':
  					var length = reader.getUint32();
  					return reader.getString( length );

  				case 'Y':
  					return reader.getInt16();

  				case 'b':
  				case 'c':
  				case 'd':
  				case 'f':
  				case 'i':
  				case 'l':

  					var arrayLength = reader.getUint32();
  					var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
  					var compressedLength = reader.getUint32();

  					if ( encoding === 0 ) {

  						switch ( type ) {

  							case 'b':
  							case 'c':
  								return reader.getBooleanArray( arrayLength );

  							case 'd':
  								return reader.getFloat64Array( arrayLength );

  							case 'f':
  								return reader.getFloat32Array( arrayLength );

  							case 'i':
  								return reader.getInt32Array( arrayLength );

  							case 'l':
  								return reader.getInt64Array( arrayLength );

  						}

  					}

  					if ( typeof Zlib === 'undefined' ) {

  						console.error( 'FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );

  					}

  					var inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef
  					var reader2 = new BinaryReader( inflate.decompress().buffer );

  					switch ( type ) {

  						case 'b':
  						case 'c':
  							return reader2.getBooleanArray( arrayLength );

  						case 'd':
  							return reader2.getFloat64Array( arrayLength );

  						case 'f':
  							return reader2.getFloat32Array( arrayLength );

  						case 'i':
  							return reader2.getInt32Array( arrayLength );

  						case 'l':
  							return reader2.getInt64Array( arrayLength );

  					}

  				default:
  					throw new Error( 'FBXLoader: Unknown property type ' + type );

  			}

  		}

  	};

  	function BinaryReader( buffer, littleEndian ) {

  		this.dv = new DataView( buffer );
  		this.offset = 0;
  		this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;

  	}

  	BinaryReader.prototype = {

  		constructor: BinaryReader,

  		getOffset: function () {

  			return this.offset;

  		},

  		size: function () {

  			return this.dv.buffer.byteLength;

  		},

  		skip: function ( length ) {

  			this.offset += length;

  		},

  		// seems like true/false representation depends on exporter.
  		// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  		// then sees LSB.
  		getBoolean: function () {

  			return ( this.getUint8() & 1 ) === 1;

  		},

  		getBooleanArray: function ( size ) {
  			var this$1 = this;


  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a.push( this$1.getBoolean() );

  			}

  			return a;

  		},

  		getUint8: function () {

  			var value = this.dv.getUint8( this.offset );
  			this.offset += 1;
  			return value;

  		},

  		getInt16: function () {

  			var value = this.dv.getInt16( this.offset, this.littleEndian );
  			this.offset += 2;
  			return value;

  		},

  		getInt32: function () {

  			var value = this.dv.getInt32( this.offset, this.littleEndian );
  			this.offset += 4;
  			return value;

  		},

  		getInt32Array: function ( size ) {
  			var this$1 = this;


  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a.push( this$1.getInt32() );

  			}

  			return a;

  		},

  		getUint32: function () {

  			var value = this.dv.getUint32( this.offset, this.littleEndian );
  			this.offset += 4;
  			return value;

  		},

  		// JavaScript doesn't support 64-bit integer so calculate this here
  		// 1 << 32 will return 1 so using multiply operation instead here.
  		// There's a possibility that this method returns wrong value if the value
  		// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  		// TODO: safely handle 64-bit integer
  		getInt64: function () {

  			var low, high;

  			if ( this.littleEndian ) {

  				low = this.getUint32();
  				high = this.getUint32();

  			} else {

  				high = this.getUint32();
  				low = this.getUint32();

  			}

  			// calculate negative value
  			if ( high & 0x80000000 ) {

  				high = ~ high & 0xFFFFFFFF;
  				low = ~ low & 0xFFFFFFFF;

  				if ( low === 0xFFFFFFFF ) { high = ( high + 1 ) & 0xFFFFFFFF; }

  				low = ( low + 1 ) & 0xFFFFFFFF;

  				return - ( high * 0x100000000 + low );

  			}

  			return high * 0x100000000 + low;

  		},

  		getInt64Array: function ( size ) {
  			var this$1 = this;


  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a.push( this$1.getInt64() );

  			}

  			return a;

  		},

  		// Note: see getInt64() comment
  		getUint64: function () {

  			var low, high;

  			if ( this.littleEndian ) {

  				low = this.getUint32();
  				high = this.getUint32();

  			} else {

  				high = this.getUint32();
  				low = this.getUint32();

  			}

  			return high * 0x100000000 + low;

  		},

  		getFloat32: function () {

  			var value = this.dv.getFloat32( this.offset, this.littleEndian );
  			this.offset += 4;
  			return value;

  		},

  		getFloat32Array: function ( size ) {
  			var this$1 = this;


  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a.push( this$1.getFloat32() );

  			}

  			return a;

  		},

  		getFloat64: function () {

  			var value = this.dv.getFloat64( this.offset, this.littleEndian );
  			this.offset += 8;
  			return value;

  		},

  		getFloat64Array: function ( size ) {
  			var this$1 = this;


  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a.push( this$1.getFloat64() );

  			}

  			return a;

  		},

  		getArrayBuffer: function ( size ) {

  			var value = this.dv.buffer.slice( this.offset, this.offset + size );
  			this.offset += size;
  			return value;

  		},

  		getString: function ( size ) {
  			var this$1 = this;


  			// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
  			var a = [];

  			for ( var i = 0; i < size; i ++ ) {

  				a[ i ] = this$1.getUint8();

  			}

  			var nullByte = a.indexOf( 0 );
  			if ( nullByte >= 0 ) { a = a.slice( 0, nullByte ); }

  			return LoaderUtils.decodeText( new Uint8Array( a ) );

  		}

  	};

  	// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
  	// and BinaryParser( FBX Binary format)
  	function FBXTree() {}

  	FBXTree.prototype = {

  		constructor: FBXTree,

  		add: function ( key, val ) {

  			this[ key ] = val;

  		},

  	};

  	// ************** UTILITY FUNCTIONS **************

  	function isFbxFormatBinary( buffer ) {

  		var CORRECT = 'Kaydara FBX Binary  \0';

  		return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );

  	}

  	function isFbxFormatASCII( text ) {

  		var CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

  		var cursor = 0;

  		function read( offset ) {

  			var result = text[ offset - 1 ];
  			text = text.slice( cursor + offset );
  			cursor ++;
  			return result;

  		}

  		for ( var i = 0; i < CORRECT.length; ++ i ) {

  			var num = read( 1 );
  			if ( num === CORRECT[ i ] ) {

  				return false;

  			}

  		}

  		return true;

  	}

  	function getFbxVersion( text ) {

  		var versionRegExp = /FBXVersion: (\d+)/;
  		var match = text.match( versionRegExp );
  		if ( match ) {

  			var version = parseInt( match[ 1 ] );
  			return version;

  		}
  		throw new Error( 'FBXLoader: Cannot find the version number for the file given.' );

  	}

  	// Converts FBX ticks into real time seconds.
  	function convertFBXTimeToSeconds( time ) {

  		return time / 46186158000;

  	}

  	var dataArray = [];

  	// extracts the data from the correct position in the FBX array based on indexing type
  	function getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

  		var index;

  		switch ( infoObject.mappingType ) {

  			case 'ByPolygonVertex' :
  				index = polygonVertexIndex;
  				break;
  			case 'ByPolygon' :
  				index = polygonIndex;
  				break;
  			case 'ByVertice' :
  				index = vertexIndex;
  				break;
  			case 'AllSame' :
  				index = infoObject.indices[ 0 ];
  				break;
  			default :
  				console.warn( 'FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );

  		}

  		if ( infoObject.referenceType === 'IndexToDirect' ) { index = infoObject.indices[ index ]; }

  		var from = index * infoObject.dataSize;
  		var to = from + infoObject.dataSize;

  		return slice( dataArray, infoObject.buffer, from, to );

  	}

  	var tempEuler = new Euler();
  	var tempVec = new Vector3();

  	// generate transformation from FBX transform data
  	// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
  	// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
  	function generateTransform( transformData ) {

  		var lTranslationM = new Matrix4();
  		var lPreRotationM = new Matrix4();
  		var lRotationM = new Matrix4();
  		var lPostRotationM = new Matrix4();

  		var lScalingM = new Matrix4();
  		var lScalingPivotM = new Matrix4();
  		var lScalingOffsetM = new Matrix4();
  		var lRotationOffsetM = new Matrix4();
  		var lRotationPivotM = new Matrix4();

  		var lParentGX = new Matrix4();
  		var lGlobalT = new Matrix4();

  		var inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

  		if ( transformData.translation ) { lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) ); }

  		if ( transformData.preRotation ) {

  			var array = transformData.preRotation.map( _Math.degToRad );
  			array.push( transformData.eulerOrder );
  			lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  		}

  		if ( transformData.rotation ) {

  			var array = transformData.rotation.map( _Math.degToRad );
  			array.push( transformData.eulerOrder );
  			lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  		}

  		if ( transformData.postRotation ) {

  			var array = transformData.postRotation.map( _Math.degToRad );
  			array.push( transformData.eulerOrder );
  			lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  		}

  		if ( transformData.scale ) { lScalingM.scale( tempVec.fromArray( transformData.scale ) ); }

  		// Pivots and offsets
  		if ( transformData.scalingOffset ) { lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) ); }
  		if ( transformData.scalingPivot ) { lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) ); }
  		if ( transformData.rotationOffset ) { lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) ); }
  		if ( transformData.rotationPivot ) { lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) ); }

  		// parent transform
  		if ( transformData.parentMatrixWorld ) { lParentGX = transformData.parentMatrixWorld; }

  		// Global Rotation
  		var lLRM = lPreRotationM.multiply( lRotationM ).multiply( lPostRotationM );
  		var lParentGRM = new Matrix4();
  		lParentGX.extractRotation( lParentGRM );

  		// Global Shear*Scaling
  		var lParentTM = new Matrix4();
  		var lLSM;
  		var lParentGSM;
  		var lParentGRSM;

  		lParentTM.copyPosition( lParentGX );
  		lParentGRSM = lParentTM.getInverse( lParentTM ).multiply( lParentGX );
  		lParentGSM = lParentGRM.getInverse( lParentGRM ).multiply( lParentGRSM );
  		lLSM = lScalingM;

  		var lGlobalRS;
  		if ( inheritType === 0 ) {

  			lGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );

  		} else if ( inheritType === 1 ) {

  			lGlobalRS = lParentGRM.multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );

  		} else {

  			var lParentLSM = new Matrix4().copy( lScalingM );

  			var lParentGSM_noLocal = lParentGSM.multiply( lParentLSM.getInverse( lParentLSM ) );

  			lGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );

  		}

  		// Calculate the local transform matrix
  		var lTransform = lTranslationM.multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM.getInverse( lRotationPivotM ) ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM.getInverse( lScalingPivotM ) );

  		var lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );

  		var lGlobalTranslation = lParentGX.multiply( lLocalTWithAllPivotAndOffsetInfo );
  		lGlobalT.copyPosition( lGlobalTranslation );

  		lTransform = lGlobalT.multiply( lGlobalRS );

  		return lTransform;

  	}

  	// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
  	// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
  	function getEulerOrder( order ) {

  		order = order || 0;

  		var enums = [
  			'ZYX', // -> XYZ extrinsic
  			'YZX', // -> XZY extrinsic
  			'XZY', // -> YZX extrinsic
  			'ZXY', // -> YXZ extrinsic
  			'YXZ', // -> ZXY extrinsic
  			'XYZ' ];

  		if ( order === 6 ) {

  			console.warn( 'FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );
  			return enums[ 0 ];

  		}

  		return enums[ order ];

  	}

  	// Parses comma separated list of numbers and returns them an array.
  	// Used internally by the TextParser
  	function parseNumberArray( value ) {

  		var array = value.split( ',' ).map( function ( val ) {

  			return parseFloat( val );

  		} );

  		return array;

  	}

  	function convertArrayBufferToString( buffer, from, to ) {

  		if ( from === undefined ) { from = 0; }
  		if ( to === undefined ) { to = buffer.byteLength; }

  		return LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );

  	}

  	function append( a, b ) {

  		for ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {

  			a[ j ] = b[ i ];

  		}

  	}

  	function slice( a, b, from, to ) {

  		for ( var i = from, j = 0; i < to; i ++, j ++ ) {

  			a[ j ] = b[ i ];

  		}

  		return a;

  	}

  	// inject array a2 into array a1 at index
  	function inject( a1, index, a2 ) {

  		return a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );

  	}

  	return FBXLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GCodeLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	this.splitLayer = false;

  };

  GCodeLoader.prototype.load = function ( url, onLoad, onProgress, onError ) {

  	var self = this;

  	var loader = new FileLoader( self.manager );
  	loader.setPath( self.path );
  	loader.load( url, function ( text ) {

  		onLoad( self.parse( text ) );

  	}, onProgress, onError );

  };

  GCodeLoader.prototype.setPath = function ( value ) {

  	this.path = value;
  	return this;

  };

  GCodeLoader.prototype.parse = function ( data ) {

  	var state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };
  	var layers = [];

  	var currentLayer = undefined;

  	var pathMaterial = new LineBasicMaterial( { color: 0xFF0000 } );
  	pathMaterial.name = 'path';

  	var extrudingMaterial = new LineBasicMaterial( { color: 0x00FF00 } );
  	extrudingMaterial.name = 'extruded';

  	function newLayer( line ) {

  		currentLayer = { vertex: [], pathVertex: [], z: line.z };
  		layers.push( currentLayer );

  	}

  	//Create lie segment between p1 and p2
  	function addSegment( p1, p2 ) {

  		if ( currentLayer === undefined ) {

  			newLayer( p1 );

  		}

  		if ( line.extruding ) {

  			currentLayer.vertex.push( p1.x, p1.y, p1.z );
  			currentLayer.vertex.push( p2.x, p2.y, p2.z );

  		} else {

  			currentLayer.pathVertex.push( p1.x, p1.y, p1.z );
  			currentLayer.pathVertex.push( p2.x, p2.y, p2.z );

  		}

  	}

  	function delta( v1, v2 ) {

  		return state.relative ? v2 : v2 - v1;

  	}

  	function absolute( v1, v2 ) {

  		return state.relative ? v1 + v2 : v2;

  	}

  	var lines = data.replace( /;.+/g, '' ).split( '\n' );

  	for ( var i = 0; i < lines.length; i ++ ) {

  		var tokens = lines[ i ].split( ' ' );
  		var cmd = tokens[ 0 ].toUpperCase();

  		//Argumments
  		var args = {};
  		tokens.splice( 1 ).forEach( function ( token ) {

  			if ( token[ 0 ] !== undefined ) {

  				var key = token[ 0 ].toLowerCase();
  				var value = parseFloat( token.substring( 1 ) );
  				args[ key ] = value;

  			}

  		} );

  		//Process commands
  		//G0/G1  Linear Movement
  		if ( cmd === 'G0' || cmd === 'G1' ) {

  			var line = {
  				x: args.x !== undefined ? absolute( state.x, args.x ) : state.x,
  				y: args.y !== undefined ? absolute( state.y, args.y ) : state.y,
  				z: args.z !== undefined ? absolute( state.z, args.z ) : state.z,
  				e: args.e !== undefined ? absolute( state.e, args.e ) : state.e,
  				f: args.f !== undefined ? absolute( state.f, args.f ) : state.f,
  			};

  			//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position
  			if ( delta( state.e, line.e ) > 0 ) {

  				line.extruding = delta( state.e, line.e ) > 0;

  				if ( currentLayer == undefined || line.z != currentLayer.z ) {

  					newLayer( line );

  				}

  			}

  			addSegment( state, line );
  			state = line;

  		} else if ( cmd === 'G2' || cmd === 'G3' ) {

  			//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )
  			console.warn( 'GCodeLoader: Arc command not supported' );

  		} else if ( cmd === 'G90' ) {

  			//G90: Set to Absolute Positioning
  			state.relative = false;

  		} else if ( cmd === 'G91' ) {

  			//G91: Set to state.relative Positioning
  			state.relative = true;

  		} else if ( cmd === 'G92' ) {

  			//G92: Set Position
  			var line = state;
  			line.x = args.x !== undefined ? args.x : line.x;
  			line.y = args.y !== undefined ? args.y : line.y;
  			line.z = args.z !== undefined ? args.z : line.z;
  			line.e = args.e !== undefined ? args.e : line.e;
  			state = line;

  		} else {

  			console.warn( 'GCodeLoader: Command not supported:' + cmd );

  		}

  	}

  	function addObject( vertex, extruding ) {

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertex, 3 ) );

  		var segments = new LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );
  		segments.name = 'layer' + i;
  		object.add( segments );

  	}

  	var object = new Group();
  	object.name = 'gcode';

  	if ( this.splitLayer ) {

  		for ( var i = 0; i < layers.length; i ++ ) {

  			var layer = layers[ i ];
  			addObject( layer.vertex, true );
  			addObject( layer.pathVertex, false );

  		}

  	} else {

  		var vertex = [], pathVertex = [];

  		for ( var i = 0; i < layers.length; i ++ ) {

  			var layer = layers[ i ];

  			vertex = vertex.concat( layer.vertex );
  			pathVertex = pathVertex.concat( layer.pathVertex );

  		}

  		addObject( vertex, true );
  		addObject( pathVertex, false );

  	}

  	object.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );

  	return object;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BufferGeometryUtils = {

  	computeTangents: function ( geometry ) {

  		var index = geometry.index;
  		var attributes = geometry.attributes;

  		// based on http://www.terathon.com/code/tangent.html
  		// (per vertex tangents)

  		if ( index === null ||
  			 attributes.position === undefined ||
  			 attributes.normal === undefined ||
  			 attributes.uv === undefined ) {

  			console.warn( 'BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
  			return;

  		}

  		var indices = index.array;
  		var positions = attributes.position.array;
  		var normals = attributes.normal.array;
  		var uvs = attributes.uv.array;

  		var nVertices = positions.length / 3;

  		if ( attributes.tangent === undefined ) {

  			geometry.addAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

  		}

  		var tangents = attributes.tangent.array;

  		var tan1 = [], tan2 = [];

  		for ( var i = 0; i < nVertices; i ++ ) {

  			tan1[ i ] = new Vector3();
  			tan2[ i ] = new Vector3();

  		}

  		var vA = new Vector3(),
  			vB = new Vector3(),
  			vC = new Vector3(),

  			uvA = new Vector2(),
  			uvB = new Vector2(),
  			uvC = new Vector2(),

  			sdir = new Vector3(),
  			tdir = new Vector3();

  		function handleTriangle( a, b, c ) {

  			vA.fromArray( positions, a * 3 );
  			vB.fromArray( positions, b * 3 );
  			vC.fromArray( positions, c * 3 );

  			uvA.fromArray( uvs, a * 2 );
  			uvB.fromArray( uvs, b * 2 );
  			uvC.fromArray( uvs, c * 2 );

  			var x1 = vB.x - vA.x;
  			var x2 = vC.x - vA.x;

  			var y1 = vB.y - vA.y;
  			var y2 = vC.y - vA.y;

  			var z1 = vB.z - vA.z;
  			var z2 = vC.z - vA.z;

  			var s1 = uvB.x - uvA.x;
  			var s2 = uvC.x - uvA.x;

  			var t1 = uvB.y - uvA.y;
  			var t2 = uvC.y - uvA.y;

  			var r = 1.0 / ( s1 * t2 - s2 * t1 );

  			sdir.set(
  				( t2 * x1 - t1 * x2 ) * r,
  				( t2 * y1 - t1 * y2 ) * r,
  				( t2 * z1 - t1 * z2 ) * r
  			);

  			tdir.set(
  				( s1 * x2 - s2 * x1 ) * r,
  				( s1 * y2 - s2 * y1 ) * r,
  				( s1 * z2 - s2 * z1 ) * r
  			);

  			tan1[ a ].add( sdir );
  			tan1[ b ].add( sdir );
  			tan1[ c ].add( sdir );

  			tan2[ a ].add( tdir );
  			tan2[ b ].add( tdir );
  			tan2[ c ].add( tdir );

  		}

  		var groups = geometry.groups;

  		if ( groups.length === 0 ) {

  			groups = [ {
  				start: 0,
  				count: indices.length
  			} ];

  		}

  		for ( var i = 0, il = groups.length; i < il; ++ i ) {

  			var group = groups[ i ];

  			var start = group.start;
  			var count = group.count;

  			for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  				handleTriangle(
  					indices[ j + 0 ],
  					indices[ j + 1 ],
  					indices[ j + 2 ]
  				);

  			}

  		}

  		var tmp = new Vector3(), tmp2 = new Vector3();
  		var n = new Vector3(), n2 = new Vector3();
  		var w, t, test;

  		function handleVertex( v ) {

  			n.fromArray( normals, v * 3 );
  			n2.copy( n );

  			t = tan1[ v ];

  			// Gram-Schmidt orthogonalize

  			tmp.copy( t );
  			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

  			// Calculate handedness

  			tmp2.crossVectors( n2, t );
  			test = tmp2.dot( tan2[ v ] );
  			w = ( test < 0.0 ) ? - 1.0 : 1.0;

  			tangents[ v * 4 ] = tmp.x;
  			tangents[ v * 4 + 1 ] = tmp.y;
  			tangents[ v * 4 + 2 ] = tmp.z;
  			tangents[ v * 4 + 3 ] = w;

  		}

  		for ( var i = 0, il = groups.length; i < il; ++ i ) {

  			var group = groups[ i ];

  			var start = group.start;
  			var count = group.count;

  			for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  				handleVertex( indices[ j + 0 ] );
  				handleVertex( indices[ j + 1 ] );
  				handleVertex( indices[ j + 2 ] );

  			}

  		}

  	},
  	mergeBufferGeometries: function ( geometries, useGroups ) {
  		var this$1 = this;


  		var isIndexed = geometries[ 0 ].index !== null;

  		var attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
  		var morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

  		var attributes = {};
  		var morphAttributes = {};

  		var mergedGeometry = new BufferGeometry();

  		var offset = 0;

  		for ( var i = 0; i < geometries.length; ++ i ) {

  			var geometry = geometries[ i ];

  			// ensure that all geometries are indexed, or none

  			if ( isIndexed !== ( geometry.index !== null ) ) { return null; }

  			// gather attributes, exit early if they're different

  			for ( var name in geometry.attributes ) {

  				if ( ! attributesUsed.has( name ) ) { return null; }

  				if ( attributes[ name ] === undefined ) { attributes[ name ] = []; }

  				attributes[ name ].push( geometry.attributes[ name ] );

  			}

  			// gather morph attributes, exit early if they're different

  			for ( var name in geometry.morphAttributes ) {

  				if ( ! morphAttributesUsed.has( name ) ) { return null; }

  				if ( morphAttributes[ name ] === undefined ) { morphAttributes[ name ] = []; }

  				morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

  			}

  			// gather .userData

  			mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
  			mergedGeometry.userData.mergedUserData.push( geometry.userData );

  			if ( useGroups ) {

  				var count;

  				if ( isIndexed ) {

  					count = geometry.index.count;

  				} else if ( geometry.attributes.position !== undefined ) {

  					count = geometry.attributes.position.count;

  				} else {

  					return null;

  				}

  				mergedGeometry.addGroup( offset, count, i );

  				offset += count;

  			}

  		}

  		// merge indices

  		if ( isIndexed ) {

  			var indexOffset = 0;
  			var mergedIndex = [];

  			for ( var i = 0; i < geometries.length; ++ i ) {

  				var index = geometries[ i ].index;

  				for ( var j = 0; j < index.count; ++ j ) {

  					mergedIndex.push( index.getX( j ) + indexOffset );

  				}

  				indexOffset += geometries[ i ].attributes.position.count;

  			}

  			mergedGeometry.setIndex( mergedIndex );

  		}

  		// merge attributes

  		for ( var name in attributes ) {

  			var mergedAttribute = this$1.mergeBufferAttributes( attributes[ name ] );

  			if ( ! mergedAttribute ) { return null; }

  			mergedGeometry.addAttribute( name, mergedAttribute );

  		}

  		// merge morph attributes

  		for ( var name in morphAttributes ) {

  			var numMorphTargets = morphAttributes[ name ][ 0 ].length;

  			if ( numMorphTargets === 0 ) { break; }

  			mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
  			mergedGeometry.morphAttributes[ name ] = [];

  			for ( var i = 0; i < numMorphTargets; ++ i ) {

  				var morphAttributesToMerge = [];

  				for ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {

  					morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

  				}

  				var mergedMorphAttribute = this$1.mergeBufferAttributes( morphAttributesToMerge );

  				if ( ! mergedMorphAttribute ) { return null; }

  				mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

  			}

  		}

  		return mergedGeometry;

  	},
  	mergeBufferAttributes: function ( attributes ) {

  		var TypedArray;
  		var itemSize;
  		var normalized;
  		var arrayLength = 0;

  		for ( var i = 0; i < attributes.length; ++ i ) {

  			var attribute = attributes[ i ];

  			if ( attribute.isInterleavedBufferAttribute ) { return null; }

  			if ( TypedArray === undefined ) { TypedArray = attribute.array.constructor; }
  			if ( TypedArray !== attribute.array.constructor ) { return null; }

  			if ( itemSize === undefined ) { itemSize = attribute.itemSize; }
  			if ( itemSize !== attribute.itemSize ) { return null; }

  			if ( normalized === undefined ) { normalized = attribute.normalized; }
  			if ( normalized !== attribute.normalized ) { return null; }

  			arrayLength += attribute.array.length;

  		}

  		var array = new TypedArray( arrayLength );
  		var offset = 0;

  		for ( var i = 0; i < attributes.length; ++ i ) {

  			array.set( attributes[ i ].array, offset );

  			offset += attributes[ i ].array.length;

  		}

  		return new BufferAttribute( array, itemSize, normalized );

  	},
  	interleaveAttributes: function ( attributes ) {

  		// Interleaves the provided attributes into an InterleavedBuffer and returns
  		// a set of InterleavedBufferAttributes for each attribute
  		var TypedArray;
  		var arrayLength = 0;
  		var stride = 0;

  		// calculate the the length and type of the interleavedBuffer
  		for ( var i = 0, l = attributes.length; i < l; ++ i ) {

  			var attribute = attributes[ i ];

  			if ( TypedArray === undefined ) { TypedArray = attribute.array.constructor; }
  			if ( TypedArray !== attribute.array.constructor ) {

  				console.warn( 'AttributeBuffers of different types cannot be interleaved' );
  				return null;

  			}

  			arrayLength += attribute.array.length;
  			stride += attribute.itemSize;

  		}

  		// Create the set of buffer attributes
  		var interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );
  		var offset = 0;
  		var res = [];
  		var getters = [ 'getX', 'getY', 'getZ', 'getW' ];
  		var setters = [ 'setX', 'setY', 'setZ', 'setW' ];

  		for ( var j = 0, l = attributes.length; j < l; j ++ ) {

  			var attribute = attributes[ j ];
  			var itemSize = attribute.itemSize;
  			var count = attribute.count;
  			var iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );
  			res.push( iba );

  			offset += itemSize;

  			// Move the data for each attribute into the new interleavedBuffer
  			// at the appropriate offset
  			for ( var c = 0; c < count; c ++ ) {

  				for ( var k = 0; k < itemSize; k ++ ) {

  					iba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );

  				}

  			}

  		}

  		return res;

  	},
  	estimateBytesUsed: function ( geometry ) {

  		// Return the estimated memory used by this geometry in bytes
  		// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
  		// for InterleavedBufferAttributes.
  		var mem = 0;
  		for ( var name in geometry.attributes ) {

  			var attr = geometry.getAttribute( name );
  			mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;

  		}

  		var indices = geometry.getIndex();
  		mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
  		return mem;

  	},
  	mergeVertices: function ( geometry, tolerance ) {
  		if ( tolerance === void 0 ) tolerance = 1e-4;


  		tolerance = Math.max( tolerance, Number.EPSILON );

  		// Generate an index buffer if the geometry doesn't have one, or optimize it
  		// if it's already available.
  		var hashToIndex = {};
  		var indices = geometry.getIndex();
  		var positions = geometry.getAttribute( 'position' );
  		var vertexCount = indices ? indices.count : positions.count;

  		// next value for triangle indices
  		var nextIndex = 0;

  		// attributes and new attribute arrays
  		var attributeNames = Object.keys( geometry.attributes );
  		var attrArrays = {};
  		var morphAttrsArrays = {};
  		var newIndices = [];
  		var getters = [ 'getX', 'getY', 'getZ', 'getW' ];

  		// initialize the arrays
  		for ( var attributeNameIndex = 0, numberOfAttributes = attributeNames.length ; attributeNameIndex < numberOfAttributes ; attributeNameIndex++  ) {
  			var name = attributeNames[ attributeNameIndex ];

  			attrArrays[ name ] = [];

  			var morphAttr = geometry.morphAttributes[ name ];
  			if ( morphAttr ) {

  				morphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( function () { return []; } );

  			}

  		}

  		// convert the error tolerance to an amount of decimal places to truncate to
  		var decimalShift = Math.log10( 1 / tolerance );
  		var shiftMultiplier = Math.pow( 10, decimalShift );
  		for ( var i = 0; i < vertexCount; i ++ ) {

  			var index = indices ? indices.getX( i ) : i;

  			// Generate a hash for the vertex attributes at the current index 'i'
  			var hash = '';
  			for ( var j = 0, l = attributeNames.length; j < l; j ++ ) {

  				var name = attributeNames[ j ];
  				var attribute = geometry.getAttribute( name );
  				var itemSize = attribute.itemSize;

  				for ( var k = 0; k < itemSize; k ++ ) {

  					// double tilde truncates the decimal value
  					hash += (~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier )) + ",";

  				}

  			}

  			// Add another reference to the vertex if it's already
  			// used by another index
  			if ( hash in hashToIndex ) {

  				newIndices.push( hashToIndex[ hash ] );

  			} else {

  				// copy data to the new index in the attribute arrays
  				for ( var j = 0, l = attributeNames.length; j < l; j ++ ) {

  					var name = attributeNames[ j ];
  					var attribute = geometry.getAttribute( name );
  					var morphAttr = geometry.morphAttributes[ name ];
  					var itemSize = attribute.itemSize;
  					var newarray = attrArrays[ name ];
  					var newMorphArrays = morphAttrsArrays[ name ];

  					for ( var k = 0; k < itemSize; k ++ ) {

  						var getterFunc = getters[ k ];
  						newarray.push( attribute[ getterFunc ]( index ) );

  						if ( morphAttr ) {

  							for ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {

  								newMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );

  							}

  						}

  					}

  				}

  				hashToIndex[ hash ] = nextIndex;
  				newIndices.push( nextIndex );
  				nextIndex ++;

  			}

  		}

  		// Generate typed arrays from new attribute arrays and update
  		// the attributeBuffers
  		var result = geometry.clone();
  		for ( var i = 0, l = attributeNames.length; i < l; i ++ ) {

  			var name = attributeNames[ i ];
  			var oldAttribute = geometry.getAttribute( name );
  			var attribute;

  			var buffer = new oldAttribute.array.constructor( attrArrays[ name ] );
  			if ( oldAttribute.isInterleavedBufferAttribute ) {

  				attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.itemSize );

  			} else {

  				attribute = geometry.getAttribute( name ).clone();
  				attribute.setArray( buffer );

  			}

  			result.addAttribute( name, attribute );

  			// Update the attribute arrays
  			if ( name in morphAttrsArrays ) {

  				for ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {

  					var morphAttribute = geometry.morphAttributes[ name ][ j ].clone();
  					morphAttribute.setArray( new morphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] ) );
  					result.morphAttributes[ name ][ j ] = morphAttribute;

  				}

  			}

  		}

  		// Generate an index buffer typed array
  		var cons = Uint8Array;
  		if ( newIndices.length >= Math.pow( 2, 8 ) ) { cons = Uint16Array; }
  		if ( newIndices.length >= Math.pow( 2, 16 ) ) { cons = Uint32Array; }

  		var newIndexBuffer = new cons( newIndices );
  		var newIndices = null;
  		if ( indices === null ) {

  			newIndices = new BufferAttribute( newIndexBuffer, 1 );

  		} else {

  			newIndices = geometry.getIndex().clone();
  			newIndices.setArray( newIndexBuffer );

  		}

  		result.setIndex( newIndices );

  		return result;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GLTFLoader = ( function () {

  	function GLTFLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  		this.dracoLoader = null;

  	}

  	GLTFLoader.prototype = {

  		constructor: GLTFLoader,

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var resourcePath;

  			if ( this.resourcePath !== undefined ) {

  				resourcePath = this.resourcePath;

  			} else if ( this.path !== undefined ) {

  				resourcePath = this.path;

  			} else {

  				resourcePath = LoaderUtils.extractUrlBase( url );

  			}

  			// Tells the LoadingManager to track an extra item, which resolves after
  			// the model is fully loaded. This means the count of items loaded will
  			// be incorrect, but ensures manager.onLoad() does not fire early.
  			scope.manager.itemStart( url );

  			var _onError = function ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					console.error( e );

  				}

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			};

  			var loader = new FileLoader( scope.manager );

  			loader.setPath( this.path );
  			loader.setResponseType( 'arraybuffer' );

  			loader.load( url, function ( data ) {

  				try {

  					scope.parse( data, resourcePath, function ( gltf ) {

  						onLoad( gltf );

  						scope.manager.itemEnd( url );

  					}, _onError );

  				} catch ( e ) {

  					_onError( e );

  				}

  			}, onProgress, _onError );

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setResourcePath: function ( value ) {

  			this.resourcePath = value;
  			return this;

  		},

  		setDRACOLoader: function ( dracoLoader ) {

  			this.dracoLoader = dracoLoader;
  			return this;

  		},

  		parse: function ( data, path, onLoad, onError ) {
  			var this$1 = this;


  			var content;
  			var extensions = {};

  			if ( typeof data === 'string' ) {

  				content = data;

  			} else {

  				var magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

  				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

  					try {

  						extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

  					} catch ( error ) {

  						if ( onError ) { onError( error ); }
  						return;

  					}

  					content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

  				} else {

  					content = LoaderUtils.decodeText( new Uint8Array( data ) );

  				}

  			}

  			var json = JSON.parse( content );

  			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

  				if ( onError ) { onError( new Error( 'GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) ); }
  				return;

  			}

  			if ( json.extensionsUsed ) {

  				for ( var i = 0; i < json.extensionsUsed.length; ++ i ) {

  					var extensionName = json.extensionsUsed[ i ];
  					var extensionsRequired = json.extensionsRequired || [];

  					switch ( extensionName ) {

  						case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
  							extensions[ extensionName ] = new GLTFLightsExtension( json );
  							break;

  						case EXTENSIONS.KHR_MATERIALS_UNLIT:
  							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json );
  							break;

  						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
  							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension( json );
  							break;

  						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
  							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this$1.dracoLoader );
  							break;

  						case EXTENSIONS.MSFT_TEXTURE_DDS:
  							extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension();
  							break;

  						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
  							extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] = new GLTFTextureTransformExtension( json );
  							break;

  						default:

  							if ( extensionsRequired.indexOf( extensionName ) >= 0 ) {

  								console.warn( 'GLTFLoader: Unknown extension "' + extensionName + '".' );

  							}

  					}

  				}

  			}

  			var parser = new GLTFParser( json, extensions, {

  				path: path || this.resourcePath || '',
  				crossOrigin: this.crossOrigin,
  				manager: this.manager

  			} );

  			parser.parse( function ( scene, scenes, cameras, animations, json ) {

  				var glTF = {
  					scene: scene,
  					scenes: scenes,
  					cameras: cameras,
  					animations: animations,
  					asset: json.asset,
  					parser: parser,
  					userData: {}
  				};

  				addUnknownExtensionsToUserData( extensions, glTF, json );

  				onLoad( glTF );

  			}, onError );

  		}

  	};
  	function GLTFRegistry() {

  		var objects = {};

  		return	{

  			get: function ( key ) {

  				return objects[ key ];

  			},

  			add: function ( key, object ) {

  				objects[ key ] = object;

  			},

  			remove: function ( key ) {

  				delete objects[ key ];

  			},

  			removeAll: function () {

  				objects = {};

  			}

  		};

  	}
  	var EXTENSIONS = {
  		KHR_BINARY_GLTF: 'KHR_binary_glTF',
  		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  		MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
  	};
  	function GLTFTextureDDSExtension() {

  		if ( ! DDSLoader ) {

  			throw new Error( 'GLTFLoader: Attempting to load .dds texture without importing DDSLoader' );

  		}

  		this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
  		this.ddsLoader = new DDSLoader();

  	}
  	function GLTFLightsExtension( json ) {

  		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

  		var extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};
  		this.lightDefs = extension.lights || [];

  	}

  	GLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {

  		var lightDef = this.lightDefs[ lightIndex ];
  		var lightNode;

  		var color = new Color( 0xffffff );
  		if ( lightDef.color !== undefined ) { color.fromArray( lightDef.color ); }

  		var range = lightDef.range !== undefined ? lightDef.range : 0;

  		switch ( lightDef.type ) {

  			case 'directional':
  				lightNode = new DirectionalLight( color );
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			case 'point':
  				lightNode = new PointLight( color );
  				lightNode.distance = range;
  				break;

  			case 'spot':
  				lightNode = new SpotLight( color );
  				lightNode.distance = range;
  				// Handle spotlight properties.
  				lightDef.spot = lightDef.spot || {};
  				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
  				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
  				lightNode.angle = lightDef.spot.outerConeAngle;
  				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
  				lightNode.target.position.set( 0, 0, - 1 );
  				lightNode.add( lightNode.target );
  				break;

  			default:
  				throw new Error( 'GLTFLoader: Unexpected light type, "' + lightDef.type + '".' );

  		}

  		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
  		// here, because node-level parsing will only override position if explicitly specified.
  		lightNode.position.set( 0, 0, 0 );

  		lightNode.decay = 2;

  		if ( lightDef.intensity !== undefined ) { lightNode.intensity = lightDef.intensity; }

  		lightNode.name = lightDef.name || ( 'light_' + lightIndex );

  		return Promise.resolve( lightNode );

  	};
  	function GLTFMaterialsUnlitExtension( json ) {

  		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

  	}

  	GLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) {

  		return MeshBasicMaterial;

  	};

  	GLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) {

  		var pending = [];

  		materialParams.color = new Color( 1.0, 1.0, 1.0 );
  		materialParams.opacity = 1.0;

  		var metallicRoughness = material.pbrMetallicRoughness;

  		if ( metallicRoughness ) {

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				var array = metallicRoughness.baseColorFactor;

  				materialParams.color.fromArray( array );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

  			}

  		}

  		return Promise.all( pending );

  	};
  	var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  	var BINARY_EXTENSION_HEADER_LENGTH = 12;
  	var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

  	function GLTFBinaryExtension( data ) {
  		var this$1 = this;


  		this.name = EXTENSIONS.KHR_BINARY_GLTF;
  		this.content = null;
  		this.body = null;

  		var headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

  		this.header = {
  			magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
  			version: headerView.getUint32( 4, true ),
  			length: headerView.getUint32( 8, true )
  		};

  		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

  			throw new Error( 'GLTFLoader: Unsupported glTF-Binary header.' );

  		} else if ( this.header.version < 2.0 ) {

  			throw new Error( 'GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' );

  		}

  		var chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
  		var chunkIndex = 0;

  		while ( chunkIndex < chunkView.byteLength ) {

  			var chunkLength = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			var chunkType = chunkView.getUint32( chunkIndex, true );
  			chunkIndex += 4;

  			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

  				var contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
  				this$1.content = LoaderUtils.decodeText( contentArray );

  			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

  				var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
  				this$1.body = data.slice( byteOffset, byteOffset + chunkLength );

  			}

  			// Clients must ignore chunks with unknown types.

  			chunkIndex += chunkLength;

  		}

  		if ( this.content === null ) {

  			throw new Error( 'GLTFLoader: JSON content not found.' );

  		}

  	}
  	function GLTFDracoMeshCompressionExtension( json, dracoLoader ) {

  		if ( ! dracoLoader ) {

  			throw new Error( 'GLTFLoader: No DRACOLoader instance provided.' );

  		}

  		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
  		this.json = json;
  		this.dracoLoader = dracoLoader;
  		DRACOLoader.getDecoderModule();

  	}

  	GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {

  		var json = this.json;
  		var dracoLoader = this.dracoLoader;
  		var bufferViewIndex = primitive.extensions[ this.name ].bufferView;
  		var gltfAttributeMap = primitive.extensions[ this.name ].attributes;
  		var threeAttributeMap = {};
  		var attributeNormalizedMap = {};
  		var attributeTypeMap = {};

  		for ( var attributeName in gltfAttributeMap ) {

  			if ( ! ( attributeName in ATTRIBUTES ) ) { continue; }

  			threeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ];

  		}

  		for ( attributeName in primitive.attributes ) {

  			if ( ATTRIBUTES[ attributeName ] !== undefined && gltfAttributeMap[ attributeName ] !== undefined ) {

  				var accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
  				var componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  				attributeTypeMap[ ATTRIBUTES[ attributeName ] ] = componentType;
  				attributeNormalizedMap[ ATTRIBUTES[ attributeName ] ] = accessorDef.normalized === true;

  			}

  		}

  		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

  			return new Promise( function ( resolve ) {

  				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

  					for ( var attributeName in geometry.attributes ) {

  						var attribute = geometry.attributes[ attributeName ];
  						var normalized = attributeNormalizedMap[ attributeName ];

  						if ( normalized !== undefined ) { attribute.normalized = normalized; }

  					}

  					resolve( geometry );

  				}, threeAttributeMap, attributeTypeMap );

  			} );

  		} );

  	};
  	function GLTFTextureTransformExtension( json ) {

  		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

  	}

  	GLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {

  		texture = texture.clone();

  		if ( transform.offset !== undefined ) {

  			texture.offset.fromArray( transform.offset );

  		}

  		if ( transform.rotation !== undefined ) {

  			texture.rotation = transform.rotation;

  		}

  		if ( transform.scale !== undefined ) {

  			texture.repeat.fromArray( transform.scale );

  		}

  		if ( transform.texCoord !== undefined ) {

  			console.warn( 'GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

  		}

  		texture.needsUpdate = true;

  		return texture;

  	};
  	function GLTFMaterialsPbrSpecularGlossinessExtension() {

  		return {

  			name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

  			specularGlossinessParams: [
  				'color',
  				'map',
  				'lightMap',
  				'lightMapIntensity',
  				'aoMap',
  				'aoMapIntensity',
  				'emissive',
  				'emissiveIntensity',
  				'emissiveMap',
  				'bumpMap',
  				'bumpScale',
  				'normalMap',
  				'displacementMap',
  				'displacementScale',
  				'displacementBias',
  				'specularMap',
  				'specular',
  				'glossinessMap',
  				'glossiness',
  				'alphaMap',
  				'envMap',
  				'envMapIntensity',
  				'refractionRatio' ],

  			getMaterialType: function () {

  				return ShaderMaterial;

  			},

  			extendParams: function ( params, material, parser ) {

  				var pbrSpecularGlossiness = material.extensions[ this.name ];

  				var shader = ShaderLib[ 'standard' ];

  				var uniforms = UniformsUtils.clone( shader.uniforms );

  				var specularMapParsFragmentChunk = [
  					'#ifdef USE_SPECULARMAP',
  					'	uniform sampler2D specularMap;',
  					'#endif'
  				].join( '\n' );

  				var glossinessMapParsFragmentChunk = [
  					'#ifdef USE_GLOSSINESSMAP',
  					'	uniform sampler2D glossinessMap;',
  					'#endif'
  				].join( '\n' );

  				var specularMapFragmentChunk = [
  					'vec3 specularFactor = specular;',
  					'#ifdef USE_SPECULARMAP',
  					'	vec4 texelSpecular = texture2D( specularMap, vUv );',
  					'	texelSpecular = sRGBToLinear( texelSpecular );',
  					'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
  					'	specularFactor *= texelSpecular.rgb;',
  					'#endif'
  				].join( '\n' );

  				var glossinessMapFragmentChunk = [
  					'float glossinessFactor = glossiness;',
  					'#ifdef USE_GLOSSINESSMAP',
  					'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
  					'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
  					'	glossinessFactor *= texelGlossiness.a;',
  					'#endif'
  				].join( '\n' );

  				var lightPhysicalFragmentChunk = [
  					'PhysicalMaterial material;',
  					'material.diffuseColor = diffuseColor.rgb;',
  					'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',
  					'material.specularColor = specularFactor.rgb;' ].join( '\n' );

  				var fragmentShader = shader.fragmentShader
  					.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
  					.replace( 'uniform float metalness;', 'uniform float glossiness;' )
  					.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
  					.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
  					.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
  					.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
  					.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

  				delete uniforms.roughness;
  				delete uniforms.metalness;
  				delete uniforms.roughnessMap;
  				delete uniforms.metalnessMap;

  				uniforms.specular = { value: new Color().setHex( 0x111111 ) };
  				uniforms.glossiness = { value: 0.5 };
  				uniforms.specularMap = { value: null };
  				uniforms.glossinessMap = { value: null };

  				params.vertexShader = shader.vertexShader;
  				params.fragmentShader = fragmentShader;
  				params.uniforms = uniforms;
  				params.defines = { 'STANDARD': '' };

  				params.color = new Color( 1.0, 1.0, 1.0 );
  				params.opacity = 1.0;

  				var pending = [];

  				if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

  					var array = pbrSpecularGlossiness.diffuseFactor;

  					params.color.fromArray( array );
  					params.opacity = array[ 3 ];

  				}

  				if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

  					pending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture ) );

  				}

  				params.emissive = new Color( 0.0, 0.0, 0.0 );
  				params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
  				params.specular = new Color( 1.0, 1.0, 1.0 );

  				if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

  					params.specular.fromArray( pbrSpecularGlossiness.specularFactor );

  				}

  				if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

  					var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
  					pending.push( parser.assignTexture( params, 'glossinessMap', specGlossMapDef ) );
  					pending.push( parser.assignTexture( params, 'specularMap', specGlossMapDef ) );

  				}

  				return Promise.all( pending );

  			},

  			createMaterial: function ( params ) {

  				// setup material properties based on MeshStandardMaterial for Specular-Glossiness

  				var material = new ShaderMaterial( {
  					defines: params.defines,
  					vertexShader: params.vertexShader,
  					fragmentShader: params.fragmentShader,
  					uniforms: params.uniforms,
  					fog: true,
  					lights: true,
  					opacity: params.opacity,
  					transparent: params.transparent
  				} );

  				material.isGLTFSpecularGlossinessMaterial = true;

  				material.color = params.color;

  				material.map = params.map === undefined ? null : params.map;

  				material.lightMap = null;
  				material.lightMapIntensity = 1.0;

  				material.aoMap = params.aoMap === undefined ? null : params.aoMap;
  				material.aoMapIntensity = 1.0;

  				material.emissive = params.emissive;
  				material.emissiveIntensity = 1.0;
  				material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;

  				material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
  				material.bumpScale = 1;

  				material.normalMap = params.normalMap === undefined ? null : params.normalMap;
  				if ( params.normalScale ) { material.normalScale = params.normalScale; }

  				material.displacementMap = null;
  				material.displacementScale = 1;
  				material.displacementBias = 0;

  				material.specularMap = params.specularMap === undefined ? null : params.specularMap;
  				material.specular = params.specular;

  				material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
  				material.glossiness = params.glossiness;

  				material.alphaMap = null;

  				material.envMap = params.envMap === undefined ? null : params.envMap;
  				material.envMapIntensity = 1.0;

  				material.refractionRatio = 0.98;

  				material.extensions.derivatives = true;

  				return material;

  			},
  			cloneMaterial: function ( source ) {

  				var target = source.clone();

  				target.isGLTFSpecularGlossinessMaterial = true;

  				var params = this.specularGlossinessParams;

  				for ( var i = 0, il = params.length; i < il; i ++ ) {

  					target[ params[ i ] ] = source[ params[ i ] ];

  				}

  				return target;

  			},

  			// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
  			refreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {

  				if ( material.isGLTFSpecularGlossinessMaterial !== true ) {

  					return;

  				}

  				var uniforms = material.uniforms;
  				var defines = material.defines;

  				uniforms.opacity.value = material.opacity;

  				uniforms.diffuse.value.copy( material.color );
  				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  				uniforms.map.value = material.map;
  				uniforms.specularMap.value = material.specularMap;
  				uniforms.alphaMap.value = material.alphaMap;

  				uniforms.lightMap.value = material.lightMap;
  				uniforms.lightMapIntensity.value = material.lightMapIntensity;

  				uniforms.aoMap.value = material.aoMap;
  				uniforms.aoMapIntensity.value = material.aoMapIntensity;

  				// uv repeat and offset setting priorities
  				// 1. color map
  				// 2. specular map
  				// 3. normal map
  				// 4. bump map
  				// 5. alpha map
  				// 6. emissive map

  				var uvScaleMap;

  				if ( material.map ) {

  					uvScaleMap = material.map;

  				} else if ( material.specularMap ) {

  					uvScaleMap = material.specularMap;

  				} else if ( material.displacementMap ) {

  					uvScaleMap = material.displacementMap;

  				} else if ( material.normalMap ) {

  					uvScaleMap = material.normalMap;

  				} else if ( material.bumpMap ) {

  					uvScaleMap = material.bumpMap;

  				} else if ( material.glossinessMap ) {

  					uvScaleMap = material.glossinessMap;

  				} else if ( material.alphaMap ) {

  					uvScaleMap = material.alphaMap;

  				} else if ( material.emissiveMap ) {

  					uvScaleMap = material.emissiveMap;

  				}

  				if ( uvScaleMap !== undefined ) {

  					// backwards compatibility
  					if ( uvScaleMap.isWebGLRenderTarget ) {

  						uvScaleMap = uvScaleMap.texture;

  					}

  					if ( uvScaleMap.matrixAutoUpdate === true ) {

  						uvScaleMap.updateMatrix();

  					}

  					uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  				}

  				if ( material.envMap ) {

  					uniforms.envMap.value = material.envMap;
  					uniforms.envMapIntensity.value = material.envMapIntensity;

  					// don't flip CubeTexture envMaps, flip everything else:
  					//  WebGLRenderTargetCube will be flipped for backwards compatibility
  					//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  					// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  					uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

  					uniforms.reflectivity.value = material.reflectivity;
  					uniforms.refractionRatio.value = material.refractionRatio;

  					uniforms.maxMipLevel.value = renderer.properties.get( material.envMap ).__maxMipLevel;

  				}

  				uniforms.specular.value.copy( material.specular );
  				uniforms.glossiness.value = material.glossiness;

  				uniforms.glossinessMap.value = material.glossinessMap;

  				uniforms.emissiveMap.value = material.emissiveMap;
  				uniforms.bumpMap.value = material.bumpMap;
  				uniforms.normalMap.value = material.normalMap;

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  				if ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {

  					defines.USE_GLOSSINESSMAP = '';
  					// set USE_ROUGHNESSMAP to enable vUv
  					defines.USE_ROUGHNESSMAP = '';

  				}

  				if ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {

  					delete defines.USE_GLOSSINESSMAP;
  					delete defines.USE_ROUGHNESSMAP;

  				}

  			}

  		};

  	}
  	// Spline Interpolation
  	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
  	function GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	GLTFCubicSplineInterpolant.prototype = Object.create( Interpolant.prototype );
  	GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

  	GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {

  		// Copies a sample value to the result buffer. See description of glTF
  		// CUBICSPLINE values layout in interpolate_() function below.

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			valueSize = this.valueSize,
  			offset = index * valueSize * 3 + valueSize;

  		for ( var i = 0; i !== valueSize; i ++ ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	};

  	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer;
  		var values = this.sampleValues;
  		var stride = this.valueSize;

  		var stride2 = stride * 2;
  		var stride3 = stride * 3;

  		var td = t1 - t0;

  		var p = ( t - t0 ) / td;
  		var pp = p * p;
  		var ppp = pp * p;

  		var offset1 = i1 * stride3;
  		var offset0 = offset1 - stride3;

  		var s2 = - 2 * ppp + 3 * pp;
  		var s3 = ppp - pp;
  		var s0 = 1 - s2;
  		var s1 = s3 - pp + p;

  		// Layout of keyframe output values for CUBICSPLINE animations:
  		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
  		for ( var i = 0; i !== stride; i ++ ) {

  			var p0 = values[ offset0 + i + stride ]; // splineVertex_k
  			var m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
  			var p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
  			var m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

  			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

  		}

  		return result;

  	};
  	var WEBGL_CONSTANTS = {
  		FLOAT: 5126,
  		//FLOAT_MAT2: 35674,
  		FLOAT_MAT3: 35675,
  		FLOAT_MAT4: 35676,
  		FLOAT_VEC2: 35664,
  		FLOAT_VEC3: 35665,
  		FLOAT_VEC4: 35666,
  		LINEAR: 9729,
  		REPEAT: 10497,
  		SAMPLER_2D: 35678,
  		POINTS: 0,
  		LINES: 1,
  		LINE_LOOP: 2,
  		LINE_STRIP: 3,
  		TRIANGLES: 4,
  		TRIANGLE_STRIP: 5,
  		TRIANGLE_FAN: 6,
  		UNSIGNED_BYTE: 5121,
  		UNSIGNED_SHORT: 5123
  	};

  	var WEBGL_COMPONENT_TYPES = {
  		5120: Int8Array,
  		5121: Uint8Array,
  		5122: Int16Array,
  		5123: Uint16Array,
  		5125: Uint32Array,
  		5126: Float32Array
  	};

  	var WEBGL_FILTERS = {
  		9728: NearestFilter,
  		9729: LinearFilter,
  		9984: NearestMipMapNearestFilter,
  		9985: LinearMipMapNearestFilter,
  		9986: NearestMipMapLinearFilter,
  		9987: LinearMipMapLinearFilter
  	};

  	var WEBGL_WRAPPINGS = {
  		33071: ClampToEdgeWrapping,
  		33648: MirroredRepeatWrapping,
  		10497: RepeatWrapping
  	};

  	var WEBGL_TYPE_SIZES = {
  		'SCALAR': 1,
  		'VEC2': 2,
  		'VEC3': 3,
  		'VEC4': 4,
  		'MAT2': 4,
  		'MAT3': 9,
  		'MAT4': 16
  	};

  	var ATTRIBUTES = {
  		POSITION: 'position',
  		NORMAL: 'normal',
  		TANGENT: 'tangent',
  		TEXCOORD_0: 'uv',
  		TEXCOORD_1: 'uv2',
  		COLOR_0: 'color',
  		WEIGHTS_0: 'skinWeight',
  		JOINTS_0: 'skinIndex',
  	};

  	var PATH_PROPERTIES = {
  		scale: 'scale',
  		translation: 'position',
  		rotation: 'quaternion',
  		weights: 'morphTargetInfluences'
  	};

  	var INTERPOLATION = {
  		CUBICSPLINE: InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.
  		                                      // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,
  		                                      // using InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.
  		                                      // See KeyframeTrack.optimize() for the detail.
  		LINEAR: InterpolateLinear,
  		STEP: InterpolateDiscrete
  	};

  	var ALPHA_MODES = {
  		OPAQUE: 'OPAQUE',
  		MASK: 'MASK',
  		BLEND: 'BLEND'
  	};

  	var MIME_TYPE_FORMATS = {
  		'image/png': RGBAFormat,
  		'image/jpeg': RGBFormat
  	};
  	function resolveURL( url, path ) {

  		// Invalid URL
  		if ( typeof url !== 'string' || url === '' ) { return ''; }

  		// Absolute URL http://,https://,//
  		if ( /^(https?:)?\/\//i.test( url ) ) { return url; }

  		// Data URI
  		if ( /^data:.*,.*$/i.test( url ) ) { return url; }

  		// Blob URL
  		if ( /^blob:.*$/i.test( url ) ) { return url; }

  		// Relative URL
  		return path + url;

  	}
  	function createDefaultMaterial() {

  		return new MeshStandardMaterial( {
  			color: 0xFFFFFF,
  			emissive: 0x000000,
  			metalness: 1,
  			roughness: 1,
  			transparent: false,
  			depthTest: true,
  			side: FrontSide
  		} );

  	}

  	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

  		// Add unknown glTF extensions to an object's userData.

  		for ( var name in objectDef.extensions ) {

  			if ( knownExtensions[ name ] === undefined ) {

  				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
  				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

  			}

  		}

  	}
  	function assignExtrasToUserData( object, gltfDef ) {

  		if ( gltfDef.extras !== undefined ) {

  			if ( typeof gltfDef.extras === 'object' ) {

  				object.userData = gltfDef.extras;

  			} else {

  				console.warn( 'GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

  			}

  		}

  	}
  	function addMorphTargets( geometry, targets, parser ) {

  		var hasMorphPosition = false;
  		var hasMorphNormal = false;

  		for ( var i = 0, il = targets.length; i < il; i ++ ) {

  			var target = targets[ i ];

  			if ( target.POSITION !== undefined ) { hasMorphPosition = true; }
  			if ( target.NORMAL !== undefined ) { hasMorphNormal = true; }

  			if ( hasMorphPosition && hasMorphNormal ) { break; }

  		}

  		if ( ! hasMorphPosition && ! hasMorphNormal ) { return Promise.resolve( geometry ); }

  		var pendingPositionAccessors = [];
  		var pendingNormalAccessors = [];

  		for ( var i = 0, il = targets.length; i < il; i ++ ) {

  			var target = targets[ i ];

  			if ( hasMorphPosition ) {

  				// TODO: Error-prone use of a callback inside a loop.
  				var accessor = target.POSITION !== undefined
  					? parser.getDependency( 'accessor', target.POSITION )
  						.then( function ( accessor ) {

  							// Cloning not to pollute original accessor below
  							return cloneBufferAttribute( accessor );

  						} )
  					: geometry.attributes.position;

  				pendingPositionAccessors.push( accessor );

  			}

  			if ( hasMorphNormal ) {

  				// TODO: Error-prone use of a callback inside a loop.
  				var accessor = target.NORMAL !== undefined
  					? parser.getDependency( 'accessor', target.NORMAL )
  						.then( function ( accessor ) {

  							return cloneBufferAttribute( accessor );

  						} )
  					: geometry.attributes.normal;

  				pendingNormalAccessors.push( accessor );

  			}

  		}

  		return Promise.all( [
  			Promise.all( pendingPositionAccessors ),
  			Promise.all( pendingNormalAccessors )
  		] ).then( function ( accessors ) {

  			var morphPositions = accessors[ 0 ];
  			var morphNormals = accessors[ 1 ];

  			for ( var i = 0, il = targets.length; i < il; i ++ ) {

  				var target = targets[ i ];
  				var attributeName = 'morphTarget' + i;

  				if ( hasMorphPosition ) {

  					// Three.js morph position is absolute value. The formula is
  					//   basePosition
  					//     + weight0 * ( morphPosition0 - basePosition )
  					//     + weight1 * ( morphPosition1 - basePosition )
  					//     ...
  					// while the glTF one is relative
  					//   basePosition
  					//     + weight0 * glTFmorphPosition0
  					//     + weight1 * glTFmorphPosition1
  					//     ...
  					// then we need to convert from relative to absolute here.

  					if ( target.POSITION !== undefined ) {

  						var positionAttribute = morphPositions[ i ];
  						positionAttribute.name = attributeName;

  						var position = geometry.attributes.position;

  						for ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {

  							positionAttribute.setXYZ(
  								j,
  								positionAttribute.getX( j ) + position.getX( j ),
  								positionAttribute.getY( j ) + position.getY( j ),
  								positionAttribute.getZ( j ) + position.getZ( j )
  							);

  						}

  					}

  				}

  				if ( hasMorphNormal ) {

  					// see target.POSITION's comment

  					if ( target.NORMAL !== undefined ) {

  						var normalAttribute = morphNormals[ i ];
  						normalAttribute.name = attributeName;

  						var normal = geometry.attributes.normal;

  						for ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) {

  							normalAttribute.setXYZ(
  								j,
  								normalAttribute.getX( j ) + normal.getX( j ),
  								normalAttribute.getY( j ) + normal.getY( j ),
  								normalAttribute.getZ( j ) + normal.getZ( j )
  							);

  						}

  					}

  				}

  			}

  			if ( hasMorphPosition ) { geometry.morphAttributes.position = morphPositions; }
  			if ( hasMorphNormal ) { geometry.morphAttributes.normal = morphNormals; }

  			return geometry;

  		} );

  	}
  	function updateMorphTargets( mesh, meshDef ) {

  		mesh.updateMorphTargets();

  		if ( meshDef.weights !== undefined ) {

  			for ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {

  				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

  			}

  		}

  		// .extras has user-defined data, so check that .extras.targetNames is an array.
  		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

  			var targetNames = meshDef.extras.targetNames;

  			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

  				mesh.morphTargetDictionary = {};

  				for ( var i = 0, il = targetNames.length; i < il; i ++ ) {

  					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

  				}

  			} else {

  				console.warn( 'GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

  			}

  		}

  	}
  	function isObjectEqual( a, b ) {

  		if ( Object.keys( a ).length !== Object.keys( b ).length ) { return false; }

  		for ( var key in a ) {

  			if ( a[ key ] !== b[ key ] ) { return false; }

  		}

  		return true;

  	}

  	function createPrimitiveKey( primitiveDef ) {

  		var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
  		var geometryKey;

  		if ( dracoExtension ) {

  			geometryKey = 'draco:' + dracoExtension.bufferView
  				+ ':' + dracoExtension.indices
  				+ ':' + createAttributesKey( dracoExtension.attributes );

  		} else {

  			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

  		}

  		return geometryKey;

  	}

  	function createAttributesKey( attributes ) {

  		var attributesKey = '';

  		var keys = Object.keys( attributes ).sort();

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

  		}

  		return attributesKey;

  	}

  	function createArrayKeyBufferGeometry( a ) {

  		var arrayKey = '';

  		for ( var i = 0, il = a.length; i < il; i ++ ) {

  			arrayKey += ':' + a[ i ].uuid;

  		}

  		return arrayKey;

  	}

  	function createMultiPassGeometryKey( geometry, primitives ) {

  		var key = geometry.uuid;

  		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

  			key += i + createPrimitiveKey( primitives[ i ] );

  		}

  		return key;

  	}

  	function cloneBufferAttribute( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) {

  			var count = attribute.count;
  			var itemSize = attribute.itemSize;
  			var array = attribute.array.slice( 0, count * itemSize );

  			for ( var i = 0, j = 0; i < count; ++ i ) {

  				array[ j ++ ] = attribute.getX( i );
  				if ( itemSize >= 2 ) { array[ j ++ ] = attribute.getY( i ); }
  				if ( itemSize >= 3 ) { array[ j ++ ] = attribute.getZ( i ); }
  				if ( itemSize >= 4 ) { array[ j ++ ] = attribute.getW( i ); }

  			}

  			return new BufferAttribute( array, itemSize, attribute.normalized );

  		}

  		return attribute.clone();

  	}
  	function isMultiPassGeometry( primitives ) {

  		if ( primitives.length < 2 ) { return false; }

  		var primitive0 = primitives[ 0 ];
  		var targets0 = primitive0.targets || [];

  		if ( primitive0.indices === undefined ) { return false; }

  		for ( var i = 1, il = primitives.length; i < il; i ++ ) {

  			var primitive = primitives[ i ];

  			if ( primitive0.mode !== primitive.mode ) { return false; }
  			if ( primitive.indices === undefined ) { return false; }
  			if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) { return false; }
  			if ( ! isObjectEqual( primitive0.attributes, primitive.attributes ) ) { return false; }

  			var targets = primitive.targets || [];

  			if ( targets0.length !== targets.length ) { return false; }

  			for ( var j = 0, jl = targets0.length; j < jl; j ++ ) {

  				if ( ! isObjectEqual( targets0[ j ], targets[ j ] ) ) { return false; }

  			}

  		}

  		return true;

  	}
  	function GLTFParser( json, extensions, options ) {

  		this.json = json || {};
  		this.extensions = extensions || {};
  		this.options = options || {};

  		// loader object cache
  		this.cache = new GLTFRegistry();

  		// BufferGeometry caching
  		this.primitiveCache = {};
  		this.multiplePrimitivesCache = {};
  		this.multiPassGeometryCache = {};

  		this.textureLoader = new TextureLoader( this.options.manager );
  		this.textureLoader.setCrossOrigin( this.options.crossOrigin );

  		this.fileLoader = new FileLoader( this.options.manager );
  		this.fileLoader.setResponseType( 'arraybuffer' );

  	}

  	GLTFParser.prototype.parse = function ( onLoad, onError ) {

  		var json = this.json;

  		// Clear the loader cache
  		this.cache.removeAll();

  		// Mark the special nodes/meshes in json for efficient parse
  		this.markDefs();

  		// Fire the callback on complete
  		this.getMultiDependencies( [

  			'scene',
  			'animation',
  			'camera'

  		] ).then( function ( dependencies ) {

  			var scenes = dependencies.scenes || [];
  			var scene = scenes[ json.scene || 0 ];
  			var animations = dependencies.animations || [];
  			var cameras = dependencies.cameras || [];

  			onLoad( scene, scenes, cameras, animations, json );

  		} ).catch( onError );

  	};
  	GLTFParser.prototype.markDefs = function () {

  		var nodeDefs = this.json.nodes || [];
  		var skinDefs = this.json.skins || [];
  		var meshDefs = this.json.meshes || [];

  		var meshReferences = {};
  		var meshUses = {};

  		// Nothing in the node definition indicates whether it is a Bone or an
  		// Object3D. Use the skins' joint references to mark bones.
  		for ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

  			var joints = skinDefs[ skinIndex ].joints;

  			for ( var i = 0, il = joints.length; i < il; i ++ ) {

  				nodeDefs[ joints[ i ] ].isBone = true;

  			}

  		}

  		// Meshes can (and should) be reused by multiple nodes in a glTF asset. To
  		// avoid having more than one Mesh with the same name, count
  		// references and rename instances below.
  		//
  		// Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
  		for ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

  			var nodeDef = nodeDefs[ nodeIndex ];

  			if ( nodeDef.mesh !== undefined ) {

  				if ( meshReferences[ nodeDef.mesh ] === undefined ) {

  					meshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;

  				}

  				meshReferences[ nodeDef.mesh ] ++;

  				// Nothing in the mesh definition indicates whether it is
  				// a SkinnedMesh or Mesh. Use the node's mesh reference
  				// to mark SkinnedMesh if node has skin.
  				if ( nodeDef.skin !== undefined ) {

  					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

  				}

  			}

  		}

  		this.json.meshReferences = meshReferences;
  		this.json.meshUses = meshUses;

  	};
  	GLTFParser.prototype.getDependency = function ( type, index ) {

  		var cacheKey = type + ':' + index;
  		var dependency = this.cache.get( cacheKey );

  		if ( ! dependency ) {

  			switch ( type ) {

  				case 'scene':
  					dependency = this.loadScene( index );
  					break;

  				case 'node':
  					dependency = this.loadNode( index );
  					break;

  				case 'mesh':
  					dependency = this.loadMesh( index );
  					break;

  				case 'accessor':
  					dependency = this.loadAccessor( index );
  					break;

  				case 'bufferView':
  					dependency = this.loadBufferView( index );
  					break;

  				case 'buffer':
  					dependency = this.loadBuffer( index );
  					break;

  				case 'material':
  					dependency = this.loadMaterial( index );
  					break;

  				case 'texture':
  					dependency = this.loadTexture( index );
  					break;

  				case 'skin':
  					dependency = this.loadSkin( index );
  					break;

  				case 'animation':
  					dependency = this.loadAnimation( index );
  					break;

  				case 'camera':
  					dependency = this.loadCamera( index );
  					break;

  				case 'light':
  					dependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );
  					break;

  				default:
  					throw new Error( 'Unknown type: ' + type );

  			}

  			this.cache.add( cacheKey, dependency );

  		}

  		return dependency;

  	};
  	GLTFParser.prototype.getDependencies = function ( type ) {

  		var dependencies = this.cache.get( type );

  		if ( ! dependencies ) {

  			var parser = this;
  			var defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

  			dependencies = Promise.all( defs.map( function ( def, index ) {

  				return parser.getDependency( type, index );

  			} ) );

  			this.cache.add( type, dependencies );

  		}

  		return dependencies;

  	};
  	GLTFParser.prototype.getMultiDependencies = function ( types ) {
  		var this$1 = this;


  		var results = {};
  		var pending = [];

  		for ( var i = 0, il = types.length; i < il; i ++ ) {

  			var type = types[ i ];
  			var value = this$1.getDependencies( type );

  			// TODO: Error-prone use of a callback inside a loop.
  			value = value.then( function ( key, value ) {

  				results[ key ] = value;

  			}.bind( this$1, type + ( type === 'mesh' ? 'es' : 's' ) ) );

  			pending.push( value );

  		}

  		return Promise.all( pending ).then( function () {

  			return results;

  		} );

  	};
  	GLTFParser.prototype.loadBuffer = function ( bufferIndex ) {

  		var bufferDef = this.json.buffers[ bufferIndex ];
  		var loader = this.fileLoader;

  		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

  			throw new Error( 'GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

  		}

  		// If present, GLB container is required to be the first buffer.
  		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

  			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

  		}

  		var options = this.options;

  		return new Promise( function ( resolve, reject ) {

  			loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

  				reject( new Error( 'GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

  			} );

  		} );

  	};
  	GLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {

  		var bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

  		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

  			var byteLength = bufferViewDef.byteLength || 0;
  			var byteOffset = bufferViewDef.byteOffset || 0;
  			return buffer.slice( byteOffset, byteOffset + byteLength );

  		} );

  	};
  	GLTFParser.prototype.loadAccessor = function ( accessorIndex ) {

  		var parser = this;
  		var json = this.json;

  		var accessorDef = this.json.accessors[ accessorIndex ];

  		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

  			// Ignore empty accessors, which may be used to declare runtime
  			// information about attributes coming from another source (e.g. Draco
  			// compression extension).
  			return Promise.resolve( null );

  		}

  		var pendingBufferViews = [];

  		if ( accessorDef.bufferView !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

  		} else {

  			pendingBufferViews.push( null );

  		}

  		if ( accessorDef.sparse !== undefined ) {

  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
  			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

  		}

  		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

  			var bufferView = bufferViews[ 0 ];

  			var itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
  			var TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

  			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
  			var elementBytes = TypedArray.BYTES_PER_ELEMENT;
  			var itemBytes = elementBytes * itemSize;
  			var byteOffset = accessorDef.byteOffset || 0;
  			var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
  			var normalized = accessorDef.normalized === true;
  			var array, bufferAttribute;

  			// The buffer is not interleaved if the stride is the item size in bytes.
  			if ( byteStride && byteStride !== itemBytes ) {

  				var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;
  				var ib = parser.cache.get( ibCacheKey );

  				if ( ! ib ) {

  					// Use the full buffer if it's interleaved.
  					array = new TypedArray( bufferView );

  					// Integer parameters to IB/IBA are in array elements, not bytes.
  					ib = new InterleavedBuffer( array, byteStride / elementBytes );

  					parser.cache.add( ibCacheKey, ib );

  				}

  				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized );

  			} else {

  				if ( bufferView === null ) {

  					array = new TypedArray( accessorDef.count * itemSize );

  				} else {

  					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

  				}

  				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

  			}

  			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
  			if ( accessorDef.sparse !== undefined ) {

  				var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
  				var TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

  				var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
  				var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

  				var sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
  				var sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

  				if ( bufferView !== null ) {

  					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
  					bufferAttribute.setArray( bufferAttribute.array.slice() );

  				}

  				for ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {

  					var index = sparseIndices[ i ];

  					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
  					if ( itemSize >= 2 ) { bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] ); }
  					if ( itemSize >= 3 ) { bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] ); }
  					if ( itemSize >= 4 ) { bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] ); }
  					if ( itemSize >= 5 ) { throw new Error( 'GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' ); }

  				}

  			}

  			return bufferAttribute;

  		} );

  	};
  	GLTFParser.prototype.loadTexture = function ( textureIndex ) {

  		var parser = this;
  		var json = this.json;
  		var options = this.options;
  		var textureLoader = this.textureLoader;

  		var URL = window.URL || window.webkitURL;

  		var textureDef = json.textures[ textureIndex ];

  		var textureExtensions = textureDef.extensions || {};

  		var source;

  		if ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {

  			source = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];

  		} else {

  			source = json.images[ textureDef.source ];

  		}

  		var sourceURI = source.uri;
  		var isObjectURL = false;

  		if ( source.bufferView !== undefined ) {

  			// Load binary image data from bufferView, if provided.

  			sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

  				isObjectURL = true;
  				var blob = new Blob( [ bufferView ], { type: source.mimeType } );
  				sourceURI = URL.createObjectURL( blob );
  				return sourceURI;

  			} );

  		}

  		return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

  			// Load Texture resource.

  			var loader = Loader$1.Handlers.get( sourceURI );

  			if ( ! loader ) {

  				loader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]
  					? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader
  					: textureLoader;

  			}

  			return new Promise( function ( resolve, reject ) {

  				loader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );

  			} );

  		} ).then( function ( texture ) {

  			// Clean up resources and configure Texture.

  			if ( isObjectURL === true ) {

  				URL.revokeObjectURL( sourceURI );

  			}

  			texture.flipY = false;

  			if ( textureDef.name !== undefined ) { texture.name = textureDef.name; }

  			// Ignore unknown mime types, like DDS files.
  			if ( source.mimeType in MIME_TYPE_FORMATS ) {

  				texture.format = MIME_TYPE_FORMATS[ source.mimeType ];

  			}

  			var samplers = json.samplers || {};
  			var sampler = samplers[ textureDef.sampler ] || {};

  			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
  			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipMapLinearFilter;
  			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
  			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

  			return texture;

  		} );

  	};
  	GLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {

  		var parser = this;

  		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

  			switch ( mapName ) {

  				case 'aoMap':
  				case 'emissiveMap':
  				case 'metalnessMap':
  				case 'normalMap':
  				case 'roughnessMap':
  					texture.format = RGBFormat;
  					break;

  			}

  			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

  				var transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

  				if ( transform ) {

  					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );

  				}

  			}

  			materialParams[ mapName ] = texture;

  		} );

  	};
  	GLTFParser.prototype.loadMaterial = function ( materialIndex ) {

  		var parser = this;
  		var json = this.json;
  		var extensions = this.extensions;
  		var materialDef = json.materials[ materialIndex ];

  		var materialType;
  		var materialParams = {};
  		var materialExtensions = materialDef.extensions || {};

  		var pending = [];

  		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

  			var sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
  			materialType = sgExtension.getMaterialType( materialDef );
  			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

  		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

  			var kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
  			materialType = kmuExtension.getMaterialType( materialDef );
  			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

  		} else {

  			// Specification:
  			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

  			materialType = MeshStandardMaterial;

  			var metallicRoughness = materialDef.pbrMetallicRoughness || {};

  			materialParams.color = new Color( 1.0, 1.0, 1.0 );
  			materialParams.opacity = 1.0;

  			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

  				var array = metallicRoughness.baseColorFactor;

  				materialParams.color.fromArray( array );
  				materialParams.opacity = array[ 3 ];

  			}

  			if ( metallicRoughness.baseColorTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

  			}

  			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
  			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

  			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

  				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
  				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

  			}

  		}

  		if ( materialDef.doubleSided === true ) {

  			materialParams.side = DoubleSide;

  		}

  		var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

  		if ( alphaMode === ALPHA_MODES.BLEND ) {

  			materialParams.transparent = true;

  		} else {

  			materialParams.transparent = false;

  			if ( alphaMode === ALPHA_MODES.MASK ) {

  				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

  			}

  		}

  		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

  			materialParams.normalScale = new Vector2( 1, 1 );

  			if ( materialDef.normalTexture.scale !== undefined ) {

  				materialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );

  			}

  		}

  		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

  			if ( materialDef.occlusionTexture.strength !== undefined ) {

  				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

  			}

  		}

  		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

  			materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

  		}

  		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

  			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

  		}

  		return Promise.all( pending ).then( function () {

  			var material;

  			if ( materialType === ShaderMaterial ) {

  				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

  			} else {

  				material = new materialType( materialParams );

  			}

  			if ( materialDef.name !== undefined ) { material.name = materialDef.name; }

  			// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
  			if ( material.map ) { material.map.encoding = sRGBEncoding; }
  			if ( material.emissiveMap ) { material.emissiveMap.encoding = sRGBEncoding; }
  			if ( material.specularMap ) { material.specularMap.encoding = sRGBEncoding; }

  			assignExtrasToUserData( material, materialDef );

  			if ( materialDef.extensions ) { addUnknownExtensionsToUserData( extensions, material, materialDef ); }

  			return material;

  		} );

  	};
  	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

  		var attributes = primitiveDef.attributes;

  		var pending = [];

  		function assignAttributeAccessor( accessorIndex, attributeName ) {

  			return parser.getDependency( 'accessor', accessorIndex )
  				.then( function ( accessor ) {

  					geometry.addAttribute( attributeName, accessor );

  				} );

  		}

  		for ( var gltfAttributeName in attributes ) {

  			var threeAttributeName = ATTRIBUTES[ gltfAttributeName ];

  			if ( ! threeAttributeName ) { continue; }

  			// Skip attributes already provided by e.g. Draco extension.
  			if ( threeAttributeName in geometry.attributes ) { continue; }

  			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

  		}

  		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

  			var accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

  				geometry.setIndex( accessor );

  			} );

  			pending.push( accessor );

  		}

  		assignExtrasToUserData( geometry, primitiveDef );

  		return Promise.all( pending ).then( function () {

  			return primitiveDef.targets !== undefined
  				? addMorphTargets( geometry, primitiveDef.targets, parser )
  				: geometry;

  		} );

  	}
  	GLTFParser.prototype.loadGeometries = function ( primitives ) {

  		var parser = this;
  		var extensions = this.extensions;
  		var cache = this.primitiveCache;

  		var isMultiPass = isMultiPassGeometry( primitives );
  		var originalPrimitives;

  		if ( isMultiPass ) {

  			originalPrimitives = primitives; // save original primitives and use later

  			// We build a single BufferGeometry with .groups from multiple primitives
  			// because all primitives share the same attributes/morph/mode and have indices.

  			primitives = [ primitives[ 0 ] ];

  			// Sets .groups and combined indices to a geometry later in this method.

  		}

  		function createDracoPrimitive( primitive ) {

  			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
  				.decodePrimitive( primitive, parser )
  				.then( function ( geometry ) {

  					return addPrimitiveAttributes( geometry, primitive, parser );

  				} );

  		}

  		var pending = [];

  		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

  			var primitive = primitives[ i ];
  			var cacheKey = createPrimitiveKey( primitive );

  			// See if we've already created this geometry
  			var cached = cache[ cacheKey ];

  			if ( cached ) {

  				// Use the cached geometry if it exists
  				pending.push( cached.promise );

  			} else {

  				var geometryPromise;

  				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

  					// Use DRACO geometry if available
  					geometryPromise = createDracoPrimitive( primitive );

  				} else {

  					// Otherwise create a new geometry
  					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

  				}

  				// Cache this geometry
  				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

  				pending.push( geometryPromise );

  			}

  		}

  		return Promise.all( pending ).then( function ( geometries ) {

  			if ( isMultiPass ) {

  				var baseGeometry = geometries[ 0 ];

  				// See if we've already created this combined geometry
  				var cache = parser.multiPassGeometryCache;
  				var cacheKey = createMultiPassGeometryKey( baseGeometry, originalPrimitives );
  				var cached = cache[ cacheKey ];

  				if ( cached !== null ) { return [ cached.geometry ]; }

  				// Cloning geometry because of index override.
  				// Attributes can be reused so cloning by myself here.
  				var geometry = new BufferGeometry();

  				geometry.name = baseGeometry.name;
  				geometry.userData = baseGeometry.userData;

  				for ( var key in baseGeometry.attributes ) { geometry.addAttribute( key, baseGeometry.attributes[ key ] ); }
  				for ( var key in baseGeometry.morphAttributes ) { geometry.morphAttributes[ key ] = baseGeometry.morphAttributes[ key ]; }

  				var pendingIndices = [];

  				for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) {

  					pendingIndices.push( parser.getDependency( 'accessor', originalPrimitives[ i ].indices ) );

  				}

  				return Promise.all( pendingIndices ).then( function ( accessors ) {

  					var indices = [];
  					var offset = 0;

  					for ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) {

  						var accessor = accessors[ i ];

  						for ( var j = 0, jl = accessor.count; j < jl; j ++ ) { indices.push( accessor.array[ j ] ); }

  						geometry.addGroup( offset, accessor.count, i );

  						offset += accessor.count;

  					}

  					geometry.setIndex( indices );

  					cache[ cacheKey ] = { geometry: geometry, baseGeometry: baseGeometry, primitives: originalPrimitives };

  					return [ geometry ];

  				} );

  			} else if ( geometries.length > 1 && BufferGeometryUtils !== undefined ) {

  				// Tries to merge geometries with BufferGeometryUtils if possible

  				for ( var i = 1, il = primitives.length; i < il; i ++ ) {

  					// can't merge if draw mode is different
  					if ( primitives[ 0 ].mode !== primitives[ i ].mode ) { return geometries; }

  				}

  				// See if we've already created this combined geometry
  				var cache = parser.multiplePrimitivesCache;
  				var cacheKey = createArrayKeyBufferGeometry( geometries );
  				var cached = cache[ cacheKey ];

  				if ( cached ) {

  					if ( cached.geometry !== null ) { return [ cached.geometry ]; }

  				} else {

  					var geometry = BufferGeometryUtils.mergeBufferGeometries( geometries, true );

  					cache[ cacheKey ] = { geometry: geometry, baseGeometries: geometries };

  					if ( geometry !== null ) { return [ geometry ]; }

  				}

  			}

  			return geometries;

  		} );

  	};
  	GLTFParser.prototype.loadMesh = function ( meshIndex ) {
  		var this$1 = this;


  		var parser = this;
  		var json = this.json;
  		var extensions = this.extensions;

  		var meshDef = json.meshes[ meshIndex ];
  		var primitives = meshDef.primitives;

  		var pending = [];

  		for ( var i = 0, il = primitives.length; i < il; i ++ ) {

  			var material = primitives[ i ].material === undefined
  				? createDefaultMaterial()
  				: this$1.getDependency( 'material', primitives[ i ].material );

  			pending.push( material );

  		}

  		return Promise.all( pending ).then( function ( originalMaterials ) {

  			return parser.loadGeometries( primitives ).then( function ( geometries ) {

  				var isMultiMaterial = geometries.length === 1 && geometries[ 0 ].groups.length > 0;

  				var meshes = [];

  				for ( var i = 0, il = geometries.length; i < il; i ++ ) {

  					var geometry = geometries[ i ];
  					var primitive = primitives[ i ];

  					// 1. create Mesh

  					var mesh;

  					var material = isMultiMaterial ? originalMaterials : originalMaterials[ i ];

  					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
  						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
  						primitive.mode === undefined ) {

  						// .isSkinnedMesh isn't in glTF spec. See .markDefs()
  						mesh = meshDef.isSkinnedMesh === true
  							? new SkinnedMesh( geometry, material )
  							: new Mesh( geometry, material );

  						if ( mesh.isSkinnedMesh === true ) { mesh.normalizeSkinWeights(); } // #15319

  						if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

  							mesh.drawMode = TriangleStripDrawMode;

  						} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

  							mesh.drawMode = TriangleFanDrawMode;

  						}

  					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

  						mesh = new LineSegments( geometry, material );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

  						mesh = new Line( geometry, material );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

  						mesh = new LineLoop( geometry, material );

  					} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

  						mesh = new Points( geometry, material );

  					} else {

  						throw new Error( 'GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

  					}

  					if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

  						updateMorphTargets( mesh, meshDef );

  					}

  					mesh.name = meshDef.name || ( 'mesh_' + meshIndex );

  					if ( geometries.length > 1 ) { mesh.name += '_' + i; }

  					assignExtrasToUserData( mesh, meshDef );

  					meshes.push( mesh );

  					// 2. update Material depending on Mesh and BufferGeometry

  					var materials = isMultiMaterial ? mesh.material : [ mesh.material ];

  					var useVertexTangents = geometry.attributes.tangent !== undefined;
  					var useVertexColors = geometry.attributes.color !== undefined;
  					var useFlatShading = geometry.attributes.normal === undefined;
  					var useSkinning = mesh.isSkinnedMesh === true;
  					var useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
  					var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

  					for ( var j = 0, jl = materials.length; j < jl; j ++ ) {

  						var material = materials[ j ];

  						if ( mesh.isPoints ) {

  							var cacheKey = 'PointsMaterial:' + material.uuid;

  							var pointsMaterial = parser.cache.get( cacheKey );

  							if ( ! pointsMaterial ) {

  								pointsMaterial = new PointsMaterial();
  								Material$1.prototype.copy.call( pointsMaterial, material );
  								pointsMaterial.color.copy( material.color );
  								pointsMaterial.map = material.map;
  								pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet

  								parser.cache.add( cacheKey, pointsMaterial );

  							}

  							material = pointsMaterial;

  						} else if ( mesh.isLine ) {

  							var cacheKey = 'LineBasicMaterial:' + material.uuid;

  							var lineMaterial = parser.cache.get( cacheKey );

  							if ( ! lineMaterial ) {

  								lineMaterial = new LineBasicMaterial();
  								Material$1.prototype.copy.call( lineMaterial, material );
  								lineMaterial.color.copy( material.color );
  								lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet

  								parser.cache.add( cacheKey, lineMaterial );

  							}

  							material = lineMaterial;

  						}

  						// Clone the material if it will be modified
  						if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

  							var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

  							if ( material.isGLTFSpecularGlossinessMaterial ) { cacheKey += 'specular-glossiness:'; }
  							if ( useSkinning ) { cacheKey += 'skinning:'; }
  							if ( useVertexTangents ) { cacheKey += 'vertex-tangents:'; }
  							if ( useVertexColors ) { cacheKey += 'vertex-colors:'; }
  							if ( useFlatShading ) { cacheKey += 'flat-shading:'; }
  							if ( useMorphTargets ) { cacheKey += 'morph-targets:'; }
  							if ( useMorphNormals ) { cacheKey += 'morph-normals:'; }

  							var cachedMaterial = parser.cache.get( cacheKey );

  							if ( ! cachedMaterial ) {

  								cachedMaterial = material.isGLTFSpecularGlossinessMaterial
  									? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material )
  									: material.clone();

  								if ( useSkinning ) { cachedMaterial.skinning = true; }
  								if ( useVertexTangents ) { cachedMaterial.vertexTangents = true; }
  								if ( useVertexColors ) { cachedMaterial.vertexColors = VertexColors; }
  								if ( useFlatShading ) { cachedMaterial.flatShading = true; }
  								if ( useMorphTargets ) { cachedMaterial.morphTargets = true; }
  								if ( useMorphNormals ) { cachedMaterial.morphNormals = true; }

  								parser.cache.add( cacheKey, cachedMaterial );

  							}

  							material = cachedMaterial;

  						}

  						materials[ j ] = material;

  						// workarounds for mesh and geometry

  						if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

  							console.log( 'GLTFLoader: Duplicating UVs to support aoMap.' );
  							geometry.addAttribute( 'uv2', new BufferAttribute( geometry.attributes.uv.array, 2 ) );

  						}

  						if ( material.isGLTFSpecularGlossinessMaterial ) {

  							// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
  							mesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;

  						}

  					}

  					mesh.material = isMultiMaterial ? materials : materials[ 0 ];

  				}

  				if ( meshes.length === 1 ) {

  					return meshes[ 0 ];

  				}

  				var group = new Group();

  				for ( var i = 0, il = meshes.length; i < il; i ++ ) {

  					group.add( meshes[ i ] );

  				}

  				return group;

  			} );

  		} );

  	};
  	GLTFParser.prototype.loadCamera = function ( cameraIndex ) {

  		var camera;
  		var cameraDef = this.json.cameras[ cameraIndex ];
  		var params = cameraDef[ cameraDef.type ];

  		if ( ! params ) {

  			console.warn( 'GLTFLoader: Missing camera parameters.' );
  			return;

  		}

  		if ( cameraDef.type === 'perspective' ) {

  			camera = new PerspectiveCamera( _Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

  		} else if ( cameraDef.type === 'orthographic' ) {

  			camera = new OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );

  		}

  		if ( cameraDef.name !== undefined ) { camera.name = cameraDef.name; }

  		assignExtrasToUserData( camera, cameraDef );

  		return Promise.resolve( camera );

  	};
  	GLTFParser.prototype.loadSkin = function ( skinIndex ) {

  		var skinDef = this.json.skins[ skinIndex ];

  		var skinEntry = { joints: skinDef.joints };

  		if ( skinDef.inverseBindMatrices === undefined ) {

  			return Promise.resolve( skinEntry );

  		}

  		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

  			skinEntry.inverseBindMatrices = accessor;

  			return skinEntry;

  		} );

  	};
  	GLTFParser.prototype.loadAnimation = function ( animationIndex ) {
  		var this$1 = this;


  		var json = this.json;

  		var animationDef = json.animations[ animationIndex ];

  		var pendingNodes = [];
  		var pendingInputAccessors = [];
  		var pendingOutputAccessors = [];
  		var pendingSamplers = [];
  		var pendingTargets = [];

  		for ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {

  			var channel = animationDef.channels[ i ];
  			var sampler = animationDef.samplers[ channel.sampler ];
  			var target = channel.target;
  			var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
  			var input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
  			var output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

  			pendingNodes.push( this$1.getDependency( 'node', name ) );
  			pendingInputAccessors.push( this$1.getDependency( 'accessor', input ) );
  			pendingOutputAccessors.push( this$1.getDependency( 'accessor', output ) );
  			pendingSamplers.push( sampler );
  			pendingTargets.push( target );

  		}

  		return Promise.all( [

  			Promise.all( pendingNodes ),
  			Promise.all( pendingInputAccessors ),
  			Promise.all( pendingOutputAccessors ),
  			Promise.all( pendingSamplers ),
  			Promise.all( pendingTargets )

  		] ).then( function ( dependencies ) {

  			var nodes = dependencies[ 0 ];
  			var inputAccessors = dependencies[ 1 ];
  			var outputAccessors = dependencies[ 2 ];
  			var samplers = dependencies[ 3 ];
  			var targets = dependencies[ 4 ];

  			var tracks = [];

  			for ( var i = 0, il = nodes.length; i < il; i ++ ) {

  				var node = nodes[ i ];
  				var inputAccessor = inputAccessors[ i ];
  				var outputAccessor = outputAccessors[ i ];
  				var sampler = samplers[ i ];
  				var target = targets[ i ];

  				if ( node === undefined ) { continue; }

  				node.updateMatrix();
  				node.matrixAutoUpdate = true;

  				var TypedKeyframeTrack;

  				switch ( PATH_PROPERTIES[ target.path ] ) {

  					case PATH_PROPERTIES.weights:

  						TypedKeyframeTrack = NumberKeyframeTrack;
  						break;

  					case PATH_PROPERTIES.rotation:

  						TypedKeyframeTrack = QuaternionKeyframeTrack;
  						break;

  					case PATH_PROPERTIES.position:
  					case PATH_PROPERTIES.scale:
  					default:

  						TypedKeyframeTrack = VectorKeyframeTrack;
  						break;

  				}

  				var targetName = node.name ? node.name : node.uuid;

  				var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

  				var targetNames = [];

  				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

  					// node can be Group here but
  					// PATH_PROPERTIES.weights(morphTargetInfluences) should be
  					// the property of a mesh object under group.

  					node.traverse( function ( object ) {

  						if ( object.isMesh === true && object.morphTargetInfluences ) {

  							targetNames.push( object.name ? object.name : object.uuid );

  						}

  					} );

  				} else {

  					targetNames.push( targetName );

  				}

  				// KeyframeTrack.optimize() will modify given 'times' and 'values'
  				// buffers before creating a truncated copy to keep. Because buffers may
  				// be reused by other tracks, make copies here.
  				for ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {

  					var track = new TypedKeyframeTrack(
  						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
  						AnimationUtils.arraySlice( inputAccessor.array, 0 ),
  						AnimationUtils.arraySlice( outputAccessor.array, 0 ),
  						interpolation
  					);

  					// Here is the trick to enable custom interpolation.
  					// Overrides .createInterpolant in a factory method which creates custom interpolation.
  					if ( sampler.interpolation === 'CUBICSPLINE' ) {

  						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

  							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
  							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
  							// must be divided by three to get the interpolant's sampleSize argument.

  							return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

  						};

  						// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.
  						// track.getInterpolation() doesn't return valid value for custom interpolant.
  						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

  					}

  					tracks.push( track );

  				}

  			}

  			var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;

  			return new AnimationClip( name, undefined, tracks );

  		} );

  	};
  	GLTFParser.prototype.loadNode = function ( nodeIndex ) {

  		var json = this.json;
  		var extensions = this.extensions;
  		var parser = this;

  		var meshReferences = json.meshReferences;
  		var meshUses = json.meshUses;

  		var nodeDef = json.nodes[ nodeIndex ];

  		return ( function () {

  			// .isBone isn't in glTF spec. See .markDefs
  			if ( nodeDef.isBone === true ) {

  				return Promise.resolve( new Bone() );

  			} else if ( nodeDef.mesh !== undefined ) {

  				return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

  					var node;

  					if ( meshReferences[ nodeDef.mesh ] > 1 ) {

  						var instanceNum = meshUses[ nodeDef.mesh ] ++;

  						node = mesh.clone();
  						node.name += '_instance_' + instanceNum;

  						// onBeforeRender copy for Specular-Glossiness
  						node.onBeforeRender = mesh.onBeforeRender;

  						for ( var i = 0, il = node.children.length; i < il; i ++ ) {

  							node.children[ i ].name += '_instance_' + instanceNum;
  							node.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender;

  						}

  					} else {

  						node = mesh;

  					}

  					// if weights are provided on the node, override weights on the mesh.
  					if ( nodeDef.weights !== undefined ) {

  						node.traverse( function ( o ) {

  							if ( ! o.isMesh ) { return; }

  							for ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

  								o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

  							}

  						} );

  					}

  					return node;

  				} );

  			} else if ( nodeDef.camera !== undefined ) {

  				return parser.getDependency( 'camera', nodeDef.camera );

  			} else if ( nodeDef.extensions
  				&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]
  				&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {

  				return parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light );

  			} else {

  				return Promise.resolve( new Object3D() );

  			}

  		}() ).then( function ( node ) {

  			if ( nodeDef.name !== undefined ) {

  				node.name = PropertyBinding.sanitizeNodeName( nodeDef.name );

  			}

  			assignExtrasToUserData( node, nodeDef );

  			if ( nodeDef.extensions ) { addUnknownExtensionsToUserData( extensions, node, nodeDef ); }

  			if ( nodeDef.matrix !== undefined ) {

  				var matrix = new Matrix4();
  				matrix.fromArray( nodeDef.matrix );
  				node.applyMatrix( matrix );

  			} else {

  				if ( nodeDef.translation !== undefined ) {

  					node.position.fromArray( nodeDef.translation );

  				}

  				if ( nodeDef.rotation !== undefined ) {

  					node.quaternion.fromArray( nodeDef.rotation );

  				}

  				if ( nodeDef.scale !== undefined ) {

  					node.scale.fromArray( nodeDef.scale );

  				}

  			}

  			return node;

  		} );

  	};
  	GLTFParser.prototype.loadScene = function () {

  		// scene node hierachy builder

  		function buildNodeHierachy( nodeId, parentObject, json, parser ) {

  			var nodeDef = json.nodes[ nodeId ];

  			return parser.getDependency( 'node', nodeId ).then( function ( node ) {

  				if ( nodeDef.skin === undefined ) { return node; }

  				// build skeleton here as well

  				var skinEntry;

  				return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

  					skinEntry = skin;

  					var pendingJoints = [];

  					for ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

  						pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

  					}

  					return Promise.all( pendingJoints );

  				} ).then( function ( jointNodes ) {

  					var meshes = node.isGroup === true ? node.children : [ node ];

  					for ( var i = 0, il = meshes.length; i < il; i ++ ) {

  						var mesh = meshes[ i ];

  						var bones = [];
  						var boneInverses = [];

  						for ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {

  							var jointNode = jointNodes[ j ];

  							if ( jointNode ) {

  								bones.push( jointNode );

  								var mat = new Matrix4();

  								if ( skinEntry.inverseBindMatrices !== undefined ) {

  									mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

  								}

  								boneInverses.push( mat );

  							} else {

  								console.warn( 'GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

  							}

  						}

  						mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

  					}

  					return node;

  				} );

  			} ).then( function ( node ) {

  				// build node hierachy

  				parentObject.add( node );

  				var pending = [];

  				if ( nodeDef.children ) {

  					var children = nodeDef.children;

  					for ( var i = 0, il = children.length; i < il; i ++ ) {

  						var child = children[ i ];
  						pending.push( buildNodeHierachy( child, node, json, parser ) );

  					}

  				}

  				return Promise.all( pending );

  			} );

  		}

  		return function loadScene( sceneIndex ) {

  			var json = this.json;
  			var extensions = this.extensions;
  			var sceneDef = this.json.scenes[ sceneIndex ];
  			var parser = this;

  			var scene = new Scene();
  			if ( sceneDef.name !== undefined ) { scene.name = sceneDef.name; }

  			assignExtrasToUserData( scene, sceneDef );

  			if ( sceneDef.extensions ) { addUnknownExtensionsToUserData( extensions, scene, sceneDef ); }

  			var nodeIds = sceneDef.nodes || [];

  			var pending = [];

  			for ( var i = 0, il = nodeIds.length; i < il; i ++ ) {

  				pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

  			}

  			return Promise.all( pending ).then( function () {

  				return scene;

  			} );

  		};

  	}();

  	return GLTFLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // https://github.com/mrdoob/three.js/issues/5552
  // http://en.wikipedia.org/wiki/RGBE_image_format

  var RGBELoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.type = UnsignedByteType;

  };

  // extend DataTextureLoader
  RGBELoader.prototype = Object.create( DataTextureLoader.prototype );

  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  RGBELoader.prototype._parser = function ( buffer ) {

  	var 
  		
  		RGBE_RETURN_FAILURE = - 1,
  		rgbe_read_error = 1,
  		rgbe_write_error = 2,
  		rgbe_format_error = 3,
  		rgbe_memory_error = 4,
  		rgbe_error = function ( rgbe_error_code, msg ) {

  			switch ( rgbe_error_code ) {

  				case rgbe_read_error: console.error( "RGBELoader Read Error: " + ( msg || '' ) );
  					break;
  				case rgbe_write_error: console.error( "RGBELoader Write Error: " + ( msg || '' ) );
  					break;
  				case rgbe_format_error: console.error( "RGBELoader Bad File Format: " + ( msg || '' ) );
  					break;
  				default:
  				case rgbe_memory_error: console.error( "RGBELoader: Error: " + ( msg || '' ) );

  			}
  			return RGBE_RETURN_FAILURE;

  		},
  		RGBE_VALID_PROGRAMTYPE = 1,
  		RGBE_VALID_FORMAT = 2,
  		RGBE_VALID_DIMENSIONS = 4,

  		NEWLINE = "\n",

  		fgets = function ( buffer, lineLimit, consume ) {

  			lineLimit = ! lineLimit ? 1024 : lineLimit;
  			var p = buffer.pos,
  				i = - 1, len = 0, s = '', chunkSize = 128,
  				chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) )
  			;
  			while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

  				s += chunk; len += chunk.length;
  				p += chunkSize;
  				chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

  			}

  			if ( - 1 < i ) {
  				if ( false !== consume ) { buffer.pos += len + i + 1; }
  				return s + chunk.slice( 0, i );

  			}
  			return false;

  		},
  		RGBE_ReadHeader = function ( buffer ) {

  			var line, match,

  				// regexes to parse header info fields
  				magic_token_re = /^#\?(\S+)$/,
  				gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
  				exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
  				format_re = /^\s*FORMAT=(\S+)\s*$/,
  				dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

  				// RGBE format header struct
  				header = {

  					valid: 0, 

  					string: '', 

  					comments: '', 

  					programtype: 'RGBE', 

  					format: '', 

  					gamma: 1.0, 

  					exposure: 1.0, 

  					width: 0, height: 0 

  				};

  			if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

  				return rgbe_error( rgbe_read_error, "no header found" );

  			}
  			
  			if ( ! ( match = line.match( magic_token_re ) ) ) {

  				return rgbe_error( rgbe_format_error, "bad initial token" );

  			}
  			header.valid |= RGBE_VALID_PROGRAMTYPE;
  			header.programtype = match[ 1 ];
  			header.string += line + "\n";

  			while ( true ) {

  				line = fgets( buffer );
  				if ( false === line ) { break; }
  				header.string += line + "\n";

  				if ( '#' === line.charAt( 0 ) ) {

  					header.comments += line + "\n";
  					continue; // comment line

  				}

  				if ( match = line.match( gamma_re ) ) {

  					header.gamma = parseFloat( match[ 1 ], 10 );

  				}
  				if ( match = line.match( exposure_re ) ) {

  					header.exposure = parseFloat( match[ 1 ], 10 );

  				}
  				if ( match = line.match( format_re ) ) {

  					header.valid |= RGBE_VALID_FORMAT;
  					header.format = match[ 1 ];//'32-bit_rle_rgbe';

  				}
  				if ( match = line.match( dimensions_re ) ) {

  					header.valid |= RGBE_VALID_DIMENSIONS;
  					header.height = parseInt( match[ 1 ], 10 );
  					header.width = parseInt( match[ 2 ], 10 );

  				}

  				if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) { break; }

  			}

  			if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

  				return rgbe_error( rgbe_format_error, "missing format specifier" );

  			}
  			if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

  				return rgbe_error( rgbe_format_error, "missing image size specifier" );

  			}

  			return header;

  		},

  		RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

  			var data_rgba, offset, pos, count, byteValue,
  				scanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun,
  				scanline_width = w, num_scanlines = h, rgbeStart
  			;

  			if (
  				// run length encoding is not allowed so read flat
  				( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
  				// this file is not run length encoded
  				( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
  			) {

  				// return the flat buffer
  				return new Uint8Array( buffer );

  			}

  			if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

  				return rgbe_error( rgbe_format_error, "wrong scanline width" );

  			}

  			data_rgba = new Uint8Array( 4 * w * h );

  			if ( ! data_rgba || ! data_rgba.length ) {

  				return rgbe_error( rgbe_memory_error, "unable to allocate buffer space" );

  			}

  			offset = 0; pos = 0; ptr_end = 4 * scanline_width;
  			rgbeStart = new Uint8Array( 4 );
  			scanline_buffer = new Uint8Array( ptr_end );

  			// read in each successive scanline
  			while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

  				if ( pos + 4 > buffer.byteLength ) {

  					return rgbe_error( rgbe_read_error );

  				}

  				rgbeStart[ 0 ] = buffer[ pos ++ ];
  				rgbeStart[ 1 ] = buffer[ pos ++ ];
  				rgbeStart[ 2 ] = buffer[ pos ++ ];
  				rgbeStart[ 3 ] = buffer[ pos ++ ];

  				if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

  					return rgbe_error( rgbe_format_error, "bad rgbe scanline format" );

  				}

  				// read each of the four channels for the scanline into the buffer
  				// first red, then green, then blue, then exponent
  				ptr = 0;
  				while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

  					count = buffer[ pos ++ ];
  					isEncodedRun = count > 128;
  					if ( isEncodedRun ) { count -= 128; }

  					if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

  						return rgbe_error( rgbe_format_error, "bad scanline data" );

  					}

  					if ( isEncodedRun ) {

  						// a (encoded) run of the same value
  						byteValue = buffer[ pos ++ ];
  						for ( i = 0; i < count; i ++ ) {

  							scanline_buffer[ ptr ++ ] = byteValue;

  						}
  						//ptr += count;

  					} else {

  						// a literal-run
  						scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
  						ptr += count; pos += count;

  					}

  				}
  				// now convert data from buffer into rgba
  				// first red, then green, then blue, then exponent (alpha)
  				l = scanline_width; //scanline_buffer.byteLength;
  				for ( i = 0; i < l; i ++ ) {

  					off = 0;
  					data_rgba[ offset ] = scanline_buffer[ i + off ];
  					off += scanline_width; //1;
  					data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
  					off += scanline_width; //1;
  					data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
  					off += scanline_width; //1;
  					data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
  					offset += 4;

  				}

  				num_scanlines --;

  			}

  			return data_rgba;

  		}
  	;

  	var byteArray = new Uint8Array( buffer );
  	byteArray.pos = 0;
  	var rgbe_header_info = RGBE_ReadHeader( byteArray );

  	if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

  		var w = rgbe_header_info.width,
  			h = rgbe_header_info.height,
  			image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h )
  		;
  		if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

  			if ( this.type === UnsignedByteType ) {

  				var data = image_rgba_data;
  				var format = RGBEFormat; // handled as RGBAFormat in shaders
  				var type = UnsignedByteType;

  			} else if ( this.type === FloatType ) {

  				var RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

  					var e = sourceArray[ sourceOffset + 3 ];
  					var scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

  					destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
  					destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
  					destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;

  				};

  				var numElements = ( image_rgba_data.length / 4 ) * 3;
  				var floatArray = new Float32Array( numElements );

  				for ( var j = 0; j < numElements; j ++ ) {

  					RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 3 );

  				}

  				var data = floatArray;
  				var format = RGBFormat;
  				var type = FloatType;
  			} else {

  				console.error( 'RGBELoader: unsupported type: ', this.type );

  			}

  			return {
  				width: w, height: h,
  				data: data,
  				header: rgbe_header_info.string,
  				gamma: rgbe_header_info.gamma,
  				exposure: rgbe_header_info.exposure,
  				format: format,
  				type: type
  			};

  		}

  	}

  	return null;

  };
  var HDRLoader = RGBELoader;
  RGBELoader.prototype.setType = function ( value ) {

  	this.type = value;
  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	images = images !== undefined ? images : [];
  	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  	format = format !== undefined ? format : RGBFormat;

  	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.flipY = false;

  }

  CubeTexture.prototype = Object.create( Texture.prototype );
  CubeTexture.prototype.constructor = CubeTexture;

  CubeTexture.prototype.isCubeTexture = true;

  Object.defineProperty( CubeTexture.prototype, 'images', {

  	get: function () {

  		return this.image;

  	},

  	set: function ( value ) {

  		this.image = value;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HDRCubeTextureLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	// override in sub classes
  	this.hdrLoader = new RGBELoader();

  };

  HDRCubeTextureLoader.prototype.load = function ( type, urls, onLoad, onProgress, onError ) {

  	var RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

  		var e = sourceArray[ sourceOffset + 3 ];
  		var scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

  		destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
  		destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
  		destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;

  	};

  	var RGBEByteToRGBHalf = ( function () {

  		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

  		var floatView = new Float32Array( 1 );
  		var int32View = new Int32Array( floatView.buffer );
  		function toHalf( val ) {

  			floatView[ 0 ] = val;
  			var x = int32View[ 0 ];

  			var bits = ( x >> 16 ) & 0x8000; 
  			var m = ( x >> 12 ) & 0x07ff; 
  			var e = ( x >> 23 ) & 0xff; 
  			if ( e < 103 ) { return bits; }
  			if ( e > 142 ) {

  				bits |= 0x7c00;
  				
  				bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
  				return bits;

  			}
  			if ( e < 113 ) {

  				m |= 0x0800;
  				
  				bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
  				return bits;

  			}

  			bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
  			
  			bits += m & 1;
  			return bits;

  		}

  		return function ( sourceArray, sourceOffset, destArray, destOffset ) {

  			var e = sourceArray[ sourceOffset + 3 ];
  			var scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

  			destArray[ destOffset + 0 ] = toHalf( sourceArray[ sourceOffset + 0 ] * scale );
  			destArray[ destOffset + 1 ] = toHalf( sourceArray[ sourceOffset + 1 ] * scale );
  			destArray[ destOffset + 2 ] = toHalf( sourceArray[ sourceOffset + 2 ] * scale );

  		};

  	} )();

  	//

  	var texture = new CubeTexture();

  	texture.type = type;
  	texture.encoding = ( type === UnsignedByteType ) ? RGBEEncoding : LinearEncoding;
  	texture.format = ( type === UnsignedByteType ) ? RGBAFormat : RGBFormat;
  	texture.minFilter = ( texture.encoding === RGBEEncoding ) ? NearestFilter : LinearFilter;
  	texture.magFilter = ( texture.encoding === RGBEEncoding ) ? NearestFilter : LinearFilter;
  	texture.generateMipmaps = ( texture.encoding !== RGBEEncoding );
  	texture.anisotropy = 0;

  	var scope = this;

  	var loaded = 0;

  	function loadHDRData( i, onLoad, onProgress, onError ) {

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( urls[ i ], function ( buffer ) {

  			loaded ++;

  			var texData = scope.hdrLoader._parser( buffer );

  			if ( ! texData ) { return; }

  			if ( type === FloatType ) {

  				var numElements = ( texData.data.length / 4 ) * 3;
  				var floatdata = new Float32Array( numElements );

  				for ( var j = 0; j < numElements; j ++ ) {

  					RGBEByteToRGBFloat( texData.data, j * 4, floatdata, j * 3 );

  				}

  				texData.data = floatdata;

  			} else if ( type === HalfFloatType ) {

  				var numElements = ( texData.data.length / 4 ) * 3;
  				var halfdata = new Uint16Array( numElements );

  				for ( var j = 0; j < numElements; j ++ ) {

  					RGBEByteToRGBHalf( texData.data, j * 4, halfdata, j * 3 );

  				}

  				texData.data = halfdata;

  			}

  			if ( texData.image !== undefined ) {

  				texture[ i ].images = texData.image;

  			} else if ( texData.data !== undefined ) {

  				var dataTexture = new DataTexture( texData.data, texData.width, texData.height );
  				dataTexture.format = texture.format;
  				dataTexture.type = texture.type;
  				dataTexture.encoding = texture.encoding;
  				dataTexture.minFilter = texture.minFilter;
  				dataTexture.magFilter = texture.magFilter;
  				dataTexture.generateMipmaps = texture.generateMipmaps;

  				texture.images[ i ] = dataTexture;

  			}

  			if ( loaded === 6 ) {

  				texture.needsUpdate = true;
  				if ( onLoad ) { onLoad( texture ); }

  			}

  		}, onProgress, onError );

  	}

  	for ( var i = 0; i < urls.length; i ++ ) {

  		loadHDRData( i, onLoad, onProgress, onError );

  	}

  	return texture;

  };

  HDRCubeTextureLoader.prototype.setPath = function ( value ) {

  	this.path = value;
  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var KMZLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  KMZLoader.prototype = {

  	constructor: KMZLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data ) {

  		function findFile( url ) {

  			for ( var path in zip.files ) {

  				if ( path.substr( - url.length ) === url ) {

  					return zip.files[ path ];

  				}

  			}

  		}

  		var manager = new LoadingManager();
  		manager.setURLModifier( function ( url ) {

  			var image = findFile( url );

  			if ( image ) {

  				console.log( 'Loading', url );

  				var blob = new Blob( [ image.asArrayBuffer() ], { type: 'application/octet-stream' } );
  				return URL.createObjectURL( blob );

  			}

  			return url;

  		} );

  		//

  		var zip = new JSZip( data ); // eslint-disable-line no-undef

  		if ( zip.files[ 'doc.kml' ] ) {

  			var xml = new DOMParser().parseFromString( zip.files[ 'doc.kml' ].asText(), 'application/xml' );

  			var model = xml.querySelector( 'Placemark Model Link href' );

  			if ( model ) {

  				var loader = new ColladaLoader( manager );
  				return loader.parse( zip.files[ model.textContent ].asText() );

  			}

  		} else {

  			console.warn( 'KMZLoader: Missing doc.kml file.' );

  			for ( var path in zip.files ) {

  				var extension = path.split( '.' ).pop().toLowerCase();

  				if ( extension === 'dae' ) {

  					var loader = new ColladaLoader( manager );
  					return loader.parse( zip.files[ path ].asText() );

  				}

  			}

  		}

  		console.error( 'KMZLoader: Couldn\'t find .dae file.' );
  		return { scene: new Group() };

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var KTXLoader = function ( manager ) {

  	CompressedTextureLoader.call( this, manager );

  	this._parser = KTXLoader.parse;

  };

  KTXLoader.prototype = Object.create( CompressedTextureLoader.prototype );
  KTXLoader.prototype.constructor = KTXLoader;

  KTXLoader.parse = function ( buffer, loadMipmaps ) {

  	var ktx = new KhronosTextureContainer( buffer, 1 );

  	return {
  		mipmaps: ktx.mipmaps( loadMipmaps ),
  		width: ktx.pixelWidth,
  		height: ktx.pixelHeight,
  		format: ktx.glInternalFormat,
  		isCubemap: ktx.numberOfFaces === 6,
  		mipmapCount: ktx.numberOfMipmapLevels
  	};

  };

  var KhronosTextureContainer = ( function () {
  	function KhronosTextureContainer( arrayBuffer, facesExpected, threeDExpected, textureArrayExpected ) {

  		this.arrayBuffer = arrayBuffer;

  		// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
  		// '', 'K', 'T', 'X', ' ', '1', '1', '', '\r', '\n', '\x1A', '\n'
  		// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
  		var identifier = new Uint8Array( this.arrayBuffer, 0, 12 );
  		if ( identifier[ 0 ] !== 0xAB ||
  			identifier[ 1 ] !== 0x4B ||
  			identifier[ 2 ] !== 0x54 ||
  			identifier[ 3 ] !== 0x58 ||
  			identifier[ 4 ] !== 0x20 ||
  			identifier[ 5 ] !== 0x31 ||
  			identifier[ 6 ] !== 0x31 ||
  			identifier[ 7 ] !== 0xBB ||
  			identifier[ 8 ] !== 0x0D ||
  			identifier[ 9 ] !== 0x0A ||
  			identifier[ 10 ] !== 0x1A ||
  			identifier[ 11 ] !== 0x0A ) {

  			console.error( 'texture missing KTX identifier' );
  			return;

  		}

  		// load the reset of the header in native 32 bit uint
  		var dataSize = Uint32Array.BYTES_PER_ELEMENT;
  		var headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize );
  		var endianness = headerDataView.getUint32( 0, true );
  		var littleEndian = endianness === 0x04030201;

  		this.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures
  		this.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures
  		this.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures
  		this.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
  		this.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
  		this.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
  		this.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
  		this.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
  		this.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays
  		this.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6
  		this.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures
  		this.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data

  		// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
  		if ( this.glType !== 0 ) {

  			console.warn( 'only compressed formats currently supported' );
  			return;

  		} else {

  			// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
  			this.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );

  		}
  		if ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {

  			console.warn( 'only 2D textures currently supported' );
  			return;

  		}
  		if ( this.numberOfArrayElements !== 0 ) {

  			console.warn( 'texture arrays not currently supported' );
  			return;

  		}
  		if ( this.numberOfFaces !== facesExpected ) {

  			console.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );
  			return;

  		}
  		// we now have a completely validated file, so could use existence of loadType as success
  		// would need to make this more elaborate & adjust checks above to support more than one load type
  		this.loadType = KhronosTextureContainer.COMPRESSED_2D;

  	}

  	// return mipmaps for js
  	KhronosTextureContainer.prototype.mipmaps = function ( loadMipmaps ) {
  		var this$1 = this;


  		var mipmaps = [];

  		// initialize width & height for level 1
  		var dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
  		var width = this.pixelWidth;
  		var height = this.pixelHeight;
  		var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;

  		for ( var level = 0; level < mipmapCount; level ++ ) {

  			var imageSize = new Int32Array( this$1.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps
  			for ( var face = 0; face < this.numberOfFaces; face ++ ) {

  				var byteArray = new Uint8Array( this$1.arrayBuffer, dataOffset + 4, imageSize );

  				mipmaps.push( { "data": byteArray, "width": width, "height": height } );

  				dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field
  				dataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image

  			}
  			width = Math.max( 1.0, width * 0.5 );
  			height = Math.max( 1.0, height * 0.5 );

  		}

  		return mipmaps;

  	};

  	KhronosTextureContainer.HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs)
  	// load types
  	KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
  	KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
  	KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()
  	KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()

  	return KhronosTextureContainer;

  }() );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LDrawLoader = ( function () {

  	function LineParser( line, lineNumber ) {

  		this.line = line;
  		this.lineLength = line.length;
  		this.currentCharIndex = 0;
  		this.currentChar = ' ';
  		this.lineNumber = lineNumber;

  	}

  	LineParser.prototype = {

  		constructor: LineParser,

  		seekNonSpace: function () {
  			var this$1 = this;


  			while ( this.currentCharIndex < this.lineLength ) {

  				this$1.currentChar = this$1.line.charAt( this$1.currentCharIndex );

  				if ( this$1.currentChar !== ' ' && this$1.currentChar !== '\t' ) {

  					return;

  				}

  				this$1.currentCharIndex ++;

  			}

  		},

  		getToken: function () {
  			var this$1 = this;


  			var pos0 = this.currentCharIndex ++;

  			// Seek space
  			while ( this.currentCharIndex < this.lineLength ) {

  				this$1.currentChar = this$1.line.charAt( this$1.currentCharIndex );

  				if ( this$1.currentChar === ' ' || this$1.currentChar === '\t' ) {

  					break;

  				}

  				this$1.currentCharIndex ++;

  			}

  			var pos1 = this.currentCharIndex;

  			this.seekNonSpace();

  			return this.line.substring( pos0, pos1 );

  		},

  		getRemainingString: function () {

  			return this.line.substring( this.currentCharIndex, this.lineLength );

  		},

  		isAtTheEnd: function () {

  			return this.currentCharIndex >= this.lineLength;

  		},

  		setToEnd: function () {

  			this.currentCharIndex = this.lineLength;

  		},

  		getLineNumberString: function () {

  			return this.lineNumber >= 0 ? " at line " + this.lineNumber : "";

  		}
  	};

  	function sortByMaterial( a, b ) {

  		if ( a.colourCode === b.colourCode ) {

  			return 0;

  		}

  		if ( a.colourCode < b.colourCode ) {

  			return - 1;

  		}

  		return 1;

  	}

  	function createObject( elements, elementSize ) {

  		// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )
  		// With per face / segment material, implemented with mesh groups and materials array

  		// Sort the triangles or line segments by colour code to make later the mesh groups
  		elements.sort( sortByMaterial );

  		var vertices = [];
  		var materials = [];

  		var bufferGeometry = new BufferGeometry();
  		bufferGeometry.clearGroups();
  		var prevMaterial = null;
  		var index0 = 0;
  		var numGroupVerts = 0;

  		for ( var iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {

  			var elem = elements[ iElem ];
  			var v0 = elem.v0;
  			var v1 = elem.v1;
  			// Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one
  			vertices.push( v0.x, v0.y, v0.z, v1.x, v1.y, v1.z );
  			if ( elementSize === 3 ) {

  				vertices.push( elem.v2.x, elem.v2.y, elem.v2.z );

  			}

  			if ( prevMaterial !== elem.material ) {

  				if ( prevMaterial !== null ) {

  					bufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );

  				}

  				materials.push( elem.material );

  				prevMaterial = elem.material;
  				index0 = iElem * elementSize;
  				numGroupVerts = elementSize;

  			} else {

  				numGroupVerts += elementSize;

  			}

  		}

  		if ( numGroupVerts > 0 ) {

  			bufferGeometry.addGroup( index0, Infinity, materials.length - 1 );

  		}

  		bufferGeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  		var object3d = null;

  		if ( elementSize === 2 ) {

  			object3d = new LineSegments( bufferGeometry, materials );

  		} else if ( elementSize === 3 ) {

  			bufferGeometry.computeVertexNormals();

  			object3d = new Mesh( bufferGeometry, materials );

  		}

  		return object3d;

  	}

  	//

  	function LDrawLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		// This is a stack of 'parse scopes' with one level per subobject loaded file.
  		// Each level contains a material lib and also other runtime variables passed between parent and child subobjects
  		// When searching for a material code, the stack is read from top of the stack to bottom
  		// Each material library is an object map keyed by colour codes.
  		this.parseScopesStack = null;

  		this.path = '';

  		// Array of Material
  		this.materials = [];

  		// Not using Cache here because it returns the previous HTML error response instead of calling onError()
  		// This also allows to handle the embedded text files ("0 FILE" lines)
  		this.subobjectCache = {};

  		// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.
  		this.fileMap = null;

  		// Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)
  		this.setMaterials( [
  			this.parseColourMetaDirective( new LineParser( "Main_Colour CODE 16 VALUE #FF8080 EDGE #333333" ) ),
  			this.parseColourMetaDirective( new LineParser( "Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333" ) )
  		] );

  		// If this flag is set to true, each subobject will be a Object.
  		// If not (the default), only one object which contains all the merged primitives will be created.
  		this.separateObjects = false;

  		// Current merged object and primitives
  		this.currentGroupObject = null;
  		this.currentTriangles = null;
  		this.currentLineSegments = null;

  	}

  	// Special surface finish tag types.
  	// Note: "MATERIAL" tag (e.g. GLITTER, SPECKLE) is not implemented
  	LDrawLoader.FINISH_TYPE_DEFAULT = 0;
  	LDrawLoader.FINISH_TYPE_CHROME = 1;
  	LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;
  	LDrawLoader.FINISH_TYPE_RUBBER = 3;
  	LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;
  	LDrawLoader.FINISH_TYPE_METAL = 5;

  	// State machine to search a subobject path.
  	// The LDraw standard establishes these various possible subfolders.
  	LDrawLoader.FILE_LOCATION_AS_IS = 0;
  	LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;
  	LDrawLoader.FILE_LOCATION_TRY_P = 2;
  	LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;
  	LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;
  	LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;
  	LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;

  	LDrawLoader.prototype = {

  		constructor: LDrawLoader,

  		load: function ( url, onLoad, onProgress, onError ) {

  			if ( ! this.fileMap ) {

  				this.fileMap = {};

  			}

  			var scope = this;

  			var fileLoader = new FileLoader( this.manager );
  			fileLoader.setPath( this.path );
  			fileLoader.load( url, function ( text ) {

  				processObject( text, onLoad );

  			}, onProgress, onError );

  			function processObject( text, onProcessed ) {

  				var parseScope = scope.newParseScopeLevel();
  				parseScope.url = url;

  				var parentParseScope = scope.getParentParseScope();

  				// Add to cache
  				var currentFileName = parentParseScope.currentFileName;
  				if ( scope.subobjectCache[ currentFileName ] === undefined ) {

  					scope.subobjectCache[ currentFileName ] = text;
  				}

  				// Parse the object (returns a Group)
  				var objGroup = scope.parse( text );

  				// Load subobjects
  				parseScope.subobjects = objGroup.userData.subobjects;
  				parseScope.numSubobjects = parseScope.subobjects.length;
  				parseScope.subobjectIndex = 0;

  				if ( parseScope.numSubobjects > 0 ) {

  					// Load the first subobject
  					var subobjectGroup = loadSubobject( parseScope.subobjects[ 0 ], true );

  					// Optimization for loading pack: If subobjects are obtained from cache, keep loading them iteratively rather than recursively
  					if ( subobjectGroup ) {

  						while ( subobjectGroup && parseScope.subobjectIndex < parseScope.numSubobjects - 1 ) {

  							subobjectGroup = loadSubobject( parseScope.subobjects[ ++ parseScope.subobjectIndex ], true );

  						}

  						if ( subobjectGroup ) {

  							finalizeObject();

  						}

  					}

  				} else {

  					// No subobjects, finish object
  					finalizeObject();

  				}

  				return objGroup;

  				function finalizeObject() {

  					if ( ! scope.separateObjects && ! parentParseScope.isFromParse ) {

  						// We are finalizing the root object and merging primitives is activated, so create the entire Mesh and LineSegments objects now
  						if ( scope.currentLineSegments.length > 0 ) {

  							objGroup.add( createObject( scope.currentLineSegments, 2 ) );

  						}

  						if ( scope.currentTriangles.length > 0 ) {

  							objGroup.add( createObject( scope.currentTriangles, 3 ) );

  						}

  					}

  					scope.removeScopeLevel();

  					if ( onProcessed ) {

  						onProcessed( objGroup );

  					}

  				}

  				function loadSubobject( subobject, sync ) {

  					parseScope.mainColourCode = subobject.material.userData.code;
  					parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;
  					parseScope.currentFileName = subobject.originalFileName;

  					if ( ! scope.separateObjects ) {

  						// Set current matrix
  						parseScope.currentMatrix.multiplyMatrices( parentParseScope.currentMatrix, subobject.matrix );

  					}

  					// If subobject was cached previously, use the cached one
  					var cached = scope.subobjectCache[ subobject.originalFileName ];
  					if ( cached ) {

  						var subobjectGroup = processObject( cached, sync ? undefined : onSubobjectLoaded );
  						if ( sync ) {

  							addSubobject( subobject, subobjectGroup );
  							return subobjectGroup;

  						}

  						return;

  					}

  					// Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)
  					// Update also subobject.locationState for the next try if this load fails.
  					var subobjectURL = subobject.fileName;
  					var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;

  					switch ( subobject.locationState ) {

  						case LDrawLoader.FILE_LOCATION_AS_IS:
  							newLocationState = subobject.locationState + 1;
  							break;

  						case LDrawLoader.FILE_LOCATION_TRY_PARTS:
  							subobjectURL = 'parts/' + subobjectURL;
  							newLocationState = subobject.locationState + 1;
  							break;

  						case LDrawLoader.FILE_LOCATION_TRY_P:
  							subobjectURL = 'p/' + subobjectURL;
  							newLocationState = subobject.locationState + 1;
  							break;

  						case LDrawLoader.FILE_LOCATION_TRY_MODELS:
  							subobjectURL = 'models/' + subobjectURL;
  							newLocationState = subobject.locationState + 1;
  							break;

  						case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:
  							subobjectURL = url.substring( 0, url.lastIndexOf( "/" ) + 1 ) + subobjectURL;
  							newLocationState = subobject.locationState + 1;
  							break;

  						case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:

  							if ( subobject.triedLowerCase ) {

  								// Try absolute path
  								newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;

  							} else {

  								// Next attempt is lower case
  								subobject.fileName = subobject.fileName.toLowerCase();
  								subobjectURL = subobject.fileName;
  								subobject.triedLowerCase = true;
  								newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;

  							}
  							break;

  						case LDrawLoader.FILE_LOCATION_NOT_FOUND:

  							// All location possibilities have been tried, give up loading this object
  							console.warn( 'LDrawLoader: Subobject "' + subobject.originalFileName + '" could not be found.' );

  							// Try to read the next subobject
  							parseScope.subobjectIndex ++;

  							if ( parseScope.subobjectIndex >= parseScope.numSubobjects ) {

  								// All subojects have been loaded. Finish parent object
  								scope.removeScopeLevel();
  								onProcessed( objGroup );

  							} else {

  								// Load next subobject
  								loadSubobject( parseScope.subobjects[ parseScope.subobjectIndex ] );

  							}

  							return;

  					}

  					subobject.locationState = newLocationState;
  					subobject.url = subobjectURL;

  					// Load the subobject
  					scope.load( subobjectURL, onSubobjectLoaded, undefined, onSubobjectError );

  				}

  				function onSubobjectLoaded( subobjectGroup ) {

  					var subobject = parseScope.subobjects[ parseScope.subobjectIndex ];

  					if ( subobjectGroup === null ) {

  						// Try to reload
  						loadSubobject( subobject );
  						return;

  					}

  					// Add the subobject just loaded
  					addSubobject( subobject, subobjectGroup );

  					// Proceed to load the next subobject, or finish the parent object

  					parseScope.subobjectIndex ++;

  					if ( parseScope.subobjectIndex < parseScope.numSubobjects ) {

  						loadSubobject( parseScope.subobjects[ parseScope.subobjectIndex ] );

  					} else {

  						finalizeObject();

  					}

  				}

  				function addSubobject( subobject, subobjectGroup ) {

  					if ( scope.separateObjects ) {

  						subobjectGroup.name = subobject.fileName;
  						objGroup.add( subobjectGroup );
  						subobjectGroup.matrix.copy( subobject.matrix );
  						subobjectGroup.matrixAutoUpdate = false;

  					}

  					scope.fileMap[ subobject.originalFileName ] = subobject.url;

  				}

  				function onSubobjectError( err ) {

  					// Retry download from a different default possible location
  					loadSubobject( parseScope.subobjects[ parseScope.subobjectIndex ] );

  				}

  			}

  		},

  		setPath: function ( value ) {

  			this.path = value;

  			return this;

  		},

  		setMaterials: function ( materials ) {

  			// Clears parse scopes stack, adds new scope with material library

  			this.parseScopesStack = [];

  			this.newParseScopeLevel( materials );

  			this.getCurrentParseScope().isFromParse = false;

  			this.materials = materials;

  			this.currentGroupObject = null;

  			return this;

  		},

  		setFileMap: function ( fileMap ) {

  			this.fileMap = fileMap;

  			return this;

  		},

  		newParseScopeLevel: function ( materials ) {

  			// Adds a new scope level, assign materials to it and returns it

  			var matLib = {};

  			if ( materials ) {

  				for ( var i = 0, n = materials.length; i < n; i ++ ) {

  					var material = materials[ i ];
  					matLib[ material.userData.code ] = material;

  				}

  			}

  			var topParseScope = this.getCurrentParseScope();

  			var parentParseScope = this.getParentParseScope();

  			var newParseScope = {

  				lib: matLib,
  				url: null,

  				// Subobjects
  				subobjects: null,
  				numSubobjects: 0,
  				subobjectIndex: 0,

  				// Current subobject
  				currentFileName: null,
  				mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',
  				mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',
  				currentMatrix: new Matrix4(),

  				// If false, it is a root material scope previous to parse
  				isFromParse: true
  			};

  			this.parseScopesStack.push( newParseScope );

  			return newParseScope;

  		},

  		removeScopeLevel: function () {

  			this.parseScopesStack.pop();

  			return this;

  		},

  		addMaterial: function ( material ) {

  			// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array

  			var matLib = this.getCurrentParseScope().lib;

  			if ( ! matLib[ material.userData.code ] ) {

  				this.materials.push( material );

  			}

  			matLib[ material.userData.code ] = material;

  			return this;

  		},

  		getMaterial: function ( colourCode ) {
  			var this$1 = this;


  			// Given a colour code search its material in the parse scopes stack

  			if ( colourCode.startsWith( "0x2" ) ) {

  				// Special 'direct' material value (RGB colour)

  				var colour = colourCode.substring( 3 );

  				return this.parseColourMetaDirective( new LineParser( "Direct_Color_" + colour + " CODE -1 VALUE #" + colour + " EDGE #" + colour + "" ) );

  			}

  			for ( var i = this.parseScopesStack.length - 1; i >= 0; i -- ) {

  				var material = this$1.parseScopesStack[ i ].lib[ colourCode ];

  				if ( material ) {

  					return material;

  				}

  			}

  			// Material was not found
  			return null;

  		},

  		getParentParseScope: function () {

  			if ( this.parseScopesStack.length > 1 ) {

  				return this.parseScopesStack[ this.parseScopesStack.length - 2 ];

  			}

  			return null;

  		},

  		getCurrentParseScope: function () {

  			if ( this.parseScopesStack.length > 0 ) {

  				return this.parseScopesStack[ this.parseScopesStack.length - 1 ];

  			}

  			return null;

  		},

  		parseColourMetaDirective: function ( lineParser ) {
  			var this$1 = this;


  			// Parses a colour definition and returns a Material or null if error

  			var code = null;

  			// Triangle and line colours
  			var colour = 0xFF00FF;
  			var edgeColour = 0xFF00FF;

  			// Transparency
  			var alpha = 1;
  			var isTransparent = false;
  			// Self-illumination:
  			var luminance = 0;

  			var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;
  			var canHaveEnvMap = true;

  			var edgeMaterial = null;

  			var name = lineParser.getToken();
  			if ( ! name ) {

  				throw 'LDrawLoader: Material name was expected after "!COLOUR tag' + lineParser.getLineNumberString() + ".";

  			}

  			// Parse tag tokens and their parameters
  			var token = null;
  			while ( true ) {

  				token = lineParser.getToken();

  				if ( ! token ) {

  					break;

  				}

  				switch ( token.toUpperCase() ) {

  					case "CODE":

  						code = lineParser.getToken();
  						break;

  					case "VALUE":

  						colour = lineParser.getToken();
  						if ( colour.startsWith( '0x' ) ) {

  							colour = '#' + colour.substring( 2 );

  						} else if ( ! colour.startsWith( '#' ) ) {

  							throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + ".";

  						}
  						break;

  					case "EDGE":

  						edgeColour = lineParser.getToken();
  						if ( edgeColour.startsWith( '0x' ) ) {

  							edgeColour = '#' + edgeColour.substring( 2 );

  						} else if ( ! edgeColour.startsWith( '#' ) ) {

  							// Try to see if edge colour is a colour code
  							edgeMaterial = this$1.getMaterial( edgeColour );
  							if ( ! edgeMaterial ) {

  								throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + ".";

  							}

  							// Get the edge material for this triangle material
  							edgeMaterial = edgeMaterial.userData.edgeMaterial;

  						}
  						break;

  					case 'ALPHA':

  						alpha = parseInt( lineParser.getToken() );

  						if ( isNaN( alpha ) ) {

  							throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + ".";

  						}

  						alpha = Math.max( 0, Math.min( 1, alpha / 255 ) );

  						if ( alpha < 1 ) {

  							isTransparent = true;

  						}

  						break;

  					case 'LUMINANCE':

  						luminance = parseInt( lineParser.getToken() );

  						if ( isNaN( luminance ) ) {

  							throw 'LDrawLoader: Invalid luminance value in material definition' + lineParser.getLineNumberString() + ".";

  						}

  						luminance = Math.max( 0, Math.min( 1, luminance / 255 ) );

  						break;

  					case 'CHROME':
  						finishType = LDrawLoader.FINISH_TYPE_CHROME;
  						break;

  					case 'PEARLESCENT':
  						finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;
  						break;

  					case 'RUBBER':
  						finishType = LDrawLoader.FINISH_TYPE_RUBBER;
  						break;

  					case 'MATTE_METALLIC':
  						finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;
  						break;

  					case 'METAL':
  						finishType = LDrawLoader.FINISH_TYPE_METAL;
  						break;

  					case 'MATERIAL':
  						// Not implemented
  						lineParser.setToEnd();
  						break;

  					default:
  						throw 'LDrawLoader: Unknown token "' + token + '" while parsing material' + lineParser.getLineNumberString() + ".";
  						break;

  				}

  			}

  			var material = null;

  			switch ( finishType ) {

  				case LDrawLoader.FINISH_TYPE_DEFAULT:
  				case LDrawLoader.FINISH_TYPE_PEARLESCENT:

  					var specular = new Color( colour );
  					var shininess = 35;
  					var hsl = specular.getHSL( { h: 0, s: 0, l: 0 } );

  					if ( finishType === LDrawLoader.FINISH_TYPE_DEFAULT ) {

  						// Default plastic material with shiny specular
  						hsl.l = Math.min( 1, hsl.l + ( 1 - hsl.l ) * 0.12 );

  					} else {

  						// Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess
  						hsl.h = ( hsl.h + 0.5 ) % 1;
  						hsl.l = Math.min( 1, hsl.l + ( 1 - hsl.l ) * 0.7 );
  						shininess = 10;

  					}

  					specular.setHSL( hsl.h, hsl.s, hsl.l );

  					material = new MeshPhongMaterial( { color: colour, specular: specular, shininess: shininess, reflectivity: 0.3 } );
  					break;

  				case LDrawLoader.FINISH_TYPE_CHROME:

  					// Mirror finish surface
  					material = new MeshStandardMaterial( { color: colour, roughness: 0, metalness: 1 } );
  					break;

  				case LDrawLoader.FINISH_TYPE_RUBBER:

  					// Rubber is best simulated with Lambert
  					material = new MeshLambertMaterial( { color: colour } );
  					canHaveEnvMap = false;
  					break;

  				case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:

  					// Brushed metal finish
  					material = new MeshStandardMaterial( { color: colour, roughness: 0.8, metalness: 0.4 } );
  					break;

  				case LDrawLoader.FINISH_TYPE_METAL:

  					// Average metal finish
  					material = new MeshStandardMaterial( { color: colour, roughness: 0.2, metalness: 0.85 } );
  					break;

  				default:
  					// Should not happen
  					break;

  			}

  			// BFC (Back Face Culling) LDraw language meta extension is not implemented, so set all materials double-sided:
  			material.side = DoubleSide;

  			material.transparent = isTransparent;
  			material.opacity = alpha;

  			material.userData.canHaveEnvMap = canHaveEnvMap;

  			if ( luminance !== 0 ) {

  				material.emissive.set( material.color ).multiplyScalar( luminance );

  			}

  			if ( ! edgeMaterial ) {

  				// This is the material used for edges
  				edgeMaterial = new LineBasicMaterial( { color: edgeColour } );
  				edgeMaterial.userData.code = code;
  				edgeMaterial.name = name + " - Edge";
  				edgeMaterial.userData.canHaveEnvMap = false;

  			}

  			material.userData.code = code;
  			material.name = name;

  			material.userData.edgeMaterial = edgeMaterial;

  			return material;

  		},

  		//

  		parse: function ( text ) {
  			var this$1 = this;


  			//console.time( 'LDrawLoader' );

  			// Retrieve data from the parent parse scope
  			var parentParseScope = this.getParentParseScope();

  			// Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)
  			var mainColourCode = parentParseScope.mainColourCode;
  			var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;

  			var url = parentParseScope.url;

  			var currentParseScope = this.getCurrentParseScope();

  			// Parse result variables
  			var triangles;
  			var lineSegments;

  			if ( this.separateObjects ) {

  				triangles = [];
  				lineSegments = [];

  			} else {

  				if ( this.currentGroupObject === null ) {

  					this.currentGroupObject = new Group();
  					this.currentTriangles = [];
  					this.currentLineSegments = [];

  				}

  				triangles = this.currentTriangles;
  				lineSegments = this.currentLineSegments;

  			}

  			var subobjects = [];

  			var category = null;
  			var keywords = null;

  			if ( text.indexOf( '\r\n' ) !== - 1 ) {

  				// This is faster than String.split with regex that splits on both
  				text = text.replace( /\r\n/g, '\n' );

  			}

  			var lines = text.split( '\n' );
  			var numLines = lines.length;
  			var lineIndex = 0;

  			var parsingEmbeddedFiles = false;
  			var currentEmbeddedFileName = null;
  			var currentEmbeddedText = null;

  			var scope = this;
  			function parseColourCode( lineParser, forEdge ) {

  				// Parses next colour code and returns a Material

  				var colourCode = lineParser.getToken();

  				if ( ! forEdge && colourCode === '16' ) {

  					colourCode = mainColourCode;

  				}
  				if ( forEdge && colourCode === '24' ) {

  					colourCode = mainEdgeColourCode;

  				}

  				var material = scope.getMaterial( colourCode );

  				if ( ! material ) {

  					throw 'LDrawLoader: Unknown colour code "' + colourCode + '" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';

  				}

  				return material;

  			}

  			function parseVector( lp ) {

  				var v = new Vector3( parseFloat( lp.getToken() ), parseFloat( lp.getToken() ), parseFloat( lp.getToken() ) );

  				if ( ! scope.separateObjects ) {

  					v.applyMatrix4( parentParseScope.currentMatrix );

  				}

  				return v;

  			}

  			// Parse all line commands
  			for ( lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {

  				var line = lines[ lineIndex ];

  				if ( line.length === 0 ) { continue; }

  				if ( parsingEmbeddedFiles ) {

  					if ( line.startsWith( '0 FILE ' ) ) {

  						// Save previous embedded file in the cache
  						this$1.subobjectCache[ currentEmbeddedFileName ] = currentEmbeddedText;

  						// New embedded text file
  						currentEmbeddedFileName = line.substring( 7 );
  						currentEmbeddedText = '';

  					} else {

  						currentEmbeddedText += line + '\n';

  					}

  					continue;

  				}

  				var lp = new LineParser( line, lineIndex + 1 );

  				lp.seekNonSpace();

  				if ( lp.isAtTheEnd() ) {

  					// Empty line
  					continue;

  				}

  				// Parse the line type
  				var lineType = lp.getToken();

  				switch ( lineType ) {

  					// Line type 0: Comment or META
  					case '0':

  						// Parse meta directive
  						var meta = lp.getToken();

  						if ( meta ) {

  							switch ( meta ) {

  								case '!COLOUR':

  									var material = this$1.parseColourMetaDirective( lp );
  									if ( material ) {

  										this$1.addMaterial( material );

  									}	else {

  										console.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );

  									}
  									break;

  								case '!CATEGORY':

  									category = lp.getToken();
  									break;

  								case '!KEYWORDS':

  									var newKeywords = lp.getRemainingString().split( ',' );
  									if ( newKeywords.length > 0 ) {

  										if ( ! keywords ) {

  											keywords = [];

  										}

  										newKeywords.forEach( function ( keyword ) {

  											keywords.push( keyword.trim() );

  										} );

  									}
  									break;

  								case 'FILE':

  									if ( lineIndex > 0 ) {

  										// Start embedded text files parsing
  										parsingEmbeddedFiles = true;
  										currentEmbeddedFileName = lp.getRemainingString();
  										currentEmbeddedText = '';

  									}

  									break;

  								default:
  									// Other meta directives are not implemented
  									break;

  							}

  						}

  						break;

  					// Line type 1: Sub-object file
  					case '1':

  						var material = parseColourCode( lp );

  						var posX = parseFloat( lp.getToken() );
  						var posY = parseFloat( lp.getToken() );
  						var posZ = parseFloat( lp.getToken() );
  						var m0 = parseFloat( lp.getToken() );
  						var m1 = parseFloat( lp.getToken() );
  						var m2 = parseFloat( lp.getToken() );
  						var m3 = parseFloat( lp.getToken() );
  						var m4 = parseFloat( lp.getToken() );
  						var m5 = parseFloat( lp.getToken() );
  						var m6 = parseFloat( lp.getToken() );
  						var m7 = parseFloat( lp.getToken() );
  						var m8 = parseFloat( lp.getToken() );

  						var matrix = new Matrix4().set(
  							m0, m1, m2, posX,
  							m3, m4, m5, posY,
  							m6, m7, m8, posZ,
  							0, 0, 0, 1
  						);

  						var fileName = lp.getRemainingString().trim().replace( "\\", "/" );

  						if ( scope.fileMap[ fileName ] ) {

  							// Found the subobject path in the preloaded file path map
  							fileName = scope.fileMap[ fileName ];

  						}	else {

  							// Standardized subfolders
  							if ( fileName.startsWith( 's/' ) ) {

  								fileName = 'parts/' + fileName;

  							} else if ( fileName.startsWith( '48/' ) ) {

  								fileName = 'p/' + fileName;

  							}

  						}

  						subobjects.push( {
  							material: material,
  							matrix: matrix,
  							fileName: fileName,
  							originalFileName: fileName,
  							locationState: LDrawLoader.FILE_LOCATION_AS_IS,
  							url: null,
  							triedLowerCase: false
  						} );

  						break;

  					// Line type 2: Line segment
  					case '2':

  						var material = parseColourCode( lp, true );

  						lineSegments.push( {
  							material: material.userData.edgeMaterial,
  							colourCode: material.userData.code,
  							v0: parseVector( lp ),
  							v1: parseVector( lp )
  						} );

  						break;

  					// Line type 3: Triangle
  					case '3':

  						var material = parseColourCode( lp );

  						triangles.push( {
  							material: material,
  							colourCode: material.userData.code,
  							v0: parseVector( lp ),
  							v1: parseVector( lp ),
  							v2: parseVector( lp )
  						} );

  						break;

  					// Line type 4: Quadrilateral
  					case '4':

  						var material = parseColourCode( lp );

  						var v0 = parseVector( lp );
  						var v1 = parseVector( lp );
  						var v2 = parseVector( lp );
  						var v3 = parseVector( lp );

  						triangles.push( {
  							material: material,
  							colourCode: material.userData.code,
  							v0: v0,
  							v1: v1,
  							v2: v2
  						} );

  						triangles.push( {
  							material: material,
  							colourCode: material.userData.code,
  							v0: v0,
  							v1: v2,
  							v2: v3
  						} );

  						break;

  					// Line type 5: Optional line
  					case '5':
  						// Line type 5 is not implemented
  						break;

  					default:
  						throw 'LDrawLoader: Unknown line type "' + lineType + '"' + lp.getLineNumberString() + '.';
  						break;

  				}

  			}

  			if ( parsingEmbeddedFiles ) {

  				this.subobjectCache[ currentEmbeddedFileName ] = currentEmbeddedText;

  			}

  			//

  			var groupObject = null;

  			if ( this.separateObjects ) {

  				groupObject = new Group();

  				if ( lineSegments.length > 0 ) {

  					groupObject.add( createObject( lineSegments, 2 ) );
  				}

  				if ( triangles.length > 0 ) {

  					groupObject.add( createObject( triangles, 3 ) );

  				}

  			} else {

  				groupObject = this.currentGroupObject;

  			}

  			groupObject.userData.category = category;
  			groupObject.userData.keywords = keywords;
  			groupObject.userData.subobjects = subobjects;

  			//console.timeEnd( 'LDrawLoader' );

  			return groupObject;

  		}

  	};

  	return LDrawLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  /*
  if ( var LoaderSupport === undefined ) { var LoaderSupport = {} }
  */
  var LoaderSupport = {};
  LoaderSupport.Validator = {
  	
  	isValid: function( input ) {
  		return ( input !== null && input !== undefined );
  	},
  	
  	verifyInput: function( input, defaultValue ) {
  		return ( input === null || input === undefined ) ? defaultValue : input;
  	}
  };
  LoaderSupport.Callbacks = function () {
  	this.onProgress = null;
  	this.onReportError = null;
  	this.onMeshAlter = null;
  	this.onLoad = null;
  	this.onLoadMaterials = null;
  };

  LoaderSupport.Callbacks.prototype = {

  	constructor: LoaderSupport.Callbacks,
  	setCallbackOnProgress: function ( callbackOnProgress ) {
  		this.onProgress = LoaderSupport.Validator.verifyInput( callbackOnProgress, this.onProgress );
  	},
  	setCallbackOnReportError: function ( callbackOnReportError ) {
  		this.onReportError = LoaderSupport.Validator.verifyInput( callbackOnReportError, this.onReportError );
  	},
  	setCallbackOnMeshAlter: function ( callbackOnMeshAlter ) {
  		this.onMeshAlter = LoaderSupport.Validator.verifyInput( callbackOnMeshAlter, this.onMeshAlter );
  	},
  	setCallbackOnLoad: function ( callbackOnLoad ) {
  		this.onLoad = LoaderSupport.Validator.verifyInput( callbackOnLoad, this.onLoad );
  	},
  	setCallbackOnLoadMaterials: function ( callbackOnLoadMaterials ) {
  		this.onLoadMaterials = LoaderSupport.Validator.verifyInput( callbackOnLoadMaterials, this.onLoadMaterials );
  	}

  };
  LoaderSupport.LoadedMeshUserOverride = function( disregardMesh, alteredMesh ) {
  	this.disregardMesh = disregardMesh === true;
  	this.alteredMesh = alteredMesh === true;
  	this.meshes = [];
  };

  LoaderSupport.LoadedMeshUserOverride.prototype = {

  	constructor: LoaderSupport.LoadedMeshUserOverride,
  	addMesh: function ( mesh ) {
  		this.meshes.push( mesh );
  		this.alteredMesh = true;
  	},
  	isDisregardMesh: function () {
  		return this.disregardMesh;
  	},
  	providesAlteredMeshes: function () {
  		return this.alteredMesh;
  	}

  };
  LoaderSupport.ResourceDescriptor = function ( url, extension ) {
  	var urlParts = url.split( '/' );

  	this.path;
  	this.resourcePath;
  	this.name = url;
  	this.url = url;
  	if ( urlParts.length >= 2 ) {

  		this.path = LoaderSupport.Validator.verifyInput( urlParts.slice( 0, urlParts.length - 1).join( '/' ) + '/', this.path );
  		this.name = urlParts[ urlParts.length - 1 ];
  		this.url = url;

  	}
  	this.name = LoaderSupport.Validator.verifyInput( this.name, 'Unnamed_Resource' );
  	this.extension = LoaderSupport.Validator.verifyInput( extension, 'default' );
  	this.extension = this.extension.trim();
  	this.content = null;
  };

  LoaderSupport.ResourceDescriptor.prototype = {

  	constructor: LoaderSupport.ResourceDescriptor,
  	setContent: function ( content ) {
  		this.content = LoaderSupport.Validator.verifyInput( content, null );
  	},
  	setResourcePath: function ( resourcePath ) {
  		this.resourcePath = LoaderSupport.Validator.verifyInput( resourcePath, this.resourcePath );
  	}
  };
  LoaderSupport.PrepData = function ( modelName ) {
  	this.logging = {
  		enabled: true,
  		debug: false
  	};
  	this.modelName = LoaderSupport.Validator.verifyInput( modelName, '' );
  	this.resources = [];
  	this.callbacks = new LoaderSupport.Callbacks();
  };

  LoaderSupport.PrepData.prototype = {

  	constructor: LoaderSupport.PrepData,
  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  	},
  	getCallbacks: function () {
  		return this.callbacks;
  	},
  	addResource: function ( resource ) {
  		this.resources.push( resource );
  	},
  	clone: function () {
  		var this$1 = this;

  		var clone = new LoaderSupport.PrepData( this.modelName );
  		clone.logging.enabled = this.logging.enabled;
  		clone.logging.debug = this.logging.debug;
  		clone.resources = this.resources;
  		clone.callbacks = this.callbacks;

  		var property, value;
  		for ( property in this$1 ) {

  			value = this$1[ property ];
  			if ( ! clone.hasOwnProperty( property ) && typeof this$1[ property ] !== 'function' ) {

  				clone[ property ] = value;

  			}
  		}

  		return clone;
  	},
  	checkResourceDescriptorFiles: function ( resources, fileDesc ) {
  		var resource, triple, i, found;
  		var result = {};

  		for ( var index in resources ) {

  			resource = resources[ index ];
  			found = false;
  			if ( ! LoaderSupport.Validator.isValid( resource.name ) ) { continue; }
  			if ( LoaderSupport.Validator.isValid( resource.content ) ) {

  				for ( i = 0; i < fileDesc.length && !found; i++ ) {

  					triple = fileDesc[ i ];
  					if ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {

  						if ( triple.ignore ) {

  							found = true;

  						} else if ( triple.type === "ArrayBuffer" ) {

  							// fast-fail on bad type
  							if ( ! ( resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array ) ) { throw 'Provided content is not of type ArrayBuffer! Aborting...'; }
  							result[ triple.ext ] = resource;
  							found = true;

  						} else if ( triple.type === "String" ) {

  							if ( ! ( typeof( resource.content ) === 'string' || resource.content instanceof String) ) { throw 'Provided  content is not of type String! Aborting...'; }
  							result[ triple.ext ] = resource;
  							found = true;

  						}

  					}

  				}
  				if ( !found ) { throw 'Unidentified resource "' + resource.name + '": ' + resource.url; }

  			} else {

  				// fast-fail on bad type
  				if ( ! ( typeof( resource.name ) === 'string' || resource.name instanceof String ) ) { throw 'Provided file is not properly defined! Aborting...'; }
  				for ( i = 0; i < fileDesc.length && !found; i++ ) {

  					triple = fileDesc[ i ];
  					if ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {

  						if ( ! triple.ignore ) { result[ triple.ext ] = resource; }
  						found = true;

  					}

  				}
  				if ( !found ) { throw 'Unidentified resource "' + resource.name + '": ' + resource.url; }

  			}
  		}

  		return result;
  	}
  };
  LoaderSupport.MeshBuilder = function() {
  	console.info( 'Using LoaderSupport.MeshBuilder version: ' + LoaderSupport.MeshBuilder.LOADER_MESH_BUILDER_VERSION );
  	this.validator = LoaderSupport.Validator;

  	this.logging = {
  		enabled: true,
  		debug: false
  	};

  	this.callbacks = new LoaderSupport.Callbacks();
  	this.materials = [];
  };
  LoaderSupport.MeshBuilder.LOADER_MESH_BUILDER_VERSION = '1.3.0';

  LoaderSupport.MeshBuilder.prototype = {

  	constructor: LoaderSupport.MeshBuilder,
  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  	},
  	init: function () {
  		var defaultMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );
  		defaultMaterial.name = 'defaultMaterial';

  		var defaultVertexColorMaterial = new MeshStandardMaterial( { color: 0xDCF1FF } );
  		defaultVertexColorMaterial.name = 'defaultVertexColorMaterial';
  		defaultVertexColorMaterial.vertexColors = VertexColors;

  		var defaultLineMaterial = new LineBasicMaterial();
  		defaultLineMaterial.name = 'defaultLineMaterial';

  		var defaultPointMaterial = new PointsMaterial( { size: 1 } );
  		defaultPointMaterial.name = 'defaultPointMaterial';

  		var runtimeMaterials = {};
  		runtimeMaterials[ defaultMaterial.name ] = defaultMaterial;
  		runtimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;
  		runtimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;
  		runtimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;

  		this.updateMaterials(
  			{
  				cmd: 'materialData',
  				materials: {
  					materialCloneInstructions: null,
  					serializedMaterials: null,
  					runtimeMaterials: runtimeMaterials
  				}
  			}
  		);
  	},
  	setMaterials: function ( materials ) {
  		var payload = {
  			cmd: 'materialData',
  			materials: {
  				materialCloneInstructions: null,
  				serializedMaterials: null,
  				runtimeMaterials: this.validator.isValid( this.callbacks.onLoadMaterials ) ? this.callbacks.onLoadMaterials( materials ) : materials
  			}
  		};
  		this.updateMaterials( payload );
  	},

  	_setCallbacks: function ( callbacks ) {
  		if ( this.validator.isValid( callbacks.onProgress ) ) { this.callbacks.setCallbackOnProgress( callbacks.onProgress ); }
  		if ( this.validator.isValid( callbacks.onReportError ) ) { this.callbacks.setCallbackOnReportError( callbacks.onReportError ); }
  		if ( this.validator.isValid( callbacks.onMeshAlter ) ) { this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter ); }
  		if ( this.validator.isValid( callbacks.onLoad ) ) { this.callbacks.setCallbackOnLoad( callbacks.onLoad ); }
  		if ( this.validator.isValid( callbacks.onLoadMaterials ) ) { this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials ); }
  	},
  	processPayload: function ( payload ) {
  		if ( payload.cmd === 'meshData' ) {

  			return this.buildMeshes( payload );

  		} else if ( payload.cmd === 'materialData' ) {

  			this.updateMaterials( payload );
  			return null;

  		}
  	},
  	buildMeshes: function ( meshPayload ) {
  		var this$1 = this;

  		var meshName = meshPayload.params.meshName;

  		var bufferGeometry = new BufferGeometry();
  		bufferGeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( meshPayload.buffers.vertices ), 3 ) );
  		if ( this.validator.isValid( meshPayload.buffers.indices ) ) {

  			bufferGeometry.setIndex( new BufferAttribute( new Uint32Array( meshPayload.buffers.indices ), 1 ));

  		}
  		var haveVertexColors = this.validator.isValid( meshPayload.buffers.colors );
  		if ( haveVertexColors ) {

  			bufferGeometry.addAttribute( 'color', new BufferAttribute( new Float32Array( meshPayload.buffers.colors ), 3 ) );

  		}
  		if ( this.validator.isValid( meshPayload.buffers.normals ) ) {

  			bufferGeometry.addAttribute( 'normal', new BufferAttribute( new Float32Array( meshPayload.buffers.normals ), 3 ) );

  		} else {

  			bufferGeometry.computeVertexNormals();

  		}
  		if ( this.validator.isValid( meshPayload.buffers.uvs ) ) {

  			bufferGeometry.addAttribute( 'uv', new BufferAttribute( new Float32Array( meshPayload.buffers.uvs ), 2 ) );

  		}

  		var material, materialName, key;
  		var materialNames = meshPayload.materials.materialNames;
  		var createMultiMaterial = meshPayload.materials.multiMaterial;
  		var multiMaterials = [];
  		for ( key in materialNames ) {

  			materialName = materialNames[ key ];
  			material = this$1.materials[ materialName ];
  			if ( createMultiMaterial ) { multiMaterials.push( material ); }

  		}
  		if ( createMultiMaterial ) {

  			material = multiMaterials;
  			var materialGroups = meshPayload.materials.materialGroups;
  			var materialGroup;
  			for ( key in materialGroups ) {

  				materialGroup = materialGroups[ key ];
  				bufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );

  			}

  		}

  		var meshes = [];
  		var mesh;
  		var callbackOnMeshAlter = this.callbacks.onMeshAlter;
  		var callbackOnMeshAlterResult;
  		var useOrgMesh = true;
  		var geometryType = this.validator.verifyInput( meshPayload.geometryType, 0 );
  		if ( this.validator.isValid( callbackOnMeshAlter ) ) {

  			callbackOnMeshAlterResult = callbackOnMeshAlter(
  				{
  					detail: {
  						meshName: meshName,
  						bufferGeometry: bufferGeometry,
  						material: material,
  						geometryType: geometryType
  					}
  				}
  			);
  			if ( this.validator.isValid( callbackOnMeshAlterResult ) ) {

  				if ( callbackOnMeshAlterResult.isDisregardMesh() ) {

  					useOrgMesh = false;

  				} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {

  					for ( var i in callbackOnMeshAlterResult.meshes ) {

  						meshes.push( callbackOnMeshAlterResult.meshes[ i ] );

  					}
  					useOrgMesh = false;

  				}

  			}

  		}
  		if ( useOrgMesh ) {

  			if ( meshPayload.computeBoundingSphere ) { bufferGeometry.computeBoundingSphere(); }
  			if ( geometryType === 0 ) {

  				mesh = new Mesh( bufferGeometry, material );

  			} else if ( geometryType === 1) {

  				mesh = new LineSegments( bufferGeometry, material );

  			} else {

  				mesh = new Points( bufferGeometry, material );

  			}
  			mesh.name = meshName;
  			meshes.push( mesh );

  		}

  		var progressMessage;
  		if ( this.validator.isValid( meshes ) && meshes.length > 0 ) {

  			var meshNames = [];
  			for ( var i in meshes ) {

  				mesh = meshes[ i ];
  				meshNames[ i ] = mesh.name;

  			}
  			progressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;
  			progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';

  		} else {

  			progressMessage = 'Not adding mesh: ' + meshName;
  			progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';

  		}
  		var callbackOnProgress = this.callbacks.onProgress;
  		if ( this.validator.isValid( callbackOnProgress ) ) {

  			var event = new CustomEvent( 'MeshBuilderEvent', {
  				detail: {
  					type: 'progress',
  					modelName: meshPayload.params.meshName,
  					text: progressMessage,
  					numericalValue: meshPayload.progress.numericalValue
  				}
  			} );
  			callbackOnProgress( event );

  		}

  		return meshes;
  	},
  	updateMaterials: function ( materialPayload ) {
  		var this$1 = this;

  		var material, materialName;
  		var materialCloneInstructions = materialPayload.materials.materialCloneInstructions;
  		if ( this.validator.isValid( materialCloneInstructions ) ) {

  			var materialNameOrg = materialCloneInstructions.materialNameOrg;
  			var materialOrg = this.materials[ materialNameOrg ];

  			if ( this.validator.isValid( materialNameOrg ) ) {

  				material = materialOrg.clone();

  				materialName = materialCloneInstructions.materialName;
  				material.name = materialName;

  				var materialProperties = materialCloneInstructions.materialProperties;
  				for ( var key in materialProperties ) {

  					if ( material.hasOwnProperty( key ) && materialProperties.hasOwnProperty( key ) ) { material[ key ] = materialProperties[ key ]; }

  				}
  				this.materials[ materialName ] = material;

  			} else {

  				console.warn( 'Requested material "' + materialNameOrg + '" is not available!' );

  			}
  		}

  		var materials = materialPayload.materials.serializedMaterials;
  		if ( this.validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {

  			var loader = new MaterialLoader();
  			var materialJson;
  			for ( materialName in materials ) {

  				materialJson = materials[ materialName ];
  				if ( this$1.validator.isValid( materialJson ) ) {

  					material = loader.parse( materialJson );
  					if ( this$1.logging.enabled ) { console.info( 'De-serialized material with name "' + materialName + '" will be added.' ); }
  					this$1.materials[ materialName ] = material;
  				}

  			}

  		}

  		materials = materialPayload.materials.runtimeMaterials;
  		if ( this.validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {

  			for ( materialName in materials ) {

  				material = materials[ materialName ];
  				if ( this$1.logging.enabled ) { console.info( 'Material with name "' + materialName + '" will be added.' ); }
  				this$1.materials[ materialName ] = material;

  			}

  		}
  	},
  	getMaterialsJSON: function () {
  		var this$1 = this;

  		var materialsJSON = {};
  		var material;
  		for ( var materialName in this$1.materials ) {

  			material = this$1.materials[ materialName ];
  			materialsJSON[ materialName ] = material.toJSON();
  		}

  		return materialsJSON;
  	},
  	getMaterials: function () {
  		return this.materials;
  	}

  };
  LoaderSupport.WorkerSupport = function () {
  	console.info( 'Using LoaderSupport.WorkerSupport version: ' + LoaderSupport.WorkerSupport.WORKER_SUPPORT_VERSION );
  	this.logging = {
  		enabled: true,
  		debug: false
  	};

  	//Choose implementation of worker based on environment
  	this.loaderWorker = typeof window !== "undefined" ? new LoaderSupport.WorkerSupport.LoaderWorker() : new LoaderSupport.WorkerSupport.NodeLoaderWorker();
  };

  LoaderSupport.WorkerSupport.WORKER_SUPPORT_VERSION = '2.3.0';

  LoaderSupport.WorkerSupport.prototype = {

  	constructor: LoaderSupport.WorkerSupport,
  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  		this.loaderWorker.setLogging( this.logging.enabled, this.logging.debug );
  	},
  	setForceWorkerDataCopy: function ( forceWorkerDataCopy ) {
  		this.loaderWorker.setForceCopy( forceWorkerDataCopy );
  	},
  	validate: function ( functionCodeBuilder, parserName, libLocations, libPath, runnerImpl ) {
  		if ( LoaderSupport.Validator.isValid( this.loaderWorker.worker ) ) { return; }

  		if ( this.logging.enabled ) {

  			console.info( 'WorkerSupport: Building worker code...' );
  			console.time( 'buildWebWorkerCode' );

  		}
  		if ( LoaderSupport.Validator.isValid( runnerImpl ) ) {

  			if ( this.logging.enabled ) { console.info( 'WorkerSupport: Using "' + runnerImpl.runnerName + '" as Runner class for worker.' ); }

  		// Browser implementation
  		} else if ( typeof window !== "undefined" ) {

  			runnerImpl = LoaderSupport.WorkerRunnerRefImpl;
  			if ( this.logging.enabled ) { console.info( 'WorkerSupport: Using DEFAULT "LoaderSupport.WorkerRunnerRefImpl" as Runner class for worker.' ); }

  		// NodeJS implementation
  		} else {

  			runnerImpl = LoaderSupport.NodeWorkerRunnerRefImpl;
  			if ( this.logging.enabled ) { console.info( 'WorkerSupport: Using DEFAULT "LoaderSupport.NodeWorkerRunnerRefImpl" as Runner class for worker.' ); }

  		}
  		var userWorkerCode = functionCodeBuilder( LoaderSupport.WorkerSupport.CodeSerializer );
  		userWorkerCode += 'var Parser = '+ parserName +  ';\n\n';
  		userWorkerCode += LoaderSupport.WorkerSupport.CodeSerializer.serializeClass( runnerImpl.runnerName, runnerImpl );
  		userWorkerCode += 'new ' + runnerImpl.runnerName + '();\n\n';

  		var scope = this;
  		if ( LoaderSupport.Validator.isValid( libLocations ) && libLocations.length > 0 ) {

  			var libsContent = '';
  			var loadAllLibraries = function ( path, locations ) {
  				if ( locations.length === 0 ) {

  					scope.loaderWorker.initWorker( libsContent + userWorkerCode, runnerImpl.runnerName );
  					if ( scope.logging.enabled ) { console.timeEnd( 'buildWebWorkerCode' ); }

  				} else {

  					var loadedLib = function ( contentAsString ) {
  						libsContent += contentAsString;
  						loadAllLibraries( path, locations );
  					};

  					var fileLoader = new FileLoader();
  					fileLoader.setPath( path );
  					fileLoader.setResponseType( 'text' );
  					fileLoader.load( locations[ 0 ], loadedLib );
  					locations.shift();

  				}
  			};
  			loadAllLibraries( libPath, libLocations );

  		} else {

  			this.loaderWorker.initWorker( userWorkerCode, runnerImpl.runnerName );
  			if ( this.logging.enabled ) { console.timeEnd( 'buildWebWorkerCode' ); }

  		}
  	},
  	setCallbacks: function ( meshBuilder, onLoad ) {
  		this.loaderWorker.setCallbacks( meshBuilder, onLoad );
  	},
  	run: function ( payload ) {
  		this.loaderWorker.run( payload );
  	},
  	setTerminateRequested: function ( terminateRequested ) {
  		this.loaderWorker.setTerminateRequested( terminateRequested );
  	}

  };
  LoaderSupport.WorkerSupport.LoaderWorker = function () {
  	this._reset();
  };

  LoaderSupport.WorkerSupport.LoaderWorker.prototype = {

  	constructor: LoaderSupport.WorkerSupport.LoaderWorker,

  	_reset: function () {
  		this.logging = {
  			enabled: true,
  			debug: false
  		};
  		this.worker = null;
  		this.runnerImplName = null;
  		this.callbacks = {
  			meshBuilder: null,
  			onLoad: null
  		};
  		this.terminateRequested = false;
  		this.queuedMessage = null;
  		this.started = false;
  		this.forceCopy = false;
  	},
  	checkSupport: function() {
  		if ( window.Worker === undefined ) { return "This browser does not support web workers!"; }
  		if ( window.Blob === undefined  ) { return "This browser does not support Blob!"; }
  		if ( typeof window.URL.createObjectURL !== 'function'  ) { return "This browser does not support Object creation from URL!"; }
  	},

  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  	},

  	setForceCopy: function ( forceCopy ) {
  		this.forceCopy = forceCopy === true;
  	},

  	initWorker: function ( code, runnerImplName ) {
  		var supportError = this.checkSupport();
  		if ( supportError ) {

  			throw supportError;

  		}
  		this.runnerImplName = runnerImplName;

  		var blob = new Blob( [ code ], { type: 'application/javascript' } );
  		this.worker = new Worker( window.URL.createObjectURL( blob ) );

  		this.worker.onmessage = this._receiveWorkerMessage;

  		// set referemce to this, then processing in worker scope within "_receiveWorkerMessage" can access members
  		this.worker.runtimeRef = this;

  		// process stored queuedMessage
  		this._postMessage();
  	},
  	_receiveWorkerMessage: function ( e ) {
  		var payload = e.data;
  		switch ( payload.cmd ) {
  			case 'meshData':
  			case 'materialData':
  			case 'imageData':
  				this.runtimeRef.callbacks.meshBuilder( payload );
  				break;

  			case 'complete':
  				this.runtimeRef.queuedMessage = null;
  				this.started = false;
  				this.runtimeRef.callbacks.onLoad( payload.msg );

  				if ( this.runtimeRef.terminateRequested ) {

  					if ( this.runtimeRef.logging.enabled ) { console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!' ); }
  					this.runtimeRef._terminate();

  				}
  				break;

  			case 'error':
  				console.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg );
  				this.runtimeRef.queuedMessage = null;
  				this.started = false;
  				this.runtimeRef.callbacks.onLoad( payload.msg );

  				if ( this.runtimeRef.terminateRequested ) {

  					if ( this.runtimeRef.logging.enabled ) { console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!' ); }
  					this.runtimeRef._terminate();

  				}
  				break;

  			default:
  				console.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd );
  				break;

  		}
  	},

  	setCallbacks: function ( meshBuilder, onLoad ) {
  		this.callbacks.meshBuilder = LoaderSupport.Validator.verifyInput( meshBuilder, this.callbacks.meshBuilder );
  		this.callbacks.onLoad = LoaderSupport.Validator.verifyInput( onLoad, this.callbacks.onLoad );
  	},

  	run: function( payload ) {
  		if ( LoaderSupport.Validator.isValid( this.queuedMessage ) ) {

  			console.warn( 'Already processing message. Rejecting new run instruction' );
  			return;

  		} else {

  			this.queuedMessage = payload;
  			this.started = true;

  		}
  		if ( ! LoaderSupport.Validator.isValid( this.callbacks.meshBuilder ) ) { throw 'Unable to run as no "MeshBuilder" callback is set.'; }
  		if ( ! LoaderSupport.Validator.isValid( this.callbacks.onLoad ) ) { throw 'Unable to run as no "onLoad" callback is set.'; }
  		if ( payload.cmd !== 'run' ) { payload.cmd = 'run'; }
  		if ( LoaderSupport.Validator.isValid( payload.logging ) ) {

  			payload.logging.enabled = payload.logging.enabled === true;
  			payload.logging.debug = payload.logging.debug === true;

  		} else {

  			payload.logging = {
  				enabled: true,
  				debug: false
  			};

  		}
  		this._postMessage();
  	},

  	_postMessage: function () {
  		if ( LoaderSupport.Validator.isValid( this.queuedMessage ) && LoaderSupport.Validator.isValid( this.worker ) ) {

  			if ( this.queuedMessage.data.input instanceof ArrayBuffer ) {

  				var content;
  				if ( this.forceCopy ) {

  					content = this.queuedMessage.data.input.slice( 0 );

  				} else {

  					content = this.queuedMessage.data.input;

  				}
  				this.worker.postMessage( this.queuedMessage, [ content ] );

  			} else {

  				this.worker.postMessage( this.queuedMessage );

  			}

  		}
  	},

  	setTerminateRequested: function ( terminateRequested ) {
  		this.terminateRequested = terminateRequested === true;
  		if ( this.terminateRequested && LoaderSupport.Validator.isValid( this.worker ) && ! LoaderSupport.Validator.isValid( this.queuedMessage ) && this.started ) {

  			if ( this.logging.enabled ) { console.info( 'Worker is terminated immediately as it is not running!' ); }
  			this._terminate();

  		}
  	},

  	_terminate: function () {
  		this.worker.terminate();
  		this._reset();
  	}
  };
  LoaderSupport.WorkerSupport.CodeSerializer = {
  	serializeObject: function ( fullName, object ) {
  		var objectString = fullName + ' = {\n\n';
  		var part;
  		for ( var name in object ) {

  			part = object[ name ];
  			if ( typeof( part ) === 'string' || part instanceof String ) {

  				part = part.replace( '\n', '\\n' );
  				part = part.replace( '\r', '\\r' );
  				objectString += '\t' + name + ': "' + part + '",\n';

  			} else if ( part instanceof Array ) {

  				objectString += '\t' + name + ': [' + part + '],\n';

  			} else if ( typeof part === 'object' ) {

  				// TODO: Short-cut for now. Recursion required?
  				objectString += '\t' + name + ': {},\n';

  			} else {

  				objectString += '\t' + name + ': ' + part + ',\n';

  			}

  		}
  		objectString += '}\n\n';

  		return objectString;
  	},
  	serializeClass: function ( fullName, object, constructorName, basePrototypeName, ignoreFunctions, includeFunctions, overrideFunctions ) {
  		var valueString, objectPart, constructorString, i, funcOverride;
  		var prototypeFunctions = [];
  		var objectProperties = [];
  		var objectFunctions = [];
  		var isExtended = ( basePrototypeName !== null && basePrototypeName !== undefined );

  		if ( ! Array.isArray( ignoreFunctions ) ) { ignoreFunctions = []; }
  		if ( ! Array.isArray( includeFunctions ) ) { includeFunctions = null; }
  		if ( ! Array.isArray( overrideFunctions ) ) { overrideFunctions = []; }

  		for ( var name in object.prototype ) {

  			objectPart = object.prototype[ name ];
  			valueString = objectPart.toString();
  			if ( name === 'constructor' ) {

  				constructorString = fullName + ' = ' + valueString + ';\n\n';

  			} else if ( typeof objectPart === 'function' ) {

  				if ( ignoreFunctions.indexOf( name ) < 0 && ( includeFunctions === null || includeFunctions.indexOf( name ) >= 0 ) ) {

  					funcOverride = overrideFunctions[ name ];
  					if ( funcOverride && funcOverride.fullName === fullName + '.prototype.' + name ) {

  						valueString = funcOverride.code;

  					}
  					if ( isExtended ) {

  						prototypeFunctions.push( fullName + '.prototype.' + name + ' = ' + valueString + ';\n\n' );

  					} else {

  						prototypeFunctions.push( '\t' + name + ': ' + valueString + ',\n\n' );

  					}
  				}

  			}

  		}
  		for ( var name in object ) {

  			objectPart = object[ name ];

  			if ( typeof objectPart === 'function' ) {

  				if ( ignoreFunctions.indexOf( name ) < 0 && ( includeFunctions === null || includeFunctions.indexOf( name ) >= 0 ) ) {

  					funcOverride = overrideFunctions[ name ];
  					if ( funcOverride && funcOverride.fullName === fullName + '.' + name ) {

  						valueString = funcOverride.code;

  					} else {

  						valueString = objectPart.toString();

  					}
  					objectFunctions.push( fullName + '.' + name + ' = ' + valueString + ';\n\n' );

  				}

  			} else {

  				if ( typeof( objectPart ) === 'string' || objectPart instanceof String) {

  					valueString = '\"' + objectPart.toString() + '\"';

  				} else if ( typeof objectPart === 'object' ) {

  					// TODO: Short-cut for now. Recursion required?
  					valueString = "{}";

  				} else {

  					valueString = objectPart;

  				}
  				objectProperties.push( fullName + '.' + name + ' = ' + valueString + ';\n' );

  			}

  		}
  		if ( ( constructorString === undefined || constructorString === null ) && typeof object.prototype.constructor === 'function' ) {

  			constructorString = fullName + ' = ' + object.prototype.constructor.toString().replace( constructorName, '' );

  		}
  		var objectString = constructorString + '\n\n';
  		if ( isExtended ) {

  			objectString += fullName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\n';

  		}
  		objectString += fullName + '.prototype.constructor = ' + fullName + ';\n';
  		objectString += '\n\n';

  		for ( i = 0; i < objectProperties.length; i ++ ) { objectString += objectProperties[ i ]; }
  		objectString += '\n\n';

  		for ( i = 0; i < objectFunctions.length; i ++ ) { objectString += objectFunctions[ i ]; }
  		objectString += '\n\n';

  		if ( isExtended ) {

  			for ( i = 0; i < prototypeFunctions.length; i ++ ) { objectString += prototypeFunctions[ i ]; }

  		} else {

  			objectString += fullName + '.prototype = {\n\n';
  			for ( i = 0; i < prototypeFunctions.length; i ++ ) { objectString += prototypeFunctions[ i ]; }
  			objectString += '\n};';

  		}
  		objectString += '\n\n';

  		return objectString;
  	},
  };
  LoaderSupport.WorkerRunnerRefImpl = function () {
  	var scopedRunner = function( event ) {
  		this.processMessage( event.data );
  	};
  	this.getParentScope().addEventListener( 'message', scopedRunner.bind( this ) );
  };

  LoaderSupport.WorkerRunnerRefImpl.runnerName = 'LoaderSupport.WorkerRunnerRefImpl';

  LoaderSupport.WorkerRunnerRefImpl.prototype = {

  	constructor: LoaderSupport.WorkerRunnerRefImpl,
  	getParentScope: function () {
  		return self;
  	},
  	applyProperties: function ( parser, params ) {
  		var property, funcName, values;
  		for ( property in params ) {
  			funcName = 'set' + property.substring( 0, 1 ).toLocaleUpperCase() + property.substring( 1 );
  			values = params[ property ];

  			if ( typeof parser[ funcName ] === 'function' ) {

  				parser[ funcName ]( values );

  			} else if ( parser.hasOwnProperty( property ) ) {

  				parser[ property ] = values;

  			}
  		}
  	},
  	processMessage: function ( payload ) {
  		if ( payload.cmd === 'run' ) {

  			var self = this.getParentScope();
  			var callbacks = {
  				callbackMeshBuilder: function ( payload ) {
  					self.postMessage( payload );
  				},
  				callbackProgress: function ( text ) {
  					if ( payload.logging.enabled && payload.logging.debug ) { console.debug( 'WorkerRunner: progress: ' + text ); }
  				}
  			};

  			// Parser is expected to be named as such
  			var parser = new Parser();
  			if ( typeof parser[ 'setLogging' ] === 'function' ) { parser.setLogging( payload.logging.enabled, payload.logging.debug ); }
  			this.applyProperties( parser, payload.params );
  			this.applyProperties( parser, payload.materials );
  			this.applyProperties( parser, callbacks );
  			parser.workerScope = self;
  			parser.parse( payload.data.input, payload.data.options );

  			if ( payload.logging.enabled ) { console.log( 'WorkerRunner: Run complete!' ); }

  			callbacks.callbackMeshBuilder( {
  				cmd: 'complete',
  				msg: 'WorkerRunner completed run.'
  			} );

  		} else {

  			console.error( 'WorkerRunner: Received unknown command: ' + payload.cmd );

  		}
  	}
  };
  LoaderSupport.NodeWorkerRunnerRefImpl = function () {
  	this.runnerName = 'LoaderSupport.NodeWorkerRunnerRefImpl';
  	// No call to super because super class only binds to processMessage
  	// In NodeJS, there is no addEventListener so use onmessage.
  	// Also, the message object can be passed directly to
  	// processMessage() as it isn't an `Event`, but a plain object
  	// with the data
  	this.getParentScope().onmessage = this.processMessage.bind( this );
  };

  LoaderSupport.NodeWorkerRunnerRefImpl.prototype = Object.create( LoaderSupport.WorkerRunnerRefImpl.prototype );
  LoaderSupport.NodeWorkerRunnerRefImpl.prototype.constructor = LoaderSupport.NodeWorkerRunnerRefImpl;
  LoaderSupport.NodeWorkerRunnerRefImpl.runnerName = 'LoaderSupport.NodeWorkerRunnerRefImpl';

  LoaderSupport.NodeWorkerRunnerRefImpl.prototype = {

  	getParentScope: function(){
  		// Work around webpack builds failing with NodeJS requires
  		// (placing it outside this function will fail because
  		// this class is passed to the worker as a string!)
  		var _require = eval( 'require' );
  		return _require( 'worker_threads' ).parentPort;
  	}
  };
  LoaderSupport.WorkerSupport.NodeLoaderWorker = function (){
  	LoaderSupport.WorkerSupport.LoaderWorker.call( this );
  };

  LoaderSupport.WorkerSupport.NodeLoaderWorker.prototype = Object.create( LoaderSupport.WorkerSupport.LoaderWorker.prototype );
  LoaderSupport.WorkerSupport.NodeLoaderWorker.prototype.constructor = LoaderSupport.WorkerSupport.NodeLoaderWorker;
  LoaderSupport.WorkerSupport.NodeLoaderWorker.checkSupport = function() {
  	try {
  		// Work around webpack builds failing with NodeJS requires
  		var _require = eval( 'require' );
  		_require.resolve( 'worker_threads' );
  	}
  	catch(e) {
  		return 'This version of Node does not support web workers!';
  	}
  };
  LoaderSupport.WorkerSupport.NodeLoaderWorker.prototype.initWorker = function ( code, runnerImplName ) {
  	var supportError = this.checkSupport();
  	if( supportError ) {

  		throw supportError;

  	}
  	this.runnerImplName = runnerImplName;

  	// Work around webpack builds failing with NodeJS requires
  	var _require = eval( 'require' );
  	var Worker = _require( 'worker_threads' ).Worker;
  	this.worker = new Worker( code, { eval: true } );

  	this.worker.onmessage = this._receiveWorkerMessage;

  	// set referemce to this, then processing in worker scope within "_receiveWorkerMessage" can access members
  	this.worker.runtimeRef = this;

  	// process stored queuedMessage
  	this._postMessage();
  };
  LoaderSupport.WorkerDirector = function ( classDef ) {
  	console.info( 'Using LoaderSupport.WorkerDirector version: ' + LoaderSupport.WorkerDirector.LOADER_WORKER_DIRECTOR_VERSION );
  	this.logging = {
  		enabled: true,
  		debug: false
  	};

  	this.maxQueueSize = LoaderSupport.WorkerDirector.MAX_QUEUE_SIZE ;
  	this.maxWebWorkers = LoaderSupport.WorkerDirector.MAX_WEB_WORKER;
  	this.crossOrigin = null;

  	if ( ! LoaderSupport.Validator.isValid( classDef ) ) { throw 'Provided invalid classDef: ' + classDef; }

  	this.workerDescription = {
  		classDef: classDef,
  		globalCallbacks: {},
  		workerSupports: {},
  		forceWorkerDataCopy: true
  	};
  	this.objectsCompleted = 0;
  	this.instructionQueue = [];
  	this.instructionQueuePointer = 0;

  	this.callbackOnFinishedProcessing = null;
  };
  LoaderSupport.WorkerDirector.LOADER_WORKER_DIRECTOR_VERSION = '2.3.0';
  LoaderSupport.WorkerDirector.MAX_WEB_WORKER = 16;
  LoaderSupport.WorkerDirector.MAX_QUEUE_SIZE = 2048;

  LoaderSupport.WorkerDirector.prototype = {

  	constructor: LoaderSupport.WorkerDirector,
  	
  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  	},
  	getMaxQueueSize: function () {
  		return this.maxQueueSize;
  	},
  	getMaxWebWorkers: function () {
  		return this.maxWebWorkers;
  	},
  	setCrossOrigin: function ( crossOrigin ) {
  		this.crossOrigin = crossOrigin;
  	},
  	setForceWorkerDataCopy: function ( forceWorkerDataCopy ) {
  		this.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;
  	},
  	prepareWorkers: function ( globalCallbacks, maxQueueSize, maxWebWorkers ) {
  		var this$1 = this;

  		if ( LoaderSupport.Validator.isValid( globalCallbacks ) ) { this.workerDescription.globalCallbacks = globalCallbacks; }
  		this.maxQueueSize = Math.min( maxQueueSize, LoaderSupport.WorkerDirector.MAX_QUEUE_SIZE );
  		this.maxWebWorkers = Math.min( maxWebWorkers, LoaderSupport.WorkerDirector.MAX_WEB_WORKER );
  		this.maxWebWorkers = Math.min( this.maxWebWorkers, this.maxQueueSize );
  		this.objectsCompleted = 0;
  		this.instructionQueue = [];
  		this.instructionQueuePointer = 0;

  		for ( var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++ ) {

  			var workerSupport = new LoaderSupport.WorkerSupport();
  			workerSupport.setLogging( this$1.logging.enabled, this$1.logging.debug );
  			workerSupport.setForceWorkerDataCopy( this$1.workerDescription.forceWorkerDataCopy );
  			this$1.workerDescription.workerSupports[ instanceNo ] = {
  				instanceNo: instanceNo,
  				inUse: false,
  				terminateRequested: false,
  				workerSupport: workerSupport,
  				loader: null
  			};

  		}
  	},
  	enqueueForRun: function ( prepData ) {
  		if ( this.instructionQueue.length < this.maxQueueSize ) {
  			this.instructionQueue.push( prepData );
  		}
  	},
  	isRunning: function () {
  		var wsKeys = Object.keys( this.workerDescription.workerSupports );
  		return ( ( this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length ) || wsKeys.length > 0 );
  	},
  	processQueue: function () {
  		var this$1 = this;

  		var prepData, supportDesc;
  		for ( var instanceNo in this$1.workerDescription.workerSupports ) {

  			supportDesc = this$1.workerDescription.workerSupports[ instanceNo ];
  			if ( ! supportDesc.inUse ) {

  				if ( this$1.instructionQueuePointer < this$1.instructionQueue.length ) {

  					prepData = this$1.instructionQueue[ this$1.instructionQueuePointer ];
  					this$1._kickWorkerRun( prepData, supportDesc );
  					this$1.instructionQueuePointer++;

  				} else {

  					this$1._deregister( supportDesc );

  				}

  			}

  		}

  		if ( ! this.isRunning() && this.callbackOnFinishedProcessing !== null ) {

  			this.callbackOnFinishedProcessing();
  			this.callbackOnFinishedProcessing = null;

  		}
  	},

  	_kickWorkerRun: function( prepData, supportDesc ) {
  		supportDesc.inUse = true;
  		supportDesc.workerSupport.setTerminateRequested( supportDesc.terminateRequested );

  		if ( this.logging.enabled ) { console.info( '\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\n\n' ); }

  		var validator = LoaderSupport.Validator;
  		var scope = this;
  		var prepDataCallbacks = prepData.getCallbacks();
  		var globalCallbacks = this.workerDescription.globalCallbacks;
  		var wrapperOnLoad = function ( event ) {
  			if ( validator.isValid( globalCallbacks.onLoad ) ) { globalCallbacks.onLoad( event ); }
  			if ( validator.isValid( prepDataCallbacks.onLoad ) ) { prepDataCallbacks.onLoad( event ); }
  			scope.objectsCompleted++;
  			supportDesc.inUse = false;

  			scope.processQueue();
  		};

  		var wrapperOnProgress = function ( event ) {
  			if ( validator.isValid( globalCallbacks.onProgress ) ) { globalCallbacks.onProgress( event ); }
  			if ( validator.isValid( prepDataCallbacks.onProgress ) ) { prepDataCallbacks.onProgress( event ); }
  		};

  		var wrapperOnMeshAlter = function ( event, override ) {
  			if ( validator.isValid( globalCallbacks.onMeshAlter ) ) { override = globalCallbacks.onMeshAlter( event, override ); }
  			if ( validator.isValid( prepDataCallbacks.onMeshAlter ) ) { override = globalCallbacks.onMeshAlter( event, override ); }
  			return override;
  		};

  		var wrapperOnLoadMaterials = function ( materials ) {
  			if ( validator.isValid( globalCallbacks.onLoadMaterials ) ) { materials = globalCallbacks.onLoadMaterials( materials ); }
  			if ( validator.isValid( prepDataCallbacks.onLoadMaterials ) ) { materials = prepDataCallbacks.onLoadMaterials( materials ); }
  			return materials;
  		};

  		var wrapperOnReportError = function ( errorMessage ) {
  			var continueProcessing = true;
  			if ( validator.isValid( globalCallbacks.onReportError ) ) { continueProcessing = globalCallbacks.onReportError( supportDesc, errorMessage ); }
  			if ( validator.isValid( prepDataCallbacks.onReportError ) )	{ continueProcessing = prepDataCallbacks.onReportError( supportDesc, errorMessage ); }

  			if ( ! validator.isValid( globalCallbacks.onReportError ) && ! validator.isValid( prepDataCallbacks.onReportError ) ) {

  				console.error( 'Loader reported an error: ' );
  				console.error( errorMessage );

  			}
  			if ( continueProcessing ) {

  				supportDesc.inUse = false;
  				scope.processQueue();

  			}
  		};

  		supportDesc.loader = this._buildLoader( supportDesc.instanceNo );

  		var updatedCallbacks = new LoaderSupport.Callbacks();
  		updatedCallbacks.setCallbackOnLoad( wrapperOnLoad );
  		updatedCallbacks.setCallbackOnProgress( wrapperOnProgress );
  		updatedCallbacks.setCallbackOnReportError( wrapperOnReportError );
  		updatedCallbacks.setCallbackOnMeshAlter( wrapperOnMeshAlter );
  		updatedCallbacks.setCallbackOnLoadMaterials( wrapperOnLoadMaterials );
  		prepData.callbacks = updatedCallbacks;

  		supportDesc.loader.run( prepData, supportDesc.workerSupport );
  	},

  	_buildLoader: function ( instanceNo ) {
  		var classDef = this.workerDescription.classDef;
  		var loader = Object.create( classDef.prototype );
  		classDef.call( loader, DefaultLoadingManager );

  		// verify that all required functions are implemented
  		if ( ! loader.hasOwnProperty( 'instanceNo' ) ) { throw classDef.name + ' has no property "instanceNo".'; }
  		loader.instanceNo = instanceNo;

  		if ( ! loader.hasOwnProperty( 'workerSupport' ) ) {

  			throw classDef.name + ' has no property "workerSupport".';

  		}
  		if ( typeof loader.run !== 'function'  ) { throw classDef.name + ' has no function "run".'; }
  		if ( ! loader.hasOwnProperty( 'callbacks' ) || ! LoaderSupport.Validator.isValid( loader.callbacks ) ) {

  			console.warn( classDef.name + ' has an invalid property "callbacks". Will change to "LoaderSupport.Callbacks"' );
  			loader.callbacks = new LoaderSupport.Callbacks();

  		}

  		return loader;
  	},

  	_deregister: function ( supportDesc ) {
  		if ( LoaderSupport.Validator.isValid( supportDesc ) ) {

  			supportDesc.workerSupport.setTerminateRequested( true );
  			if ( this.logging.enabled ) { console.info( 'Requested termination of worker #' + supportDesc.instanceNo + '.' ); }

  			var loaderCallbacks = supportDesc.loader.callbacks;
  			if ( LoaderSupport.Validator.isValid( loaderCallbacks.onProgress ) ) { loaderCallbacks.onProgress( { detail: { text: '' } } ); }
  			delete this.workerDescription.workerSupports[ supportDesc.instanceNo ];

  		}
  	},
  	tearDown: function ( callbackOnFinishedProcessing ) {
  		var this$1 = this;

  		if ( this.logging.enabled ) { console.info( 'WorkerDirector received the deregister call. Terminating all workers!' ); }

  		this.instructionQueuePointer = this.instructionQueue.length;
  		this.callbackOnFinishedProcessing = LoaderSupport.Validator.verifyInput( callbackOnFinishedProcessing, null );

  		for ( var name in this$1.workerDescription.workerSupports ) {

  			this$1.workerDescription.workerSupports[ name ].terminateRequested = true;

  		}
  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MD2Loader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  MD2Loader.prototype = {

  	constructor: MD2Loader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( buffer ) {

  			onLoad( scope.parse( buffer ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: ( function () {

  		var normalData = [
  			[ - 0.525731, 0.000000, 0.850651 ], [ - 0.442863, 0.238856, 0.864188 ],
  			[ - 0.295242, 0.000000, 0.955423 ], [ - 0.309017, 0.500000, 0.809017 ],
  			[ - 0.162460, 0.262866, 0.951056 ], [ 0.000000, 0.000000, 1.000000 ],
  			[ 0.000000, 0.850651, 0.525731 ], [ - 0.147621, 0.716567, 0.681718 ],
  			[ 0.147621, 0.716567, 0.681718 ], [ 0.000000, 0.525731, 0.850651 ],
  			[ 0.309017, 0.500000, 0.809017 ], [ 0.525731, 0.000000, 0.850651 ],
  			[ 0.295242, 0.000000, 0.955423 ], [ 0.442863, 0.238856, 0.864188 ],
  			[ 0.162460, 0.262866, 0.951056 ], [ - 0.681718, 0.147621, 0.716567 ],
  			[ - 0.809017, 0.309017, 0.500000 ], [ - 0.587785, 0.425325, 0.688191 ],
  			[ - 0.850651, 0.525731, 0.000000 ], [ - 0.864188, 0.442863, 0.238856 ],
  			[ - 0.716567, 0.681718, 0.147621 ], [ - 0.688191, 0.587785, 0.425325 ],
  			[ - 0.500000, 0.809017, 0.309017 ], [ - 0.238856, 0.864188, 0.442863 ],
  			[ - 0.425325, 0.688191, 0.587785 ], [ - 0.716567, 0.681718, - 0.147621 ],
  			[ - 0.500000, 0.809017, - 0.309017 ], [ - 0.525731, 0.850651, 0.000000 ],
  			[ 0.000000, 0.850651, - 0.525731 ], [ - 0.238856, 0.864188, - 0.442863 ],
  			[ 0.000000, 0.955423, - 0.295242 ], [ - 0.262866, 0.951056, - 0.162460 ],
  			[ 0.000000, 1.000000, 0.000000 ], [ 0.000000, 0.955423, 0.295242 ],
  			[ - 0.262866, 0.951056, 0.162460 ], [ 0.238856, 0.864188, 0.442863 ],
  			[ 0.262866, 0.951056, 0.162460 ], [ 0.500000, 0.809017, 0.309017 ],
  			[ 0.238856, 0.864188, - 0.442863 ], [ 0.262866, 0.951056, - 0.162460 ],
  			[ 0.500000, 0.809017, - 0.309017 ], [ 0.850651, 0.525731, 0.000000 ],
  			[ 0.716567, 0.681718, 0.147621 ], [ 0.716567, 0.681718, - 0.147621 ],
  			[ 0.525731, 0.850651, 0.000000 ], [ 0.425325, 0.688191, 0.587785 ],
  			[ 0.864188, 0.442863, 0.238856 ], [ 0.688191, 0.587785, 0.425325 ],
  			[ 0.809017, 0.309017, 0.500000 ], [ 0.681718, 0.147621, 0.716567 ],
  			[ 0.587785, 0.425325, 0.688191 ], [ 0.955423, 0.295242, 0.000000 ],
  			[ 1.000000, 0.000000, 0.000000 ], [ 0.951056, 0.162460, 0.262866 ],
  			[ 0.850651, - 0.525731, 0.000000 ], [ 0.955423, - 0.295242, 0.000000 ],
  			[ 0.864188, - 0.442863, 0.238856 ], [ 0.951056, - 0.162460, 0.262866 ],
  			[ 0.809017, - 0.309017, 0.500000 ], [ 0.681718, - 0.147621, 0.716567 ],
  			[ 0.850651, 0.000000, 0.525731 ], [ 0.864188, 0.442863, - 0.238856 ],
  			[ 0.809017, 0.309017, - 0.500000 ], [ 0.951056, 0.162460, - 0.262866 ],
  			[ 0.525731, 0.000000, - 0.850651 ], [ 0.681718, 0.147621, - 0.716567 ],
  			[ 0.681718, - 0.147621, - 0.716567 ], [ 0.850651, 0.000000, - 0.525731 ],
  			[ 0.809017, - 0.309017, - 0.500000 ], [ 0.864188, - 0.442863, - 0.238856 ],
  			[ 0.951056, - 0.162460, - 0.262866 ], [ 0.147621, 0.716567, - 0.681718 ],
  			[ 0.309017, 0.500000, - 0.809017 ], [ 0.425325, 0.688191, - 0.587785 ],
  			[ 0.442863, 0.238856, - 0.864188 ], [ 0.587785, 0.425325, - 0.688191 ],
  			[ 0.688191, 0.587785, - 0.425325 ], [ - 0.147621, 0.716567, - 0.681718 ],
  			[ - 0.309017, 0.500000, - 0.809017 ], [ 0.000000, 0.525731, - 0.850651 ],
  			[ - 0.525731, 0.000000, - 0.850651 ], [ - 0.442863, 0.238856, - 0.864188 ],
  			[ - 0.295242, 0.000000, - 0.955423 ], [ - 0.162460, 0.262866, - 0.951056 ],
  			[ 0.000000, 0.000000, - 1.000000 ], [ 0.295242, 0.000000, - 0.955423 ],
  			[ 0.162460, 0.262866, - 0.951056 ], [ - 0.442863, - 0.238856, - 0.864188 ],
  			[ - 0.309017, - 0.500000, - 0.809017 ], [ - 0.162460, - 0.262866, - 0.951056 ],
  			[ 0.000000, - 0.850651, - 0.525731 ], [ - 0.147621, - 0.716567, - 0.681718 ],
  			[ 0.147621, - 0.716567, - 0.681718 ], [ 0.000000, - 0.525731, - 0.850651 ],
  			[ 0.309017, - 0.500000, - 0.809017 ], [ 0.442863, - 0.238856, - 0.864188 ],
  			[ 0.162460, - 0.262866, - 0.951056 ], [ 0.238856, - 0.864188, - 0.442863 ],
  			[ 0.500000, - 0.809017, - 0.309017 ], [ 0.425325, - 0.688191, - 0.587785 ],
  			[ 0.716567, - 0.681718, - 0.147621 ], [ 0.688191, - 0.587785, - 0.425325 ],
  			[ 0.587785, - 0.425325, - 0.688191 ], [ 0.000000, - 0.955423, - 0.295242 ],
  			[ 0.000000, - 1.000000, 0.000000 ], [ 0.262866, - 0.951056, - 0.162460 ],
  			[ 0.000000, - 0.850651, 0.525731 ], [ 0.000000, - 0.955423, 0.295242 ],
  			[ 0.238856, - 0.864188, 0.442863 ], [ 0.262866, - 0.951056, 0.162460 ],
  			[ 0.500000, - 0.809017, 0.309017 ], [ 0.716567, - 0.681718, 0.147621 ],
  			[ 0.525731, - 0.850651, 0.000000 ], [ - 0.238856, - 0.864188, - 0.442863 ],
  			[ - 0.500000, - 0.809017, - 0.309017 ], [ - 0.262866, - 0.951056, - 0.162460 ],
  			[ - 0.850651, - 0.525731, 0.000000 ], [ - 0.716567, - 0.681718, - 0.147621 ],
  			[ - 0.716567, - 0.681718, 0.147621 ], [ - 0.525731, - 0.850651, 0.000000 ],
  			[ - 0.500000, - 0.809017, 0.309017 ], [ - 0.238856, - 0.864188, 0.442863 ],
  			[ - 0.262866, - 0.951056, 0.162460 ], [ - 0.864188, - 0.442863, 0.238856 ],
  			[ - 0.809017, - 0.309017, 0.500000 ], [ - 0.688191, - 0.587785, 0.425325 ],
  			[ - 0.681718, - 0.147621, 0.716567 ], [ - 0.442863, - 0.238856, 0.864188 ],
  			[ - 0.587785, - 0.425325, 0.688191 ], [ - 0.309017, - 0.500000, 0.809017 ],
  			[ - 0.147621, - 0.716567, 0.681718 ], [ - 0.425325, - 0.688191, 0.587785 ],
  			[ - 0.162460, - 0.262866, 0.951056 ], [ 0.442863, - 0.238856, 0.864188 ],
  			[ 0.162460, - 0.262866, 0.951056 ], [ 0.309017, - 0.500000, 0.809017 ],
  			[ 0.147621, - 0.716567, 0.681718 ], [ 0.000000, - 0.525731, 0.850651 ],
  			[ 0.425325, - 0.688191, 0.587785 ], [ 0.587785, - 0.425325, 0.688191 ],
  			[ 0.688191, - 0.587785, 0.425325 ], [ - 0.955423, 0.295242, 0.000000 ],
  			[ - 0.951056, 0.162460, 0.262866 ], [ - 1.000000, 0.000000, 0.000000 ],
  			[ - 0.850651, 0.000000, 0.525731 ], [ - 0.955423, - 0.295242, 0.000000 ],
  			[ - 0.951056, - 0.162460, 0.262866 ], [ - 0.864188, 0.442863, - 0.238856 ],
  			[ - 0.951056, 0.162460, - 0.262866 ], [ - 0.809017, 0.309017, - 0.500000 ],
  			[ - 0.864188, - 0.442863, - 0.238856 ], [ - 0.951056, - 0.162460, - 0.262866 ],
  			[ - 0.809017, - 0.309017, - 0.500000 ], [ - 0.681718, 0.147621, - 0.716567 ],
  			[ - 0.681718, - 0.147621, - 0.716567 ], [ - 0.850651, 0.000000, - 0.525731 ],
  			[ - 0.688191, 0.587785, - 0.425325 ], [ - 0.587785, 0.425325, - 0.688191 ],
  			[ - 0.425325, 0.688191, - 0.587785 ], [ - 0.425325, - 0.688191, - 0.587785 ],
  			[ - 0.587785, - 0.425325, - 0.688191 ], [ - 0.688191, - 0.587785, - 0.425325 ]
  		];

  		return function ( buffer ) {

  			console.time( 'MD2Loader' );

  			var data = new DataView( buffer );

  			// http://tfc.duke.free.fr/coding/md2-specs-en.html

  			var header = {};
  			var headerNames = [
  				'ident', 'version',
  				'skinwidth', 'skinheight',
  				'framesize',
  				'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames',
  				'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'
  			];

  			for ( var i = 0; i < headerNames.length; i ++ ) {

  				header[ headerNames[ i ] ] = data.getInt32( i * 4, true );

  			}

  			if ( header.ident !== 844121161 || header.version !== 8 ) {

  				console.error( 'Not a valid MD2 file' );
  				return;

  			}

  			if ( header.offset_end !== data.byteLength ) {

  				console.error( 'Corrupted MD2 file' );
  				return;

  			}

  			//

  			var geometry = new BufferGeometry();

  			// uvs

  			var uvsTemp = [];
  			var offset = header.offset_st;

  			for ( var i = 0, l = header.num_st; i < l; i ++ ) {

  				var u = data.getInt16( offset + 0, true );
  				var v = data.getInt16( offset + 2, true );

  				uvsTemp.push( u / header.skinwidth, 1 - ( v / header.skinheight ) );

  				offset += 4;

  			}

  			// triangles

  			offset = header.offset_tris;

  			var vertexIndices = [];
  			var uvIndices = [];

  			for ( var i = 0, l = header.num_tris; i < l; i ++ ) {

  				vertexIndices.push(
  					data.getUint16( offset + 0, true ),
  					data.getUint16( offset + 2, true ),
  					data.getUint16( offset + 4, true )
  				);

  				uvIndices.push(
  					data.getUint16( offset + 6, true ),
  					data.getUint16( offset + 8, true ),
  					data.getUint16( offset + 10, true )
  				);

  				offset += 12;

  			}

  			// frames

  			var translation = new Vector3();
  			var scale = new Vector3();
  			var string = [];

  			var frames = [];

  			offset = header.offset_frames;

  			for ( var i = 0, l = header.num_frames; i < l; i ++ ) {

  				scale.set(
  					data.getFloat32( offset + 0, true ),
  					data.getFloat32( offset + 4, true ),
  					data.getFloat32( offset + 8, true )
  				);

  				translation.set(
  					data.getFloat32( offset + 12, true ),
  					data.getFloat32( offset + 16, true ),
  					data.getFloat32( offset + 20, true )
  				);

  				offset += 24;

  				for ( var j = 0; j < 16; j ++ ) {

  					var character = data.getUint8( offset + j, true );
  					if ( character === 0 ) { break; }

  					string[ j ] = character;

  				}

  				var frame = {
  					name: String.fromCharCode.apply( null, string ),
  					vertices: [],
  					normals: []
  				};

  				offset += 16;

  				for ( var j = 0; j < header.num_vertices; j ++ ) {

  					var x = data.getUint8( offset ++, true );
  					var y = data.getUint8( offset ++, true );
  					var z = data.getUint8( offset ++, true );
  					var n = normalData[ data.getUint8( offset ++, true ) ];

  					x = x * scale.x + translation.x;
  					y = y * scale.y + translation.y;
  					z = z * scale.z + translation.z;

  					frame.vertices.push( x, z, y ); // convert to Y-up
  					frame.normals.push( n[ 0 ], n[ 2 ], n[ 1 ] ); // convert to Y-up

  				}

  				frames.push( frame );

  			}

  			// static

  			var positions = [];
  			var normals = [];
  			var uvs = [];

  			var verticesTemp = frames[ 0 ].vertices;
  			var normalsTemp = frames[ 0 ].normals;

  			for ( var i = 0, l = vertexIndices.length; i < l; i ++ ) {

  				var vertexIndex = vertexIndices[ i ];
  				var stride = vertexIndex * 3;

  				//

  				var x = verticesTemp[ stride ];
  				var y = verticesTemp[ stride + 1 ];
  				var z = verticesTemp[ stride + 2 ];

  				positions.push( x, y, z );

  				//

  				var nx = normalsTemp[ stride ];
  				var ny = normalsTemp[ stride + 1 ];
  				var nz = normalsTemp[ stride + 2 ];

  				normals.push( nx, ny, nz );

  				//

  				var uvIndex = uvIndices[ i ];
  				stride = uvIndex * 2;

  				var u = uvsTemp[ stride ];
  				var v = uvsTemp[ stride + 1 ];

  				uvs.push( u, v );

  			}

  			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  			geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  			geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  			// animation

  			var morphPositions = [];
  			var morphNormals = [];

  			for ( var i = 0, l = frames.length; i < l; i ++ ) {

  				var frame = frames[ i ];
  				var attributeName = frame.name;

  				if ( frame.vertices.length > 0 ) {

  					var positions = [];

  					for ( var j = 0, jl = vertexIndices.length; j < jl; j ++ ) {

  						var vertexIndex = vertexIndices[ j ];
  						var stride = vertexIndex * 3;

  						var x = frame.vertices[ stride ];
  						var y = frame.vertices[ stride + 1 ];
  						var z = frame.vertices[ stride + 2 ];

  						positions.push( x, y, z );

  					}

  					var positionAttribute = new Float32BufferAttribute( positions, 3 );
  					positionAttribute.name = attributeName;

  					morphPositions.push( positionAttribute );

  				}

  				if ( frame.normals.length > 0 ) {

  					var normals = [];

  					for ( var j = 0, jl = vertexIndices.length; j < jl; j ++ ) {

  						var vertexIndex = vertexIndices[ j ];
  						var stride = vertexIndex * 3;

  						var nx = frame.normals[ stride ];
  						var ny = frame.normals[ stride + 1 ];
  						var nz = frame.normals[ stride + 2 ];

  						normals.push( nx, ny, nz );

  					}

  					var normalAttribute = new Float32BufferAttribute( normals, 3 );
  					normalAttribute.name = attributeName;

  					morphNormals.push( normalAttribute );

  				}

  			}

  			geometry.morphAttributes.position = morphPositions;
  			geometry.morphAttributes.normal = morphNormals;

  			geometry.animations = AnimationClip.CreateClipsFromMorphTargetSequences( frames, 10 );

  			console.timeEnd( 'MD2Loader' );

  			return geometry;

  		};

  	} )()

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MMDLoader = ( function () {
  	function MMDLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.loader = new FileLoader( this.manager );

  		this.parser = null; // lazy generation
  		this.meshBuilder = new MeshBuilder( this.manager );
  		this.animationBuilder = new AnimationBuilder();

  	}

  	MMDLoader.prototype = {

  		constructor: MMDLoader,

  		crossOrigin: 'anonymous',
  		setCrossOrigin: function ( crossOrigin ) {

  			this.crossOrigin = crossOrigin;
  			return this;

  		},
  		setAnimationPath: function ( animationPath ) {

  			this.animationPath = animationPath;
  			return this;

  		},
  		setPath: function ( path ) {

  			this.path = path;
  			return this;

  		},
  		setResoucePath: function ( resourcePath ) {

  			this.resourcePath = resourcePath;
  			return this;

  		},

  		// Load MMD assets as Three.js Object
  		load: function ( url, onLoad, onProgress, onError ) {

  			var builder = this.meshBuilder.setCrossOrigin( this.crossOrigin );

  			// resource path

  			var resourcePath;

  			if ( this.resourcePath !== undefined ) {

  				resourcePath = this.resourcePath;

  			} else if ( this.path !== undefined ) {

  				resourcePath = this.path;

  			} else {

  				resourcePath = LoaderUtils.extractUrlBase( url );

  			}

  			var modelExtension = this._extractExtension( url ).toLowerCase();

  			// Should I detect by seeing header?
  			if ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) {

  				if ( onError ) { onError( new Error( 'MMDLoader: Unknown model file extension .' + modelExtension + '.' ) ); }

  				return;

  			}

  			this[ modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX' ]( url, function ( data ) {

  				onLoad(	builder.build( data, resourcePath, onProgress, onError )	);

  			}, onProgress, onError );

  		},
  		loadAnimation: function ( url, object, onLoad, onProgress, onError ) {

  			var builder = this.animationBuilder;

  			this.loadVMD( url, function ( vmd ) {

  				onLoad( object.isCamera
  					? builder.buildCameraAnimation( vmd )
  					: builder.build( vmd, object ) );

  			}, onProgress, onError );

  		},
  		loadWithAnimation: function ( modelUrl, vmdUrl, onLoad, onProgress, onError ) {

  			var scope = this;

  			this.load( modelUrl, function ( mesh ) {

  				scope.loadAnimation( vmdUrl, mesh, function ( animation ) {

  					onLoad( {
  						mesh: mesh,
  						animation: animation
  					} );

  				}, onProgress, onError );

  			}, onProgress, onError );

  		},

  		// Load MMD assets as Object data parsed by MMDParser
  		loadPMD: function ( url, onLoad, onProgress, onError ) {

  			var parser = this._getParser();

  			this.loader
  				.setMimeType( undefined )
  				.setPath( this.path )
  				.setResponseType( 'arraybuffer' )
  				.load( url, function ( buffer ) {

  					onLoad( parser.parsePmd( buffer, true ) );

  				}, onProgress, onError );

  		},
  		loadPMX: function ( url, onLoad, onProgress, onError ) {

  			var parser = this._getParser();

  			this.loader
  				.setMimeType( undefined )
  				.setPath( this.path )
  				.setResponseType( 'arraybuffer' )
  				.load( url, function ( buffer ) {

  					onLoad( parser.parsePmx( buffer, true ) );

  				}, onProgress, onError );

  		},
  		loadVMD: function ( url, onLoad, onProgress, onError ) {
  			var this$1 = this;


  			var urls = Array.isArray( url ) ? url : [ url ];

  			var vmds = [];
  			var vmdNum = urls.length;

  			var parser = this._getParser();

  			this.loader
  				.setMimeType( undefined )
  				.setPath( this.animationPath )
  				.setResponseType( 'arraybuffer' );

  			for ( var i = 0, il = urls.length; i < il; i ++ ) {

  				this$1.loader.load( urls[ i ], function ( buffer ) {

  					vmds.push( parser.parseVmd( buffer, true ) );

  					if ( vmds.length === vmdNum ) { onLoad( parser.mergeVmds( vmds ) ); }

  				}, onProgress, onError );

  			}

  		},
  		loadVPD: function ( url, isUnicode, onLoad, onProgress, onError ) {

  			var parser = this._getParser();

  			this.loader
  				.setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' )
  				.setPath( this.animationPath )
  				.setResponseType( 'text' )
  				.load( url, function ( text ) {

  					onLoad( parser.parseVpd( text, true ) );

  				}, onProgress, onError );

  		},

  		// private methods

  		_extractExtension: function ( url ) {

  			var index = url.lastIndexOf( '.' );
  			return index < 0 ? '' : url.slice( index + 1 );

  		},

  		_getParser: function () {

  			if ( this.parser === null ) {

  				if ( typeof MMDParser === 'undefined' ) {

  					throw new Error( 'MMDLoader: Import MMDParser https://github.com/takahirox/mmd-parser' );

  				}

  				this.parser = new MMDParser.Parser();

  			}

  			return this.parser;

  		}

  	};

  	// Utilities
  	var DEFAULT_TOON_TEXTURES = [
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',
  		'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='
  	];

  	// Builders. They build Three.js object from Object data parsed by MMDParser.
  	function MeshBuilder( manager ) {

  		this.geometryBuilder = new GeometryBuilder();
  		this.materialBuilder = new MaterialBuilder( manager );

  	}

  	MeshBuilder.prototype = {

  		constructor: MeshBuilder,

  		crossOrigin: 'anonymous',
  		setCrossOrigin: function ( crossOrigin ) {

  			this.crossOrigin = crossOrigin;
  			return this;

  		},
  		build: function ( data, resourcePath, onProgress, onError ) {

  			var geometry = this.geometryBuilder.build( data );
  			var material = this.materialBuilder
  				.setCrossOrigin( this.crossOrigin )
  				.setResourcePath( resourcePath )
  				.build( data, geometry, onProgress, onError );

  			var mesh = new SkinnedMesh( geometry, material );

  			var skeleton = new Skeleton( initBones( mesh ) );
  			mesh.bind( skeleton );

  			// console.log( mesh ); // for console debug

  			return mesh;

  		}

  	};

  	// TODO: Try to remove this function

  	function initBones( mesh ) {

  		var geometry = mesh.geometry;

  		var bones = [], bone, gbone;
  		var i, il;

  		if ( geometry && geometry.bones !== undefined ) {

  			// first, create array of 'Bone' objects from geometry data

  			for ( i = 0, il = geometry.bones.length; i < il; i ++ ) {

  				gbone = geometry.bones[ i ];

  				// create new 'Bone' object

  				bone = new Bone();
  				bones.push( bone );

  				// apply values

  				bone.name = gbone.name;
  				bone.position.fromArray( gbone.pos );
  				bone.quaternion.fromArray( gbone.rotq );
  				if ( gbone.scl !== undefined ) { bone.scale.fromArray( gbone.scl ); }

  			}

  			// second, create bone hierarchy

  			for ( i = 0, il = geometry.bones.length; i < il; i ++ ) {

  				gbone = geometry.bones[ i ];

  				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

  					// subsequent bones in the hierarchy

  					bones[ gbone.parent ].add( bones[ i ] );

  				} else {

  					// topmost bone, immediate child of the skinned mesh

  					mesh.add( bones[ i ] );

  				}

  			}

  		}

  		// now the bones are part of the scene graph and children of the skinned mesh.
  		// let's update the corresponding matrices

  		mesh.updateMatrixWorld( true );

  		return bones;

  	}

  	//

  	function GeometryBuilder() {

  	}

  	GeometryBuilder.prototype = {

  		constructor: GeometryBuilder,
  		build: function ( data ) {

  			// for geometry
  			var positions = [];
  			var uvs = [];
  			var normals = [];

  			var indices = [];

  			var groups = [];

  			var bones = [];
  			var skinIndices = [];
  			var skinWeights = [];

  			var morphTargets = [];
  			var morphPositions = [];

  			var iks = [];
  			var grants = [];

  			var rigidBodies = [];
  			var constraints = [];

  			// for work
  			var offset = 0;
  			var boneTypeTable = {};

  			// positions, normals, uvs, skinIndices, skinWeights

  			for ( var i = 0; i < data.metadata.vertexCount; i ++ ) {

  				var v = data.vertices[ i ];

  				for ( var j = 0, jl = v.position.length; j < jl; j ++ ) {

  					positions.push( v.position[ j ] );

  				}

  				for ( var j = 0, jl = v.normal.length; j < jl; j ++ ) {

  					normals.push( v.normal[ j ] );

  				}

  				for ( var j = 0, jl = v.uv.length; j < jl; j ++ ) {

  					uvs.push( v.uv[ j ] );

  				}

  				for ( var j = 0; j < 4; j ++ ) {

  					skinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 );

  				}

  				for ( var j = 0; j < 4; j ++ ) {

  					skinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 );

  				}

  			}

  			// indices

  			for ( var i = 0; i < data.metadata.faceCount; i ++ ) {

  				var face = data.faces[ i ];

  				for ( var j = 0, jl = face.indices.length; j < jl; j ++ ) {

  					indices.push( face.indices[ j ] );

  				}

  			}

  			// groups

  			for ( var i = 0; i < data.metadata.materialCount; i ++ ) {

  				var material = data.materials[ i ];

  				groups.push( {
  					offset: offset * 3,
  					count: material.faceCount * 3
  				} );

  				offset += material.faceCount;

  			}

  			// bones

  			for ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {

  				var body = data.rigidBodies[ i ];
  				var value = boneTypeTable[ body.boneIndex ];

  				// keeps greater number if already value is set without any special reasons
  				value = value === undefined ? body.type : Math.max( body.type, value );

  				boneTypeTable[ body.boneIndex ] = value;

  			}

  			for ( var i = 0; i < data.metadata.boneCount; i ++ ) {

  				var boneData = data.bones[ i ];

  				var bone = {
  					parent: boneData.parentIndex,
  					name: boneData.name,
  					pos: boneData.position.slice( 0, 3 ),
  					rotq: [ 0, 0, 0, 1 ],
  					scl: [ 1, 1, 1 ],
  					rigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1
  				};

  				if ( bone.parent !== - 1 ) {

  					bone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ];
  					bone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ];
  					bone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ];

  				}

  				bones.push( bone );

  			}

  			// iks

  			// TODO: remove duplicated codes between PMD and PMX
  			if ( data.metadata.format === 'pmd' ) {

  				for ( var i = 0; i < data.metadata.ikCount; i ++ ) {

  					var ik = data.iks[ i ];

  					var param = {
  						target: ik.target,
  						effector: ik.effector,
  						iteration: ik.iteration,
  						maxAngle: ik.maxAngle * 4,
  						links: []
  					};

  					for ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {

  						var link = {};
  						link.index = ik.links[ j ].index;
  						link.enabled = true;

  						if ( data.bones[ link.index ].name.indexOf( '' ) >= 0 ) {

  							link.limitation = new Vector3( 1.0, 0.0, 0.0 );

  						}

  						param.links.push( link );

  					}

  					iks.push( param );

  				}

  			} else {

  				for ( var i = 0; i < data.metadata.boneCount; i ++ ) {

  					var ik = data.bones[ i ].ik;

  					if ( ik === undefined ) { continue; }

  					var param = {
  						target: i,
  						effector: ik.effector,
  						iteration: ik.iteration,
  						maxAngle: ik.maxAngle,
  						links: []
  					};

  					for ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {

  						var link = {};
  						link.index = ik.links[ j ].index;
  						link.enabled = true;

  						if ( ik.links[ j ].angleLimitation === 1 ) {

  							// Revert if rotationMin/Max doesn't work well
  							// link.limitation = new Vector3( 1.0, 0.0, 0.0 );

  							var rotationMin = ik.links[ j ].lowerLimitationAngle;
  							var rotationMax = ik.links[ j ].upperLimitationAngle;

  							// Convert Left to Right coordinate by myself because
  							// MMDParser doesn't convert. It's a MMDParser's bug

  							var tmp1 = - rotationMax[ 0 ];
  							var tmp2 = - rotationMax[ 1 ];
  							rotationMax[ 0 ] = - rotationMin[ 0 ];
  							rotationMax[ 1 ] = - rotationMin[ 1 ];
  							rotationMin[ 0 ] = tmp1;
  							rotationMin[ 1 ] = tmp2;

  							link.rotationMin = new Vector3().fromArray( rotationMin );
  							link.rotationMax = new Vector3().fromArray( rotationMax );

  						}

  						param.links.push( link );

  					}

  					iks.push( param );

  				}

  			}

  			// grants

  			if ( data.metadata.format === 'pmx' ) {

  				for ( var i = 0; i < data.metadata.boneCount; i ++ ) {

  					var boneData = data.bones[ i ];
  					var grant = boneData.grant;

  					if ( grant === undefined ) { continue; }

  					var param = {
  						index: i,
  						parentIndex: grant.parentIndex,
  						ratio: grant.ratio,
  						isLocal: grant.isLocal,
  						affectRotation: grant.affectRotation,
  						affectPosition: grant.affectPosition,
  						transformationClass: boneData.transformationClass
  					};

  					grants.push( param );

  				}

  				grants.sort( function ( a, b ) {

  					return a.transformationClass - b.transformationClass;

  				} );

  			}

  			// morph

  			function updateAttributes( attribute, morph, ratio ) {

  				for ( var i = 0; i < morph.elementCount; i ++ ) {

  					var element = morph.elements[ i ];

  					var index;

  					if ( data.metadata.format === 'pmd' ) {

  						index = data.morphs[ 0 ].elements[ element.index ].index;

  					} else {

  						index = element.index;

  					}

  					attribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio;
  					attribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio;
  					attribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio;

  				}

  			}

  			for ( var i = 0; i < data.metadata.morphCount; i ++ ) {

  				var morph = data.morphs[ i ];
  				var params = { name: morph.name };

  				var attribute = new Float32BufferAttribute( data.metadata.vertexCount * 3, 3 );
  				attribute.name = morph.name;

  				for ( var j = 0; j < data.metadata.vertexCount * 3; j ++ ) {

  					attribute.array[ j ] = positions[ j ];

  				}

  				if ( data.metadata.format === 'pmd' ) {

  					if ( i !== 0 ) {

  						updateAttributes( attribute, morph, 1.0 );

  					}

  				} else {

  					if ( morph.type === 0 ) { // group

  						for ( var j = 0; j < morph.elementCount; j ++ ) {

  							var morph2 = data.morphs[ morph.elements[ j ].index ];
  							var ratio = morph.elements[ j ].ratio;

  							if ( morph2.type === 1 ) {

  								updateAttributes( attribute, morph2, ratio );

  							}

  						}

  					} else if ( morph.type === 1 ) { // vertex

  						updateAttributes( attribute, morph, 1.0 );

  					} else if ( morph.type === 2 ) ; else if ( morph.type === 3 ) ; else if ( morph.type === 4 ) ; else if ( morph.type === 5 ) ; else if ( morph.type === 6 ) ; else if ( morph.type === 7 ) ; else if ( morph.type === 8 ) ;

  				}

  				morphTargets.push( params );
  				morphPositions.push( attribute );

  			}

  			// rigid bodies from rigidBodies field.

  			for ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {

  				var rigidBody = data.rigidBodies[ i ];
  				var params = {};

  				for ( var key in rigidBody ) {

  					params[ key ] = rigidBody[ key ];

  				}
  				if ( data.metadata.format === 'pmx' ) {

  					if ( params.boneIndex !== - 1 ) {

  						var bone = data.bones[ params.boneIndex ];
  						params.position[ 0 ] -= bone.position[ 0 ];
  						params.position[ 1 ] -= bone.position[ 1 ];
  						params.position[ 2 ] -= bone.position[ 2 ];

  					}

  				}

  				rigidBodies.push( params );

  			}

  			// constraints from constraints field.

  			for ( var i = 0; i < data.metadata.constraintCount; i ++ ) {

  				var constraint = data.constraints[ i ];
  				var params = {};

  				for ( var key in constraint ) {

  					params[ key ] = constraint[ key ];

  				}

  				var bodyA = rigidBodies[ params.rigidBodyIndex1 ];
  				var bodyB = rigidBodies[ params.rigidBodyIndex2 ];

  				// Refer to http://www20.atpages.jp/katwat/wp/?p=4135
  				if ( bodyA.type !== 0 && bodyB.type === 2 ) {

  					if ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 &&
  					     data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) {

  						bodyB.type = 1;

  					}

  				}

  				constraints.push( params );

  			}

  			// build BufferGeometry.

  			var geometry = new BufferGeometry();

  			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  			geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  			geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
  			geometry.addAttribute( 'skinIndex', new Uint16BufferAttribute( skinIndices, 4 ) );
  			geometry.addAttribute( 'skinWeight', new Float32BufferAttribute( skinWeights, 4 ) );
  			geometry.setIndex( indices );

  			for ( var i = 0, il = groups.length; i < il; i ++ ) {

  				geometry.addGroup( groups[ i ].offset, groups[ i ].count, i );

  			}

  			geometry.bones = bones;

  			geometry.morphTargets = morphTargets;
  			geometry.morphAttributes.position = morphPositions;

  			geometry.userData.MMD = {
  				bones: bones,
  				iks: iks,
  				grants: grants,
  				rigidBodies: rigidBodies,
  				constraints: constraints,
  				format: data.metadata.format
  			};

  			geometry.computeBoundingSphere();

  			return geometry;

  		}

  	};

  	//
  	function MaterialBuilder( manager ) {

  		this.manager = manager;

  		this.textureLoader = new TextureLoader( this.manager );
  		this.tgaLoader = null; // lazy generation

  	}

  	MaterialBuilder.prototype = {

  		constructor: MaterialBuilder,

  		crossOrigin: 'anonymous',

  		resourcePath: undefined,
  		setCrossOrigin: function ( crossOrigin ) {

  			this.crossOrigin = crossOrigin;
  			return this;

  		},
  		setResourcePath: function ( resourcePath ) {

  			this.resourcePath = resourcePath;
  			return this;

  		},
  		build: function ( data, geometry, onProgress, onError ) {
  			var this$1 = this;


  			var materials = [];

  			var textures = {};

  			this.textureLoader.setCrossOrigin( this.crossOrigin );

  			// materials

  			for ( var i = 0; i < data.metadata.materialCount; i ++ ) {

  				var material = data.materials[ i ];

  				var params = { userData: {} };

  				if ( material.name !== undefined ) { params.name = material.name; }
  				params.color = new Color().fromArray( material.diffuse );
  				params.opacity = material.diffuse[ 3 ];
  				params.specular = new Color().fromArray( material.specular );
  				params.emissive = new Color().fromArray( material.ambient );
  				params.shininess = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
  				params.transparent = params.opacity !== 1.0;

  				//

  				params.skinning = geometry.bones.length > 0 ? true : false;
  				params.morphTargets = geometry.morphTargets.length > 0 ? true : false;
  				params.lights = true;
  				params.fog = true;

  				// blend

  				params.blending = CustomBlending;
  				params.blendSrc = SrcAlphaFactor;
  				params.blendDst = OneMinusSrcAlphaFactor;
  				params.blendSrcAlpha = SrcAlphaFactor;
  				params.blendDstAlpha = DstAlphaFactor;

  				// side

  				if ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) {

  					params.side = DoubleSide;

  				} else {

  					params.side = params.opacity === 1.0 ? FrontSide : DoubleSide;

  				}

  				if ( data.metadata.format === 'pmd' ) {

  					// map, envMap

  					if ( material.fileName ) {

  						var fileName = material.fileName;
  						var fileNames = fileName.split( '*' );

  						// fileNames[ 0 ]: mapFileName
  						// fileNames[ 1 ]: envMapFileName( optional )

  						params.map = this$1._loadTexture( fileNames[ 0 ], textures );

  						if ( fileNames.length > 1 ) {

  							var extension = fileNames[ 1 ].slice( - 4 ).toLowerCase();

  							params.envMap = this$1._loadTexture(
  								fileNames[ 1 ],
  								textures,
  								{ sphericalReflectionMapping: true }
  							);

  							params.combine = extension === '.sph'
  								? MultiplyOperation
  								: AddOperation;

  						}

  					}

  					// gradientMap

  					var toonFileName = ( material.toonIndex === - 1 )
  						? 'toon00.bmp'
  						: data.toonTextures[ material.toonIndex ].fileName;

  					params.gradientMap = this$1._loadTexture(
  						toonFileName,
  						textures,
  						{
  							isToonTexture: true,
  							isDefaultToonTexture: this$1._isDefaultToonTexture( toonFileName )
  						}
  					);

  					// parameters for OutlineEffect

  					params.userData.outlineParameters = {
  						thickness: material.edgeFlag === 1 ? 0.003 : 0.0,
  						color: [ 0, 0, 0 ],
  						alpha: 1.0,
  						visible: material.edgeFlag === 1
  					};

  				} else {

  					// map

  					if ( material.textureIndex !== - 1 ) {

  						params.map = this$1._loadTexture( data.textures[ material.textureIndex ], textures );

  					}

  					// envMap TODO: support m.envFlag === 3

  					if ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) {

  						params.envMap = this$1._loadTexture(
  							data.textures[ material.envTextureIndex ],
  							textures, { sphericalReflectionMapping: true }
  						);

  						params.combine = material.envFlag === 1
  							? MultiplyOperation
  							: AddOperation;

  					}

  					// gradientMap

  					var toonFileName, isDefaultToon;

  					if ( material.toonIndex === - 1 || material.toonFlag !== 0 ) {

  						toonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp';
  						isDefaultToon = true;

  					} else {

  						toonFileName = data.textures[ material.toonIndex ];
  						isDefaultToon = false;

  					}

  					params.gradientMap = this$1._loadTexture(
  						toonFileName,
  						textures,
  						{
  							isToonTexture: true,
  							isDefaultToonTexture: isDefaultToon
  						}
  					);

  					// parameters for OutlineEffect
  					params.userData.outlineParameters = {
  						thickness: material.edgeSize / 300, // TODO: better calculation?
  						color: material.edgeColor.slice( 0, 3 ),
  						alpha: material.edgeColor[ 3 ],
  						visible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0
  					};

  				}

  				if ( params.map !== undefined ) {

  					if ( ! params.transparent ) {

  						this$1._checkImageTransparency( params.map, geometry, i );

  					}

  					params.emissive.multiplyScalar( 0.2 );

  				}

  				materials.push( new MeshToonMaterial( params ) );

  			}

  			if ( data.metadata.format === 'pmx' ) {

  				// set transparent true if alpha morph is defined.

  				function checkAlphaMorph( elements, materials ) {

  					for ( var i = 0, il = elements.length; i < il; i ++ ) {

  						var element = elements[ i ];

  						if ( element.index === - 1 ) { continue; }

  						var material = materials[ element.index ];

  						if ( material.opacity !== element.diffuse[ 3 ] ) {

  							material.transparent = true;

  						}

  					}

  				}

  				for ( var i = 0, il = data.morphs.length; i < il; i ++ ) {

  					var morph = data.morphs[ i ];
  					var elements = morph.elements;

  					if ( morph.type === 0 ) {

  						for ( var j = 0, jl = elements.length; j < jl; j ++ ) {

  							var morph2 = data.morphs[ elements[ j ].index ];

  							if ( morph2.type !== 8 ) { continue; }

  							checkAlphaMorph( morph2.elements, materials );

  						}

  					} else if ( morph.type === 8 ) {

  						checkAlphaMorph( elements, materials );

  					}

  				}

  			}

  			return materials;

  		},

  		// private methods

  		_getTGALoader: function () {

  			if ( this.tgaLoader === null ) {

  				if ( TGALoader === undefined ) {

  					throw new Error( 'MMDLoader: Import TGALoader' );

  				}

  				this.tgaLoader = new TGALoader( this.manager );

  			}

  			return this.tgaLoader;

  		},

  		_isDefaultToonTexture: function ( name ) {

  			if ( name.length !== 10 ) { return false; }

  			return /toon(10|0[0-9])\.bmp/.test( name );

  		},

  		_loadTexture: function ( filePath, textures, params, onProgress, onError ) {

  			params = params || {};

  			var scope = this;

  			var fullPath;

  			if ( params.isDefaultToonTexture === true ) {

  				var index;

  				try {

  					index = parseInt( filePath.match( 'toon([0-9]{2})\.bmp$' )[ 1 ] );

  				} catch ( e ) {

  					console.warn( 'MMDLoader: ' + filePath + ' seems like a '
  						+ 'not right default texture path. Using toon00.bmp instead.' );

  					index = 0;

  				}

  				fullPath = DEFAULT_TOON_TEXTURES[ index ];

  			} else {

  				fullPath = this.resourcePath + filePath;

  			}

  			if ( textures[ fullPath ] !== undefined ) { return textures[ fullPath ]; }

  			var loader = Loader.Handlers.get( fullPath );

  			if ( loader === null ) {

  				loader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' )
  					? this._getTGALoader()
  					: this.textureLoader;

  			}

  			var texture = loader.load( fullPath, function ( t ) {

  				// MMD toon texture is Axis-Y oriented
  				// but Three.js gradient map is Axis-X oriented.
  				// So here replaces the toon texture image with the rotated one.
  				if ( params.isToonTexture === true ) {

  					t.image = scope._getRotatedImage( t.image );

  				}

  				t.flipY = false;
  				t.wrapS = RepeatWrapping;
  				t.wrapT = RepeatWrapping;

  				for ( var i = 0; i < texture.readyCallbacks.length; i ++ ) {

  					texture.readyCallbacks[ i ]( texture );

  				}

  				delete texture.readyCallbacks;

  			}, onProgress, onError );

  			if ( params.sphericalReflectionMapping === true ) {

  				texture.mapping = SphericalReflectionMapping;

  			}

  			texture.readyCallbacks = [];

  			textures[ fullPath ] = texture;

  			return texture;

  		},

  		_getRotatedImage: function ( image ) {

  			var canvas = document.createElement( 'canvas' );
  			var context = canvas.getContext( '2d' );

  			var width = image.width;
  			var height = image.height;

  			canvas.width = width;
  			canvas.height = height;

  			context.clearRect( 0, 0, width, height );
  			context.translate( width / 2.0, height / 2.0 );
  			context.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0
  			context.translate( - width / 2.0, - height / 2.0 );
  			context.drawImage( image, 0, 0 );

  			return context.getImageData( 0, 0, width, height );

  		},

  		// Check if the partial image area used by the texture is transparent.
  		_checkImageTransparency: function ( map, geometry, groupIndex ) {

  			map.readyCallbacks.push( function ( texture ) {

  				// Is there any efficient ways?
  				function createImageData( image ) {

  					var canvas = document.createElement( 'canvas' );
  					canvas.width = image.width;
  					canvas.height = image.height;

  					var context = canvas.getContext( '2d' );
  					context.drawImage( image, 0, 0 );

  					return context.getImageData( 0, 0, canvas.width, canvas.height );

  				}

  				function detectImageTransparency( image, uvs, indices ) {

  					var width = image.width;
  					var height = image.height;
  					var data = image.data;
  					var threshold = 253;

  					if ( data.length / ( width * height ) !== 4 ) { return false; }

  					for ( var i = 0; i < indices.length; i += 3 ) {

  						var centerUV = { x: 0.0, y: 0.0 };

  						for ( var j = 0; j < 3; j ++ ) {

  							var index = indices[ i * 3 + j ];
  							var uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] };

  							if ( getAlphaByUv( image, uv ) < threshold ) { return true; }

  							centerUV.x += uv.x;
  							centerUV.y += uv.y;

  						}

  						centerUV.x /= 3;
  						centerUV.y /= 3;

  						if ( getAlphaByUv( image, centerUV ) < threshold ) { return true; }

  					}

  					return false;

  				}
  				function getAlphaByUv( image, uv ) {

  					var width = image.width;
  					var height = image.height;

  					var x = Math.round( uv.x * width ) % width;
  					var y = Math.round( uv.y * height ) % height;

  					if ( x < 0 ) { x += width; }
  					if ( y < 0 ) { y += height; }

  					var index = y * width + x;

  					return image.data[ index * 4 + 3 ];

  				}

  				var imageData = texture.image.data !== undefined
  					? texture.image
  					: createImageData( texture.image );

  				var group = geometry.groups[ groupIndex ];

  				if ( detectImageTransparency(
  					imageData,
  					geometry.attributes.uv.array,
  					geometry.index.array.slice( group.start, group.start + group.count ) ) ) {

  					map.transparent = true;

  				}

  			} );

  		}

  	};

  	//

  	function AnimationBuilder() {

  	}

  	AnimationBuilder.prototype = {

  		constructor: AnimationBuilder,
  		build: function ( vmd, mesh ) {

  			// combine skeletal and morph animations

  			var tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks;
  			var tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks;

  			for ( var i = 0, il = tracks2.length; i < il; i ++ ) {

  				tracks.push( tracks2[ i ] );

  			}

  			return new AnimationClip( '', - 1, tracks );

  		},
  		buildSkeletalAnimation: function ( vmd, mesh ) {
  			var this$1 = this;


  			function pushInterpolation( array, interpolation, index ) {

  				array.push( interpolation[ index + 0 ] / 127 ); // x1
  				array.push( interpolation[ index + 8 ] / 127 ); // x2
  				array.push( interpolation[ index + 4 ] / 127 ); // y1
  				array.push( interpolation[ index + 12 ] / 127 ); // y2

  			}

  			var tracks = [];

  			var motions = {};
  			var bones = mesh.skeleton.bones;
  			var boneNameDictionary = {};

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				boneNameDictionary[ bones[ i ].name ] = true;

  			}

  			for ( var i = 0; i < vmd.metadata.motionCount; i ++ ) {

  				var motion = vmd.motions[ i ];
  				var boneName = motion.boneName;

  				if ( boneNameDictionary[ boneName ] === undefined ) { continue; }

  				motions[ boneName ] = motions[ boneName ] || [];
  				motions[ boneName ].push( motion );

  			}

  			for ( var key in motions ) {

  				var array = motions[ key ];

  				array.sort( function ( a, b ) {

  					return a.frameNum - b.frameNum;

  				} );

  				var times = [];
  				var positions = [];
  				var rotations = [];
  				var pInterpolations = [];
  				var rInterpolations = [];

  				var basePosition = mesh.skeleton.getBoneByName( key ).position.toArray();

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					var time = array[ i ].frameNum / 30;
  					var position = array[ i ].position;
  					var rotation = array[ i ].rotation;
  					var interpolation = array[ i ].interpolation;

  					times.push( time );

  					for ( var j = 0; j < 3; j ++ ) { positions.push( basePosition[ j ] + position[ j ] ); }
  					for ( var j = 0; j < 4; j ++ ) { rotations.push( rotation[ j ] ); }
  					for ( var j = 0; j < 3; j ++ ) { pushInterpolation( pInterpolations, interpolation, j ); }

  					pushInterpolation( rInterpolations, interpolation, 3 );

  				}

  				var targetName = '.bones[' + key + ']';

  				tracks.push( this$1._createTrack( targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );
  				tracks.push( this$1._createTrack( targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations ) );

  			}

  			return new AnimationClip( '', - 1, tracks );

  		},
  		buildMorphAnimation: function ( vmd, mesh ) {

  			var tracks = [];

  			var morphs = {};
  			var morphTargetDictionary = mesh.morphTargetDictionary;

  			for ( var i = 0; i < vmd.metadata.morphCount; i ++ ) {

  				var morph = vmd.morphs[ i ];
  				var morphName = morph.morphName;

  				if ( morphTargetDictionary[ morphName ] === undefined ) { continue; }

  				morphs[ morphName ] = morphs[ morphName ] || [];
  				morphs[ morphName ].push( morph );

  			}

  			for ( var key in morphs ) {

  				var array = morphs[ key ];

  				array.sort( function ( a, b ) {

  					return a.frameNum - b.frameNum;

  				} );

  				var times = [];
  				var values = [];

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					times.push( array[ i ].frameNum / 30 );
  					values.push( array[ i ].weight );

  				}

  				tracks.push( new NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) );

  			}

  			return new AnimationClip( '', - 1, tracks );

  		},
  		buildCameraAnimation: function ( vmd ) {

  			function pushVector3( array, vec ) {

  				array.push( vec.x );
  				array.push( vec.y );
  				array.push( vec.z );

  			}

  			function pushQuaternion( array, q ) {

  				array.push( q.x );
  				array.push( q.y );
  				array.push( q.z );
  				array.push( q.w );

  			}

  			function pushInterpolation( array, interpolation, index ) {

  				array.push( interpolation[ index * 4 + 0 ] / 127 ); // x1
  				array.push( interpolation[ index * 4 + 1 ] / 127 ); // x2
  				array.push( interpolation[ index * 4 + 2 ] / 127 ); // y1
  				array.push( interpolation[ index * 4 + 3 ] / 127 ); // y2

  			}

  			var tracks = [];

  			var cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();

  			cameras.sort( function ( a, b ) {

  				return a.frameNum - b.frameNum;

  			} );

  			var times = [];
  			var centers = [];
  			var quaternions = [];
  			var positions = [];
  			var fovs = [];

  			var cInterpolations = [];
  			var qInterpolations = [];
  			var pInterpolations = [];
  			var fInterpolations = [];

  			var quaternion = new Quaternion();
  			var euler = new Euler();
  			var position = new Vector3();
  			var center = new Vector3();

  			for ( var i = 0, il = cameras.length; i < il; i ++ ) {

  				var motion = cameras[ i ];

  				var time = motion.frameNum / 30;
  				var pos = motion.position;
  				var rot = motion.rotation;
  				var distance = motion.distance;
  				var fov = motion.fov;
  				var interpolation = motion.interpolation;

  				times.push( time );

  				position.set( 0, 0, - distance );
  				center.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );

  				euler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] );
  				quaternion.setFromEuler( euler );

  				position.add( center );
  				position.applyQuaternion( quaternion );

  				pushVector3( centers, center );
  				pushQuaternion( quaternions, quaternion );
  				pushVector3( positions, position );

  				fovs.push( fov );

  				for ( var j = 0; j < 3; j ++ ) {

  					pushInterpolation( cInterpolations, interpolation, j );

  				}

  				pushInterpolation( qInterpolations, interpolation, 3 );

  				// use the same parameter for x, y, z axis.
  				for ( var j = 0; j < 3; j ++ ) {

  					pushInterpolation( pInterpolations, interpolation, 4 );

  				}

  				pushInterpolation( fInterpolations, interpolation, 5 );

  			}

  			var tracks = [];

  			// I expect an object whose name 'target' exists under Camera
  			tracks.push( this._createTrack( 'target.position', VectorKeyframeTrack, times, centers, cInterpolations ) );

  			tracks.push( this._createTrack( '.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations ) );
  			tracks.push( this._createTrack( '.position', VectorKeyframeTrack, times, positions, pInterpolations ) );
  			tracks.push( this._createTrack( '.fov', NumberKeyframeTrack, times, fovs, fInterpolations ) );

  			return new AnimationClip( '', - 1, tracks );

  		},

  		// private method

  		_createTrack: function ( node, typedKeyframeTrack, times, values, interpolations ) {
  			if ( times.length > 2 ) {

  				times = times.slice();
  				values = values.slice();
  				interpolations = interpolations.slice();

  				var stride = values.length / times.length;
  				var interpolateStride = interpolations.length / times.length;

  				var index = 1;

  				for ( var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) {

  					for ( var i = 0; i < stride; i ++ ) {

  						if ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] ||
  							values[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) {

  							index ++;
  							break;

  						}

  					}

  					if ( aheadIndex > index ) {

  						times[ index ] = times[ aheadIndex ];

  						for ( var i = 0; i < stride; i ++ ) {

  							values[ index * stride + i ] = values[ aheadIndex * stride + i ];

  						}

  						for ( var i = 0; i < interpolateStride; i ++ ) {

  							interpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ];

  						}

  					}

  				}

  				times.length = index + 1;
  				values.length = ( index + 1 ) * stride;
  				interpolations.length = ( index + 1 ) * interpolateStride;

  			}

  			var track = new typedKeyframeTrack( node, times, values );

  			track.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) {

  				return new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) );

  			};

  			return track;

  		}

  	};

  	// interpolation

  	function CubicBezierInterpolation( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  		this.interpolationParams = params;

  	}

  	CubicBezierInterpolation.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  		constructor: CubicBezierInterpolation,

  		interpolate_: function ( i1, t0, t, t1 ) {
  			var this$1 = this;


  			var result = this.resultBuffer;
  			var values = this.sampleValues;
  			var stride = this.valueSize;
  			var params = this.interpolationParams;

  			var offset1 = i1 * stride;
  			var offset0 = offset1 - stride;

  			// No interpolation if next key frame is in one frame in 30fps.
  			// This is from MMD animation spec.
  			// '1.5' is for precision loss. times are Float32 in Three.js Animation system.
  			var weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 );

  			if ( stride === 4 ) { // Quaternion

  				var x1 = params[ i1 * 4 + 0 ];
  				var x2 = params[ i1 * 4 + 1 ];
  				var y1 = params[ i1 * 4 + 2 ];
  				var y2 = params[ i1 * 4 + 3 ];

  				var ratio = this._calculate( x1, x2, y1, y2, weight1 );

  				Quaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio );

  			} else if ( stride === 3 ) { // Vector3

  				for ( var i = 0; i !== stride; ++ i ) {

  					var x1 = params[ i1 * 12 + i * 4 + 0 ];
  					var x2 = params[ i1 * 12 + i * 4 + 1 ];
  					var y1 = params[ i1 * 12 + i * 4 + 2 ];
  					var y2 = params[ i1 * 12 + i * 4 + 3 ];

  					var ratio = this$1._calculate( x1, x2, y1, y2, weight1 );

  					result[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio;

  				}

  			} else { // Number

  				var x1 = params[ i1 * 4 + 0 ];
  				var x2 = params[ i1 * 4 + 1 ];
  				var y1 = params[ i1 * 4 + 2 ];
  				var y2 = params[ i1 * 4 + 3 ];

  				var ratio = this._calculate( x1, x2, y1, y2, weight1 );

  				result[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio;

  			}

  			return result;

  		},

  		_calculate: function ( x1, x2, y1, y2, x ) {
  			var c = 0.5;
  			var t = c;
  			var s = 1.0 - t;
  			var loop = 15;
  			var eps = 1e-5;
  			var math = Math;

  			var sst3, stt3, ttt;

  			for ( var i = 0; i < loop; i ++ ) {

  				sst3 = 3.0 * s * s * t;
  				stt3 = 3.0 * s * t * t;
  				ttt = t * t * t;

  				var ft = ( sst3 * x1 ) + ( stt3 * x2 ) + ( ttt ) - x;

  				if ( math.abs( ft ) < eps ) { break; }

  				c /= 2.0;

  				t += ( ft < 0 ) ? c : - c;
  				s = 1.0 - t;

  			}

  			return ( sst3 * y1 ) + ( stt3 * y2 ) + ttt;

  		}

  	} );

  	return MMDLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MTLLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  MTLLoader.prototype = {

  	constructor: MTLLoader,
  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text, path ) );

  		}, onProgress, onError );

  	},
  	setPath: function ( path ) {

  		this.path = path;
  		return this;

  	},
  	setResourcePath: function ( path ) {

  		this.resourcePath = path;
  		return this;

  	},

  	setTexturePath: function ( path ) {

  		console.warn( 'MTLLoader: .setTexturePath() has been renamed to .setResourcePath().' );
  		return this.setResourcePath( path );

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setMaterialOptions: function ( value ) {

  		this.materialOptions = value;
  		return this;

  	},
  	parse: function ( text, path ) {

  		var lines = text.split( '\n' );
  		var info = {};
  		var delimiter_pattern = /\s+/;
  		var materialsInfo = {};

  		for ( var i = 0; i < lines.length; i ++ ) {

  			var line = lines[ i ];
  			line = line.trim();

  			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

  				// Blank line or comment ignore
  				continue;

  			}

  			var pos = line.indexOf( ' ' );

  			var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
  			key = key.toLowerCase();

  			var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
  			value = value.trim();

  			if ( key === 'newmtl' ) {

  				// New material

  				info = { name: value };
  				materialsInfo[ value ] = info;

  			} else {

  				if ( key === 'ka' || key === 'kd' || key === 'ks' || key ==='ke' ) {

  					var ss = value.split( delimiter_pattern, 3 );
  					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

  				} else {

  					info[ key ] = value;

  				}

  			}

  		}

  		var materialCreator = new MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );
  		materialCreator.setCrossOrigin( this.crossOrigin );
  		materialCreator.setManager( this.manager );
  		materialCreator.setMaterials( materialsInfo );
  		return materialCreator;

  	}

  };
  MTLLoader.MaterialCreator = function ( baseUrl, options ) {

  	this.baseUrl = baseUrl || '';
  	this.options = options;
  	this.materialsInfo = {};
  	this.materials = {};
  	this.materialsArray = [];
  	this.nameLookup = {};

  	this.side = ( this.options && this.options.side ) ? this.options.side : FrontSide;
  	this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : RepeatWrapping;

  };

  MTLLoader.MaterialCreator.prototype = {

  	constructor: MTLLoader.MaterialCreator,

  	crossOrigin: 'anonymous',

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setManager: function ( value ) {

  		this.manager = value;

  	},

  	setMaterials: function ( materialsInfo ) {

  		this.materialsInfo = this.convert( materialsInfo );
  		this.materials = {};
  		this.materialsArray = [];
  		this.nameLookup = {};

  	},

  	convert: function ( materialsInfo ) {
  		var this$1 = this;


  		if ( ! this.options ) { return materialsInfo; }

  		var converted = {};

  		for ( var mn in materialsInfo ) {

  			// Convert materials info into normalized form based on options

  			var mat = materialsInfo[ mn ];

  			var covmat = {};

  			converted[ mn ] = covmat;

  			for ( var prop in mat ) {

  				var save = true;
  				var value = mat[ prop ];
  				var lprop = prop.toLowerCase();

  				switch ( lprop ) {

  					case 'kd':
  					case 'ka':
  					case 'ks':

  						// Diffuse color (color under white light) using RGB values

  						if ( this$1.options && this$1.options.normalizeRGB ) {

  							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

  						}

  						if ( this$1.options && this$1.options.ignoreZeroRGBs ) {

  							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

  								// ignore

  								save = false;

  							}

  						}

  						break;

  					default:

  						break;

  				}

  				if ( save ) {

  					covmat[ lprop ] = value;

  				}

  			}

  		}

  		return converted;

  	},

  	preload: function () {
  		var this$1 = this;


  		for ( var mn in this$1.materialsInfo ) {

  			this$1.create( mn );

  		}

  	},

  	getIndex: function ( materialName ) {

  		return this.nameLookup[ materialName ];

  	},

  	getAsArray: function () {
  		var this$1 = this;


  		var index = 0;

  		for ( var mn in this$1.materialsInfo ) {

  			this$1.materialsArray[ index ] = this$1.create( mn );
  			this$1.nameLookup[ mn ] = index;
  			index ++;

  		}

  		return this.materialsArray;

  	},

  	create: function ( materialName ) {

  		if ( this.materials[ materialName ] === undefined ) {

  			this.createMaterial_( materialName );

  		}

  		return this.materials[ materialName ];

  	},

  	createMaterial_: function ( materialName ) {
  		var this$1 = this;


  		// Create material

  		var scope = this;
  		var mat = this.materialsInfo[ materialName ];
  		var params = {

  			name: materialName,
  			side: this.side

  		};

  		function resolveURL( baseUrl, url ) {

  			if ( typeof url !== 'string' || url === '' )
  				{ return ''; }

  			// Absolute URL
  			if ( /^https?:\/\//i.test( url ) ) { return url; }

  			return baseUrl + url;

  		}

  		function setMapForType( mapType, value ) {

  			if ( params[ mapType ] ) { return; } // Keep the first encountered texture

  			var texParams = scope.getTextureParams( value, params );
  			var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

  			map.repeat.copy( texParams.scale );
  			map.offset.copy( texParams.offset );

  			map.wrapS = scope.wrap;
  			map.wrapT = scope.wrap;

  			params[ mapType ] = map;

  		}

  		for ( var prop in mat ) {

  			var value = mat[ prop ];
  			var n;

  			if ( value === '' ) { continue; }

  			switch ( prop.toLowerCase() ) {

  				// Ns is material specular exponent

  				case 'kd':

  					// Diffuse color (color under white light) using RGB values

  					params.color = new Color().fromArray( value );

  					break;

  				case 'ks':

  					// Specular color (color when light is reflected from shiny surface) using RGB values
  					params.specular = new Color().fromArray( value );

  					break;

  				case 'ke':

  					// Emissive using RGB values
  					params.emissive = new Color().fromArray( value );

  					break;

  				case 'map_kd':

  					// Diffuse texture map

  					setMapForType( "map", value );

  					break;

  				case 'map_ks':

  					// Specular map

  					setMapForType( "specularMap", value );

  					break;

  				case 'map_ke':

  					// Emissive map

  					setMapForType( "emissiveMap", value );

  					break;

  				case 'norm':

  					setMapForType( "normalMap", value );

  					break;

  				case 'map_bump':
  				case 'bump':

  					// Bump texture map

  					setMapForType( "bumpMap", value );

  					break;

  				case 'map_d':

  					// Alpha map

  					setMapForType( "alphaMap", value );
  					params.transparent = true;

  					break;

  				case 'ns':

  					// The specular exponent (defines the focus of the specular highlight)
  					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

  					params.shininess = parseFloat( value );

  					break;

  				case 'd':
  					n = parseFloat( value );

  					if ( n < 1 ) {

  						params.opacity = n;
  						params.transparent = true;

  					}

  					break;

  				case 'tr':
  					n = parseFloat( value );

  					if ( this$1.options && this$1.options.invertTrProperty ) { n = 1 - n; }

  					if ( n > 0 ) {

  						params.opacity = 1 - n;
  						params.transparent = true;

  					}

  					break;

  				default:
  					break;

  			}

  		}

  		this.materials[ materialName ] = new MeshPhongMaterial( params );
  		return this.materials[ materialName ];

  	},

  	getTextureParams: function ( value, matParams ) {

  		var texParams = {

  			scale: new Vector2( 1, 1 ),
  			offset: new Vector2( 0, 0 )

  		 };

  		var items = value.split( /\s+/ );
  		var pos;

  		pos = items.indexOf( '-bm' );

  		if ( pos >= 0 ) {

  			matParams.bumpScale = parseFloat( items[ pos + 1 ] );
  			items.splice( pos, 2 );

  		}

  		pos = items.indexOf( '-s' );

  		if ( pos >= 0 ) {

  			texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
  			items.splice( pos, 4 ); // we expect 3 parameters here!

  		}

  		pos = items.indexOf( '-o' );

  		if ( pos >= 0 ) {

  			texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
  			items.splice( pos, 4 ); // we expect 3 parameters here!

  		}

  		texParams.url = items.join( ' ' ).trim();
  		return texParams;

  	},

  	loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

  		var texture;
  		var loader = Loader$1.Handlers.get( url );
  		var manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;

  		if ( loader === null ) {

  			loader = new TextureLoader( manager );

  		}

  		if ( loader.setCrossOrigin ) { loader.setCrossOrigin( this.crossOrigin ); }
  		texture = loader.load( url, onLoad, onProgress, onError );

  		if ( mapping !== undefined ) { texture.mapping = mapping; }

  		return texture;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NodeMaterialLoader = function ( manager, library ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	this.nodes = {};
  	this.materials = {};
  	this.passes = {};
  	this.names = {};
  	this.library = library || {};

  };

  Object.assign( NodeMaterialLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	getObjectByName: function ( uuid ) {

  		return this.names[ uuid ];

  	},

  	getObjectById: function ( uuid ) {

  		return this.library[ uuid ] ||
  			this.nodes[ uuid ] ||
  			this.materials[ uuid ] ||
  			this.passes[ uuid ] ||
  			this.names[ uuid ];

  	},

  	getNode: function ( uuid ) {

  		var object = this.getObjectById( uuid );

  		if ( ! object ) {

  			console.warn( "Node \"" + uuid + "\" not found." );

  		}

  		return object;

  	},

  	resolve: function( json ) {
  		var this$1 = this;


  		switch( typeof json ) {

  			case "boolean":
  			case "number":

  				return json;

  			case "string":

  				if (/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/i.test(json) || this.library[ json ]) {

  					return this.getNode( json );

  				}

  				return json;

  			default:

  				if ( Array.isArray( json ) ) {

  					for(var i = 0; i < json.length; i++) {

  						json[i] = this$1.resolve( json[i] );

  					}

  				} else {

  					for ( var prop in json ) {

  						if (prop === "uuid") { continue; }

  						json[ prop ] = this$1.resolve( json[ prop ] );

  					}

  				}

  		}

  		return json;

  	},

  	declare: function( json ) {
  		var this$1 = this;


  		var uuid, node, object;

  		for ( uuid in json.nodes ) {

  			node = json.nodes[ uuid ];

  			object = new THREE[ node.nodeType + "Node" ]();

  			if ( node.name ) {

  				object.name = node.name;

  				this$1.names[ object.name ] = object;

  			}

  			this$1.nodes[ uuid ] = object;

  		}

  		for ( uuid in json.materials ) {

  			node = json.materials[ uuid ];

  			object = new THREE[ node.type ]();

  			if ( node.name ) {

  				object.name = node.name;

  				this$1.names[ object.name ] = object;

  			}

  			this$1.materials[ uuid ] = object;

  		}

  		for ( uuid in json.passes ) {

  			node = json.passes[ uuid ];

  			object = new THREE[ node.type ]();

  			if ( node.name ) {

  				object.name = node.name;

  				this$1.names[ object.name ] = object;

  			}

  			this$1.passes[ uuid ] = object;

  		}

  		if ( json.material ) { this.material = this.materials[ json.material ]; }

  		if ( json.pass ) { this.pass = this.passes[ json.pass ]; }

  		return json;

  	},

  	parse: function ( json ) {
  		var this$1 = this;


  		var uuid;

  		json = this.resolve( this.declare( json ) );

  		for ( uuid in json.nodes ) {

  			this$1.nodes[ uuid ].copy( json.nodes[ uuid ] );

  		}

  		for ( uuid in json.materials ) {

  			this$1.materials[ uuid ].copy( json.materials[ uuid ] );

  		}

  		for ( uuid in json.passes ) {

  			this$1.passes[ uuid ].copy( json.passes[ uuid ] );

  		}

  		return this.material || this.pass || this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var OBJLoader = ( function () {

  	// o object_name | g group_name
  	var object_pattern = /^[og]\s*(.+)?/;
  	// mtllib file_reference
  	var material_library_pattern = /^mtllib /;
  	// usemtl material_name
  	var material_use_pattern = /^usemtl /;

  	function ParserState() {

  		var state = {
  			objects: [],
  			object: {},

  			vertices: [],
  			normals: [],
  			colors: [],
  			uvs: [],

  			materialLibraries: [],

  			startObject: function ( name, fromDeclaration ) {

  				// If the current object (initial from reset) is not from a g/o declaration in the parsed
  				// file. We need to use it for the first parsed g/o to keep things in sync.
  				if ( this.object && this.object.fromDeclaration === false ) {

  					this.object.name = name;
  					this.object.fromDeclaration = ( fromDeclaration !== false );
  					return;

  				}

  				var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

  				if ( this.object && typeof this.object._finalize === 'function' ) {

  					this.object._finalize( true );

  				}

  				this.object = {
  					name: name || '',
  					fromDeclaration: ( fromDeclaration !== false ),

  					geometry: {
  						vertices: [],
  						normals: [],
  						colors: [],
  						uvs: []
  					},
  					materials: [],
  					smooth: true,

  					startMaterial: function ( name, libraries ) {

  						var previous = this._finalize( false );

  						// New usemtl declaration overwrites an inherited material, except if faces were declared
  						// after the material, then it must be preserved for proper MultiMaterial continuation.
  						if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

  							this.materials.splice( previous.index, 1 );

  						}

  						var material = {
  							index: this.materials.length,
  							name: name || '',
  							mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
  							smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
  							groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
  							groupEnd: - 1,
  							groupCount: - 1,
  							inherited: false,

  							clone: function ( index ) {

  								var cloned = {
  									index: ( typeof index === 'number' ? index : this.index ),
  									name: this.name,
  									mtllib: this.mtllib,
  									smooth: this.smooth,
  									groupStart: 0,
  									groupEnd: - 1,
  									groupCount: - 1,
  									inherited: false
  								};
  								cloned.clone = this.clone.bind( cloned );
  								return cloned;

  							}
  						};

  						this.materials.push( material );

  						return material;

  					},

  					currentMaterial: function () {

  						if ( this.materials.length > 0 ) {

  							return this.materials[ this.materials.length - 1 ];

  						}

  						return undefined;

  					},

  					_finalize: function ( end ) {
  						var this$1 = this;


  						var lastMultiMaterial = this.currentMaterial();
  						if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {

  							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
  							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
  							lastMultiMaterial.inherited = false;

  						}

  						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
  						if ( end && this.materials.length > 1 ) {

  							for ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {

  								if ( this$1.materials[ mi ].groupCount <= 0 ) {

  									this$1.materials.splice( mi, 1 );

  								}

  							}

  						}

  						// Guarantee at least one empty material, this makes the creation later more straight forward.
  						if ( end && this.materials.length === 0 ) {

  							this.materials.push( {
  								name: '',
  								smooth: this.smooth
  							} );

  						}

  						return lastMultiMaterial;

  					}
  				};

  				// Inherit previous objects material.
  				// Spec tells us that a declared material must be set to all objects until a new material is declared.
  				// If a usemtl declaration is encountered while this new object is being parsed, it will
  				// overwrite the inherited material. Exception being that there was already face declarations
  				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

  				if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

  					var declared = previousMaterial.clone( 0 );
  					declared.inherited = true;
  					this.object.materials.push( declared );

  				}

  				this.objects.push( this.object );

  			},

  			finalize: function () {

  				if ( this.object && typeof this.object._finalize === 'function' ) {

  					this.object._finalize( true );

  				}

  			},

  			parseVertexIndex: function ( value, len ) {

  				var index = parseInt( value, 10 );
  				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

  			},

  			parseNormalIndex: function ( value, len ) {

  				var index = parseInt( value, 10 );
  				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

  			},

  			parseUVIndex: function ( value, len ) {

  				var index = parseInt( value, 10 );
  				return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

  			},

  			addVertex: function ( a, b, c ) {

  				var src = this.vertices;
  				var dst = this.object.geometry.vertices;

  				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
  				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
  				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

  			},

  			addVertexPoint: function ( a ) {

  				var src = this.vertices;
  				var dst = this.object.geometry.vertices;

  				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

  			},

  			addVertexLine: function ( a ) {

  				var src = this.vertices;
  				var dst = this.object.geometry.vertices;

  				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

  			},

  			addNormal: function ( a, b, c ) {

  				var src = this.normals;
  				var dst = this.object.geometry.normals;

  				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
  				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
  				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

  			},

  			addColor: function ( a, b, c ) {

  				var src = this.colors;
  				var dst = this.object.geometry.colors;

  				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
  				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
  				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

  			},

  			addUV: function ( a, b, c ) {

  				var src = this.uvs;
  				var dst = this.object.geometry.uvs;

  				dst.push( src[ a + 0 ], src[ a + 1 ] );
  				dst.push( src[ b + 0 ], src[ b + 1 ] );
  				dst.push( src[ c + 0 ], src[ c + 1 ] );

  			},

  			addUVLine: function ( a ) {

  				var src = this.uvs;
  				var dst = this.object.geometry.uvs;

  				dst.push( src[ a + 0 ], src[ a + 1 ] );

  			},

  			addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

  				var vLen = this.vertices.length;

  				var ia = this.parseVertexIndex( a, vLen );
  				var ib = this.parseVertexIndex( b, vLen );
  				var ic = this.parseVertexIndex( c, vLen );

  				this.addVertex( ia, ib, ic );

  				if ( ua !== undefined && ua !== '' ) {

  					var uvLen = this.uvs.length;
  					ia = this.parseUVIndex( ua, uvLen );
  					ib = this.parseUVIndex( ub, uvLen );
  					ic = this.parseUVIndex( uc, uvLen );
  					this.addUV( ia, ib, ic );

  				}

  				if ( na !== undefined && na !== '' ) {

  					// Normals are many times the same. If so, skip function call and parseInt.
  					var nLen = this.normals.length;
  					ia = this.parseNormalIndex( na, nLen );

  					ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
  					ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

  					this.addNormal( ia, ib, ic );

  				}

  				if ( this.colors.length > 0 ) {

  					this.addColor( ia, ib, ic );

  				}

  			},

  			addPointGeometry: function ( vertices ) {
  				var this$1 = this;


  				this.object.geometry.type = 'Points';

  				var vLen = this.vertices.length;

  				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

  					this$1.addVertexPoint( this$1.parseVertexIndex( vertices[ vi ], vLen ) );

  				}

  			},

  			addLineGeometry: function ( vertices, uvs ) {
  				var this$1 = this;


  				this.object.geometry.type = 'Line';

  				var vLen = this.vertices.length;
  				var uvLen = this.uvs.length;

  				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

  					this$1.addVertexLine( this$1.parseVertexIndex( vertices[ vi ], vLen ) );

  				}

  				for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

  					this$1.addUVLine( this$1.parseUVIndex( uvs[ uvi ], uvLen ) );

  				}

  			}

  		};

  		state.startObject( '', false );

  		return state;

  	}

  	//

  	function OBJLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		this.materials = null;

  	}

  	OBJLoader.prototype = {

  		constructor: OBJLoader,

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( this.path );
  			loader.load( url, function ( text ) {

  				onLoad( scope.parse( text ) );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;

  			return this;

  		},

  		setMaterials: function ( materials ) {

  			this.materials = materials;

  			return this;

  		},

  		parse: function ( text ) {
  			var this$1 = this;


  			console.time( 'OBJLoader' );

  			var state = new ParserState();

  			if ( text.indexOf( '\r\n' ) !== - 1 ) {

  				// This is faster than String.split with regex that splits on both
  				text = text.replace( /\r\n/g, '\n' );

  			}

  			if ( text.indexOf( '\\\n' ) !== - 1 ) {

  				// join lines separated by a line continuation character (\)
  				text = text.replace( /\\\n/g, '' );

  			}

  			var lines = text.split( '\n' );
  			var line = '', lineFirstChar = '';
  			var lineLength = 0;
  			var result = [];

  			// Faster to just trim left side of the line. Use if available.
  			var trimLeft = ( typeof ''.trimLeft === 'function' );

  			for ( var i = 0, l = lines.length; i < l; i ++ ) {

  				line = lines[ i ];

  				line = trimLeft ? line.trimLeft() : line.trim();

  				lineLength = line.length;

  				if ( lineLength === 0 ) { continue; }

  				lineFirstChar = line.charAt( 0 );

  				// @todo invoke passed in handler if any
  				if ( lineFirstChar === '#' ) { continue; }

  				if ( lineFirstChar === 'v' ) {

  					var data = line.split( /\s+/ );

  					switch ( data[ 0 ] ) {

  						case 'v':
  							state.vertices.push(
  								parseFloat( data[ 1 ] ),
  								parseFloat( data[ 2 ] ),
  								parseFloat( data[ 3 ] )
  							);
  							if ( data.length === 8 ) {

  								state.colors.push(
  									parseFloat( data[ 4 ] ),
  									parseFloat( data[ 5 ] ),
  									parseFloat( data[ 6 ] )

  								);

  							}
  							break;
  						case 'vn':
  							state.normals.push(
  								parseFloat( data[ 1 ] ),
  								parseFloat( data[ 2 ] ),
  								parseFloat( data[ 3 ] )
  							);
  							break;
  						case 'vt':
  							state.uvs.push(
  								parseFloat( data[ 1 ] ),
  								parseFloat( data[ 2 ] )
  							);
  							break;

  					}

  				} else if ( lineFirstChar === 'f' ) {

  					var lineData = line.substr( 1 ).trim();
  					var vertexData = lineData.split( /\s+/ );
  					var faceVertices = [];

  					// Parse the face vertex data into an easy to work with format

  					for ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {

  						var vertex = vertexData[ j ];

  						if ( vertex.length > 0 ) {

  							var vertexParts = vertex.split( '/' );
  							faceVertices.push( vertexParts );

  						}

  					}

  					// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

  					var v1 = faceVertices[ 0 ];

  					for ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

  						var v2 = faceVertices[ j ];
  						var v3 = faceVertices[ j + 1 ];

  						state.addFace(
  							v1[ 0 ], v2[ 0 ], v3[ 0 ],
  							v1[ 1 ], v2[ 1 ], v3[ 1 ],
  							v1[ 2 ], v2[ 2 ], v3[ 2 ]
  						);

  					}

  				} else if ( lineFirstChar === 'l' ) {

  					var lineParts = line.substring( 1 ).trim().split( " " );
  					var lineVertices = [], lineUVs = [];

  					if ( line.indexOf( "/" ) === - 1 ) {

  						lineVertices = lineParts;

  					} else {

  						for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

  							var parts = lineParts[ li ].split( "/" );

  							if ( parts[ 0 ] !== "" ) { lineVertices.push( parts[ 0 ] ); }
  							if ( parts[ 1 ] !== "" ) { lineUVs.push( parts[ 1 ] ); }

  						}

  					}
  					state.addLineGeometry( lineVertices, lineUVs );

  				} else if ( lineFirstChar === 'p' ) {

  					var lineData = line.substr( 1 ).trim();
  					var pointData = lineData.split( " " );

  					state.addPointGeometry( pointData );

  				} else if ( ( result = object_pattern.exec( line ) ) !== null ) {

  					// o object_name
  					// or
  					// g group_name

  					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
  					// var name = result[ 0 ].substr( 1 ).trim();
  					var name = ( " " + result[ 0 ].substr( 1 ).trim() ).substr( 1 );

  					state.startObject( name );

  				} else if ( material_use_pattern.test( line ) ) {

  					// material

  					state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

  				} else if ( material_library_pattern.test( line ) ) {

  					// mtl file

  					state.materialLibraries.push( line.substring( 7 ).trim() );

  				} else if ( lineFirstChar === 's' ) {

  					result = line.split( ' ' );

  					// smooth shading

  					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
  					// but does not define a usemtl for each face set.
  					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
  					// This requires some care to not create extra material on each smooth value for "normal" obj files.
  					// where explicit usemtl defines geometry groups.
  					// Example asset: examples/models/obj/cerberus/Cerberus.obj
  					if ( result.length > 1 ) {

  						var value = result[ 1 ].trim().toLowerCase();
  						state.object.smooth = ( value !== '0' && value !== 'off' );

  					} else {

  						// ZBrush can produce "s" lines #11707
  						state.object.smooth = true;

  					}
  					var material = state.object.currentMaterial();
  					if ( material ) { material.smooth = state.object.smooth; }

  				} else {

  					// Handle null terminated files without exception
  					if ( line === '\0' ) { continue; }

  					throw new Error( 'OBJLoader: Unexpected line: "' + line + '"' );

  				}

  			}

  			state.finalize();

  			var container = new Group();
  			container.materialLibraries = [].concat( state.materialLibraries );

  			for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

  				var object = state.objects[ i ];
  				var geometry = object.geometry;
  				var materials = object.materials;
  				var isLine = ( geometry.type === 'Line' );
  				var isPoints = ( geometry.type === 'Points' );
  				var hasVertexColors = false;

  				// Skip o/g line declarations that did not follow with any faces
  				if ( geometry.vertices.length === 0 ) { continue; }

  				var buffergeometry = new BufferGeometry();

  				buffergeometry.addAttribute( 'position', new Float32BufferAttribute( geometry.vertices, 3 ) );

  				if ( geometry.normals.length > 0 ) {

  					buffergeometry.addAttribute( 'normal', new Float32BufferAttribute( geometry.normals, 3 ) );

  				} else {

  					buffergeometry.computeVertexNormals();

  				}

  				if ( geometry.colors.length > 0 ) {

  					hasVertexColors = true;
  					buffergeometry.addAttribute( 'color', new Float32BufferAttribute( geometry.colors, 3 ) );

  				}

  				if ( geometry.uvs.length > 0 ) {

  					buffergeometry.addAttribute( 'uv', new Float32BufferAttribute( geometry.uvs, 2 ) );

  				}

  				// Create materials

  				var createdMaterials = [];

  				for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

  					var sourceMaterial = materials[ mi ];
  					var material = undefined;

  					if ( this$1.materials !== null ) {

  						material = this$1.materials.create( sourceMaterial.name );

  						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
  						if ( isLine && material && ! ( material instanceof LineBasicMaterial ) ) {

  							var materialLine = new LineBasicMaterial();
  							Material.prototype.copy.call( materialLine, material );
  							materialLine.color.copy( material.color );
  							materialLine.lights = false;
  							material = materialLine;

  						} else if ( isPoints && material && ! ( material instanceof PointsMaterial ) ) {

  							var materialPoints = new PointsMaterial( { size: 10, sizeAttenuation: false } );
  							Material.prototype.copy.call( materialPoints, material );
  							materialPoints.color.copy( material.color );
  							materialPoints.map = material.map;
  							materialPoints.lights = false;
  							material = materialPoints;

  						}

  					}

  					if ( ! material ) {

  						if ( isLine ) {

  							material = new LineBasicMaterial();

  						} else if ( isPoints ) {

  							material = new PointsMaterial( { size: 1, sizeAttenuation: false } );

  						} else {

  							material = new MeshPhongMaterial();

  						}

  						material.name = sourceMaterial.name;

  					}

  					material.flatShading = sourceMaterial.smooth ? false : true;
  					material.vertexColors = hasVertexColors ? VertexColors : NoColors;

  					createdMaterials.push( material );

  				}

  				// Create mesh

  				var mesh;

  				if ( createdMaterials.length > 1 ) {

  					for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {

  						var sourceMaterial = materials[ mi ];
  						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

  					}

  					if ( isLine ) {

  						mesh = new LineSegments( buffergeometry, createdMaterials );

  					} else if ( isPoints ) {

  						mesh = new Points( buffergeometry, createdMaterials );

  					} else {

  						mesh = new Mesh( buffergeometry, createdMaterials );

  					}

  				} else {

  					if ( isLine ) {

  						mesh = new LineSegments( buffergeometry, createdMaterials[ 0 ] );

  					} else if ( isPoints ) {

  						mesh = new Points( buffergeometry, createdMaterials[ 0 ] );

  					} else {

  						mesh = new Mesh( buffergeometry, createdMaterials[ 0 ] );

  					}

  				}

  				mesh.name = object.name;

  				container.add( mesh );

  			}

  			console.timeEnd( 'OBJLoader' );

  			return container;

  		}

  	};

  	return OBJLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if ( LoaderSupport === undefined ) { console.error( '"LoaderSupport" is not available. "OBJLoader2" requires it. Please include "LoaderSupport.js" in your HTML.' ); }
  var OBJLoader2 = function ( manager ) {
  	console.info( 'Using OBJLoader2 version: ' + OBJLoader2.OBJLOADER2_VERSION );

  	this.manager = LoaderSupport.Validator.verifyInput( manager, DefaultLoadingManager );
  	this.logging = {
  		enabled: true,
  		debug: false
  	};

  	this.modelName = '';
  	this.instanceNo = 0;
  	this.path;
  	this.resourcePath;
  	this.useIndices = false;
  	this.disregardNormals = false;
  	this.materialPerSmoothingGroup = false;
  	this.useOAsMesh = false;
  	this.loaderRootNode = new Group();

  	this.meshBuilder = new LoaderSupport.MeshBuilder();
  	this.callbacks = new LoaderSupport.Callbacks();
  	this.workerSupport = new LoaderSupport.WorkerSupport();
  	this.terminateWorkerOnLoad = true;
  };

  OBJLoader2.OBJLOADER2_VERSION = '2.5.0';

  OBJLoader2.prototype = {

  	constructor: OBJLoader2,
  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  		this.meshBuilder.setLogging( this.logging.enabled, this.logging.debug );
  	},
  	setModelName: function ( modelName ) {
  		this.modelName = LoaderSupport.Validator.verifyInput( modelName, this.modelName );
  	},
  	setPath: function ( path ) {
  		this.path = LoaderSupport.Validator.verifyInput( path, this.path );
  	},
  	setResourcePath: function ( resourcePath ) {
  		this.resourcePath = LoaderSupport.Validator.verifyInput( resourcePath, this.resourcePath );
  	},
  	setStreamMeshesTo: function ( streamMeshesTo ) {
  		this.loaderRootNode = LoaderSupport.Validator.verifyInput( streamMeshesTo, this.loaderRootNode );
  	},
  	setMaterials: function ( materials ) {
  		this.meshBuilder.setMaterials( materials );
  	},
  	setUseIndices: function ( useIndices ) {
  		this.useIndices = useIndices === true;
  	},
  	setDisregardNormals: function ( disregardNormals ) {
  		this.disregardNormals = disregardNormals === true;
  	},
  	setMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {
  		this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;
  	},
  	setUseOAsMesh: function ( useOAsMesh ) {
  		this.useOAsMesh = useOAsMesh === true;
  	},

  	_setCallbacks: function ( callbacks ) {
  		if ( LoaderSupport.Validator.isValid( callbacks.onProgress ) ) { this.callbacks.setCallbackOnProgress( callbacks.onProgress ); }
  		if ( LoaderSupport.Validator.isValid( callbacks.onReportError ) ) { this.callbacks.setCallbackOnReportError( callbacks.onReportError ); }
  		if ( LoaderSupport.Validator.isValid( callbacks.onMeshAlter ) ) { this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter ); }
  		if ( LoaderSupport.Validator.isValid( callbacks.onLoad ) ) { this.callbacks.setCallbackOnLoad( callbacks.onLoad ); }
  		if ( LoaderSupport.Validator.isValid( callbacks.onLoadMaterials ) ) { this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials ); }

  		this.meshBuilder._setCallbacks( this.callbacks );
  	},
  	onProgress: function ( type, text, numericalValue ) {
  		var content = LoaderSupport.Validator.isValid( text ) ? text: '';
  		var event = {
  			detail: {
  				type: type,
  				modelName: this.modelName,
  				instanceNo: this.instanceNo,
  				text: content,
  				numericalValue: numericalValue
  			}
  		};

  		if ( LoaderSupport.Validator.isValid( this.callbacks.onProgress ) ) { this.callbacks.onProgress( event ); }

  		if ( this.logging.enabled && this.logging.debug ) { console.debug( content ); }
  	},

  	_onError: function ( event ) {
  		var output = 'Error occurred while downloading!';

  		if ( event.currentTarget && event.currentTarget.statusText !== null ) {

  			output += '\nurl: ' + event.currentTarget.responseURL + '\nstatus: ' + event.currentTarget.statusText;

  		}
  		this.onProgress( 'error', output, -1 );
  		this._throwError( output );
  	},

  	_throwError: function ( errorMessage ) {
  		if ( LoaderSupport.Validator.isValid( this.callbacks.onReportError ) )  {

  			this.callbacks.onReportError( errorMessage );

  		} else {

  			throw errorMessage;

  		}
  	},
  	load: function ( url, onLoad, onProgress, onError, onMeshAlter, useAsync ) {
  		var resource = new LoaderSupport.ResourceDescriptor( url, 'OBJ' );
  		this._loadObj( resource, onLoad, onProgress, onError, onMeshAlter, useAsync );
  	},

  	_loadObj: function ( resource, onLoad, onProgress, onError, onMeshAlter, useAsync ) {
  		var scope = this;
  		if ( ! LoaderSupport.Validator.isValid( onError ) ) {
  			onError = function ( event ) {
  				scope._onError( event );
  			};
  		}

  		// fast-fail
  		if ( ! LoaderSupport.Validator.isValid( resource ) ) { onError( 'An invalid ResourceDescriptor was provided. Unable to continue!' ); }
  		var fileLoaderOnLoad = function ( content ) {

  			resource.content = content;
  			if ( useAsync ) {

  				scope.parseAsync( content, onLoad );

  			} else {

  				var callbacks = new LoaderSupport.Callbacks();
  				callbacks.setCallbackOnMeshAlter( onMeshAlter );
  				scope._setCallbacks( callbacks );
  				onLoad(
  					{
  						detail: {
  							loaderRootNode: scope.parse( content ),
  							modelName: scope.modelName,
  							instanceNo: scope.instanceNo
  						}
  					}
  				);

  			}
  		};
  		this.setPath( resource.path );
  		this.setResourcePath( resource.resourcePath );

  		// fast-fail
  		if ( ! LoaderSupport.Validator.isValid( resource.url ) || LoaderSupport.Validator.isValid( resource.content ) ) {

  			fileLoaderOnLoad( LoaderSupport.Validator.isValid( resource.content ) ? resource.content : null );

  		} else {

  			if ( ! LoaderSupport.Validator.isValid( onProgress ) ) {
  				var numericalValueRef = 0;
  				var numericalValue = 0;
  				onProgress = function ( event ) {
  					if ( ! event.lengthComputable ) { return; }

  					numericalValue = event.loaded / event.total;
  					if ( numericalValue > numericalValueRef ) {

  						numericalValueRef = numericalValue;
  						var output = 'Download of "' + resource.url + '": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';
  						scope.onProgress( 'progressLoad', output, numericalValue );

  					}
  				};
  			}
  			var fileLoader = new FileLoader( this.manager );
  			fileLoader.setPath( this.path || this.resourcePath );
  			fileLoader.setResponseType( 'arraybuffer' );
  			fileLoader.load( resource.name, fileLoaderOnLoad, onProgress, onError );

  		}
  	},
  	run: function ( prepData, workerSupportExternal ) {
  		this._applyPrepData( prepData );
  		var available = prepData.checkResourceDescriptorFiles( prepData.resources,
  			[
  				{ ext: "obj", type: "ArrayBuffer", ignore: false },
  				{ ext: "mtl", type: "String", ignore: false },
  				{ ext: "zip", type: "String", ignore: true }
  			]
  		);
  		if ( LoaderSupport.Validator.isValid( workerSupportExternal ) ) {

  			this.terminateWorkerOnLoad = false;
  			this.workerSupport = workerSupportExternal;
  			this.logging.enabled = this.workerSupport.logging.enabled;
  			this.logging.debug = this.workerSupport.logging.debug;

  		}
  		var scope = this;
  		var onMaterialsLoaded = function ( materials ) {
  			if ( materials !== null ) { scope.meshBuilder.setMaterials( materials ); }
  			scope._loadObj( available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync );

  		};
  		this._loadMtl( available.mtl, onMaterialsLoaded, null, null, prepData.crossOrigin, prepData.materialOptions );
  	},

  	_applyPrepData: function ( prepData ) {
  		if ( LoaderSupport.Validator.isValid( prepData ) ) {

  			this.setLogging( prepData.logging.enabled, prepData.logging.debug );
  			this.setModelName( prepData.modelName );
  			this.setStreamMeshesTo( prepData.streamMeshesTo );
  			this.meshBuilder.setMaterials( prepData.materials );
  			this.setUseIndices( prepData.useIndices );
  			this.setDisregardNormals( prepData.disregardNormals );
  			this.setMaterialPerSmoothingGroup( prepData.materialPerSmoothingGroup );
  			this.setUseOAsMesh( prepData.useOAsMesh );

  			this._setCallbacks( prepData.getCallbacks() );

  		}
  	},
  	parse: function ( content ) {
  		// fast-fail in case of illegal data
  		if ( ! LoaderSupport.Validator.isValid( content ) ) {

  			console.warn( 'Provided content is not a valid ArrayBuffer or String.' );
  			return this.loaderRootNode;

  		}
  		if ( this.logging.enabled ) { console.time( 'OBJLoader2 parse: ' + this.modelName ); }
  		this.meshBuilder.init();

  		var parser = new OBJLoader2.Parser();
  		parser.setLogging( this.logging.enabled, this.logging.debug );
  		parser.setMaterialPerSmoothingGroup( this.materialPerSmoothingGroup );
  		parser.setUseOAsMesh( this.useOAsMesh );
  		parser.setUseIndices( this.useIndices );
  		parser.setDisregardNormals( this.disregardNormals );
  		// sync code works directly on the material references
  		parser.setMaterials( this.meshBuilder.getMaterials() );

  		var scope = this;
  		var onMeshLoaded = function ( payload ) {
  			var meshes = scope.meshBuilder.processPayload( payload );
  			var mesh;
  			for ( var i in meshes ) {
  				mesh = meshes[ i ];
  				scope.loaderRootNode.add( mesh );
  			}
  		};
  		parser.setCallbackMeshBuilder( onMeshLoaded );
  		var onProgressScoped = function ( text, numericalValue ) {
  			scope.onProgress( 'progressParse', text, numericalValue );
  		};
  		parser.setCallbackProgress( onProgressScoped );

  		if ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {

  			if ( this.logging.enabled ) { console.info( 'Parsing arrayBuffer...' ); }
  			parser.parse( content );

  		} else if ( typeof( content ) === 'string' || content instanceof String ) {

  			if ( this.logging.enabled ) { console.info( 'Parsing text...' ); }
  			parser.parseText( content );

  		} else {

  			this._throwError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );

  		}
  		if ( this.logging.enabled ) { console.timeEnd( 'OBJLoader2 parse: ' + this.modelName ); }

  		return this.loaderRootNode;
  	},
  	parseAsync: function ( content, onLoad ) {
  		var scope = this;
  		var measureTime = false;
  		var scopedOnLoad = function () {
  			onLoad(
  				{
  					detail: {
  						loaderRootNode: scope.loaderRootNode,
  						modelName: scope.modelName,
  						instanceNo: scope.instanceNo
  					}
  				}
  			);
  			if ( measureTime && scope.logging.enabled ) { console.timeEnd( 'OBJLoader2 parseAsync: ' + scope.modelName ); }
  		};
  		// fast-fail in case of illegal data
  		if ( ! LoaderSupport.Validator.isValid( content ) ) {

  			console.warn( 'Provided content is not a valid ArrayBuffer.' );
  			scopedOnLoad();

  		} else {

  			measureTime = true;

  		}
  		if ( measureTime && this.logging.enabled ) { console.time( 'OBJLoader2 parseAsync: ' + this.modelName ); }
  		this.meshBuilder.init();

  		var scopedOnMeshLoaded = function ( payload ) {
  			var meshes = scope.meshBuilder.processPayload( payload );
  			var mesh;
  			for ( var i in meshes ) {
  				mesh = meshes[ i ];
  				scope.loaderRootNode.add( mesh );
  			}
  		};
  		var buildCode = function ( codeSerializer ) {
  			var workerCode = '';
  			workerCode += '\n\n';
  			workerCode += 'THREE = { LoaderSupport: {}, OBJLoader2: {} };\n\n';
  			workerCode += codeSerializer.serializeObject( 'LoaderSupport.Validator', LoaderSupport.Validator );
  			workerCode += codeSerializer.serializeClass( 'OBJLoader2.Parser', OBJLoader2.Parser );

  			return workerCode;
  		};
  		this.workerSupport.validate( buildCode, 'OBJLoader2.Parser' );
  		this.workerSupport.setCallbacks( scopedOnMeshLoaded, scopedOnLoad );
  		if ( scope.terminateWorkerOnLoad ) { this.workerSupport.setTerminateRequested( true ); }

  		var materialNames = {};
  		var materials = this.meshBuilder.getMaterials();
  		for ( var materialName in materials ) {

  			materialNames[ materialName ] = materialName;

  		}
  		this.workerSupport.run(
  			{
  				params: {
  					useAsync: true,
  					materialPerSmoothingGroup: this.materialPerSmoothingGroup,
  					useOAsMesh: this.useOAsMesh,
  					useIndices: this.useIndices,
  					disregardNormals: this.disregardNormals
  				},
  				logging: {
  					enabled: this.logging.enabled,
  					debug: this.logging.debug
  				},
  				materials: {
  					// in async case only material names are supplied to parser
  					materials: materialNames
  				},
  				data: {
  					input: content,
  					options: null
  				}
  			}
  		);
  	},
  	loadMtl: function ( url, content, onLoad, onProgress, onError, crossOrigin, materialOptions ) {
  		var resource = new LoaderSupport.ResourceDescriptor( url, 'MTL' );
  		resource.setContent( content );
  		this._loadMtl( resource, onLoad, onProgress, onError, crossOrigin, materialOptions );
  	},

  	_loadMtl: function ( resource, onLoad, onProgress, onError, crossOrigin, materialOptions ) {
  		if ( MTLLoader === undefined ) { console.error( '"MTLLoader" is not available. "OBJLoader2" requires it for loading MTL files.' ); }
  		if ( LoaderSupport.Validator.isValid( resource ) && this.logging.enabled ) { console.time( 'Loading MTL: ' + resource.name ); }

  		var materials = [];
  		var scope = this;
  		var processMaterials = function ( materialCreator ) {
  			var materialCreatorMaterials = [];
  			if ( LoaderSupport.Validator.isValid( materialCreator ) ) {

  				materialCreator.preload();
  				materialCreatorMaterials = materialCreator.materials;
  				for ( var materialName in materialCreatorMaterials ) {

  					if ( materialCreatorMaterials.hasOwnProperty( materialName ) ) {

  						materials[ materialName ] = materialCreatorMaterials[ materialName ];

  					}
  				}
  			}

  			if ( LoaderSupport.Validator.isValid( resource ) && scope.logging.enabled ) { console.timeEnd( 'Loading MTL: ' + resource.name ); }
  			onLoad( materials, materialCreator );
  		};

  		// fast-fail
  		if ( ! LoaderSupport.Validator.isValid( resource ) || ( ! LoaderSupport.Validator.isValid( resource.content ) && ! LoaderSupport.Validator.isValid( resource.url ) ) ) {

  			processMaterials();

  		} else {

  			var mtlLoader = new MTLLoader( this.manager );
  			crossOrigin = LoaderSupport.Validator.verifyInput( crossOrigin, 'anonymous' );
  			mtlLoader.setCrossOrigin( crossOrigin );
  			mtlLoader.setResourcePath( resource.resourcePath || resource.path );
  			if ( LoaderSupport.Validator.isValid( materialOptions ) ) { mtlLoader.setMaterialOptions( materialOptions ); }

  			var parseTextWithMtlLoader = function ( content ) {
  				var contentAsText = content;
  				if ( typeof( content ) !== 'string' && ! ( content instanceof String ) ) {

  					if ( content.length > 0 || content.byteLength > 0 ) {

  						contentAsText = LoaderUtils.decodeText( content );

  					} else {

  						this._throwError( 'Unable to parse mtl as it it seems to be neither a String, an Array or an ArrayBuffer!' );
  					}

  				}
  				processMaterials( mtlLoader.parse( contentAsText ) );
  			};

  			if ( LoaderSupport.Validator.isValid( resource.content ) ) {

  				parseTextWithMtlLoader( resource.content );

  			} else if ( LoaderSupport.Validator.isValid( resource.url ) ) {

  				var fileLoader = new FileLoader( this.manager );
  				if ( ! LoaderSupport.Validator.isValid( onError ) ) {
  					onError = function ( event ) {
  						scope._onError( event );
  					};
  				}
  				if ( ! LoaderSupport.Validator.isValid( onProgress ) ) {
  					var numericalValueRef = 0;
  					var numericalValue = 0;
  					onProgress = function ( event ) {
  						if ( ! event.lengthComputable ) { return; }

  						numericalValue = event.loaded / event.total;
  						if ( numericalValue > numericalValueRef ) {

  							numericalValueRef = numericalValue;
  							var output = 'Download of "' + resource.url + '": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';
  							scope.onProgress( 'progressLoad', output, numericalValue );

  						}
  					};
  				}

  				fileLoader.load( resource.url, parseTextWithMtlLoader, onProgress, onError );

  			}
  		}
  	}
  };
  OBJLoader2.Parser = function () {
  	this.callbackProgress = null;
  	this.callbackMeshBuilder = null;
  	this.contentRef = null;
  	this.legacyMode = false;

  	this.materials = {};
  	this.useAsync = false;
  	this.materialPerSmoothingGroup = false;
  	this.useOAsMesh = false;
  	this.useIndices = false;
  	this.disregardNormals = false;

  	this.vertices = [];
  	this.colors = [];
  	this.normals = [];
  	this.uvs = [];

  	this.rawMesh = {
  		objectName: '',
  		groupName: '',
  		activeMtlName: '',
  		mtllibName: '',

  		// reset with new mesh
  		faceType: -1,
  		subGroups: [],
  		subGroupInUse: null,
  		smoothingGroup: {
  			splitMaterials: false,
  			normalized: -1,
  			real: -1
  		},
  		counts: {
  			doubleIndicesCount: 0,
  			faceCount: 0,
  			mtlCount: 0,
  			smoothingGroupCount: 0
  		}
  	};

  	this.inputObjectCount = 1;
  	this.outputObjectCount = 1;
  	this.globalCounts = {
  		vertices: 0,
  		faces: 0,
  		doubleIndicesCount: 0,
  		lineByte: 0,
  		currentByte: 0,
  		totalBytes: 0
  	};

  	this.logging = {
  		enabled: true,
  		debug: false
  	};
  };
  OBJLoader2.Parser.prototype = {

  	constructor: OBJLoader2.Parser,

  	resetRawMesh: function () {
  		// faces are stored according combined index of group, material and smoothingGroup (0 or not)
  		this.rawMesh.subGroups = [];
  		this.rawMesh.subGroupInUse = null;
  		this.rawMesh.smoothingGroup.normalized = -1;
  		this.rawMesh.smoothingGroup.real = -1;

  		// this default index is required as it is possible to define faces without 'g' or 'usemtl'
  		this.pushSmoothingGroup( 1 );

  		this.rawMesh.counts.doubleIndicesCount = 0;
  		this.rawMesh.counts.faceCount = 0;
  		this.rawMesh.counts.mtlCount = 0;
  		this.rawMesh.counts.smoothingGroupCount = 0;
  	},

  	setUseAsync: function ( useAsync ) {
  		this.useAsync = useAsync;
  	},

  	setMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {
  		this.materialPerSmoothingGroup = materialPerSmoothingGroup;
  	},

  	setUseOAsMesh: function ( useOAsMesh ) {
  		this.useOAsMesh = useOAsMesh;
  	},

  	setUseIndices: function ( useIndices ) {
  		this.useIndices = useIndices;
  	},

  	setDisregardNormals: function ( disregardNormals ) {
  		this.disregardNormals = disregardNormals;
  	},

  	setMaterials: function ( materials ) {
  		this.materials = LoaderSupport.Validator.verifyInput( materials, this.materials );
  		this.materials = LoaderSupport.Validator.verifyInput( this.materials, {} );
  	},

  	setCallbackMeshBuilder: function ( callbackMeshBuilder ) {
  		if ( ! LoaderSupport.Validator.isValid( callbackMeshBuilder ) ) {

  			this._throwError( 'Unable to run as no "MeshBuilder" callback is set.' );

  		}
  		this.callbackMeshBuilder = callbackMeshBuilder;
  	},

  	setCallbackProgress: function ( callbackProgress ) {
  		this.callbackProgress = callbackProgress;
  	},

  	setLogging: function ( enabled, debug ) {
  		this.logging.enabled = enabled === true;
  		this.logging.debug = debug === true;
  	},

  	configure: function () {
  		this.pushSmoothingGroup( 1 );

  		if ( this.logging.enabled ) {

  			var matKeys = Object.keys( this.materials );
  			var matNames = ( matKeys.length > 0 ) ? '\n\tmaterialNames:\n\t\t- ' + matKeys.join( '\n\t\t- ' ) : '\n\tmaterialNames: None';
  			var printedConfig = 'OBJLoader2.Parser configuration:'
  				+ matNames
  				+ '\n\tuseAsync: ' + this.useAsync
  				+ '\n\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup
  				+ '\n\tuseOAsMesh: ' + this.useOAsMesh
  				+ '\n\tuseIndices: ' + this.useIndices
  				+ '\n\tdisregardNormals: ' + this.disregardNormals
  				+ '\n\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name
  				+ '\n\tcallbackProgressName: ' + this.callbackProgress.name;
  			console.info( printedConfig );
  		}
  	},
  	parse: function ( arrayBuffer ) {
  		var this$1 = this;

  		if ( this.logging.enabled ) { console.time( 'OBJLoader2.Parser.parse' ); }
  		this.configure();

  		var arrayBufferView = new Uint8Array( arrayBuffer );
  		this.contentRef = arrayBufferView;
  		var length = arrayBufferView.byteLength;
  		this.globalCounts.totalBytes = length;
  		var buffer = new Array( 128 );

  		for ( var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {

  			code = arrayBufferView[ i ];
  			switch ( code ) {
  				// space
  				case 32:
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					word = '';
  					break;
  				// slash
  				case 47:
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					slashesCount++;
  					word = '';
  					break;

  				// LF
  				case 10:
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					word = '';
  					this$1.globalCounts.lineByte = this$1.globalCounts.currentByte;
  					this$1.globalCounts.currentByte = i;
  					this$1.processLine( buffer, bufferPointer, slashesCount );
  					bufferPointer = 0;
  					slashesCount = 0;
  					break;

  				// CR
  				case 13:
  					break;

  				default:
  					word += String.fromCharCode( code );
  					break;
  			}
  		}
  		this.finalizeParsing();
  		if ( this.logging.enabled ) { console.timeEnd(  'OBJLoader2.Parser.parse' ); }
  	},
  	parseText: function ( text ) {
  		var this$1 = this;

  		if ( this.logging.enabled ) { console.time(  'OBJLoader2.Parser.parseText' ); }
  		this.configure();
  		this.legacyMode = true;
  		this.contentRef = text;
  		var length = text.length;
  		this.globalCounts.totalBytes = length;
  		var buffer = new Array( 128 );

  		for ( var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {

  			char = text[ i ];
  			switch ( char ) {
  				case ' ':
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					word = '';
  					break;

  				case '/':
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					slashesCount++;
  					word = '';
  					break;

  				case '\n':
  					if ( word.length > 0 ) { buffer[ bufferPointer++ ] = word; }
  					word = '';
  					this$1.globalCounts.lineByte = this$1.globalCounts.currentByte;
  					this$1.globalCounts.currentByte = i;
  					this$1.processLine( buffer, bufferPointer, slashesCount );
  					bufferPointer = 0;
  					slashesCount = 0;
  					break;

  				case '\r':
  					break;

  				default:
  					word += char;
  			}
  		}
  		this.finalizeParsing();
  		if ( this.logging.enabled ) { console.timeEnd( 'OBJLoader2.Parser.parseText' ); }
  	},

  	processLine: function ( buffer, bufferPointer, slashesCount ) {
  		var this$1 = this;

  		if ( bufferPointer < 1 ) { return; }

  		var reconstructString = function ( content, legacyMode, start, stop ) {
  			var line = '';
  			if ( stop > start ) {

  				var i;
  				if ( legacyMode ) {

  					for ( i = start; i < stop; i++ ) { line += content[ i ]; }

  				} else {
  					for ( i = start; i < stop; i++ ) { line += String.fromCharCode( content[ i ] ); }

  				}
  				line = line.trim();

  			}
  			return line;
  		};

  		var bufferLength, length, i, lineDesignation;
  		lineDesignation = buffer [ 0 ];
  		switch ( lineDesignation ) {
  			case 'v':
  				this.vertices.push( parseFloat( buffer[ 1 ] ) );
  				this.vertices.push( parseFloat( buffer[ 2 ] ) );
  				this.vertices.push( parseFloat( buffer[ 3 ] ) );
  				if ( bufferPointer > 4 ) {

  					this.colors.push( parseFloat( buffer[ 4 ] ) );
  					this.colors.push( parseFloat( buffer[ 5 ] ) );
  					this.colors.push( parseFloat( buffer[ 6 ] ) );

  				}
  				break;

  			case 'vt':
  				this.uvs.push( parseFloat( buffer[ 1 ] ) );
  				this.uvs.push( parseFloat( buffer[ 2 ] ) );
  				break;

  			case 'vn':
  				this.normals.push( parseFloat( buffer[ 1 ] ) );
  				this.normals.push( parseFloat( buffer[ 2 ] ) );
  				this.normals.push( parseFloat( buffer[ 3 ] ) );
  				break;

  			case 'f':
  				bufferLength = bufferPointer - 1;

  				// "f vertex ..."
  				if ( slashesCount === 0 ) {

  					this.checkFaceType( 0 );
  					for ( i = 2, length = bufferLength; i < length; i ++ ) {

  						this$1.buildFace( buffer[ 1 ] );
  						this$1.buildFace( buffer[ i ] );
  						this$1.buildFace( buffer[ i + 1 ] );

  					}

  					// "f vertex/uv ..."
  				} else if  ( bufferLength === slashesCount * 2 ) {

  					this.checkFaceType( 1 );
  					for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {

  						this$1.buildFace( buffer[ 1 ], buffer[ 2 ] );
  						this$1.buildFace( buffer[ i ], buffer[ i + 1 ] );
  						this$1.buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );

  					}

  					// "f vertex/uv/normal ..."
  				} else if  ( bufferLength * 2 === slashesCount * 3 ) {

  					this.checkFaceType( 2 );
  					for ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {

  						this$1.buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );
  						this$1.buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );
  						this$1.buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );

  					}

  					// "f vertex//normal ..."
  				} else {

  					this.checkFaceType( 3 );
  					for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {

  						this$1.buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );
  						this$1.buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );
  						this$1.buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );

  					}

  				}
  				break;

  			case 'l':
  			case 'p':
  				bufferLength = bufferPointer - 1;
  				if ( bufferLength === slashesCount * 2 )  {

  					this.checkFaceType( 4 );
  					for ( i = 1, length = bufferLength + 1; i < length; i += 2 ) { this$1.buildFace( buffer[ i ], buffer[ i + 1 ] ); }

  				} else {

  					this.checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6  );
  					for ( i = 1, length = bufferLength + 1; i < length; i ++ ) { this$1.buildFace( buffer[ i ] ); }

  				}
  				break;

  			case 's':
  				this.pushSmoothingGroup( buffer[ 1 ] );
  				break;

  			case 'g':
  				// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set
  				this.processCompletedMesh();
  				this.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );
  				break;

  			case 'o':
  				// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with "useOAsMesh"
  				if ( this.useOAsMesh ) { this.processCompletedMesh(); }
  				this.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );
  				break;

  			case 'mtllib':
  				this.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );
  				break;

  			case 'usemtl':
  				var mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );
  				if ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {

  					this.rawMesh.activeMtlName = mtlName;
  					this.rawMesh.counts.mtlCount++;
  					this.checkSubGroup();

  				}
  				break;

  			default:
  				break;
  		}
  	},

  	pushSmoothingGroup: function ( smoothingGroup ) {
  		var smoothingGroupInt = parseInt( smoothingGroup );
  		if ( isNaN( smoothingGroupInt ) ) {
  			smoothingGroupInt = smoothingGroup === "off" ? 0 : 1;
  		}

  		var smoothCheck = this.rawMesh.smoothingGroup.normalized;
  		this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;
  		this.rawMesh.smoothingGroup.real = smoothingGroupInt;

  		if ( smoothCheck !== smoothingGroupInt ) {

  			this.rawMesh.counts.smoothingGroupCount++;
  			this.checkSubGroup();

  		}
  	},
  	checkFaceType: function ( faceType ) {
  		if ( this.rawMesh.faceType !== faceType ) {

  			this.processCompletedMesh();
  			this.rawMesh.faceType = faceType;
  			this.checkSubGroup();

  		}
  	},

  	checkSubGroup: function () {
  		var index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;
  		this.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];

  		if ( ! LoaderSupport.Validator.isValid( this.rawMesh.subGroupInUse ) ) {

  			this.rawMesh.subGroupInUse = {
  				index: index,
  				objectName: this.rawMesh.objectName,
  				groupName: this.rawMesh.groupName,
  				materialName: this.rawMesh.activeMtlName,
  				smoothingGroup: this.rawMesh.smoothingGroup.normalized,
  				vertices: [],
  				indexMappingsCount: 0,
  				indexMappings: [],
  				indices: [],
  				colors: [],
  				uvs: [],
  				normals: []
  			};
  			this.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;

  		}
  	},

  	buildFace: function ( faceIndexV, faceIndexU, faceIndexN ) {
  		if ( this.disregardNormals ) { faceIndexN = undefined; }
  		var scope = this;
  		var updateSubGroupInUse = function () {

  			var faceIndexVi = parseInt( faceIndexV );
  			var indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );
  			var indexPointerC = scope.colors.length > 0 ? indexPointerV : null;

  			var vertices = scope.rawMesh.subGroupInUse.vertices;
  			vertices.push( scope.vertices[ indexPointerV++ ] );
  			vertices.push( scope.vertices[ indexPointerV++ ] );
  			vertices.push( scope.vertices[ indexPointerV ] );

  			if ( indexPointerC !== null ) {

  				var colors = scope.rawMesh.subGroupInUse.colors;
  				colors.push( scope.colors[ indexPointerC++ ] );
  				colors.push( scope.colors[ indexPointerC++ ] );
  				colors.push( scope.colors[ indexPointerC ] );

  			}
  			if ( faceIndexU ) {

  				var faceIndexUi = parseInt( faceIndexU );
  				var indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );
  				var uvs = scope.rawMesh.subGroupInUse.uvs;
  				uvs.push( scope.uvs[ indexPointerU++ ] );
  				uvs.push( scope.uvs[ indexPointerU ] );

  			}
  			if ( faceIndexN ) {

  				var faceIndexNi = parseInt( faceIndexN );
  				var indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );
  				var normals = scope.rawMesh.subGroupInUse.normals;
  				normals.push( scope.normals[ indexPointerN++ ] );
  				normals.push( scope.normals[ indexPointerN++ ] );
  				normals.push( scope.normals[ indexPointerN ] );

  			}
  		};

  		if ( this.useIndices ) {

  			var mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );
  			var indicesPointer = this.rawMesh.subGroupInUse.indexMappings[ mappingName ];
  			if ( LoaderSupport.Validator.isValid( indicesPointer ) ) {

  				this.rawMesh.counts.doubleIndicesCount++;

  			} else {

  				indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;
  				updateSubGroupInUse();
  				this.rawMesh.subGroupInUse.indexMappings[ mappingName ] = indicesPointer;
  				this.rawMesh.subGroupInUse.indexMappingsCount++;

  			}
  			this.rawMesh.subGroupInUse.indices.push( indicesPointer );

  		} else {

  			updateSubGroupInUse();

  		}
  		this.rawMesh.counts.faceCount++;
  	},

  	createRawMeshReport: function ( inputObjectCount ) {
  		return 'Input Object number: ' + inputObjectCount +
  			'\n\tObject name: ' + this.rawMesh.objectName +
  			'\n\tGroup name: ' + this.rawMesh.groupName +
  			'\n\tMtllib name: ' + this.rawMesh.mtllibName +
  			'\n\tVertex count: ' + this.vertices.length / 3 +
  			'\n\tNormal count: ' + this.normals.length / 3 +
  			'\n\tUV count: ' + this.uvs.length / 2 +
  			'\n\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +
  			'\n\tMaterial count: ' + this.rawMesh.counts.mtlCount +
  			'\n\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;
  	},
  	finalizeRawMesh: function () {
  		var this$1 = this;

  		var meshOutputGroupTemp = [];
  		var meshOutputGroup;
  		var absoluteVertexCount = 0;
  		var absoluteIndexMappingsCount = 0;
  		var absoluteIndexCount = 0;
  		var absoluteColorCount = 0;
  		var absoluteNormalCount = 0;
  		var absoluteUvCount = 0;
  		var indices;
  		for ( var name in this$1.rawMesh.subGroups ) {

  			meshOutputGroup = this$1.rawMesh.subGroups[ name ];
  			if ( meshOutputGroup.vertices.length > 0 ) {

  				indices = meshOutputGroup.indices;
  				if ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {

  					for ( var i in indices ) { indices[ i ] = indices[ i ] + absoluteIndexMappingsCount; }

  				}
  				meshOutputGroupTemp.push( meshOutputGroup );
  				absoluteVertexCount += meshOutputGroup.vertices.length;
  				absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;
  				absoluteIndexCount += meshOutputGroup.indices.length;
  				absoluteColorCount += meshOutputGroup.colors.length;
  				absoluteUvCount += meshOutputGroup.uvs.length;
  				absoluteNormalCount += meshOutputGroup.normals.length;

  			}
  		}

  		// do not continue if no result
  		var result = null;
  		if ( meshOutputGroupTemp.length > 0 ) {

  			result = {
  				name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,
  				subGroups: meshOutputGroupTemp,
  				absoluteVertexCount: absoluteVertexCount,
  				absoluteIndexCount: absoluteIndexCount,
  				absoluteColorCount: absoluteColorCount,
  				absoluteNormalCount: absoluteNormalCount,
  				absoluteUvCount: absoluteUvCount,
  				faceCount: this.rawMesh.counts.faceCount,
  				doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount
  			};

  		}
  		return result;
  	},

  	processCompletedMesh: function () {
  		var result = this.finalizeRawMesh();
  		if ( LoaderSupport.Validator.isValid( result ) ) {

  			if ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {

  				this._throwError( 'Vertex Colors were detected, but vertex count and color count do not match!' );

  			}
  			if ( this.logging.enabled && this.logging.debug ) { console.debug( this.createRawMeshReport( this.inputObjectCount ) ); }
  			this.inputObjectCount++;

  			this.buildMesh( result );
  			var progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;
  			this.callbackProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%', progressBytesPercent );
  			this.resetRawMesh();
  			return true;

  		} else {

  			return false;
  		}
  	},
  	buildMesh: function ( result ) {
  		var this$1 = this;

  		var meshOutputGroups = result.subGroups;

  		var vertexFA = new Float32Array( result.absoluteVertexCount );
  		this.globalCounts.vertices += result.absoluteVertexCount / 3;
  		this.globalCounts.faces += result.faceCount;
  		this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;
  		var indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;
  		var colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;
  		var normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;
  		var uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;
  		var haveVertexColors = LoaderSupport.Validator.isValid( colorFA );

  		var meshOutputGroup;
  		var materialNames = [];

  		var createMultiMaterial = ( meshOutputGroups.length > 1 );
  		var materialIndex = 0;
  		var materialIndexMapping = [];
  		var selectedMaterialIndex;
  		var materialGroup;
  		var materialGroups = [];

  		var vertexFAOffset = 0;
  		var indexUAOffset = 0;
  		var colorFAOffset = 0;
  		var normalFAOffset = 0;
  		var uvFAOffset = 0;
  		var materialGroupOffset = 0;
  		var materialGroupLength = 0;

  		var materialOrg, material, materialName, materialNameOrg;
  		// only one specific face type
  		for ( var oodIndex in meshOutputGroups ) {

  			if ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) { continue; }
  			meshOutputGroup = meshOutputGroups[ oodIndex ];

  			materialNameOrg = meshOutputGroup.materialName;
  			if ( this$1.rawMesh.faceType < 4 ) {

  				materialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );
  			} else {

  				materialName = this$1.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';

  			}
  			materialOrg = this$1.materials[ materialNameOrg ];
  			material = this$1.materials[ materialName ];

  			// both original and derived names do not lead to an existing material => need to use a default material
  			if ( ! LoaderSupport.Validator.isValid( materialOrg ) && ! LoaderSupport.Validator.isValid( material ) ) {

  				var defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';
  				materialOrg = this$1.materials[ defaultMaterialName ];
  				if ( this$1.logging.enabled ) { console.warn( 'object_group "' + meshOutputGroup.objectName + '_' +
  					meshOutputGroup.groupName + '" was defined with unresolvable material "' +
  					materialNameOrg + '"! Assigning "' + defaultMaterialName + '".' ); }
  				materialNameOrg = defaultMaterialName;

  				// if names are identical then there is no need for later manipulation
  				if ( materialNameOrg === materialName ) {

  					material = materialOrg;
  					materialName = defaultMaterialName;

  				}

  			}
  			if ( ! LoaderSupport.Validator.isValid( material ) ) {

  				var materialCloneInstructions = {
  					materialNameOrg: materialNameOrg,
  					materialName: materialName,
  					materialProperties: {
  						vertexColors: haveVertexColors ? 2 : 0,
  						flatShading: meshOutputGroup.smoothingGroup === 0
  					}
  				};
  				var payload = {
  					cmd: 'materialData',
  					materials: {
  						materialCloneInstructions: materialCloneInstructions
  					}
  				};
  				this$1.callbackMeshBuilder( payload );

  				// fake entry for async; sync Parser always works on material references (Builder update directly visible here)
  				if ( this$1.useAsync ) { this$1.materials[ materialName ] = materialCloneInstructions; }

  			}

  			if ( createMultiMaterial ) {

  				// re-use material if already used before. Reduces materials array size and eliminates duplicates
  				selectedMaterialIndex = materialIndexMapping[ materialName ];
  				if ( ! selectedMaterialIndex ) {

  					selectedMaterialIndex = materialIndex;
  					materialIndexMapping[ materialName ] = materialIndex;
  					materialNames.push( materialName );
  					materialIndex++;

  				}
  				materialGroupLength = this$1.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;
  				materialGroup = {
  					start: materialGroupOffset,
  					count: materialGroupLength,
  					index: selectedMaterialIndex
  				};
  				materialGroups.push( materialGroup );
  				materialGroupOffset += materialGroupLength;

  			} else {

  				materialNames.push( materialName );

  			}

  			vertexFA.set( meshOutputGroup.vertices, vertexFAOffset );
  			vertexFAOffset += meshOutputGroup.vertices.length;

  			if ( indexUA ) {

  				indexUA.set( meshOutputGroup.indices, indexUAOffset );
  				indexUAOffset += meshOutputGroup.indices.length;

  			}

  			if ( colorFA ) {

  				colorFA.set( meshOutputGroup.colors, colorFAOffset );
  				colorFAOffset += meshOutputGroup.colors.length;

  			}

  			if ( normalFA ) {

  				normalFA.set( meshOutputGroup.normals, normalFAOffset );
  				normalFAOffset += meshOutputGroup.normals.length;

  			}
  			if ( uvFA ) {

  				uvFA.set( meshOutputGroup.uvs, uvFAOffset );
  				uvFAOffset += meshOutputGroup.uvs.length;

  			}

  			if ( this$1.logging.enabled && this$1.logging.debug ) {
  				var materialIndexLine = LoaderSupport.Validator.isValid( selectedMaterialIndex ) ? '\n\t\tmaterialIndex: ' + selectedMaterialIndex : '';
  				var createdReport = '\tOutput Object no.: ' + this$1.outputObjectCount +
  					'\n\t\tgroupName: ' + meshOutputGroup.groupName +
  					'\n\t\tIndex: ' + meshOutputGroup.index +
  					'\n\t\tfaceType: ' + this$1.rawMesh.faceType +
  					'\n\t\tmaterialName: ' + meshOutputGroup.materialName +
  					'\n\t\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +
  					materialIndexLine +
  					'\n\t\tobjectName: ' + meshOutputGroup.objectName +
  					'\n\t\t#vertices: ' + meshOutputGroup.vertices.length / 3 +
  					'\n\t\t#indices: ' + meshOutputGroup.indices.length +
  					'\n\t\t#colors: ' + meshOutputGroup.colors.length / 3 +
  					'\n\t\t#uvs: ' + meshOutputGroup.uvs.length / 2 +
  					'\n\t\t#normals: ' + meshOutputGroup.normals.length / 3;
  				console.debug( createdReport );
  			}

  		}

  		this.outputObjectCount++;
  		this.callbackMeshBuilder(
  			{
  				cmd: 'meshData',
  				progress: {
  					numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes
  				},
  				params: {
  					meshName: result.name
  				},
  				materials: {
  					multiMaterial: createMultiMaterial,
  					materialNames: materialNames,
  					materialGroups: materialGroups
  				},
  				buffers: {
  					vertices: vertexFA,
  					indices: indexUA,
  					colors: colorFA,
  					normals: normalFA,
  					uvs: uvFA
  				},
  				// 0: mesh, 1: line, 2: point
  				geometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1
  			},
  			[ vertexFA.buffer ],
  			LoaderSupport.Validator.isValid( indexUA ) ? [ indexUA.buffer ] : null,
  			LoaderSupport.Validator.isValid( colorFA ) ? [ colorFA.buffer ] : null,
  			LoaderSupport.Validator.isValid( normalFA ) ? [ normalFA.buffer ] : null,
  			LoaderSupport.Validator.isValid( uvFA ) ? [ uvFA.buffer ] : null
  		);
  	},

  	finalizeParsing: function () {
  		if ( this.logging.enabled ) { console.info( 'Global output object count: ' + this.outputObjectCount ); }
  		if ( this.processCompletedMesh() && this.logging.enabled ) {

  			var parserFinalReport = 'Overall counts: ' +
  				'\n\tVertices: ' + this.globalCounts.vertices +
  				'\n\tFaces: ' + this.globalCounts.faces +
  				'\n\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;
  			console.info( parserFinalReport );

  		}
  	}
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PCDLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.littleEndian = true;

  };
  PCDLoader.prototype = {

  	constructor: PCDLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( data ) {

  			try {

  				onLoad( scope.parse( data, url ) );

  			} catch ( e ) {

  				if ( onError ) {

  					onError( e );

  				} else {

  					throw e;

  				}

  			}

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data, url ) {
  		var this$1 = this;


  		function parseHeader( data ) {

  			var PCDheader = {};
  			var result1 = data.search( /[\r\n]DATA\s(\S*)\s/i );
  			var result2 = /[\r\n]DATA\s(\S*)\s/i.exec( data.substr( result1 - 1 ) );

  			PCDheader.data = result2[ 1 ];
  			PCDheader.headerLen = result2[ 0 ].length + result1;
  			PCDheader.str = data.substr( 0, PCDheader.headerLen );

  			// remove comments

  			PCDheader.str = PCDheader.str.replace( /\#.*/gi, '' );

  			// parse

  			PCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );
  			PCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );
  			PCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );
  			PCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );
  			PCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );
  			PCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );
  			PCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );
  			PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );
  			PCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );

  			// evaluate

  			if ( PCDheader.version !== null )
  				{ PCDheader.version = parseFloat( PCDheader.version[ 1 ] ); }

  			if ( PCDheader.fields !== null )
  				{ PCDheader.fields = PCDheader.fields[ 1 ].split( ' ' ); }

  			if ( PCDheader.type !== null )
  				{ PCDheader.type = PCDheader.type[ 1 ].split( ' ' ); }

  			if ( PCDheader.width !== null )
  				{ PCDheader.width = parseInt( PCDheader.width[ 1 ] ); }

  			if ( PCDheader.height !== null )
  				{ PCDheader.height = parseInt( PCDheader.height[ 1 ] ); }

  			if ( PCDheader.viewpoint !== null )
  				{ PCDheader.viewpoint = PCDheader.viewpoint[ 1 ]; }

  			if ( PCDheader.points !== null )
  				{ PCDheader.points = parseInt( PCDheader.points[ 1 ], 10 ); }

  			if ( PCDheader.points === null )
  				{ PCDheader.points = PCDheader.width * PCDheader.height; }

  			if ( PCDheader.size !== null ) {

  				PCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {

  					return parseInt( x, 10 );

  				} );

  			}

  			if ( PCDheader.count !== null ) {

  				PCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {

  					return parseInt( x, 10 );

  				} );

  			} else {

  				PCDheader.count = [];

  				for ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {

  					PCDheader.count.push( 1 );

  				}

  			}

  			PCDheader.offset = {};

  			var sizeSum = 0;

  			for ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {

  				if ( PCDheader.data === 'ascii' ) {

  					PCDheader.offset[ PCDheader.fields[ i ] ] = i;

  				} else {

  					PCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;
  					sizeSum += PCDheader.size[ i ];

  				}

  			}

  			// for binary only

  			PCDheader.rowSize = sizeSum;

  			return PCDheader;

  		}

  		var textData = LoaderUtils.decodeText( data );

  		// parse header (always ascii format)

  		var PCDheader = parseHeader( textData );

  		// parse data

  		var position = [];
  		var normal = [];
  		var color = [];

  		// ascii

  		if ( PCDheader.data === 'ascii' ) {

  			var offset = PCDheader.offset;
  			var pcdData = textData.substr( PCDheader.headerLen );
  			var lines = pcdData.split( '\n' );

  			for ( var i = 0, l = lines.length; i < l; i ++ ) {

  				if ( lines[ i ] === '' ) { continue; }

  				var line = lines[ i ].split( ' ' );

  				if ( offset.x !== undefined ) {

  					position.push( parseFloat( line[ offset.x ] ) );
  					position.push( parseFloat( line[ offset.y ] ) );
  					position.push( parseFloat( line[ offset.z ] ) );

  				}

  				if ( offset.rgb !== undefined ) {

  					var rgb = parseFloat( line[ offset.rgb ] );
  					var r = ( rgb >> 16 ) & 0x0000ff;
  					var g = ( rgb >> 8 ) & 0x0000ff;
  					var b = ( rgb >> 0 ) & 0x0000ff;
  					color.push( r / 255, g / 255, b / 255 );

  				}

  				if ( offset.normal_x !== undefined ) {

  					normal.push( parseFloat( line[ offset.normal_x ] ) );
  					normal.push( parseFloat( line[ offset.normal_y ] ) );
  					normal.push( parseFloat( line[ offset.normal_z ] ) );

  				}

  			}

  		}

  		// binary

  		if ( PCDheader.data === 'binary_compressed' ) {

  			console.error( 'PCDLoader: binary_compressed files are not supported' );
  			return;

  		}

  		if ( PCDheader.data === 'binary' ) {

  			var dataview = new DataView( data, PCDheader.headerLen );
  			var offset = PCDheader.offset;

  			for ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {

  				if ( offset.x !== undefined ) {

  					position.push( dataview.getFloat32( row + offset.x, this$1.littleEndian ) );
  					position.push( dataview.getFloat32( row + offset.y, this$1.littleEndian ) );
  					position.push( dataview.getFloat32( row + offset.z, this$1.littleEndian ) );

  				}

  				if ( offset.rgb !== undefined ) {

  					color.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );
  					color.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );
  					color.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );

  				}

  				if ( offset.normal_x !== undefined ) {

  					normal.push( dataview.getFloat32( row + offset.normal_x, this$1.littleEndian ) );
  					normal.push( dataview.getFloat32( row + offset.normal_y, this$1.littleEndian ) );
  					normal.push( dataview.getFloat32( row + offset.normal_z, this$1.littleEndian ) );

  				}

  			}

  		}

  		// build geometry

  		var geometry = new BufferGeometry();

  		if ( position.length > 0 ) { geometry.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) ); }
  		if ( normal.length > 0 ) { geometry.addAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) ); }
  		if ( color.length > 0 ) { geometry.addAttribute( 'color', new Float32BufferAttribute( color, 3 ) ); }

  		geometry.computeBoundingSphere();

  		// build material

  		var material = new PointsMaterial( { size: 0.005 } );

  		if ( color.length > 0 ) {

  			material.vertexColors = VertexColors;

  		} else {

  			material.color.setHex( Math.random() * 0xffffff );

  		}

  		// build mesh

  		var mesh = new Points( geometry, material );
  		var name = url.split( '' ).reverse().join( '' );
  		name = /([^\/]*)/.exec( name );
  		name = name[ 1 ].split( '' ).reverse().join( '' );
  		mesh.name = name;

  		return mesh;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PDBLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  PDBLoader.prototype = {

  	constructor: PDBLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	// Based on CanvasMol PDB parser

  	parse: function ( text ) {

  		function trim( text ) {

  			return text.replace( /^\s\s*/, '' ).replace( /\s\s*$/, '' );

  		}

  		function capitalize( text ) {

  			return text.charAt( 0 ).toUpperCase() + text.substr( 1 ).toLowerCase();

  		}

  		function hash( s, e ) {

  			return 's' + Math.min( s, e ) + 'e' + Math.max( s, e );

  		}

  		function parseBond( start, length ) {

  			var eatom = parseInt( lines[ i ].substr( start, length ) );

  			if ( eatom ) {

  				var h = hash( satom, eatom );

  				if ( bhash[ h ] === undefined ) {

  					bonds.push( [ satom - 1, eatom - 1, 1 ] );
  					bhash[ h ] = bonds.length - 1;

  				}

  			}

  		}

  		function buildGeometry() {

  			var build = {
  				geometryAtoms: new BufferGeometry(),
  				geometryBonds: new BufferGeometry(),
  				json: {
  					atoms: atoms,
  					bonds: bonds
  				}
  			};

  			var geometryAtoms = build.geometryAtoms;
  			var geometryBonds = build.geometryBonds;

  			var i, l;

  			var verticesAtoms = [];
  			var colorsAtoms = [];
  			var verticesBonds = [];

  			// atoms

  			for ( i = 0, l = atoms.length; i < l; i ++ ) {

  				var atom = atoms[ i ];

  				var x = atom[ 0 ];
  				var y = atom[ 1 ];
  				var z = atom[ 2 ];

  				verticesAtoms.push( x, y, z );

  				var r = atom[ 3 ][ 0 ] / 255;
  				var g = atom[ 3 ][ 1 ] / 255;
  				var b = atom[ 3 ][ 2 ] / 255;

  				colorsAtoms.push( r, g, b );

  			}

  			// bonds

  			for ( i = 0, l = bonds.length; i < l; i ++ ) {

  				var bond = bonds[ i ];

  				var start = bond[ 0 ];
  				var end = bond[ 1 ];

  				verticesBonds.push( verticesAtoms[ ( start * 3 ) + 0 ] );
  				verticesBonds.push( verticesAtoms[ ( start * 3 ) + 1 ] );
  				verticesBonds.push( verticesAtoms[ ( start * 3 ) + 2 ] );

  				verticesBonds.push( verticesAtoms[ ( end * 3 ) + 0 ] );
  				verticesBonds.push( verticesAtoms[ ( end * 3 ) + 1 ] );
  				verticesBonds.push( verticesAtoms[ ( end * 3 ) + 2 ] );

  			}

  			// build geometry

  			geometryAtoms.addAttribute( 'position', new Float32BufferAttribute( verticesAtoms, 3 ) );
  			geometryAtoms.addAttribute( 'color', new Float32BufferAttribute( colorsAtoms, 3 ) );

  			geometryBonds.addAttribute( 'position', new Float32BufferAttribute( verticesBonds, 3 ) );

  			return build;

  		}

  		var CPK = { h: [ 255, 255, 255 ], he: [ 217, 255, 255 ], li: [ 204, 128, 255 ], be: [ 194, 255, 0 ], b: [ 255, 181, 181 ], c: [ 144, 144, 144 ], n: [ 48, 80, 248 ], o: [ 255, 13, 13 ], f: [ 144, 224, 80 ], ne: [ 179, 227, 245 ], na: [ 171, 92, 242 ], mg: [ 138, 255, 0 ], al: [ 191, 166, 166 ], si: [ 240, 200, 160 ], p: [ 255, 128, 0 ], s: [ 255, 255, 48 ], cl: [ 31, 240, 31 ], ar: [ 128, 209, 227 ], k: [ 143, 64, 212 ], ca: [ 61, 255, 0 ], sc: [ 230, 230, 230 ], ti: [ 191, 194, 199 ], v: [ 166, 166, 171 ], cr: [ 138, 153, 199 ], mn: [ 156, 122, 199 ], fe: [ 224, 102, 51 ], co: [ 240, 144, 160 ], ni: [ 80, 208, 80 ], cu: [ 200, 128, 51 ], zn: [ 125, 128, 176 ], ga: [ 194, 143, 143 ], ge: [ 102, 143, 143 ], as: [ 189, 128, 227 ], se: [ 255, 161, 0 ], br: [ 166, 41, 41 ], kr: [ 92, 184, 209 ], rb: [ 112, 46, 176 ], sr: [ 0, 255, 0 ], y: [ 148, 255, 255 ], zr: [ 148, 224, 224 ], nb: [ 115, 194, 201 ], mo: [ 84, 181, 181 ], tc: [ 59, 158, 158 ], ru: [ 36, 143, 143 ], rh: [ 10, 125, 140 ], pd: [ 0, 105, 133 ], ag: [ 192, 192, 192 ], cd: [ 255, 217, 143 ], in: [ 166, 117, 115 ], sn: [ 102, 128, 128 ], sb: [ 158, 99, 181 ], te: [ 212, 122, 0 ], i: [ 148, 0, 148 ], xe: [ 66, 158, 176 ], cs: [ 87, 23, 143 ], ba: [ 0, 201, 0 ], la: [ 112, 212, 255 ], ce: [ 255, 255, 199 ], pr: [ 217, 255, 199 ], nd: [ 199, 255, 199 ], pm: [ 163, 255, 199 ], sm: [ 143, 255, 199 ], eu: [ 97, 255, 199 ], gd: [ 69, 255, 199 ], tb: [ 48, 255, 199 ], dy: [ 31, 255, 199 ], ho: [ 0, 255, 156 ], er: [ 0, 230, 117 ], tm: [ 0, 212, 82 ], yb: [ 0, 191, 56 ], lu: [ 0, 171, 36 ], hf: [ 77, 194, 255 ], ta: [ 77, 166, 255 ], w: [ 33, 148, 214 ], re: [ 38, 125, 171 ], os: [ 38, 102, 150 ], ir: [ 23, 84, 135 ], pt: [ 208, 208, 224 ], au: [ 255, 209, 35 ], hg: [ 184, 184, 208 ], tl: [ 166, 84, 77 ], pb: [ 87, 89, 97 ], bi: [ 158, 79, 181 ], po: [ 171, 92, 0 ], at: [ 117, 79, 69 ], rn: [ 66, 130, 150 ], fr: [ 66, 0, 102 ], ra: [ 0, 125, 0 ], ac: [ 112, 171, 250 ], th: [ 0, 186, 255 ], pa: [ 0, 161, 255 ], u: [ 0, 143, 255 ], np: [ 0, 128, 255 ], pu: [ 0, 107, 255 ], am: [ 84, 92, 242 ], cm: [ 120, 92, 227 ], bk: [ 138, 79, 227 ], cf: [ 161, 54, 212 ], es: [ 179, 31, 212 ], fm: [ 179, 31, 186 ], md: [ 179, 13, 166 ], no: [ 189, 13, 135 ], lr: [ 199, 0, 102 ], rf: [ 204, 0, 89 ], db: [ 209, 0, 79 ], sg: [ 217, 0, 69 ], bh: [ 224, 0, 56 ], hs: [ 230, 0, 46 ], mt: [ 235, 0, 38 ], ds: [ 235, 0, 38 ], rg: [ 235, 0, 38 ], cn: [ 235, 0, 38 ], uut: [ 235, 0, 38 ], uuq: [ 235, 0, 38 ], uup: [ 235, 0, 38 ], uuh: [ 235, 0, 38 ], uus: [ 235, 0, 38 ], uuo: [ 235, 0, 38 ] };

  		var atoms = [];
  		var bonds = [];

  		var bhash = {};

  		var x, y, z, index, e;

  		// parse

  		var lines = text.split( '\n' );

  		for ( var i = 0, l = lines.length; i < l; i ++ ) {

  			if ( lines[ i ].substr( 0, 4 ) === 'ATOM' || lines[ i ].substr( 0, 6 ) === 'HETATM' ) {

  				x = parseFloat( lines[ i ].substr( 30, 7 ) );
  				y = parseFloat( lines[ i ].substr( 38, 7 ) );
  				z = parseFloat( lines[ i ].substr( 46, 7 ) );
  				index = parseInt( lines[ i ].substr( 6, 5 ) ) - 1;

  				e = trim( lines[ i ].substr( 76, 2 ) ).toLowerCase();

  				if ( e === '' ) {

  					e = trim( lines[ i ].substr( 12, 2 ) ).toLowerCase();

  				}

  				atoms[ index ] = [ x, y, z, CPK[ e ], capitalize( e ) ];

  			} else if ( lines[ i ].substr( 0, 6 ) === 'CONECT' ) {

  				var satom = parseInt( lines[ i ].substr( 6, 5 ) );

  				parseBond( 11, 5 );
  				parseBond( 16, 5 );
  				parseBond( 21, 5 );
  				parseBond( 26, 5 );

  			}

  		}

  		// build and return geometry

  		return buildGeometry();

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PlayCanvasLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  PlayCanvasLoader.prototype = {

  	constructor: PlayCanvasLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( json ) {

  		function parseVertices( data ) {

  			var attributes = {};

  			// create a buffer attribute for each array that contains vertex information

  			for ( var name in data ) {

  				var array = data[ name ];

  				var type = array.type;
  				var size = array.components;

  				var attribute;

  				switch ( type ) {

  					case 'float32':
  						attribute = new Float32BufferAttribute( array.data, size );
  						break;

  					case 'uint8':
  						attribute = new Uint8BufferAttribute( array.data, size );
  						break;

  					case 'uint16':
  						attribute = new Uint16BufferAttribute( array.data, size );
  						break;

  					default:
  						console.log( 'PlayCanvasLoader: Array type "%s" not yet supported.', type );

  				}

  				attributes[ name ] = attribute;

  			}

  			data._attributes = attributes;

  		}

  		function parseMeshes( data ) {

  			// create buffer geometry

  			var geometry = new BufferGeometry();

  			geometry.setIndex( data.indices );

  			var attributes = model.vertices[ data.vertices ]._attributes;

  			for ( var name in attributes ) {

  				var attribute = attributes[ name ];

  				if ( name === 'texCoord0' ) { name = 'uv'; }

  				geometry.addAttribute( name, attribute );

  			}

  			data._geometry = geometry;

  		}

  		function parseMeshInstances( data ) {

  			var node = model.nodes[ data.node ];
  			var mesh = model.meshes[ data.mesh ];

  			if ( node._geometries === undefined ) {

  				node._geometries = [];

  			}

  			node._geometries.push( mesh._geometry );

  		}

  		function parseNodes( data ) {

  			var object = new Group();

  			var geometries = data._geometries;

  			if ( geometries !== undefined ) {

  				var material = new MeshPhongMaterial();

  				for ( var i = 0, l = geometries.length; i < l; i ++ ) {

  					var geometry = geometries[ i ];

  					object.add( new Mesh( geometry, material ) );

  				}

  			}

  			for ( var i = 0, l = data.rotation.length; i < l; i ++ ) {

  				data.rotation[ i ] *= Math.PI / 180;

  			}

  			//

  			object.name = data.name;

  			object.position.fromArray( data.position );
  			object.quaternion.setFromEuler( new Euler().fromArray( data.rotation ) );
  			object.scale.fromArray( data.scale );

  			data._object = object;

  		}

  		//

  		var model = json.model;

  		for ( var i = 0, l = model.vertices.length; i < l; i ++ ) {

  			parseVertices( model.vertices[ i ] );

  		}

  		for ( var i = 0, l = model.meshes.length; i < l; i ++ ) {

  			parseMeshes( model.meshes[ i ] );

  		}

  		for ( var i = 0, l = model.meshInstances.length; i < l; i ++ ) {

  			parseMeshInstances( model.meshInstances[ i ] );

  		}

  		for ( var i = 0, l = model.nodes.length; i < l; i ++ ) {

  			parseNodes( model.nodes[ i ] );

  		}

  		// setup scene hierarchy

  		for ( var i = 0, l = model.parents.length; i < l; i ++ ) {

  			var parent = model.parents[ i ];

  			if ( parent === - 1 ) { continue; }

  			model.nodes[ parent ]._object.add( model.nodes[ i ]._object );
  		}

  		return model.nodes[ 0 ]._object;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PLYLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	this.propertyNameMapping = {};

  };

  PLYLoader.prototype = {

  	constructor: PLYLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setPropertyNameMapping: function ( mapping ) {

  		this.propertyNameMapping = mapping;

  	},

  	parse: function ( data ) {

  		function parseHeader( data ) {

  			var patternHeader = /ply([\s\S]*)end_header\r?\n/;
  			var headerText = '';
  			var headerLength = 0;
  			var result = patternHeader.exec( data );

  			if ( result !== null ) {

  				headerText = result[ 1 ];
  				headerLength = result[ 0 ].length;

  			}

  			var header = {
  				comments: [],
  				elements: [],
  				headerLength: headerLength
  			};

  			var lines = headerText.split( '\n' );
  			var currentElement;
  			var lineType, lineValues;

  			function make_ply_element_property( propertValues, propertyNameMapping ) {

  				var property = { type: propertValues[ 0 ] };

  				if ( property.type === 'list' ) {

  					property.name = propertValues[ 3 ];
  					property.countType = propertValues[ 1 ];
  					property.itemType = propertValues[ 2 ];

  				} else {

  					property.name = propertValues[ 1 ];

  				}

  				if ( property.name in propertyNameMapping ) {

  					property.name = propertyNameMapping[ property.name ];

  				}

  				return property;

  			}

  			for ( var i = 0; i < lines.length; i ++ ) {

  				var line = lines[ i ];
  				line = line.trim();

  				if ( line === '' ) { continue; }

  				lineValues = line.split( /\s+/ );
  				lineType = lineValues.shift();
  				line = lineValues.join( ' ' );

  				switch ( lineType ) {

  					case 'format':

  						header.format = lineValues[ 0 ];
  						header.version = lineValues[ 1 ];

  						break;

  					case 'comment':

  						header.comments.push( line );

  						break;

  					case 'element':

  						if ( currentElement !== undefined ) {

  							header.elements.push( currentElement );

  						}

  						currentElement = {};
  						currentElement.name = lineValues[ 0 ];
  						currentElement.count = parseInt( lineValues[ 1 ] );
  						currentElement.properties = [];

  						break;

  					case 'property':

  						currentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );

  						break;
  					default:

  						console.log( 'unhandled', lineType, lineValues );

  				}

  			}

  			if ( currentElement !== undefined ) {

  				header.elements.push( currentElement );

  			}

  			return header;

  		}

  		function parseASCIINumber( n, type ) {

  			switch ( type ) {

  				case 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':
  				case 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':

  					return parseInt( n );

  				case 'float': case 'double': case 'float32': case 'float64':

  					return parseFloat( n );

  			}

  		}

  		function parseASCIIElement( properties, line ) {

  			var values = line.split( /\s+/ );

  			var element = {};

  			for ( var i = 0; i < properties.length; i ++ ) {

  				if ( properties[ i ].type === 'list' ) {

  					var list = [];
  					var n = parseASCIINumber( values.shift(), properties[ i ].countType );

  					for ( var j = 0; j < n; j ++ ) {

  						list.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );

  					}

  					element[ properties[ i ].name ] = list;

  				} else {

  					element[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );

  				}

  			}

  			return element;

  		}

  		function parseASCII( data, header ) {

  			// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

  			var buffer = {
  				indices: [],
  				vertices: [],
  				normals: [],
  				uvs: [],
  				faceVertexUvs: [],
  				colors: []
  			};

  			var result;

  			var patternBody = /end_header\s([\s\S]*)$/;
  			var body = '';
  			if ( ( result = patternBody.exec( data ) ) !== null ) {

  				body = result[ 1 ];

  			}

  			var lines = body.split( '\n' );
  			var currentElement = 0;
  			var currentElementCount = 0;

  			for ( var i = 0; i < lines.length; i ++ ) {

  				var line = lines[ i ];
  				line = line.trim();
  				if ( line === '' ) {

  					continue;

  				}

  				if ( currentElementCount >= header.elements[ currentElement ].count ) {

  					currentElement ++;
  					currentElementCount = 0;

  				}

  				var element = parseASCIIElement( header.elements[ currentElement ].properties, line );

  				handleElement( buffer, header.elements[ currentElement ].name, element );

  				currentElementCount ++;

  			}

  			return postProcess( buffer );

  		}

  		function postProcess( buffer ) {

  			var geometry = new BufferGeometry();

  			// mandatory buffer data

  			if ( buffer.indices.length > 0 ) {

  				geometry.setIndex( buffer.indices );

  			}

  			geometry.addAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );

  			// optional buffer data

  			if ( buffer.normals.length > 0 ) {

  				geometry.addAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );

  			}

  			if ( buffer.uvs.length > 0 ) {

  				geometry.addAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );

  			}

  			if ( buffer.colors.length > 0 ) {

  				geometry.addAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );

  			}

  			if ( buffer.faceVertexUvs.length > 0 ) {

  				geometry = geometry.toNonIndexed();
  				geometry.addAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );

  			}

  			geometry.computeBoundingSphere();

  			return geometry;

  		}

  		function handleElement( buffer, elementName, element ) {

  			if ( elementName === 'vertex' ) {

  				buffer.vertices.push( element.x, element.y, element.z );

  				if ( 'nx' in element && 'ny' in element && 'nz' in element ) {

  					buffer.normals.push( element.nx, element.ny, element.nz );

  				}

  				if ( 's' in element && 't' in element ) {

  					buffer.uvs.push( element.s, element.t );

  				}

  				if ( 'red' in element && 'green' in element && 'blue' in element ) {

  					buffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );

  				}

  			} else if ( elementName === 'face' ) {

  				var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338
  				var texcoord = element.texcoord;

  				if ( vertex_indices.length === 3 ) {

  					buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );

  					if ( texcoord && texcoord.length === 6 ) {

  						buffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );
  						buffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );
  						buffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );

  					}

  				} else if ( vertex_indices.length === 4 ) {

  					buffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );
  					buffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );

  				}

  			}

  		}

  		function binaryRead( dataview, at, type, little_endian ) {

  			switch ( type ) {

  				// corespondences for non-specific length types here match rply:
  				case 'int8':		case 'char':	 return [ dataview.getInt8( at ), 1 ];
  				case 'uint8':		case 'uchar':	 return [ dataview.getUint8( at ), 1 ];
  				case 'int16':		case 'short':	 return [ dataview.getInt16( at, little_endian ), 2 ];
  				case 'uint16':	case 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];
  				case 'int32':		case 'int':		 return [ dataview.getInt32( at, little_endian ), 4 ];
  				case 'uint32':	case 'uint':	 return [ dataview.getUint32( at, little_endian ), 4 ];
  				case 'float32': case 'float':	 return [ dataview.getFloat32( at, little_endian ), 4 ];
  				case 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];

  			}

  		}

  		function binaryReadElement( dataview, at, properties, little_endian ) {

  			var element = {};
  			var result, read = 0;

  			for ( var i = 0; i < properties.length; i ++ ) {

  				if ( properties[ i ].type === 'list' ) {

  					var list = [];

  					result = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );
  					var n = result[ 0 ];
  					read += result[ 1 ];

  					for ( var j = 0; j < n; j ++ ) {

  						result = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );
  						list.push( result[ 0 ] );
  						read += result[ 1 ];

  					}

  					element[ properties[ i ].name ] = list;

  				} else {

  					result = binaryRead( dataview, at + read, properties[ i ].type, little_endian );
  					element[ properties[ i ].name ] = result[ 0 ];
  					read += result[ 1 ];

  				}

  			}

  			return [ element, read ];

  		}

  		function parseBinary( data, header ) {

  			var buffer = {
  				indices: [],
  				vertices: [],
  				normals: [],
  				uvs: [],
  				faceVertexUvs: [],
  				colors: []
  			};

  			var little_endian = ( header.format === 'binary_little_endian' );
  			var body = new DataView( data, header.headerLength );
  			var result, loc = 0;

  			for ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {

  				for ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {

  					result = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );
  					loc += result[ 1 ];
  					var element = result[ 0 ];

  					handleElement( buffer, header.elements[ currentElement ].name, element );

  				}

  			}

  			return postProcess( buffer );

  		}

  		//

  		var geometry;
  		var scope = this;

  		if ( data instanceof ArrayBuffer ) {

  			var text = LoaderUtils.decodeText( new Uint8Array( data ) );
  			var header = parseHeader( text );

  			geometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );

  		} else {

  			geometry = parseASCII( data, parseHeader( data ) );

  		}

  		return geometry;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  	var bigEndianPlatform = null;
  	function isBigEndianPlatform() {

  		if ( bigEndianPlatform === null ) {

  			var buffer = new ArrayBuffer( 2 ),
  				uint8Array = new Uint8Array( buffer ),
  				uint16Array = new Uint16Array( buffer );

  			uint8Array[ 0 ] = 0xAA; // set first byte
  			uint8Array[ 1 ] = 0xBB; // set second byte
  			bigEndianPlatform = ( uint16Array[ 0 ] === 0xAABB );

  		}

  		return bigEndianPlatform;

  	}

  	// match the values defined in the spec to the TypedArray types
  	var InvertedEncodingTypes = [
  		null,
  		Float32Array,
  		null,
  		Int8Array,
  		Int16Array,
  		null,
  		Int32Array,
  		Uint8Array,
  		Uint16Array,
  		null,
  		Uint32Array
  	];

  	// define the method to use on a DataView, corresponding the TypedArray type
  	var getMethods = {
  		Uint16Array: 'getUint16',
  		Uint32Array: 'getUint32',
  		Int16Array: 'getInt16',
  		Int32Array: 'getInt32',
  		Float32Array: 'getFloat32',
  		Float64Array: 'getFloat64'
  	};
  	function copyFromBuffer( sourceArrayBuffer, viewType, position, length, fromBigEndian ) {

  		var bytesPerElement = viewType.BYTES_PER_ELEMENT,
  			result;

  		if ( fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1 ) {

  			result = new viewType( sourceArrayBuffer, position, length );

  		} else {

  			var readView = new DataView( sourceArrayBuffer, position, length * bytesPerElement ),
  				getMethod = getMethods[ viewType.name ],
  				littleEndian = ! fromBigEndian,
  				i = 0;

  			result = new viewType( length );

  			for ( ; i < length; i ++ ) {

  				result[ i ] = readView[ getMethod ]( i * bytesPerElement, littleEndian );

  			}

  		}

  		return result;

  	}
  	function decodePrwm( buffer ) {

  		var array = new Uint8Array( buffer ),
  			version = array[ 0 ],
  			flags = array[ 1 ],
  			indexedGeometry = !! ( flags >> 7 & 0x01 ),
  			indicesType = flags >> 6 & 0x01,
  			bigEndian = ( flags >> 5 & 0x01 ) === 1,
  			attributesNumber = flags & 0x1F,
  			valuesNumber = 0,
  			indicesNumber = 0;

  		if ( bigEndian ) {

  			valuesNumber = ( array[ 2 ] << 16 ) + ( array[ 3 ] << 8 ) + array[ 4 ];
  			indicesNumber = ( array[ 5 ] << 16 ) + ( array[ 6 ] << 8 ) + array[ 7 ];

  		} else {

  			valuesNumber = array[ 2 ] + ( array[ 3 ] << 8 ) + ( array[ 4 ] << 16 );
  			indicesNumber = array[ 5 ] + ( array[ 6 ] << 8 ) + ( array[ 7 ] << 16 );

  		}
  		if ( version === 0 ) {

  			throw new Error( 'PRWM decoder: Invalid format version: 0' );

  		} else if ( version !== 1 ) {

  			throw new Error( 'PRWM decoder: Unsupported format version: ' + version );

  		}

  		if ( ! indexedGeometry ) {

  			if ( indicesType !== 0 ) {

  				throw new Error( 'PRWM decoder: Indices type must be set to 0 for non-indexed geometries' );

  			} else if ( indicesNumber !== 0 ) {

  				throw new Error( 'PRWM decoder: Number of indices must be set to 0 for non-indexed geometries' );

  			}

  		}
  		var pos = 8;

  		var attributes = {},
  			attributeName,
  			char,
  			attributeType,
  			cardinality,
  			encodingType,
  			arrayType,
  			values,
  			indices,
  			i;

  		for ( i = 0; i < attributesNumber; i ++ ) {

  			attributeName = '';

  			while ( pos < array.length ) {

  				char = array[ pos ];
  				pos ++;

  				if ( char === 0 ) {

  					break;

  				} else {

  					attributeName += String.fromCharCode( char );

  				}

  			}

  			flags = array[ pos ];

  			attributeType = flags >> 7 & 0x01;
  			cardinality = ( flags >> 4 & 0x03 ) + 1;
  			encodingType = flags & 0x0F;
  			arrayType = InvertedEncodingTypes[ encodingType ];

  			pos ++;

  			// padding to next multiple of 4
  			pos = Math.ceil( pos / 4 ) * 4;

  			values = copyFromBuffer( buffer, arrayType, pos, cardinality * valuesNumber, bigEndian );

  			pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;

  			attributes[ attributeName ] = {
  				type: attributeType,
  				cardinality: cardinality,
  				values: values
  			};

  		}

  		pos = Math.ceil( pos / 4 ) * 4;

  		indices = null;

  		if ( indexedGeometry ) {

  			indices = copyFromBuffer(
  				buffer,
  				indicesType === 1 ? Uint32Array : Uint16Array,
  				pos,
  				indicesNumber,
  				bigEndian
  			);

  		}

  		return {
  			version: version,
  			attributes: attributes,
  			indices: indices
  		};

  	}

  	// Define the public interface

  	var PRWMLoader = function PRWMLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	};

  	PRWMLoader.prototype = {

  		constructor: PRWMLoader,

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( scope.path );
  			loader.setResponseType( 'arraybuffer' );

  			url = url.replace( /\*/g, isBigEndianPlatform() ? 'be' : 'le' );

  			loader.load( url, function ( arrayBuffer ) {

  				onLoad( scope.parse( arrayBuffer ) );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		parse: function ( arrayBuffer ) {

  			console.time( 'PRWMLoader' );

  			var data = decodePrwm( arrayBuffer ),
  				attributesKey = Object.keys( data.attributes ),
  				bufferGeometry = new BufferGeometry(),
  				attribute,
  				i;

  			for ( i = 0; i < attributesKey.length; i ++ ) {

  				attribute = data.attributes[ attributesKey[ i ] ];
  				bufferGeometry.addAttribute( attributesKey[ i ], new BufferAttribute( attribute.values, attribute.cardinality, attribute.normalized ) );

  			}

  			if ( data.indices !== null ) {

  				bufferGeometry.setIndex( new BufferAttribute( data.indices, 1 ) );

  			}

  			console.timeEnd( 'PRWMLoader' );

  			return bufferGeometry;

  		}

  	};

  	PRWMLoader.isBigEndianPlatform = function () {

  		return isBigEndianPlatform();

  	};

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PVRLoader = function ( manager ) {

  	CompressedTextureLoader.call( this, manager );

  	this._parser = PVRLoader.parse;

  };

  PVRLoader.prototype = Object.create( CompressedTextureLoader.prototype );
  PVRLoader.prototype.constructor = PVRLoader;
  PVRLoader.parse = function ( buffer, loadMipmaps ) {

  	var headerLengthInt = 13;
  	var header = new Uint32Array( buffer, 0, headerLengthInt );

  	var pvrDatas = {
  		buffer: buffer,
  		header: header,
  		loadMipmaps: loadMipmaps
  	};

  	if ( header[ 0 ] === 0x03525650 ) {

  		// PVR v3

  		return PVRLoader._parseV3( pvrDatas );

  	} else if ( header[ 11 ] === 0x21525650 ) {

  		// PVR v2

  		return PVRLoader._parseV2( pvrDatas );

  	} else {

  		console.error( 'PVRLoader: Unknown PVR format.' );

  	}

  };

  PVRLoader._parseV3 = function ( pvrDatas ) {

  	var header = pvrDatas.header;
  	var bpp, format;
  	var metaLen = header[ 12 ],
  		pixelFormat = header[ 2 ],
  		height = header[ 6 ],
  		width = header[ 7 ],
  		// numSurfs = header[ 9 ],
  		numFaces = header[ 10 ],
  		numMipmaps = header[ 11 ];

  	switch ( pixelFormat ) {

  		case 0 : // PVRTC 2bpp RGB
  			bpp = 2;
  			format = RGB_PVRTC_2BPPV1_Format;
  			break;

  		case 1 : // PVRTC 2bpp RGBA
  			bpp = 2;
  			format = RGBA_PVRTC_2BPPV1_Format;
  			break;

  		case 2 : // PVRTC 4bpp RGB
  			bpp = 4;
  			format = RGB_PVRTC_4BPPV1_Format;
  			break;

  		case 3 : // PVRTC 4bpp RGBA
  			bpp = 4;
  			format = RGBA_PVRTC_4BPPV1_Format;
  			break;

  		default :
  			console.error( 'PVRLoader: Unsupported PVR format:', pixelFormat );

  	}

  	pvrDatas.dataPtr = 52 + metaLen;
  	pvrDatas.bpp = bpp;
  	pvrDatas.format = format;
  	pvrDatas.width = width;
  	pvrDatas.height = height;
  	pvrDatas.numSurfaces = numFaces;
  	pvrDatas.numMipmaps = numMipmaps;
  	pvrDatas.isCubemap 	= ( numFaces === 6 );

  	return PVRLoader._extract( pvrDatas );

  };

  PVRLoader._parseV2 = function ( pvrDatas ) {

  	var header = pvrDatas.header;

  	var headerLength = header[ 0 ],
  		height = header[ 1 ],
  		width = header[ 2 ],
  		numMipmaps = header[ 3 ],
  		flags = header[ 4 ],
  		// dataLength = header[ 5 ],
  		// bpp =  header[ 6 ],
  		// bitmaskRed = header[ 7 ],
  		// bitmaskGreen = header[ 8 ],
  		// bitmaskBlue = header[ 9 ],
  		bitmaskAlpha = header[ 10 ],
  		// pvrTag = header[ 11 ],
  		numSurfs = header[ 12 ];
  	var TYPE_MASK = 0xff;
  	var PVRTC_2 = 24,
  		PVRTC_4 = 25;

  	var formatFlags = flags & TYPE_MASK;

  	var bpp, format;
  	var _hasAlpha = bitmaskAlpha > 0;

  	if ( formatFlags === PVRTC_4 ) {

  		format = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;
  		bpp = 4;

  	} else if ( formatFlags === PVRTC_2 ) {

  		format = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;
  		bpp = 2;

  	} else {

  		console.error( 'PVRLoader: Unknown PVR format:', formatFlags );

  	}

  	pvrDatas.dataPtr = headerLength;
  	pvrDatas.bpp = bpp;
  	pvrDatas.format = format;
  	pvrDatas.width = width;
  	pvrDatas.height = height;
  	pvrDatas.numSurfaces = numSurfs;
  	pvrDatas.numMipmaps = numMipmaps + 1;

  	// guess cubemap type seems tricky in v2
  	// it juste a pvr containing 6 surface (no explicit cubemap type)
  	pvrDatas.isCubemap 	= ( numSurfs === 6 );

  	return PVRLoader._extract( pvrDatas );

  };
  PVRLoader._extract = function ( pvrDatas ) {

  	var pvr = {
  		mipmaps: [],
  		width: pvrDatas.width,
  		height: pvrDatas.height,
  		format: pvrDatas.format,
  		mipmapCount: pvrDatas.numMipmaps,
  		isCubemap: pvrDatas.isCubemap
  	};

  	var buffer = pvrDatas.buffer;

  	var dataOffset = pvrDatas.dataPtr,
  		bpp = pvrDatas.bpp,
  		numSurfs = pvrDatas.numSurfaces,
  		dataSize = 0,
  		blockSize = 0,
  		blockWidth = 0,
  		blockHeight = 0,
  		widthBlocks = 0,
  		heightBlocks = 0;

  	if ( bpp === 2 ) {

  		blockWidth = 8;
  		blockHeight = 4;

  	} else {

  		blockWidth = 4;
  		blockHeight = 4;

  	}

  	blockSize = ( blockWidth * blockHeight ) * bpp / 8;

  	pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;

  	var mipLevel = 0;

  	while ( mipLevel < pvrDatas.numMipmaps ) {

  		var sWidth = pvrDatas.width >> mipLevel,
  			sHeight = pvrDatas.height >> mipLevel;

  		widthBlocks = sWidth / blockWidth;
  		heightBlocks = sHeight / blockHeight;

  		// Clamp to minimum number of blocks
  		if ( widthBlocks < 2 ) { widthBlocks = 2; }
  		if ( heightBlocks < 2 ) { heightBlocks = 2; }

  		dataSize = widthBlocks * heightBlocks * blockSize;

  		for ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {

  			var byteArray = new Uint8Array( buffer, dataOffset, dataSize );

  			var mipmap = {
  				data: byteArray,
  				width: sWidth,
  				height: sHeight
  			};

  			pvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;

  			dataOffset += dataSize;

  		}

  		mipLevel ++;

  	}

  	return pvr;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var STLLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  STLLoader.prototype = {

  	constructor: STLLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( text ) {

  			try {

  				onLoad( scope.parse( text ) );

  			} catch ( exception ) {

  				if ( onError ) {

  					onError( exception );

  				}

  			}

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data ) {

  		function isBinary( data ) {

  			var expect, face_size, n_faces, reader;
  			reader = new DataView( data );
  			face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
  			n_faces = reader.getUint32( 80, true );
  			expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

  			if ( expect === reader.byteLength ) {

  				return true;

  			}

  			// An ASCII STL data must begin with 'solid ' as the first six bytes.
  			// However, ASCII STLs lacking the SPACE after the 'd' are known to be
  			// plentiful.  So, check the first 5 bytes for 'solid'.

  			// Several encodings, such as UTF-8, precede the text with up to 5 bytes:
  			// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
  			// Search for "solid" to start anywhere after those prefixes.

  			// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

  			var solid = [ 115, 111, 108, 105, 100 ];

  			for ( var off = 0; off < 5; off ++ ) {

  				// If "solid" text is matched to the current offset, declare it to be an ASCII STL.

  				if ( matchDataViewAt ( solid, reader, off ) ) { return false; }

  			}

  			// Couldn't find "solid" text at the beginning; it is binary STL.

  			return true;

  		}

  		function matchDataViewAt( query, reader, offset ) {

  			// Check if each byte in query matches the corresponding byte from the current offset

  			for ( var i = 0, il = query.length; i < il; i ++ ) {

  				if ( query[ i ] !== reader.getUint8( offset + i, false ) ) { return false; }

  			}

  			return true;

  		}

  		function parseBinary( data ) {

  			var reader = new DataView( data );
  			var faces = reader.getUint32( 80, true );

  			var r, g, b, hasColors = false, colors;
  			var defaultR, defaultG, defaultB, alpha;

  			// process STL header
  			// check for default color in header ("COLOR=rgba" sequence).

  			for ( var index = 0; index < 80 - 10; index ++ ) {

  				if ( ( reader.getUint32( index, false ) == 0x434F4C4F  ) &&
  					( reader.getUint8( index + 4 ) == 0x52  ) &&
  					( reader.getUint8( index + 5 ) == 0x3D  ) ) {

  					hasColors = true;
  					colors = [];

  					defaultR = reader.getUint8( index + 6 ) / 255;
  					defaultG = reader.getUint8( index + 7 ) / 255;
  					defaultB = reader.getUint8( index + 8 ) / 255;
  					alpha = reader.getUint8( index + 9 ) / 255;

  				}

  			}

  			var dataOffset = 84;
  			var faceLength = 12 * 4 + 2;

  			var geometry = new BufferGeometry();

  			var vertices = [];
  			var normals = [];

  			for ( var face = 0; face < faces; face ++ ) {

  				var start = dataOffset + face * faceLength;
  				var normalX = reader.getFloat32( start, true );
  				var normalY = reader.getFloat32( start + 4, true );
  				var normalZ = reader.getFloat32( start + 8, true );

  				if ( hasColors ) {

  					var packedColor = reader.getUint16( start + 48, true );

  					if ( ( packedColor & 0x8000 ) === 0 ) {

  						// facet has its own unique color

  						r = ( packedColor & 0x1F ) / 31;
  						g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
  						b = ( ( packedColor >> 10 ) & 0x1F ) / 31;

  					} else {

  						r = defaultR;
  						g = defaultG;
  						b = defaultB;

  					}

  				}

  				for ( var i = 1; i <= 3; i ++ ) {

  					var vertexstart = start + i * 12;

  					vertices.push( reader.getFloat32( vertexstart, true ) );
  					vertices.push( reader.getFloat32( vertexstart + 4, true ) );
  					vertices.push( reader.getFloat32( vertexstart + 8, true ) );

  					normals.push( normalX, normalY, normalZ );

  					if ( hasColors ) {

  						colors.push( r, g, b );

  					}

  				}

  			}

  			geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );
  			geometry.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );

  			if ( hasColors ) {

  				geometry.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );
  				geometry.hasColors = true;
  				geometry.alpha = alpha;

  			}

  			return geometry;

  		}

  		function parseASCII( data ) {

  			var geometry = new BufferGeometry();
  			var patternFace = /facet([\s\S]*?)endfacet/g;
  			var faceCounter = 0;

  			var patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
  			var patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );
  			var patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );

  			var vertices = [];
  			var normals = [];

  			var normal = new Vector3();

  			var result;

  			while ( ( result = patternFace.exec( data ) ) !== null ) {

  				var vertexCountPerFace = 0;
  				var normalCountPerFace = 0;

  				var text = result[ 0 ];

  				while ( ( result = patternNormal.exec( text ) ) !== null ) {

  					normal.x = parseFloat( result[ 1 ] );
  					normal.y = parseFloat( result[ 2 ] );
  					normal.z = parseFloat( result[ 3 ] );
  					normalCountPerFace ++;

  				}

  				while ( ( result = patternVertex.exec( text ) ) !== null ) {

  					vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );
  					normals.push( normal.x, normal.y, normal.z );
  					vertexCountPerFace ++;

  				}

  				// every face have to own ONE valid normal

  				if ( normalCountPerFace !== 1 ) {

  					console.error( 'STLLoader: Something isn\'t right with the normal of face number ' + faceCounter );

  				}

  				// each face have to own THREE valid vertices

  				if ( vertexCountPerFace !== 3 ) {

  					console.error( 'STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter );

  				}

  				faceCounter ++;

  			}

  			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  			geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  			return geometry;

  		}

  		function ensureString( buffer ) {

  			if ( typeof buffer !== 'string' ) {

  				return LoaderUtils.decodeText( new Uint8Array( buffer ) );

  			}

  			return buffer;

  		}

  		function ensureBinary( buffer ) {

  			if ( typeof buffer === 'string' ) {

  				var array_buffer = new Uint8Array( buffer.length );
  				for ( var i = 0; i < buffer.length; i ++ ) {

  					array_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian

  				}
  				return array_buffer.buffer || array_buffer;

  			} else {

  				return buffer;

  			}

  		}

  		// start

  		var binData = ensureBinary( data );

  		return isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  	Curve.call( this );

  	this.type = 'EllipseCurve';

  	this.aX = aX || 0;
  	this.aY = aY || 0;

  	this.xRadius = xRadius || 1;
  	this.yRadius = yRadius || 1;

  	this.aStartAngle = aStartAngle || 0;
  	this.aEndAngle = aEndAngle || 2 * Math.PI;

  	this.aClockwise = aClockwise || false;

  	this.aRotation = aRotation || 0;

  }

  EllipseCurve.prototype = Object.create( Curve.prototype );
  EllipseCurve.prototype.constructor = EllipseCurve;

  EllipseCurve.prototype.isEllipseCurve = true;

  EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector2();

  	var twoPi = Math.PI * 2;
  	var deltaAngle = this.aEndAngle - this.aStartAngle;
  	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

  	// ensures that deltaAngle is 0 .. 2 PI
  	while ( deltaAngle < 0 ) { deltaAngle += twoPi; }
  	while ( deltaAngle > twoPi ) { deltaAngle -= twoPi; }

  	if ( deltaAngle < Number.EPSILON ) {

  		if ( samePoints ) {

  			deltaAngle = 0;

  		} else {

  			deltaAngle = twoPi;

  		}

  	}

  	if ( this.aClockwise === true && ! samePoints ) {

  		if ( deltaAngle === twoPi ) {

  			deltaAngle = - twoPi;

  		} else {

  			deltaAngle = deltaAngle - twoPi;

  		}

  	}

  	var angle = this.aStartAngle + t * deltaAngle;
  	var x = this.aX + this.xRadius * Math.cos( angle );
  	var y = this.aY + this.yRadius * Math.sin( angle );

  	if ( this.aRotation !== 0 ) {

  		var cos = Math.cos( this.aRotation );
  		var sin = Math.sin( this.aRotation );

  		var tx = x - this.aX;
  		var ty = y - this.aY;

  		// Rotate the point about the center of the ellipse.
  		x = tx * cos - ty * sin + this.aX;
  		y = tx * sin + ty * cos + this.aY;

  	}

  	return point.set( x, y );

  };

  EllipseCurve.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.aX = source.aX;
  	this.aY = source.aY;

  	this.xRadius = source.xRadius;
  	this.yRadius = source.yRadius;

  	this.aStartAngle = source.aStartAngle;
  	this.aEndAngle = source.aEndAngle;

  	this.aClockwise = source.aClockwise;

  	this.aRotation = source.aRotation;

  	return this;

  };
  EllipseCurve.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.aX = this.aX;
  	data.aY = this.aY;

  	data.xRadius = this.xRadius;
  	data.yRadius = this.yRadius;

  	data.aStartAngle = this.aStartAngle;
  	data.aEndAngle = this.aEndAngle;

  	data.aClockwise = this.aClockwise;

  	data.aRotation = this.aRotation;

  	return data;

  };

  EllipseCurve.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.aX = json.aX;
  	this.aY = json.aY;

  	this.xRadius = json.xRadius;
  	this.yRadius = json.yRadius;

  	this.aStartAngle = json.aStartAngle;
  	this.aEndAngle = json.aEndAngle;

  	this.aClockwise = json.aClockwise;

  	this.aRotation = json.aRotation;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  	this.type = 'ArcCurve';

  }

  ArcCurve.prototype = Object.create( EllipseCurve.prototype );
  ArcCurve.prototype.constructor = ArcCurve;

  ArcCurve.prototype.isArcCurve = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubicPoly() {

  	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  	function init( x0, x1, t0, t1 ) {

  		c0 = x0;
  		c1 = t0;
  		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
  		c3 = 2 * x0 - 2 * x1 + t0 + t1;

  	}

  	return {

  		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

  			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  		},

  		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

  			// compute tangents when parameterized in [t1,t2]
  			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
  			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

  			// rescale tangents for parametrization in [0,1]
  			t1 *= dt1;
  			t2 *= dt1;

  			init( x1, x2, t1, t2 );

  		},

  		calc: function ( t ) {

  			var t2 = t * t;
  			var t3 = t2 * t;
  			return c0 + c1 * t + c2 * t2 + c3 * t3;

  		}

  	};

  }

  //

  var tmp = new Vector3();
  var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

  function CatmullRomCurve3( points, closed, curveType, tension ) {

  	Curve.call( this );

  	this.type = 'CatmullRomCurve3';

  	this.points = points || [];
  	this.closed = closed || false;
  	this.curveType = curveType || 'centripetal';
  	this.tension = tension || 0.5;

  }

  CatmullRomCurve3.prototype = Object.create( Curve.prototype );
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

  CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector3();

  	var points = this.points;
  	var l = points.length;

  	var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
  	var intPoint = Math.floor( p );
  	var weight = p - intPoint;

  	if ( this.closed ) {

  		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

  	} else if ( weight === 0 && intPoint === l - 1 ) {

  		intPoint = l - 2;
  		weight = 1;

  	}

  	var p0, p1, p2, p3; // 4 points

  	if ( this.closed || intPoint > 0 ) {

  		p0 = points[ ( intPoint - 1 ) % l ];

  	} else {

  		// extrapolate first point
  		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
  		p0 = tmp;

  	}

  	p1 = points[ intPoint % l ];
  	p2 = points[ ( intPoint + 1 ) % l ];

  	if ( this.closed || intPoint + 2 < l ) {

  		p3 = points[ ( intPoint + 2 ) % l ];

  	} else {

  		// extrapolate last point
  		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
  		p3 = tmp;

  	}

  	if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

  		// init Centripetal / Chordal Catmull-Rom
  		var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
  		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
  		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
  		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

  		// safety check for repeated points
  		if ( dt1 < 1e-4 ) { dt1 = 1.0; }
  		if ( dt0 < 1e-4 ) { dt0 = dt1; }
  		if ( dt2 < 1e-4 ) { dt2 = dt1; }

  		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
  		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
  		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

  	} else if ( this.curveType === 'catmullrom' ) {

  		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
  		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
  		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

  	}

  	point.set(
  		px.calc( weight ),
  		py.calc( weight ),
  		pz.calc( weight )
  	);

  	return point;

  };

  CatmullRomCurve3.prototype.copy = function ( source ) {
  	var this$1 = this;


  	Curve.prototype.copy.call( this, source );

  	this.points = [];

  	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

  		var point = source.points[ i ];

  		this$1.points.push( point.clone() );

  	}

  	this.closed = source.closed;
  	this.curveType = source.curveType;
  	this.tension = source.tension;

  	return this;

  };

  CatmullRomCurve3.prototype.toJSON = function () {
  	var this$1 = this;


  	var data = Curve.prototype.toJSON.call( this );

  	data.points = [];

  	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

  		var point = this$1.points[ i ];
  		data.points.push( point.toArray() );

  	}

  	data.closed = this.closed;
  	data.curveType = this.curveType;
  	data.tension = this.tension;

  	return data;

  };

  CatmullRomCurve3.prototype.fromJSON = function ( json ) {
  	var this$1 = this;


  	Curve.prototype.fromJSON.call( this, json );

  	this.points = [];

  	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

  		var point = json.points[ i ];
  		this$1.points.push( new Vector3().fromArray( point ) );

  	}

  	this.closed = json.closed;
  	this.curveType = json.curveType;
  	this.tension = json.tension;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CatmullRom( t, p0, p1, p2, p3 ) {

  	var v0 = ( p2 - p0 ) * 0.5;
  	var v1 = ( p3 - p1 ) * 0.5;
  	var t2 = t * t;
  	var t3 = t * t2;
  	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0( t, p ) {

  	var k = 1 - t;
  	return k * k * p;

  }

  function QuadraticBezierP1( t, p ) {

  	return 2 * ( 1 - t ) * t * p;

  }

  function QuadraticBezierP2( t, p ) {

  	return t * t * p;

  }

  function QuadraticBezier( t, p0, p1, p2 ) {

  	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
  		QuadraticBezierP2( t, p2 );

  }

  //

  function CubicBezierP0( t, p ) {

  	var k = 1 - t;
  	return k * k * k * p;

  }

  function CubicBezierP1( t, p ) {

  	var k = 1 - t;
  	return 3 * k * k * t * p;

  }

  function CubicBezierP2( t, p ) {

  	return 3 * ( 1 - t ) * t * t * p;

  }

  function CubicBezierP3( t, p ) {

  	return t * t * t * p;

  }

  function CubicBezier( t, p0, p1, p2, p3 ) {

  	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
  		CubicBezierP3( t, p3 );

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubicBezierCurve( v0, v1, v2, v3 ) {

  	Curve.call( this );

  	this.type = 'CubicBezierCurve';

  	this.v0 = v0 || new Vector2();
  	this.v1 = v1 || new Vector2();
  	this.v2 = v2 || new Vector2();
  	this.v3 = v3 || new Vector2();

  }

  CubicBezierCurve.prototype = Object.create( Curve.prototype );
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;

  CubicBezierCurve.prototype.isCubicBezierCurve = true;

  CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector2();

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	point.set(
  		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
  	);

  	return point;

  };

  CubicBezierCurve.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v0.copy( source.v0 );
  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );
  	this.v3.copy( source.v3 );

  	return this;

  };

  CubicBezierCurve.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v0 = this.v0.toArray();
  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();
  	data.v3 = this.v3.toArray();

  	return data;

  };

  CubicBezierCurve.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v0.fromArray( json.v0 );
  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );
  	this.v3.fromArray( json.v3 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubicBezierCurve3( v0, v1, v2, v3 ) {

  	Curve.call( this );

  	this.type = 'CubicBezierCurve3';

  	this.v0 = v0 || new Vector3();
  	this.v1 = v1 || new Vector3();
  	this.v2 = v2 || new Vector3();
  	this.v3 = v3 || new Vector3();

  }

  CubicBezierCurve3.prototype = Object.create( Curve.prototype );
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

  CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector3();

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	point.set(
  		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
  		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
  	);

  	return point;

  };

  CubicBezierCurve3.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v0.copy( source.v0 );
  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );
  	this.v3.copy( source.v3 );

  	return this;

  };

  CubicBezierCurve3.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v0 = this.v0.toArray();
  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();
  	data.v3 = this.v3.toArray();

  	return data;

  };

  CubicBezierCurve3.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v0.fromArray( json.v0 );
  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );
  	this.v3.fromArray( json.v3 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineCurve( v1, v2 ) {

  	Curve.call( this );

  	this.type = 'LineCurve';

  	this.v1 = v1 || new Vector2();
  	this.v2 = v2 || new Vector2();

  }

  LineCurve.prototype = Object.create( Curve.prototype );
  LineCurve.prototype.constructor = LineCurve;

  LineCurve.prototype.isLineCurve = true;

  LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector2();

  	if ( t === 1 ) {

  		point.copy( this.v2 );

  	} else {

  		point.copy( this.v2 ).sub( this.v1 );
  		point.multiplyScalar( t ).add( this.v1 );

  	}

  	return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

  	return this.getPoint( u, optionalTarget );

  };

  LineCurve.prototype.getTangent = function (  ) {

  	var tangent = this.v2.clone().sub( this.v1 );

  	return tangent.normalize();

  };

  LineCurve.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );

  	return this;

  };

  LineCurve.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();

  	return data;

  };

  LineCurve.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LineCurve3( v1, v2 ) {

  	Curve.call( this );

  	this.type = 'LineCurve3';

  	this.v1 = v1 || new Vector3();
  	this.v2 = v2 || new Vector3();

  }

  LineCurve3.prototype = Object.create( Curve.prototype );
  LineCurve3.prototype.constructor = LineCurve3;

  LineCurve3.prototype.isLineCurve3 = true;

  LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector3();

  	if ( t === 1 ) {

  		point.copy( this.v2 );

  	} else {

  		point.copy( this.v2 ).sub( this.v1 );
  		point.multiplyScalar( t ).add( this.v1 );

  	}

  	return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

  	return this.getPoint( u, optionalTarget );

  };

  LineCurve3.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );

  	return this;

  };

  LineCurve3.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();

  	return data;

  };

  LineCurve3.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function QuadraticBezierCurve( v0, v1, v2 ) {

  	Curve.call( this );

  	this.type = 'QuadraticBezierCurve';

  	this.v0 = v0 || new Vector2();
  	this.v1 = v1 || new Vector2();
  	this.v2 = v2 || new Vector2();

  }

  QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

  QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector2();

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	point.set(
  		QuadraticBezier( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier( t, v0.y, v1.y, v2.y )
  	);

  	return point;

  };

  QuadraticBezierCurve.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v0.copy( source.v0 );
  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );

  	return this;

  };

  QuadraticBezierCurve.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v0 = this.v0.toArray();
  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();

  	return data;

  };

  QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v0.fromArray( json.v0 );
  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function QuadraticBezierCurve3( v0, v1, v2 ) {

  	Curve.call( this );

  	this.type = 'QuadraticBezierCurve3';

  	this.v0 = v0 || new Vector3();
  	this.v1 = v1 || new Vector3();
  	this.v2 = v2 || new Vector3();

  }

  QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

  QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector3();

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	point.set(
  		QuadraticBezier( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier( t, v0.y, v1.y, v2.y ),
  		QuadraticBezier( t, v0.z, v1.z, v2.z )
  	);

  	return point;

  };

  QuadraticBezierCurve3.prototype.copy = function ( source ) {

  	Curve.prototype.copy.call( this, source );

  	this.v0.copy( source.v0 );
  	this.v1.copy( source.v1 );
  	this.v2.copy( source.v2 );

  	return this;

  };

  QuadraticBezierCurve3.prototype.toJSON = function () {

  	var data = Curve.prototype.toJSON.call( this );

  	data.v0 = this.v0.toArray();
  	data.v1 = this.v1.toArray();
  	data.v2 = this.v2.toArray();

  	return data;

  };

  QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

  	Curve.prototype.fromJSON.call( this, json );

  	this.v0.fromArray( json.v0 );
  	this.v1.fromArray( json.v1 );
  	this.v2.fromArray( json.v2 );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SplineCurve( points  ) {

  	Curve.call( this );

  	this.type = 'SplineCurve';

  	this.points = points || [];

  }

  SplineCurve.prototype = Object.create( Curve.prototype );
  SplineCurve.prototype.constructor = SplineCurve;

  SplineCurve.prototype.isSplineCurve = true;

  SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

  	var point = optionalTarget || new Vector2();

  	var points = this.points;
  	var p = ( points.length - 1 ) * t;

  	var intPoint = Math.floor( p );
  	var weight = p - intPoint;

  	var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  	var p1 = points[ intPoint ];
  	var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  	var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  	point.set(
  		CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
  		CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
  	);

  	return point;

  };

  SplineCurve.prototype.copy = function ( source ) {
  	var this$1 = this;


  	Curve.prototype.copy.call( this, source );

  	this.points = [];

  	for ( var i = 0, l = source.points.length; i < l; i ++ ) {

  		var point = source.points[ i ];

  		this$1.points.push( point.clone() );

  	}

  	return this;

  };

  SplineCurve.prototype.toJSON = function () {
  	var this$1 = this;


  	var data = Curve.prototype.toJSON.call( this );

  	data.points = [];

  	for ( var i = 0, l = this.points.length; i < l; i ++ ) {

  		var point = this$1.points[ i ];
  		data.points.push( point.toArray() );

  	}

  	return data;

  };

  SplineCurve.prototype.fromJSON = function ( json ) {
  	var this$1 = this;


  	Curve.prototype.fromJSON.call( this, json );

  	this.points = [];

  	for ( var i = 0, l = json.points.length; i < l; i ++ ) {

  		var point = json.points[ i ];
  		this$1.points.push( new Vector2().fromArray( point ) );

  	}

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Curves$1 = {
      ArcCurve: ArcCurve,
      CatmullRomCurve3: CatmullRomCurve3,
      CubicBezierCurve: CubicBezierCurve,
      CubicBezierCurve3: CubicBezierCurve3,
      EllipseCurve: EllipseCurve,
      LineCurve: LineCurve,
      LineCurve3: LineCurve3,
      QuadraticBezierCurve: QuadraticBezierCurve,
      QuadraticBezierCurve3: QuadraticBezierCurve3,
      SplineCurve: SplineCurve
  };
  function CurvePath() {

  	Curve.call( this );

  	this.type = 'CurvePath';

  	this.curves = [];
  	this.autoClose = false; // Automatically closes the path

  }

  CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

  	constructor: CurvePath,

  	add: function ( curve ) {

  		this.curves.push( curve );

  	},

  	closePath: function () {

  		// Add a line curve if start and end of lines are not connected
  		var startPoint = this.curves[ 0 ].getPoint( 0 );
  		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  		if ( ! startPoint.equals( endPoint ) ) {

  			this.curves.push( new Curves$1[ 'LineCurve' ]( endPoint, startPoint ) );

  		}

  	},

  	// To get accurate point with reference to
  	// entire path distance at time t,
  	// following has to be done:

  	// 1. Length of each sub path have to be known
  	// 2. Locate and identify type of curve
  	// 3. Get t for the curve
  	// 4. Return curve.getPointAt(t')

  	getPoint: function ( t ) {
  		var this$1 = this;


  		var d = t * this.getLength();
  		var curveLengths = this.getCurveLengths();
  		var i = 0;

  		// To think about boundaries points.

  		while ( i < curveLengths.length ) {

  			if ( curveLengths[ i ] >= d ) {

  				var diff = curveLengths[ i ] - d;
  				var curve = this$1.curves[ i ];

  				var segmentLength = curve.getLength();
  				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

  				return curve.getPointAt( u );

  			}

  			i ++;

  		}

  		return null;

  		// loop where sum != 0, sum > d , sum+1 <d

  	},

  	// We cannot use the default Curve getPoint() with getLength() because in
  	// Curve, getLength() depends on getPoint() but in CurvePath
  	// getPoint() depends on getLength

  	getLength: function () {

  		var lens = this.getCurveLengths();
  		return lens[ lens.length - 1 ];

  	},

  	// cacheLengths must be recalculated.
  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.cacheLengths = null;
  		this.getCurveLengths();

  	},

  	// Compute lengths and cache them
  	// We cannot overwrite getLengths() because UtoT mapping uses it.

  	getCurveLengths: function () {
  		var this$1 = this;


  		// We use cache values if curves and cache array are same length

  		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

  			return this.cacheLengths;

  		}

  		// Get length of sub-curve
  		// Push sums into cached array

  		var lengths = [], sums = 0;

  		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  			sums += this$1.curves[ i ].getLength();
  			lengths.push( sums );

  		}

  		this.cacheLengths = lengths;

  		return lengths;

  	},

  	getSpacedPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 40; }

  		var points = [];

  		for ( var i = 0; i <= divisions; i ++ ) {

  			points.push( this$1.getPoint( i / divisions ) );

  		}

  		if ( this.autoClose ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	getPoints: function ( divisions ) {

  		divisions = divisions || 12;

  		var points = [], last;

  		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

  			var curve = curves[ i ];
  			var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
  				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
  					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
  						: divisions;

  			var pts = curve.getPoints( resolution );

  			for ( var j = 0; j < pts.length; j ++ ) {

  				var point = pts[ j ];

  				if ( last && last.equals( point ) ) { continue; } // ensures no consecutive points are duplicates

  				points.push( point );
  				last = point;

  			}

  		}

  		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		Curve.prototype.copy.call( this, source );

  		this.curves = [];

  		for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

  			var curve = source.curves[ i ];

  			this$1.curves.push( curve.clone() );

  		}

  		this.autoClose = source.autoClose;

  		return this;

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = Curve.prototype.toJSON.call( this );

  		data.autoClose = this.autoClose;
  		data.curves = [];

  		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  			var curve = this$1.curves[ i ];
  			data.curves.push( curve.toJSON() );

  		}

  		return data;

  	},

  	fromJSON: function ( json ) {
  		var this$1 = this;


  		Curve.prototype.fromJSON.call( this, json );

  		this.autoClose = json.autoClose;
  		this.curves = [];

  		for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

  			var curve = json.curves[ i ];
  			this$1.curves.push( new Curves$1[ curve.type ]().fromJSON( curve ) );

  		}

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Path( points ) {

  	CurvePath.call( this );

  	this.type = 'Path';

  	this.currentPoint = new Vector2();

  	if ( points ) {

  		this.setFromPoints( points );

  	}

  }

  Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

  	constructor: Path,

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.moveTo( points[ 0 ].x, points[ 0 ].y );

  		for ( var i = 1, l = points.length; i < l; i ++ ) {

  			this$1.lineTo( points[ i ].x, points[ i ].y );

  		}

  	},

  	moveTo: function ( x, y ) {

  		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

  	},

  	lineTo: function ( x, y ) {

  		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
  		this.curves.push( curve );

  		this.currentPoint.set( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		var curve = new QuadraticBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2( aCPx, aCPy ),
  			new Vector2( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		var curve = new CubicBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2( aCP1x, aCP1y ),
  			new Vector2( aCP2x, aCP2y ),
  			new Vector2( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	splineThru: function ( pts  ) {

  		var npts = [ this.currentPoint.clone() ].concat( pts );

  		var curve = new SplineCurve( npts );
  		this.curves.push( curve );

  		this.currentPoint.copy( pts[ pts.length - 1 ] );

  	},

  	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absarc( aX + x0, aY + y0, aRadius,
  			aStartAngle, aEndAngle, aClockwise );

  	},

  	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  	},

  	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  	},

  	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		if ( this.curves.length > 0 ) {

  			// if a previous curve is present, attempt to join
  			var firstPoint = curve.getPoint( 0 );

  			if ( ! firstPoint.equals( this.currentPoint ) ) {

  				this.lineTo( firstPoint.x, firstPoint.y );

  			}

  		}

  		this.curves.push( curve );

  		var lastPoint = curve.getPoint( 1 );
  		this.currentPoint.copy( lastPoint );

  	},

  	copy: function ( source ) {

  		CurvePath.prototype.copy.call( this, source );

  		this.currentPoint.copy( source.currentPoint );

  		return this;

  	},

  	toJSON: function () {

  		var data = CurvePath.prototype.toJSON.call( this );

  		data.currentPoint = this.currentPoint.toArray();

  		return data;

  	},

  	fromJSON: function ( json ) {

  		CurvePath.prototype.fromJSON.call( this, json );

  		this.currentPoint.fromArray( json.currentPoint );

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.

  function Shape( points ) {

  	Path.call( this, points );

  	this.uuid = _Math.generateUUID();

  	this.type = 'Shape';

  	this.holes = [];

  }

  Shape.prototype = Object.assign( Object.create( Path.prototype ), {

  	constructor: Shape,

  	getPointsHoles: function ( divisions ) {
  		var this$1 = this;


  		var holesPts = [];

  		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  			holesPts[ i ] = this$1.holes[ i ].getPoints( divisions );

  		}

  		return holesPts;

  	},

  	// get points of shape and holes (keypoints based on segments parameter)

  	extractPoints: function ( divisions ) {

  		return {

  			shape: this.getPoints( divisions ),
  			holes: this.getPointsHoles( divisions )

  		};

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		Path.prototype.copy.call( this, source );

  		this.holes = [];

  		for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

  			var hole = source.holes[ i ];

  			this$1.holes.push( hole.clone() );

  		}

  		return this;

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = Path.prototype.toJSON.call( this );

  		data.uuid = this.uuid;
  		data.holes = [];

  		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  			var hole = this$1.holes[ i ];
  			data.holes.push( hole.toJSON() );

  		}

  		return data;

  	},

  	fromJSON: function ( json ) {
  		var this$1 = this;


  		Path.prototype.fromJSON.call( this, json );

  		this.uuid = json.uuid;
  		this.holes = [];

  		for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

  			var hole = json.holes[ i ];
  			this$1.holes.push( new Path().fromJSON( hole ) );

  		}

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Earcut = {

  	triangulate: function ( data, holeIndices, dim ) {

  		dim = dim || 2;

  		var hasHoles = holeIndices && holeIndices.length,
  			outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
  			outerNode = linkedList( data, 0, outerLen, dim, true ),
  			triangles = [];

  		if ( ! outerNode ) { return triangles; }

  		var minX, minY, maxX, maxY, x, y, invSize;

  		if ( hasHoles ) { outerNode = eliminateHoles( data, holeIndices, outerNode, dim ); }

  		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

  		if ( data.length > 80 * dim ) {

  			minX = maxX = data[ 0 ];
  			minY = maxY = data[ 1 ];

  			for ( var i = dim; i < outerLen; i += dim ) {

  				x = data[ i ];
  				y = data[ i + 1 ];
  				if ( x < minX ) { minX = x; }
  				if ( y < minY ) { minY = y; }
  				if ( x > maxX ) { maxX = x; }
  				if ( y > maxY ) { maxY = y; }

  			}

  			// minX, minY and invSize are later used to transform coords into integers for z-order calculation

  			invSize = Math.max( maxX - minX, maxY - minY );
  			invSize = invSize !== 0 ? 1 / invSize : 0;

  		}

  		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

  		return triangles;

  	}

  };

  // create a circular doubly linked list from polygon points in the specified winding order

  function linkedList( data, start, end, dim, clockwise ) {

  	var i, last;

  	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

  		for ( i = start; i < end; i += dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

  	} else {

  		for ( i = end - dim; i >= start; i -= dim ) { last = insertNode( i, data[ i ], data[ i + 1 ], last ); }

  	}

  	if ( last && equals( last, last.next ) ) {

  		removeNode( last );
  		last = last.next;

  	}

  	return last;

  }

  // eliminate colinear or duplicate points

  function filterPoints( start, end ) {

  	if ( ! start ) { return start; }
  	if ( ! end ) { end = start; }

  	var p = start, again;

  	do {

  		again = false;

  		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

  			removeNode( p );
  			p = end = p.prev;
  			if ( p === p.next ) { break; }
  			again = true;

  		} else {

  			p = p.next;

  		}

  	} while ( again || p !== end );

  	return end;

  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)

  function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

  	if ( ! ear ) { return; }

  	// interlink polygon nodes in z-order

  	if ( ! pass && invSize ) { indexCurve( ear, minX, minY, invSize ); }

  	var stop = ear, prev, next;

  	// iterate through ears, slicing them one by one

  	while ( ear.prev !== ear.next ) {

  		prev = ear.prev;
  		next = ear.next;

  		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

  			// cut off the triangle
  			triangles.push( prev.i / dim );
  			triangles.push( ear.i / dim );
  			triangles.push( next.i / dim );

  			removeNode( ear );

  			// skipping the next vertice leads to less sliver triangles
  			ear = next.next;
  			stop = next.next;

  			continue;

  		}

  		ear = next;

  		// if we looped through the whole remaining polygon and can't find any more ears

  		if ( ear === stop ) {

  			// try filtering points and slicing again

  			if ( ! pass ) {

  				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

  				// if this didn't work, try curing all small self-intersections locally

  			} else if ( pass === 1 ) {

  				ear = cureLocalIntersections( ear, triangles, dim );
  				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

  				// as a last resort, try splitting the remaining polygon into two

  			} else if ( pass === 2 ) {

  				splitEarcut( ear, triangles, dim, minX, minY, invSize );

  			}

  			break;

  		}

  	}

  }

  // check whether a polygon node forms a valid ear with adjacent nodes

  function isEar( ear ) {

  	var a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

  	// now make sure we don't have other points inside the potential ear
  	var p = ear.next.next;

  	while ( p !== ear.prev ) {

  		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

  			return false;

  		}

  		p = p.next;

  	}

  	return true;

  }

  function isEarHashed( ear, minX, minY, invSize ) {

  	var a = ear.prev,
  		b = ear,
  		c = ear.next;

  	if ( area( a, b, c ) >= 0 ) { return false; } // reflex, can't be an ear

  	// triangle bbox; min & max are calculated like this for speed

  	var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
  		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
  		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
  		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

  	// z-order range for the current triangle bbox;

  	var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
  		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

  	// first look for points inside the triangle in increasing z-order

  	var p = ear.nextZ;

  	while ( p && p.z <= maxZ ) {

  		if ( p !== ear.prev && p !== ear.next &&
  				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  				area( p.prev, p, p.next ) >= 0 ) { return false; }
  		p = p.nextZ;

  	}

  	// then look for points in decreasing z-order

  	p = ear.prevZ;

  	while ( p && p.z >= minZ ) {

  		if ( p !== ear.prev && p !== ear.next &&
  				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  				area( p.prev, p, p.next ) >= 0 ) { return false; }

  		p = p.prevZ;

  	}

  	return true;

  }

  // go through all polygon nodes and cure small local self-intersections

  function cureLocalIntersections( start, triangles, dim ) {

  	var p = start;

  	do {

  		var a = p.prev, b = p.next.next;

  		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

  			triangles.push( a.i / dim );
  			triangles.push( p.i / dim );
  			triangles.push( b.i / dim );

  			// remove two nodes involved

  			removeNode( p );
  			removeNode( p.next );

  			p = start = b;

  		}

  		p = p.next;

  	} while ( p !== start );

  	return p;

  }

  // try splitting polygon into two and triangulate them independently

  function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

  	// look for a valid diagonal that divides the polygon into two

  	var a = start;

  	do {

  		var b = a.next.next;

  		while ( b !== a.prev ) {

  			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

  				// split the polygon in two by the diagonal

  				var c = splitPolygon( a, b );

  				// filter colinear points around the cuts

  				a = filterPoints( a, a.next );
  				c = filterPoints( c, c.next );

  				// run earcut on each half

  				earcutLinked( a, triangles, dim, minX, minY, invSize );
  				earcutLinked( c, triangles, dim, minX, minY, invSize );
  				return;

  			}

  			b = b.next;

  		}

  		a = a.next;

  	} while ( a !== start );

  }

  // link every hole into the outer loop, producing a single-ring polygon without holes

  function eliminateHoles( data, holeIndices, outerNode, dim ) {

  	var queue = [], i, len, start, end, list;

  	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

  		start = holeIndices[ i ] * dim;
  		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
  		list = linkedList( data, start, end, dim, false );
  		if ( list === list.next ) { list.steiner = true; }
  		queue.push( getLeftmost( list ) );

  	}

  	queue.sort( compareX );

  	// process holes from left to right

  	for ( i = 0; i < queue.length; i ++ ) {

  		eliminateHole( queue[ i ], outerNode );
  		outerNode = filterPoints( outerNode, outerNode.next );

  	}

  	return outerNode;

  }

  function compareX( a, b ) {

  	return a.x - b.x;

  }

  // find a bridge between vertices that connects hole with an outer ring and and link it

  function eliminateHole( hole, outerNode ) {

  	outerNode = findHoleBridge( hole, outerNode );

  	if ( outerNode ) {

  		var b = splitPolygon( outerNode, hole );

  		filterPoints( b, b.next );

  	}

  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon

  function findHoleBridge( hole, outerNode ) {

  	var p = outerNode,
  		hx = hole.x,
  		hy = hole.y,
  		qx = - Infinity,
  		m;

  	// find a segment intersected by a ray from the hole's leftmost point to the left;
  	// segment's endpoint with lesser x will be potential connection point

  	do {

  		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

  			var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

  			if ( x <= hx && x > qx ) {

  				qx = x;

  				if ( x === hx ) {

  					if ( hy === p.y ) { return p; }
  					if ( hy === p.next.y ) { return p.next; }

  				}

  				m = p.x < p.next.x ? p : p.next;

  			}

  		}

  		p = p.next;

  	} while ( p !== outerNode );

  	if ( ! m ) { return null; }

  	if ( hx === qx ) { return m.prev; } // hole touches outer segment; pick lower endpoint

  	// look for points inside the triangle of hole point, segment intersection and endpoint;
  	// if there are no points found, we have a valid connection;
  	// otherwise choose the point of the minimum angle with the ray as connection point

  	var stop = m,
  		mx = m.x,
  		my = m.y,
  		tanMin = Infinity,
  		tan;

  	p = m.next;

  	while ( p !== stop ) {

  		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
  						pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

  			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

  			if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

  				m = p;
  				tanMin = tan;

  			}

  		}

  		p = p.next;

  	}

  	return m;

  }

  // interlink polygon nodes in z-order

  function indexCurve( start, minX, minY, invSize ) {

  	var p = start;

  	do {

  		if ( p.z === null ) { p.z = zOrder( p.x, p.y, minX, minY, invSize ); }
  		p.prevZ = p.prev;
  		p.nextZ = p.next;
  		p = p.next;

  	} while ( p !== start );

  	p.prevZ.nextZ = null;
  	p.prevZ = null;

  	sortLinked( p );

  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

  function sortLinked( list ) {

  	var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

  	do {

  		p = list;
  		list = null;
  		tail = null;
  		numMerges = 0;

  		while ( p ) {

  			numMerges ++;
  			q = p;
  			pSize = 0;

  			for ( i = 0; i < inSize; i ++ ) {

  				pSize ++;
  				q = q.nextZ;
  				if ( ! q ) { break; }

  			}

  			qSize = inSize;

  			while ( pSize > 0 || ( qSize > 0 && q ) ) {

  				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

  					e = p;
  					p = p.nextZ;
  					pSize --;

  				} else {

  					e = q;
  					q = q.nextZ;
  					qSize --;

  				}

  				if ( tail ) { tail.nextZ = e; }
  				else { list = e; }

  				e.prevZ = tail;
  				tail = e;

  			}

  			p = q;

  		}

  		tail.nextZ = null;
  		inSize *= 2;

  	} while ( numMerges > 1 );

  	return list;

  }

  // z-order of a point given coords and inverse of the longer side of data bbox

  function zOrder( x, y, minX, minY, invSize ) {

  	// coords are transformed into non-negative 15-bit integer range

  	x = 32767 * ( x - minX ) * invSize;
  	y = 32767 * ( y - minY ) * invSize;

  	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
  	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
  	x = ( x | ( x << 2 ) ) & 0x33333333;
  	x = ( x | ( x << 1 ) ) & 0x55555555;

  	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
  	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
  	y = ( y | ( y << 2 ) ) & 0x33333333;
  	y = ( y | ( y << 1 ) ) & 0x55555555;

  	return x | ( y << 1 );

  }

  // find the leftmost node of a polygon ring

  function getLeftmost( start ) {

  	var p = start, leftmost = start;

  	do {

  		if ( p.x < leftmost.x ) { leftmost = p; }
  		p = p.next;

  	} while ( p !== start );

  	return leftmost;

  }

  // check if a point lies within a convex triangle

  function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

  	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
  	 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
  	 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)

  function isValidDiagonal( a, b ) {

  	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
  		locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

  }

  // signed area of a triangle

  function area( p, q, r ) {

  	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

  }

  // check if two points are equal

  function equals( p1, p2 ) {

  	return p1.x === p2.x && p1.y === p2.y;

  }

  // check if two segments intersect

  function intersects( p1, q1, p2, q2 ) {

  	if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
  			( equals( p1, q2 ) && equals( p2, q1 ) ) ) { return true; }

  	return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
  				 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

  }

  // check if a polygon diagonal intersects any polygon segments

  function intersectsPolygon( a, b ) {

  	var p = a;

  	do {

  		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
  						intersects( p, p.next, a, b ) ) {

  			return true;

  		}

  		p = p.next;

  	} while ( p !== a );

  	return false;

  }

  // check if a polygon diagonal is locally inside the polygon

  function locallyInside( a, b ) {

  	return area( a.prev, a, a.next ) < 0 ?
  		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
  		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

  }

  // check if the middle point of a polygon diagonal is inside the polygon

  function middleInside( a, b ) {

  	var p = a,
  		inside = false,
  		px = ( a.x + b.x ) / 2,
  		py = ( a.y + b.y ) / 2;

  	do {

  		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
  						( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

  			inside = ! inside;

  		}

  		p = p.next;

  	} while ( p !== a );

  	return inside;

  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring

  function splitPolygon( a, b ) {

  	var a2 = new Node( a.i, a.x, a.y ),
  		b2 = new Node( b.i, b.x, b.y ),
  		an = a.next,
  		bp = b.prev;

  	a.next = b;
  	b.prev = a;

  	a2.next = an;
  	an.prev = a2;

  	b2.next = a2;
  	a2.prev = b2;

  	bp.next = b2;
  	b2.prev = bp;

  	return b2;

  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)

  function insertNode( i, x, y, last ) {

  	var p = new Node( i, x, y );

  	if ( ! last ) {

  		p.prev = p;
  		p.next = p;

  	} else {

  		p.next = last.next;
  		p.prev = last;
  		last.next.prev = p;
  		last.next = p;

  	}

  	return p;

  }

  function removeNode( p ) {

  	p.next.prev = p.prev;
  	p.prev.next = p.next;

  	if ( p.prevZ ) { p.prevZ.nextZ = p.nextZ; }
  	if ( p.nextZ ) { p.nextZ.prevZ = p.prevZ; }

  }

  function Node( i, x, y ) {

  	// vertice index in coordinates array
  	this.i = i;

  	// vertex coordinates
  	this.x = x;
  	this.y = y;

  	// previous and next vertice nodes in a polygon ring
  	this.prev = null;
  	this.next = null;

  	// z-order curve value
  	this.z = null;

  	// previous and next nodes in z-order
  	this.prevZ = null;
  	this.nextZ = null;

  	// indicates whether this is a steiner point
  	this.steiner = false;

  }

  function signedArea( data, start, end, dim ) {

  	var sum = 0;

  	for ( var i = start, j = end - dim; i < end; i += dim ) {

  		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
  		j = i;

  	}

  	return sum;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShapeUtils = {

  	// calculate area of the contour polygon

  	area: function ( contour ) {

  		var n = contour.length;
  		var a = 0.0;

  		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	},

  	isClockWise: function ( pts ) {

  		return ShapeUtils.area( pts ) < 0;

  	},

  	triangulateShape: function ( contour, holes ) {

  		var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  		var holeIndices = []; // array of hole indices
  		var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

  		removeDupEndPts( contour );
  		addContour( vertices, contour );

  		//

  		var holeIndex = contour.length;

  		holes.forEach( removeDupEndPts );

  		for ( var i = 0; i < holes.length; i ++ ) {

  			holeIndices.push( holeIndex );
  			holeIndex += holes[ i ].length;
  			addContour( vertices, holes[ i ] );

  		}

  		//

  		var triangles = Earcut.triangulate( vertices, holeIndices );

  		//

  		for ( var i = 0; i < triangles.length; i += 3 ) {

  			faces.push( triangles.slice( i, i + 3 ) );

  		}

  		return faces;

  	}

  };

  function removeDupEndPts( points ) {

  	var l = points.length;

  	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  		points.pop();

  	}

  }

  function addContour( vertices, contour ) {

  	for ( var i = 0; i < contour.length; i ++ ) {

  		vertices.push( contour[ i ].x );
  		vertices.push( contour[ i ].y );

  	}

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ShapePath() {

  	this.type = 'ShapePath';

  	this.color = new Color();

  	this.subPaths = [];
  	this.currentPath = null;

  }

  Object.assign( ShapePath.prototype, {

  	moveTo: function ( x, y ) {

  		this.currentPath = new Path();
  		this.subPaths.push( this.currentPath );
  		this.currentPath.moveTo( x, y );

  	},

  	lineTo: function ( x, y ) {

  		this.currentPath.lineTo( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

  	},

  	splineThru: function ( pts ) {

  		this.currentPath.splineThru( pts );

  	},

  	toShapes: function ( isCCW, noHoles ) {

  		function toShapesNoHoles( inSubpaths ) {

  			var shapes = [];

  			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

  				var tmpPath = inSubpaths[ i ];

  				var tmpShape = new Shape();
  				tmpShape.curves = tmpPath.curves;

  				shapes.push( tmpShape );

  			}

  			return shapes;

  		}

  		function isPointInsidePolygon( inPt, inPolygon ) {

  			var polyLen = inPolygon.length;

  			// inPt on polygon contour => immediate success    or
  			// toggling of inside/outside at every single! intersection point of an edge
  			//  with the horizontal line through inPt, left of inPt
  			//  not counting lowerY endpoints of edges and whole edges on that line
  			var inside = false;
  			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

  				var edgeLowPt = inPolygon[ p ];
  				var edgeHighPt = inPolygon[ q ];

  				var edgeDx = edgeHighPt.x - edgeLowPt.x;
  				var edgeDy = edgeHighPt.y - edgeLowPt.y;

  				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

  					// not parallel
  					if ( edgeDy < 0 ) {

  						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
  						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

  					}
  					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		{ continue; }

  					if ( inPt.y === edgeLowPt.y ) {

  						if ( inPt.x === edgeLowPt.x )		{ return	true; }		// inPt is on contour ?
  						// continue;				// no intersection or edgeLowPt => doesn't count !!!

  					} else {

  						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
  						if ( perpEdge === 0 )				{ return	true; }		// inPt is on contour ?
  						if ( perpEdge < 0 ) 				{ continue; }
  						inside = ! inside;		// true intersection left of inPt

  					}

  				} else {

  					// parallel or collinear
  					if ( inPt.y !== edgeLowPt.y ) 		{ continue; }			// parallel
  					// edge lies on the same horizontal line as inPt
  					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
  						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		{ return	true; }	// inPt: Point on contour !
  					// continue;

  				}

  			}

  			return	inside;

  		}

  		var isClockWise = ShapeUtils.isClockWise;

  		var subPaths = this.subPaths;
  		if ( subPaths.length === 0 ) { return []; }

  		if ( noHoles === true )	{ return	toShapesNoHoles( subPaths ); }
  		var solid, tmpPath, tmpShape, shapes = [];

  		if ( subPaths.length === 1 ) {

  			tmpPath = subPaths[ 0 ];
  			tmpShape = new Shape();
  			tmpShape.curves = tmpPath.curves;
  			shapes.push( tmpShape );
  			return shapes;

  		}

  		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  		holesFirst = isCCW ? ! holesFirst : holesFirst;

  		// console.log("Holes first", holesFirst);

  		var betterShapeHoles = [];
  		var newShapes = [];
  		var newShapeHoles = [];
  		var mainIdx = 0;
  		var tmpPoints;

  		newShapes[ mainIdx ] = undefined;
  		newShapeHoles[ mainIdx ] = [];

  		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

  			tmpPath = subPaths[ i ];
  			tmpPoints = tmpPath.getPoints();
  			solid = isClockWise( tmpPoints );
  			solid = isCCW ? ! solid : solid;

  			if ( solid ) {

  				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	{ mainIdx ++; }

  				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
  				newShapes[ mainIdx ].s.curves = tmpPath.curves;

  				if ( holesFirst )	{ mainIdx ++; }
  				newShapeHoles[ mainIdx ] = [];

  				//console.log('cw', i);

  			} else {

  				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

  				//console.log('ccw', i);

  			}

  		}

  		// only Holes? -> probably all Shapes with wrong orientation
  		if ( ! newShapes[ 0 ] )	{ return	toShapesNoHoles( subPaths ); }
  		if ( newShapes.length > 1 ) {

  			var ambiguous = false;
  			var toChange = [];

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				betterShapeHoles[ sIdx ] = [];

  			}

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				var sho = newShapeHoles[ sIdx ];

  				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

  					var ho = sho[ hIdx ];
  					var hole_unassigned = true;

  					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

  						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

  							if ( sIdx !== s2Idx )	{ toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); }
  							if ( hole_unassigned ) {

  								hole_unassigned = false;
  								betterShapeHoles[ s2Idx ].push( ho );

  							} else {

  								ambiguous = true;

  							}

  						}

  					}
  					if ( hole_unassigned ) {

  						betterShapeHoles[ sIdx ].push( ho );

  					}

  				}

  			}
  			// console.log("ambiguous: ", ambiguous);
  			if ( toChange.length > 0 ) {

  				// console.log("to change: ", toChange);
  				if ( ! ambiguous )	{ newShapeHoles = betterShapeHoles; }

  			}

  		}

  		var tmpHoles;

  		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

  			tmpShape = newShapes[ i ].s;
  			shapes.push( tmpShape );
  			tmpHoles = newShapeHoles[ i ];

  			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

  				tmpShape.holes.push( tmpHoles[ j ].h );

  			}

  		}

  		//console.log("shape", shapes);

  		return shapes;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SVGLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  SVGLoader.prototype = {

  	constructor: SVGLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( text ) {

  		function parseNode( node, style ) {

  			if ( node.nodeType !== 1 ) { return; }

  			var transform = getNodeTransform( node );

  			var path = null;

  			switch ( node.nodeName ) {

  				case 'svg':
  					break;

  				case 'g':
  					style = parseStyle( node, style );
  					break;

  				case 'path':
  					style = parseStyle( node, style );
  					if ( node.hasAttribute( 'd' ) && isVisible( style ) ) { path = parsePathNode( node, style ); }
  					break;

  				case 'rect':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parseRectNode( node, style ); }
  					break;

  				case 'polygon':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parsePolygonNode( node, style ); }
  					break;

  				case 'polyline':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parsePolylineNode( node, style ); }
  					break;

  				case 'circle':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parseCircleNode( node, style ); }
  					break;

  				case 'ellipse':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parseEllipseNode( node, style ); }
  					break;

  				case 'line':
  					style = parseStyle( node, style );
  					if ( isVisible( style ) ) { path = parseLineNode( node, style ); }
  					break;

  				default:
  					console.log( node );

  			}

  			if ( path ) {

  				transformPath( path, currentTransform );

  				paths.push( path );

  			}

  			var nodes = node.childNodes;

  			for ( var i = 0; i < nodes.length; i ++ ) {

  				parseNode( nodes[ i ], style );

  			}

  			if ( transform ) {

  				currentTransform.copy( transformStack.pop() );

  			}

  		}

  		function parsePathNode( node, style ) {

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );

  			var point = new Vector2();
  			var control = new Vector2();

  			var firstPoint = new Vector2();
  			var isFirstPoint = true;
  			var doSetFirstPoint = false;

  			var d = node.getAttribute( 'd' );

  			// console.log( d );

  			var commands = d.match( /[a-df-z][^a-df-z]*/ig );

  			for ( var i = 0, l = commands.length; i < l; i ++ ) {

  				var command = commands[ i ];

  				var type = command.charAt( 0 );
  				var data = command.substr( 1 ).trim();

  				if ( isFirstPoint === true ) {
  					doSetFirstPoint = true;
  					isFirstPoint = false;
  				}

  				switch ( type ) {

  					case 'M':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							point.x = numbers[ j + 0 ];
  							point.y = numbers[ j + 1 ];
  							control.x = point.x;
  							control.y = point.y;
  							if ( j === 0 ) {
  								path.moveTo( point.x, point.y );
  							} else {
  								path.lineTo( point.x, point.y );
  							}
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'H':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {
  							point.x = numbers[ j ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'V':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {
  							point.y = numbers[ j ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'L':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							point.x = numbers[ j + 0 ];
  							point.y = numbers[ j + 1 ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'C':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {
  							path.bezierCurveTo(
  								numbers[ j + 0 ],
  								numbers[ j + 1 ],
  								numbers[ j + 2 ],
  								numbers[ j + 3 ],
  								numbers[ j + 4 ],
  								numbers[ j + 5 ]
  							);
  							control.x = numbers[ j + 2 ];
  							control.y = numbers[ j + 3 ];
  							point.x = numbers[ j + 4 ];
  							point.y = numbers[ j + 5 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'S':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {
  							path.bezierCurveTo(
  								getReflection( point.x, control.x ),
  								getReflection( point.y, control.y ),
  								numbers[ j + 0 ],
  								numbers[ j + 1 ],
  								numbers[ j + 2 ],
  								numbers[ j + 3 ]
  							);
  							control.x = numbers[ j + 0 ];
  							control.y = numbers[ j + 1 ];
  							point.x = numbers[ j + 2 ];
  							point.y = numbers[ j + 3 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'Q':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {
  							path.quadraticCurveTo(
  								numbers[ j + 0 ],
  								numbers[ j + 1 ],
  								numbers[ j + 2 ],
  								numbers[ j + 3 ]
  							);
  							control.x = numbers[ j + 0 ];
  							control.y = numbers[ j + 1 ];
  							point.x = numbers[ j + 2 ];
  							point.y = numbers[ j + 3 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'T':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							var rx = getReflection( point.x, control.x );
  							var ry = getReflection( point.y, control.y );
  							path.quadraticCurveTo(
  								rx,
  								ry,
  								numbers[ j + 0 ],
  								numbers[ j + 1 ]
  							);
  							control.x = rx;
  							control.y = ry;
  							point.x = numbers[ j + 0 ];
  							point.y = numbers[ j + 1 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'A':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {
  							var start = point.clone();
  							point.x = numbers[ j + 5 ];
  							point.y = numbers[ j + 6 ];
  							control.x = point.x;
  							control.y = point.y;
  							parseArcCommand(
  								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
  							);
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					//

  					case 'm':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							point.x += numbers[ j + 0 ];
  							point.y += numbers[ j + 1 ];
  							control.x = point.x;
  							control.y = point.y;
  							if ( j === 0 ) {
  								path.moveTo( point.x, point.y );
  							} else {
  								path.lineTo( point.x, point.y );
  							}
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'h':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {
  							point.x += numbers[ j ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'v':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j ++ ) {
  							point.y += numbers[ j ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'l':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							point.x += numbers[ j + 0 ];
  							point.y += numbers[ j + 1 ];
  							control.x = point.x;
  							control.y = point.y;
  							path.lineTo( point.x, point.y );
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'c':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {
  							path.bezierCurveTo(
  								point.x + numbers[ j + 0 ],
  								point.y + numbers[ j + 1 ],
  								point.x + numbers[ j + 2 ],
  								point.y + numbers[ j + 3 ],
  								point.x + numbers[ j + 4 ],
  								point.y + numbers[ j + 5 ]
  							);
  							control.x = point.x + numbers[ j + 2 ];
  							control.y = point.y + numbers[ j + 3 ];
  							point.x += numbers[ j + 4 ];
  							point.y += numbers[ j + 5 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 's':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {
  							path.bezierCurveTo(
  								getReflection( point.x, control.x ),
  								getReflection( point.y, control.y ),
  								point.x + numbers[ j + 0 ],
  								point.y + numbers[ j + 1 ],
  								point.x + numbers[ j + 2 ],
  								point.y + numbers[ j + 3 ]
  							);
  							control.x = point.x + numbers[ j + 0 ];
  							control.y = point.y + numbers[ j + 1 ];
  							point.x += numbers[ j + 2 ];
  							point.y += numbers[ j + 3 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'q':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {
  							path.quadraticCurveTo(
  								point.x + numbers[ j + 0 ],
  								point.y + numbers[ j + 1 ],
  								point.x + numbers[ j + 2 ],
  								point.y + numbers[ j + 3 ]
  							);
  							control.x = point.x + numbers[ j + 0 ];
  							control.y = point.y + numbers[ j + 1 ];
  							point.x += numbers[ j + 2 ];
  							point.y += numbers[ j + 3 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 't':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {
  							var rx = getReflection( point.x, control.x );
  							var ry = getReflection( point.y, control.y );
  							path.quadraticCurveTo(
  								rx,
  								ry,
  								point.x + numbers[ j + 0 ],
  								point.y + numbers[ j + 1 ]
  							);
  							control.x = rx;
  							control.y = ry;
  							point.x = point.x + numbers[ j + 0 ];
  							point.y = point.y + numbers[ j + 1 ];
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					case 'a':
  						var numbers = parseFloats( data );
  						for ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {
  							var start = point.clone();
  							point.x += numbers[ j + 5 ];
  							point.y += numbers[ j + 6 ];
  							control.x = point.x;
  							control.y = point.y;
  							parseArcCommand(
  								path, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point
  							);
  							if ( j === 0 && doSetFirstPoint === true ) { firstPoint.copy( point ); }
  						}
  						break;

  					//

  					case 'Z':
  					case 'z':
  						path.currentPath.autoClose = true;
  						if ( path.currentPath.curves.length > 0 ) {
  							// Reset point to beginning of Path
  							point.copy( firstPoint );
  							path.currentPath.currentPoint.copy( point );
  							isFirstPoint = true;
  						}
  						break;

  					default:
  						console.warn( command );

  				}

  				// console.log( type, parseFloats( data ), parseFloats( data ).length  )

  				doSetFirstPoint = false;

  			}

  			return path;

  		}
  		function parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {

  			x_axis_rotation = x_axis_rotation * Math.PI / 180;

  			// Ensure radii are positive
  			rx = Math.abs( rx );
  			ry = Math.abs( ry );

  			// Compute (x1, y1)
  			var dx2 = ( start.x - end.x ) / 2.0;
  			var dy2 = ( start.y - end.y ) / 2.0;
  			var x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;
  			var y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;

  			// Compute (cx, cy)
  			var rxs = rx * rx;
  			var rys = ry * ry;
  			var x1ps = x1p * x1p;
  			var y1ps = y1p * y1p;

  			// Ensure radii are large enough
  			var cr = x1ps / rxs + y1ps / rys;

  			if ( cr > 1 ) {

  				// scale up rx,ry equally so cr == 1
  				var s = Math.sqrt( cr );
  				rx = s * rx;
  				ry = s * ry;
  				rxs = rx * rx;
  				rys = ry * ry;

  			}

  			var dq = ( rxs * y1ps + rys * x1ps );
  			var pq = ( rxs * rys - dq ) / dq;
  			var q = Math.sqrt( Math.max( 0, pq ) );
  			if ( large_arc_flag === sweep_flag ) { q = - q; }
  			var cxp = q * rx * y1p / ry;
  			var cyp = - q * ry * x1p / rx;

  			// Step 3: Compute (cx, cy) from (cx, cy)
  			var cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;
  			var cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;

  			// Step 4: Compute 1 and 
  			var theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );
  			var delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );

  			path.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );

  		}

  		function svgAngle( ux, uy, vx, vy ) {

  			var dot = ux * vx + uy * vy;
  			var len = Math.sqrt( ux * ux + uy * uy ) *  Math.sqrt( vx * vx + vy * vy );
  			var ang = Math.acos( Math.max( -1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear
  			if ( ( ux * vy - uy * vx ) < 0 ) { ang = - ang; }
  			return ang;

  		}
  		function parseRectNode( node, style ) {

  			var x = parseFloat( node.getAttribute( 'x' ) || 0 );
  			var y = parseFloat( node.getAttribute( 'y' ) || 0 );
  			var rx = parseFloat( node.getAttribute( 'rx' ) || 0 );
  			var ry = parseFloat( node.getAttribute( 'ry' ) || 0 );
  			var w = parseFloat( node.getAttribute( 'width' ) );
  			var h = parseFloat( node.getAttribute( 'height' ) );

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );
  			path.moveTo( x + 2 * rx, y );
  			path.lineTo( x + w - 2 * rx, y );
  			if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry ); }
  			path.lineTo( x + w, y + h - 2 * ry );
  			if ( rx !== 0 || ry !== 0 ) { path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h ); }
  			path.lineTo( x + 2 * rx, y + h );

  			if ( rx !== 0 || ry !== 0 ) {

  				path.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );

  			}

  			path.lineTo( x, y + 2 * ry );

  			if ( rx !== 0 || ry !== 0 ) {

  				path.bezierCurveTo( x, y, x, y, x + 2 * rx, y );

  			}

  			return path;

  		}

  		function parsePolygonNode( node, style ) {

  			function iterator( match, a, b ) {

  				var x = parseFloat( a );
  				var y = parseFloat( b );

  				if ( index === 0 ) {
  					path.moveTo( x, y );
  				} else {
  					path.lineTo( x, y );
  				}

  				index ++;

  			}

  			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );

  			var index = 0;

  			node.getAttribute( 'points' ).replace(regex, iterator);

  			path.currentPath.autoClose = true;

  			return path;

  		}

  		function parsePolylineNode( node, style ) {

  			function iterator( match, a, b ) {

  				var x = parseFloat( a );
  				var y = parseFloat( b );

  				if ( index === 0 ) {
  					path.moveTo( x, y );
  				} else {
  					path.lineTo( x, y );
  				}

  				index ++;

  			}

  			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );

  			var index = 0;

  			node.getAttribute( 'points' ).replace(regex, iterator);

  			path.currentPath.autoClose = false;

  			return path;

  		}

  		function parseCircleNode( node, style ) {

  			var x = parseFloat( node.getAttribute( 'cx' ) );
  			var y = parseFloat( node.getAttribute( 'cy' ) );
  			var r = parseFloat( node.getAttribute( 'r' ) );

  			var subpath = new Path();
  			subpath.absarc( x, y, r, 0, Math.PI * 2 );

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );
  			path.subPaths.push( subpath );

  			return path;

  		}

  		function parseEllipseNode( node, style ) {

  			var x = parseFloat( node.getAttribute( 'cx' ) );
  			var y = parseFloat( node.getAttribute( 'cy' ) );
  			var rx = parseFloat( node.getAttribute( 'rx' ) );
  			var ry = parseFloat( node.getAttribute( 'ry' ) );

  			var subpath = new Path();
  			subpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );

  			var path = new ShapePath();
  			path.color.setStyle( style.fill );
  			path.subPaths.push( subpath );

  			return path;

  		}

  		function parseLineNode( node, style ) {

  			var x1 = parseFloat( node.getAttribute( 'x1' ) );
  			var y1 = parseFloat( node.getAttribute( 'y1' ) );
  			var x2 = parseFloat( node.getAttribute( 'x2' ) );
  			var y2 = parseFloat( node.getAttribute( 'y2' ) );

  			var path = new ShapePath();
  			path.moveTo( x1, y1 );
  			path.lineTo( x2, y2 );
  			path.currentPath.autoClose = false;

  			return path;

  		}

  		//

  		function parseStyle( node, style ) {

  			style = Object.assign( {}, style ); // clone style

  			if ( node.hasAttribute( 'fill' ) ) { style.fill = node.getAttribute( 'fill' ); }
  			if ( node.style.fill !== '' ) { style.fill = node.style.fill; }

  			return style;

  		}

  		function isVisible( style ) {

  			return style.fill !== 'none' && style.fill !== 'transparent';

  		}

  		// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes

  		function getReflection( a, b ) {

  			return a - ( b - a );

  		}

  		function parseFloats( string ) {

  			var array = string.split( /[\s,]+|(?=\s?[+\-])/ );

  			for ( var i = 0; i < array.length; i ++ ) {

  				var number = array[ i ];

  				// Handle values like 48.6037.7.8
  				// TODO Find a regex for this

  				if ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {

  					var split = number.split( '.' );

  					for ( var s = 2; s < split.length; s ++ ) {

  						array.splice( i + s - 1, 0, '0.' + split[ s ] );

  					}

  				}

  				array[ i ] = parseFloat( number );

  			}

  			return array;
  		}

  		function getNodeTransform( node ) {

  			if ( ! node.hasAttribute( 'transform' ) ) {
  				return null;
  			}

  			var transform = parseTransformNode( node );

  			if ( transform ) {

  				if ( transformStack.length > 0 ) {
  					transform.premultiply( transformStack[ transformStack.length - 1 ] );
  				}

  				currentTransform.copy( transform );
  				transformStack.push( transform );

  			}

  			return transform;

  		}

  		function parseTransformNode( node ) {

  			var transform = new Matrix3();
  			var currentTransform = tempTransform0;
  			var transformsTexts = node.getAttribute( 'transform' ).split( ' ' );

  			for ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex-- ) {

  				var transformText = transformsTexts[ tIndex ];
  				var openParPos = transformText.indexOf( "(" );
  				var closeParPos = transformText.indexOf( ")" );

  				if ( openParPos > 0 && openParPos < closeParPos ) {

  					var transformType = transformText.substr( 0, openParPos );

  					var array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );

  					currentTransform.identity();

  					switch ( transformType ) {

  						case "translate":

  							if ( array.length >= 1 ) {

  								var tx = array[ 0 ];
  								var ty = tx;

  								if ( array.length >= 2 ) {

  									ty = array[ 1 ];

  								}

  								currentTransform.translate( tx, ty );

  							}

  							break;

  						case "rotate":

  							if ( array.length >= 1 ) {

  								var angle = 0;
  								var cx = 0;
  								var cy = 0;

  								// Angle
  								angle = - array[ 0 ] * Math.PI / 180;

  								if ( array.length >= 3 ) {

  									// Center x, y
  									cx = array[ 1 ];
  									cy = array[ 2 ];

  								}

  								// Rotate around center (cx, cy)
  								tempTransform1.identity().translate( -cx, -cy );
  								tempTransform2.identity().rotate( angle );
  								tempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );
  								tempTransform1.identity().translate( cx, cy );
  								currentTransform.multiplyMatrices( tempTransform1, tempTransform3 );

  							}

  							break;

  						case "scale":

  							if ( array.length >= 1 ) {

  								var scaleX = array[ 0 ];
  								var scaleY = scaleX;

  								if ( array.length >= 2 ) {
  									scaleY = array[ 1 ];
  								}

  								currentTransform.scale( scaleX, scaleY );

  							}

  							break;

  						case "skewX":

  							if ( array.length === 1 ) {

  								currentTransform.set(
  									1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,
  									0, 1, 0,
  									0, 0, 1
  								);

  							}

  							break;

  						case "skewY":

  							if ( array.length === 1 ) {

  								currentTransform.set(
  									1, 0, 0,
  									Math.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,
  									0, 0, 1
  								);

  							}

  							break;

  						case "matrix":

  							if ( array.length === 6 ) {

  								currentTransform.set(
  									array[ 0 ], array[ 2 ], array[ 4 ],
  									array[ 1 ], array[ 3 ], array[ 5 ],
  									0, 0, 1
  								);

  							}

  							break;
  					}

  				}

  				transform.premultiply( currentTransform );

  			}

  			return transform;

  		}

  		function transformPath( path, m ) {

  			function transfVec2( v2 ) {

  				tempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );

  				v2.set( tempV3.x, tempV3.y );

  			}

  			var isRotated = isTransformRotated( m );

  			var tempV2 = new Vector2();
  			var tempV3 = new Vector3();

  			var subPaths = path.subPaths;

  			for ( var i = 0, n = subPaths.length; i < n; i++ ) {

  				var subPath = subPaths[ i ];
  				var curves = subPath.curves;

  				for ( var j = 0; j < curves.length; j++ ) {

  					var curve = curves[ j ];

  					if ( curve.isLineCurve ) {

  						transfVec2( curve.v1 );
  						transfVec2( curve.v2 );

  					} else if ( curve.isCubicBezierCurve ) {

  						transfVec2( curve.v0 );
  						transfVec2( curve.v1 );
  						transfVec2( curve.v2 );
  						transfVec2( curve.v3 );

  					} else if ( curve.isQuadraticBezierCurve ) {

  						transfVec2( curve.v0 );
  						transfVec2( curve.v1 );
  						transfVec2( curve.v2 );

  					} else if ( curve.isEllipseCurve ) {

  						if ( isRotated ) {
  							console.warn( "SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented." );
  						}

  						tempV2.set( curve.aX, curve.aY );
  						transfVec2( tempV2 );
  						curve.aX = tempV2.x;
  						curve.aY = tempV2.y;

  						curve.xRadius *= getTransformScaleX( m );
  						curve.yRadius *= getTransformScaleY( m );

  					}

  				}

  			}

  		}

  		function isTransformRotated( m ) {
  			return m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;
  		}

  		function getTransformScaleX( m ) {
  			var te = m.elements;
  			return Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] )
  		}

  		function getTransformScaleY( m ) {
  			var te = m.elements;
  			return Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] )
  		}

  		//

  		console.log( 'SVGLoader' );

  		var paths = [];

  		var transformStack = [];

  		var tempTransform0 = new Matrix3();
  		var tempTransform1 = new Matrix3();
  		var tempTransform2 = new Matrix3();
  		var tempTransform3 = new Matrix3();

  		var currentTransform = new Matrix3();

  		console.time( 'SVGLoader: DOMParser' );

  		var xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml

  		console.timeEnd( 'SVGLoader: DOMParser' );

  		console.time( 'SVGLoader: Parse' );

  		parseNode( xml.documentElement, { fill: '#000' } );

  		// console.log( paths );
  		console.timeEnd( 'SVGLoader: Parse' );

  		return paths;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var TDSLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.debug = false;

  	this.group = null;
  	this.position = 0;

  	this.materials = [];
  	this.meshes = [];

  };

  TDSLoader.prototype = {

  	constructor: TDSLoader,

  	crossOrigin: 'anonymous',
  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = this.path !== undefined ? this.path : LoaderUtils.extractUrlBase( url );

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );

  		loader.load( url, function ( data ) {

  			onLoad( scope.parse( data, path ) );

  		}, onProgress, onError );

  	},
  	parse: function ( arraybuffer, path ) {
  		var this$1 = this;


  		this.group = new Group();
  		this.position = 0;
  		this.materials = [];
  		this.meshes = [];

  		this.readFile( arraybuffer, path );

  		for ( var i = 0; i < this.meshes.length; i ++ ) {

  			this$1.group.add( this$1.meshes[ i ] );

  		}

  		return this.group;

  	},
  	readFile: function ( arraybuffer, path ) {
  		var this$1 = this;


  		var data = new DataView( arraybuffer );
  		var chunk = this.readChunk( data );

  		if ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {

  			var next = this.nextChunk( data, chunk );

  			while ( next !== 0 ) {

  				if ( next === M3D_VERSION ) {

  					var version = this$1.readDWord( data );
  					this$1.debugMessage( '3DS file version: ' + version );

  				} else if ( next === MDATA ) {

  					this$1.resetPosition( data );
  					this$1.readMeshData( data, path );

  				} else {

  					this$1.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );

  				}

  				next = this$1.nextChunk( data, chunk );

  			}

  		}

  		this.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );

  	},
  	readMeshData: function ( data, path ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var next = this.nextChunk( data, chunk );

  		while ( next !== 0 ) {

  			if ( next === MESH_VERSION ) {

  				var version = + this$1.readDWord( data );
  				this$1.debugMessage( 'Mesh Version: ' + version );

  			} else if ( next === MASTER_SCALE ) {

  				var scale = this$1.readFloat( data );
  				this$1.debugMessage( 'Master scale: ' + scale );
  				this$1.group.scale.set( scale, scale, scale );

  			} else if ( next === NAMED_OBJECT ) {

  				this$1.debugMessage( 'Named Object' );
  				this$1.resetPosition( data );
  				this$1.readNamedObject( data );

  			} else if ( next === MAT_ENTRY ) {

  				this$1.debugMessage( 'Material' );
  				this$1.resetPosition( data );
  				this$1.readMaterialEntry( data, path );

  			} else {

  				this$1.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );

  			}

  			next = this$1.nextChunk( data, chunk );

  		}

  	},
  	readNamedObject: function ( data ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var name = this.readString( data, 64 );
  		chunk.cur = this.position;

  		var next = this.nextChunk( data, chunk );
  		while ( next !== 0 ) {

  			if ( next === N_TRI_OBJECT ) {

  				this$1.resetPosition( data );
  				var mesh = this$1.readMesh( data );
  				mesh.name = name;
  				this$1.meshes.push( mesh );

  			} else {

  				this$1.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );

  			}

  			next = this$1.nextChunk( data, chunk );

  		}

  		this.endChunk( chunk );

  	},
  	readMaterialEntry: function ( data, path ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var next = this.nextChunk( data, chunk );
  		var material = new MeshPhongMaterial();

  		while ( next !== 0 ) {

  			if ( next === MAT_NAME ) {

  				material.name = this$1.readString( data, 64 );
  				this$1.debugMessage( '   Name: ' + material.name );

  			} else if ( next === MAT_WIRE ) {

  				this$1.debugMessage( '   Wireframe' );
  				material.wireframe = true;

  			} else if ( next === MAT_WIRE_SIZE ) {

  				var value = this$1.readByte( data );
  				material.wireframeLinewidth = value;
  				this$1.debugMessage( '   Wireframe Thickness: ' + value );

  			} else if ( next === MAT_TWO_SIDE ) {

  				material.side = DoubleSide;
  				this$1.debugMessage( '   DoubleSided' );

  			} else if ( next === MAT_ADDITIVE ) {

  				this$1.debugMessage( '   Additive Blending' );
  				material.blending = AdditiveBlending;

  			} else if ( next === MAT_DIFFUSE ) {

  				this$1.debugMessage( '   Diffuse Color' );
  				material.color = this$1.readColor( data );

  			} else if ( next === MAT_SPECULAR ) {

  				this$1.debugMessage( '   Specular Color' );
  				material.specular = this$1.readColor( data );

  			} else if ( next === MAT_AMBIENT ) {

  				this$1.debugMessage( '   Ambient color' );
  				material.color = this$1.readColor( data );

  			} else if ( next === MAT_SHININESS ) {

  				var shininess = this$1.readWord( data );
  				material.shininess = shininess;
  				this$1.debugMessage( '   Shininess : ' + shininess );

  			} else if ( next === MAT_TEXMAP ) {

  				this$1.debugMessage( '   ColorMap' );
  				this$1.resetPosition( data );
  				material.map = this$1.readMap( data, path );

  			} else if ( next === MAT_BUMPMAP ) {

  				this$1.debugMessage( '   BumpMap' );
  				this$1.resetPosition( data );
  				material.bumpMap = this$1.readMap( data, path );

  			} else if ( next === MAT_OPACMAP ) {

  				this$1.debugMessage( '   OpacityMap' );
  				this$1.resetPosition( data );
  				material.alphaMap = this$1.readMap( data, path );

  			} else if ( next === MAT_SPECMAP ) {

  				this$1.debugMessage( '   SpecularMap' );
  				this$1.resetPosition( data );
  				material.specularMap = this$1.readMap( data, path );

  			} else {

  				this$1.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );

  			}

  			next = this$1.nextChunk( data, chunk );

  		}

  		this.endChunk( chunk );

  		this.materials[ material.name ] = material;

  	},
  	readMesh: function ( data ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var next = this.nextChunk( data, chunk );

  		var geometry = new BufferGeometry();
  		var uvs = [];

  		var material = new MeshPhongMaterial();
  		var mesh = new Mesh( geometry, material );
  		mesh.name = 'mesh';

  		while ( next !== 0 ) {

  			if ( next === POINT_ARRAY ) {

  				var points = this$1.readWord( data );

  				this$1.debugMessage( '   Vertex: ' + points );

  				//BufferGeometry

  				var vertices = [];

  				for ( var i = 0; i < points; i ++ )		{

  					vertices.push( this$1.readFloat( data ) );
  					vertices.push( this$1.readFloat( data ) );
  					vertices.push( this$1.readFloat( data ) );

  				}

  				geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  			} else if ( next === FACE_ARRAY ) {

  				this$1.resetPosition( data );
  				this$1.readFaceArray( data, mesh );

  			} else if ( next === TEX_VERTS ) {

  				var texels = this$1.readWord( data );

  				this$1.debugMessage( '   UV: ' + texels );

  				//BufferGeometry

  				var uvs = [];

  				for ( var i = 0; i < texels; i ++ )		{

  					uvs.push( this$1.readFloat( data ) );
  					uvs.push( this$1.readFloat( data ) );

  				}

  				geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
  			} else if ( next === MESH_MATRIX ) {

  				this$1.debugMessage( '   Tranformation Matrix (TODO)' );

  				var values = [];
  				for ( var i = 0; i < 12; i ++ ) {

  					values[ i ] = this$1.readFloat( data );

  				}

  				var matrix = new Matrix4();

  				//X Line
  				matrix.elements[ 0 ] = values[ 0 ];
  				matrix.elements[ 1 ] = values[ 6 ];
  				matrix.elements[ 2 ] = values[ 3 ];
  				matrix.elements[ 3 ] = values[ 9 ];

  				//Y Line
  				matrix.elements[ 4 ] = values[ 2 ];
  				matrix.elements[ 5 ] = values[ 8 ];
  				matrix.elements[ 6 ] = values[ 5 ];
  				matrix.elements[ 7 ] = values[ 11 ];

  				//Z Line
  				matrix.elements[ 8 ] = values[ 1 ];
  				matrix.elements[ 9 ] = values[ 7 ];
  				matrix.elements[ 10 ] = values[ 4 ];
  				matrix.elements[ 11 ] = values[ 10 ];

  				//W Line
  				matrix.elements[ 12 ] = 0;
  				matrix.elements[ 13 ] = 0;
  				matrix.elements[ 14 ] = 0;
  				matrix.elements[ 15 ] = 1;

  				matrix.transpose();

  				var inverse = new Matrix4();
  				inverse.getInverse( matrix, true );
  				geometry.applyMatrix( inverse );

  				matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );

  			} else {

  				this$1.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );

  			}

  			next = this$1.nextChunk( data, chunk );

  		}

  		this.endChunk( chunk );

  		geometry.computeVertexNormals();

  		return mesh;

  	},
  	readFaceArray: function ( data, mesh ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var faces = this.readWord( data );

  		this.debugMessage( '   Faces: ' + faces );

  		var index = [];

  		for ( var i = 0; i < faces; ++ i ) {

  			index.push( this$1.readWord( data ), this$1.readWord( data ), this$1.readWord( data ) );

  			var visibility = this$1.readWord( data );

  		}

  		mesh.geometry.setIndex( index );

  		//The rest of the FACE_ARRAY chunk is subchunks

  		while ( this.position < chunk.end ) {

  			var chunk = this$1.readChunk( data );

  			if ( chunk.id === MSH_MAT_GROUP ) {

  				this$1.debugMessage( '      Material Group' );

  				this$1.resetPosition( data );

  				var group = this$1.readMaterialGroup( data );

  				var material = this$1.materials[ group.name ];

  				if ( material !== undefined )	{

  					mesh.material = material;

  					if ( material.name === '' )		{

  						material.name = mesh.name;

  					}

  				}

  			} else {

  				this$1.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );

  			}

  			this$1.endChunk( chunk );

  		}

  		this.endChunk( chunk );

  	},
  	readMap: function ( data, path ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var next = this.nextChunk( data, chunk );
  		var texture = {};

  		var loader = new TextureLoader( this.manager );
  		loader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		while ( next !== 0 ) {

  			if ( next === MAT_MAPNAME ) {

  				var name = this$1.readString( data, 128 );
  				texture = loader.load( name );

  				this$1.debugMessage( '      File: ' + path + name );

  			} else if ( next === MAT_MAP_UOFFSET ) {

  				texture.offset.x = this$1.readFloat( data );
  				this$1.debugMessage( '      OffsetX: ' + texture.offset.x );

  			} else if ( next === MAT_MAP_VOFFSET ) {

  				texture.offset.y = this$1.readFloat( data );
  				this$1.debugMessage( '      OffsetY: ' + texture.offset.y );

  			} else if ( next === MAT_MAP_USCALE ) {

  				texture.repeat.x = this$1.readFloat( data );
  				this$1.debugMessage( '      RepeatX: ' + texture.repeat.x );

  			} else if ( next === MAT_MAP_VSCALE ) {

  				texture.repeat.y = this$1.readFloat( data );
  				this$1.debugMessage( '      RepeatY: ' + texture.repeat.y );

  			} else {

  				this$1.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );

  			}

  			next = this$1.nextChunk( data, chunk );

  		}

  		this.endChunk( chunk );

  		return texture;

  	},
  	readMaterialGroup: function ( data ) {
  		var this$1 = this;


  		var chunk = this.readChunk( data );
  		var name = this.readString( data, 64 );
  		var numFaces = this.readWord( data );

  		this.debugMessage( '         Name: ' + name );
  		this.debugMessage( '         Faces: ' + numFaces );

  		var index = [];
  		for ( var i = 0; i < numFaces; ++ i ) {

  			index.push( this$1.readWord( data ) );

  		}

  		return { name: name, index: index };

  	},
  	readColor: function ( data ) {

  		var chunk = this.readChunk( data );
  		var color = new Color();

  		if ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {

  			var r = this.readByte( data );
  			var g = this.readByte( data );
  			var b = this.readByte( data );

  			color.setRGB( r / 255, g / 255, b / 255 );

  			this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

  		}	else if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {

  			var r = this.readFloat( data );
  			var g = this.readFloat( data );
  			var b = this.readFloat( data );

  			color.setRGB( r, g, b );

  			this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

  		}	else {

  			this.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );

  		}

  		this.endChunk( chunk );
  		return color;

  	},
  	readChunk: function ( data ) {

  		var chunk = {};

  		chunk.cur = this.position;
  		chunk.id = this.readWord( data );
  		chunk.size = this.readDWord( data );
  		chunk.end = chunk.cur + chunk.size;
  		chunk.cur += 6;

  		return chunk;

  	},
  	endChunk: function ( chunk ) {

  		this.position = chunk.end;

  	},
  	nextChunk: function ( data, chunk ) {

  		if ( chunk.cur >= chunk.end ) {

  			return 0;

  		}

  		this.position = chunk.cur;

  		try {

  			var next = this.readChunk( data );
  			chunk.cur += next.size;
  			return next.id;

  		}	catch ( e ) {

  			this.debugMessage( 'Unable to read chunk at ' + this.position );
  			return 0;

  		}

  	},
  	resetPosition: function () {

  		this.position -= 6;

  	},
  	readByte: function ( data ) {

  		var v = data.getUint8( this.position, true );
  		this.position += 1;
  		return v;

  	},
  	readFloat: function ( data ) {

  		try {

  			var v = data.getFloat32( this.position, true );
  			this.position += 4;
  			return v;

  		}	catch ( e ) {

  			this.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );

  		}

  	},
  	readInt: function ( data ) {

  		var v = data.getInt32( this.position, true );
  		this.position += 4;
  		return v;

  	},
  	readShort: function ( data ) {

  		var v = data.getInt16( this.position, true );
  		this.position += 2;
  		return v;

  	},
  	readDWord: function ( data ) {

  		var v = data.getUint32( this.position, true );
  		this.position += 4;
  		return v;

  	},
  	readWord: function ( data ) {

  		var v = data.getUint16( this.position, true );
  		this.position += 2;
  		return v;

  	},
  	readString: function ( data, maxLength ) {
  		var this$1 = this;


  		var s = '';

  		for ( var i = 0; i < maxLength; i ++ ) {

  			var c = this$1.readByte( data );
  			if ( ! c ) {

  				break;

  			}

  			s += String.fromCharCode( c );

  		}

  		return s;

  	},
  	setPath: function ( path ) {

  		this.path = path;

  		return this;

  	},
  	setResourcePath: function ( resourcePath ) {

  		this.resourcePath = resourcePath;

  		return this;

  	},
  	setCrossOrigin: function ( crossOrigin ) {

  		this.crossOrigin = crossOrigin;

  		return this;

  	},
  	debugMessage: function ( message ) {

  		if ( this.debug ) {

  			console.log( message );

  		}

  	}
  };
  var M3DMAGIC = 0x4D4D;
  var MLIBMAGIC = 0x3DAA;
  var CMAGIC = 0xC23D;
  var M3D_VERSION = 0x0002;
  var COLOR_F = 0x0010;
  var COLOR_24 = 0x0011;
  var LIN_COLOR_24 = 0x0012;
  var LIN_COLOR_F = 0x0013;
  var MDATA = 0x3D3D;
  var MESH_VERSION = 0x3D3E;
  var MASTER_SCALE = 0x0100;
  var MAT_ENTRY = 0xAFFF;
  var MAT_NAME = 0xA000;
  var MAT_AMBIENT = 0xA010;
  var MAT_DIFFUSE = 0xA020;
  var MAT_SPECULAR = 0xA030;
  var MAT_SHININESS = 0xA040;
  var MAT_TWO_SIDE = 0xA081;
  var MAT_ADDITIVE = 0xA083;
  var MAT_WIRE = 0xA085;
  var MAT_WIRE_SIZE = 0xA087;
  var MAT_TEXMAP = 0xA200;
  var MAT_OPACMAP = 0xA210;
  var MAT_BUMPMAP = 0xA230;
  var MAT_SPECMAP = 0xA204;
  var MAT_MAPNAME = 0xA300;
  var MAT_MAP_USCALE = 0xA354;
  var MAT_MAP_VSCALE = 0xA356;
  var MAT_MAP_UOFFSET = 0xA358;
  var MAT_MAP_VOFFSET = 0xA35A;
  var NAMED_OBJECT = 0x4000;
  var N_TRI_OBJECT = 0x4100;
  var POINT_ARRAY = 0x4110;
  var FACE_ARRAY = 0x4120;
  var MSH_MAT_GROUP = 0x4130;
  var TEX_VERTS = 0x4140;
  var MESH_MATRIX = 0x4160;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TTFLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.reversed = false;

  };

  TTFLoader.prototype = {

  	constructor: TTFLoader,

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( buffer ) {

  			onLoad( scope.parse( buffer ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( arraybuffer ) {

  		function convert( font, reversed ) {

  			var round = Math.round;

  			var glyphs = {};
  			var scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 );

  			for ( var i = 0; i < font.glyphs.length; i ++ ) {

  				var glyph = font.glyphs.glyphs[ i ];

  				if ( glyph.unicode !== undefined ) {

  					var token = {
  						ha: round( glyph.advanceWidth * scale ),
  						x_min: round( glyph.xMin * scale ),
  						x_max: round( glyph.xMax * scale ),
  						o: ''
  					};

  					if ( reversed ) {

  						glyph.path.commands = reverseCommands( glyph.path.commands );

  					}

  					glyph.path.commands.forEach( function ( command, i ) {

  						if ( command.type.toLowerCase() === 'c' ) {

  							command.type = 'b';

  						}

  						token.o += command.type.toLowerCase() + ' ';

  						if ( command.x !== undefined && command.y !== undefined ) {

  							token.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' ';

  						}

  						if ( command.x1 !== undefined && command.y1 !== undefined ) {

  							token.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' ';

  						}

  						if ( command.x2 !== undefined && command.y2 !== undefined ) {

  							token.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' ';

  						}

  					} );

  					glyphs[ String.fromCharCode( glyph.unicode ) ] = token;

  				}

  			}

  			return {
  				glyphs: glyphs,
  				familyName: font.familyName,
  				ascender: round( font.ascender * scale ),
  				descender: round( font.descender * scale ),
  				underlinePosition: font.tables.post.underlinePosition,
  				underlineThickness: font.tables.post.underlineThickness,
  				boundingBox: {
  					xMin: font.tables.head.xMin,
  					xMax: font.tables.head.xMax,
  					yMin: font.tables.head.yMin,
  					yMax: font.tables.head.yMax
  				},
  				resolution: 1000,
  				original_font_information: font.tables.name
  			};

  		}

  		function reverseCommands( commands ) {

  			var paths = [];
  			var path;

  			commands.forEach( function ( c ) {

  				if ( c.type.toLowerCase() === 'm' ) {

  					path = [ c ];
  					paths.push( path );

  				} else if ( c.type.toLowerCase() !== 'z' ) {

  					path.push( c );

  				}

  			} );

  			var reversed = [];

  			paths.forEach( function ( p ) {

  				var result = {
  					type: 'm',
  					x: p[ p.length - 1 ].x,
  					y: p[ p.length - 1 ].y
  				};

  				reversed.push( result );

  				for ( var i = p.length - 1; i > 0; i -- ) {

  					var command = p[ i ];
  					var result = { type: command.type };

  					if ( command.x2 !== undefined && command.y2 !== undefined ) {

  						result.x1 = command.x2;
  						result.y1 = command.y2;
  						result.x2 = command.x1;
  						result.y2 = command.y1;

  					} else if ( command.x1 !== undefined && command.y1 !== undefined ) {

  						result.x1 = command.x1;
  						result.y1 = command.y1;

  					}

  					result.x = p[ i - 1 ].x;
  					result.y = p[ i - 1 ].y;
  					reversed.push( result );

  				}

  			} );

  			return reversed;

  		}

  		if ( typeof opentype === 'undefined' ) {

  			console.warn( 'TTFLoader: The loader requires opentype.js. Make sure it\'s included before using the loader.' );
  			return null;

  		}

  		return convert( opentype.parse( arraybuffer ), this.reversed );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VRMLLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  VRMLLoader.prototype = {

  	constructor: VRMLLoader,

  	// for IndexedFaceSet support
  	isRecordingPoints: false,
  	isRecordingFaces: false,
  	points: [],
  	indexes: [],

  	// for Background support
  	isRecordingAngles: false,
  	isRecordingColors: false,
  	angles: [],
  	colors: [],

  	recordingFieldname: null,

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( scope.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text, path ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResourcePath: function ( value ) {

  		this.resourcePath = value;
  		return this;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	parse: function ( data, path ) {

  		var scope = this;

  		var textureLoader = new TextureLoader( this.manager );
  		textureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

  		function parseV2( lines, scene ) {

  			var defines = {};
  			var float_pattern = /(\b|\-|\+)([\d\.e]+)/;
  			var float2_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;
  			var float3_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;
  			function paintFaces( geometry, radius, angles, colors, topDown ) {

  				var direction = ( topDown === true ) ? 1 : - 1;

  				var coord = [], A = {}, B = {}, applyColor = false;

  				for ( var k = 0; k < angles.length; k ++ ) {

  					// push the vector at which the color changes

  					var vec = {
  						x: direction * ( Math.cos( angles[ k ] ) * radius ),
  						y: direction * ( Math.sin( angles[ k ] ) * radius )
  					};

  					coord.push( vec );

  				}

  				var index = geometry.index;
  				var positionAttribute = geometry.attributes.position;
  				var colorAttribute = new BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );

  				var position = new Vector3();
  				var color = new Color();

  				for ( var i = 0; i < index.count; i ++ ) {

  					var vertexIndex = index.getX( i );

  					position.fromBufferAttribute( positionAttribute, vertexIndex );

  					for ( var j = 0; j < colors.length; j ++ ) {

  						// linear interpolation between aColor and bColor, calculate proportion
  						// A is previous point (angle)

  						if ( j === 0 ) {

  							A.x = 0;
  							A.y = ( topDown === true ) ? radius : - 1 * radius;

  						} else {

  							A.x = coord[ j - 1 ].x;
  							A.y = coord[ j - 1 ].y;

  						}

  						// B is current point (angle)

  						B = coord[ j ];

  						if ( B !== undefined ) {

  							// p has to be between the points A and B which we interpolate

  							applyColor = ( topDown === true ) ? ( position.y <= A.y && position.y > B.y ) : ( position.y >= A.y && position.y < B.y );

  							if ( applyColor === true ) {

  								var aColor = colors[ j ];
  								var bColor = colors[ j + 1 ];

  								// below is simple linear interpolation

  								var t = Math.abs( position.y - A.y ) / ( A.y - B.y );

  								// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y

  								color.copy( aColor ).lerp( bColor, t );

  								colorAttribute.setXYZ( vertexIndex, color.r, color.g, color.b );

  							} else {

  								var colorIndex = ( topDown === true ) ? colors.length - 1 : 0;
  								var c = colors[ colorIndex ];
  								colorAttribute.setXYZ( vertexIndex, c.r, c.g, c.b );

  							}

  						}

  					}

  				}

  				geometry.addAttribute( 'color', colorAttribute );

  			}

  			var index = [];

  			function parseProperty( node, line ) {

  				var parts = [], part, property = {}, fieldName;
  				var regex = /[^\s,\[\]]+/g;

  				var point;

  				while ( null !== ( part = regex.exec( line ) ) ) {

  					parts.push( part[ 0 ] );

  				}

  				fieldName = parts[ 0 ];
  				// trigger several recorders
  				switch ( fieldName ) {

  					case 'skyAngle':
  					case 'groundAngle':
  						scope.recordingFieldname = fieldName;
  						scope.isRecordingAngles = true;
  						scope.angles = [];
  						break;

  					case 'color':
  					case 'skyColor':
  					case 'groundColor':
  						scope.recordingFieldname = fieldName;
  						scope.isRecordingColors = true;
  						scope.colors = [];
  						break;

  					case 'point':
  					case 'vector':
  						scope.recordingFieldname = fieldName;
  						scope.isRecordingPoints = true;
  						scope.points = [];
  						break;

  					case 'colorIndex':
  					case 'coordIndex':
  					case 'normalIndex':
  					case 'texCoordIndex':
  						scope.recordingFieldname = fieldName;
  						scope.isRecordingFaces = true;
  						scope.indexes = [];
  						break;

  				}

  				if ( scope.isRecordingFaces ) {

  					// the parts hold the indexes as strings
  					if ( parts.length > 0 ) {

  						for ( var ind = 0; ind < parts.length; ind ++ ) {

  							// the part should either be positive integer or -1
  							if ( ! /(-?\d+)/.test( parts[ ind ] ) ) {

  								continue;

  							}

  							// end of current face
  							if ( parts[ ind ] === '-1' ) {

  								if ( index.length > 0 ) {

  									scope.indexes.push( index );

  								}

  								// start new one
  								index = [];

  							} else {

  								index.push( parseInt( parts[ ind ] ) );

  							}

  						}

  					}

  					// end
  					if ( /]/.exec( line ) ) {

  						if ( index.length > 0 ) {

  							scope.indexes.push( index );

  						}

  						// start new one
  						index = [];

  						scope.isRecordingFaces = false;
  						node[ scope.recordingFieldname ] = scope.indexes;

  					}

  				} else if ( scope.isRecordingPoints ) {

  					if ( node.nodeType == 'Coordinate' ) {

  						while ( null !== ( parts = float3_pattern.exec( line ) ) ) {

  							point = {
  								x: parseFloat( parts[ 1 ] ),
  								y: parseFloat( parts[ 2 ] ),
  								z: parseFloat( parts[ 3 ] )
  							};

  							scope.points.push( point );

  						}

  					}

  					if ( node.nodeType == 'Normal' ) {

    						while ( null !== ( parts = float3_pattern.exec( line ) ) ) {

  							point = {
  								x: parseFloat( parts[ 1 ] ),
  								y: parseFloat( parts[ 2 ] ),
  								z: parseFloat( parts[ 3 ] )
  							};

  							scope.points.push( point );

  						}

  					}

  					if ( node.nodeType == 'TextureCoordinate' ) {

  						while ( null !== ( parts = float2_pattern.exec( line ) ) ) {

  							point = {
  								x: parseFloat( parts[ 1 ] ),
  								y: parseFloat( parts[ 2 ] )
  							};

  							scope.points.push( point );

  						}

  					}

  					// end
  					if ( /]/.exec( line ) ) {

  						scope.isRecordingPoints = false;
  						node.points = scope.points;

  					}

  				} else if ( scope.isRecordingAngles ) {

  					// the parts hold the angles as strings
  					if ( parts.length > 0 ) {

  						for ( var ind = 0; ind < parts.length; ind ++ ) {

  							// the part should be a float
  							if ( ! float_pattern.test( parts[ ind ] ) ) {

  								continue;

  							}

  							scope.angles.push( parseFloat( parts[ ind ] ) );

  						}

  					}

  					// end
  					if ( /]/.exec( line ) ) {

  						scope.isRecordingAngles = false;
  						node[ scope.recordingFieldname ] = scope.angles;

  					}

  				} else if ( scope.isRecordingColors ) {

  					while ( null !== ( parts = float3_pattern.exec( line ) ) ) {

  						var color = {
  							r: parseFloat( parts[ 1 ] ),
  							g: parseFloat( parts[ 2 ] ),
  							b: parseFloat( parts[ 3 ] )
  						};

  						scope.colors.push( color );

  					}

  					// end
  					if ( /]/.exec( line ) ) {

  						scope.isRecordingColors = false;
  						node[ scope.recordingFieldname ] = scope.colors;

  					}

  				} else if ( parts[ parts.length - 1 ] !== 'NULL' && fieldName !== 'children' ) {

  					switch ( fieldName ) {

  						case 'diffuseColor':
  						case 'emissiveColor':
  						case 'specularColor':
  						case 'color':

  							if ( parts.length !== 4 ) {

  								console.warn( 'VRMLLoader: Invalid color format detected for %s.', fieldName );
  								break;

  							}

  							property = {
  								r: parseFloat( parts[ 1 ] ),
  								g: parseFloat( parts[ 2 ] ),
  								b: parseFloat( parts[ 3 ] )
  							};

  							break;

  						case 'location':
  						case 'direction':
  						case 'translation':
  						case 'scale':
  						case 'size':
  							if ( parts.length !== 4 ) {

  								console.warn( 'VRMLLoader: Invalid vector format detected for %s.', fieldName );
  								break;

  							}

  							property = {
  								x: parseFloat( parts[ 1 ] ),
  								y: parseFloat( parts[ 2 ] ),
  								z: parseFloat( parts[ 3 ] )
  							};

  							break;

  						case 'intensity':
  						case 'cutOffAngle':
  						case 'radius':
  						case 'topRadius':
  						case 'bottomRadius':
  						case 'height':
  						case 'transparency':
  						case 'shininess':
  						case 'ambientIntensity':
  						case 'creaseAngle':
  							if ( parts.length !== 2 ) {

  								console.warn( 'VRMLLoader: Invalid single float value specification detected for %s.', fieldName );
  								break;

  							}

  							property = parseFloat( parts[ 1 ] );

  							break;

  						case 'rotation':
  							if ( parts.length !== 5 ) {

  								console.warn( 'VRMLLoader: Invalid quaternion format detected for %s.', fieldName );
  								break;

  							}

  							property = {
  								x: parseFloat( parts[ 1 ] ),
  								y: parseFloat( parts[ 2 ] ),
  								z: parseFloat( parts[ 3 ] ),
  								w: parseFloat( parts[ 4 ] )
  							};

  							break;

  						case 'on':
  						case 'ccw':
  						case 'solid':
  						case 'colorPerVertex':
  						case 'convex':
  							if ( parts.length !== 2 ) {

  								console.warn( 'VRMLLoader: Invalid format detected for %s.', fieldName );
  								break;

  							}

  							property = parts[ 1 ] === 'TRUE' ? true : false;

  							break;

  					}

  					node[ fieldName ] = property;

  				}

  				return property;

  			}

  			function getTree( lines ) {

  				var tree = { 'string': 'Scene', children: [] };
  				var current = tree;
  				var matches;
  				var specification;

  				for ( var i = 0; i < lines.length; i ++ ) {

  					var comment = '';

  					var line = lines[ i ];

  					// omit whitespace only lines
  					if ( null !== ( /^\s+?$/g.exec( line ) ) ) {

  						continue;

  					}

  					line = line.trim();

  					// skip empty lines
  					if ( line === '' ) {

  						continue;

  					}

  					if ( /#/.exec( line ) ) {

  						var parts = line.split( '#' );

  						// discard everything after the #, it is a comment
  						line = parts[ 0 ];

  						// well, let's also keep the comment
  						comment = parts[ 1 ];

  					}

  					if ( matches = /([^\s]*){1}(?:\s+)?{/.exec( line ) ) {

  						// first subpattern should match the Node name

  						var block = { 'nodeType': matches[ 1 ], 'string': line, 'parent': current, 'children': [], 'comment': comment };
  						current.children.push( block );
  						current = block;

  						if ( /}/.exec( line ) ) {

  							// example: geometry Box { size 1 1 1 } # all on the same line
  							specification = /{(.*)}/.exec( line )[ 1 ];

  							// todo: remove once new parsing is complete?
  							block.children.push( specification );

  							parseProperty( current, specification );

  							current = current.parent;

  						}

  					} else if ( /}/.exec( line ) ) {

  						current = current.parent;

  					} else if ( line !== '' ) {

  						parseProperty( current, line );
  						// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way
  						current.children.push( line );

  					}

  				}

  				return tree;

  			}

  			function parseNode( data, parent ) {

  				var object;

  				if ( typeof data === 'string' ) {

  					if ( /USE/.exec( data ) ) {

  						var defineKey = /USE\s+?([^\s]+)/.exec( data )[ 1 ];

  						if ( undefined == defines[ defineKey ] ) {

  							console.warn( 'VRMLLoader: %s is not defined.', defineKey );

  						} else {

  							if ( /appearance/.exec( data ) && defineKey ) {

  								parent.material = defines[ defineKey ].clone();

  							} else if ( /geometry/.exec( data ) && defineKey ) {

  								parent.geometry = defines[ defineKey ].clone();

  								// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it
  								if ( defines[ defineKey ].solid !== undefined && defines[ defineKey ].solid === false ) {

  									parent.geometry.solid = false;
  									parent.material.side = DoubleSide;

  								}

  							} else if ( defineKey ) {

  								object = defines[ defineKey ].clone();
  								parent.add( object );

  							}

  						}

  					}

  					return;

  				}

  				object = parent;

  				if ( data.string.indexOf( 'AmbientLight' ) > - 1 && data.nodeType === 'PointLight' ) {

  					data.nodeType = 'AmbientLight';

  				}

  				var l_visible = data.on !== undefined ? data.on : true;
  				var l_intensity = data.intensity !== undefined ? data.intensity : 1;
  				var l_color = new Color();

  				if ( data.color ) {

  					l_color.copy( data.color );

  				}

  				if ( data.nodeType === 'AmbientLight' ) {

  					object = new AmbientLight( l_color, l_intensity );
  					object.visible = l_visible;

  					parent.add( object );

  				} else if ( data.nodeType === 'PointLight' ) {

  					var l_distance = 0;

  					if ( data.radius !== undefined && data.radius < 1000 ) {

  						l_distance = data.radius;

  					}

  					object = new PointLight( l_color, l_intensity, l_distance );
  					object.visible = l_visible;

  					parent.add( object );

  				} else if ( data.nodeType === 'SpotLight' ) {

  					var l_intensity = 1;
  					var l_distance = 0;
  					var l_angle = Math.PI / 3;
  					var l_penumbra = 0;
  					var l_visible = true;

  					if ( data.radius !== undefined && data.radius < 1000 ) {

  						l_distance = data.radius;

  					}

  					if ( data.cutOffAngle !== undefined ) {

  						l_angle = data.cutOffAngle;

  					}

  					object = new SpotLight( l_color, l_intensity, l_distance, l_angle, l_penumbra );
  					object.visible = l_visible;

  					parent.add( object );

  				} else if ( data.nodeType === 'Transform' || data.nodeType === 'Group' ) {

  					object = new Object3D();

  					if ( /DEF/.exec( data.string ) ) {

  						object.name = /DEF\s+([^\s]+)/.exec( data.string )[ 1 ];
  						defines[ object.name ] = object;

  					}

  					if ( data.translation !== undefined ) {

  						var t = data.translation;

  						object.position.set( t.x, t.y, t.z );

  					}

  					if ( data.rotation !== undefined ) {

  						var r = data.rotation;

  						object.quaternion.setFromAxisAngle( new Vector3( r.x, r.y, r.z ), r.w );

  					}

  					if ( data.scale !== undefined ) {

  						var s = data.scale;

  						object.scale.set( s.x, s.y, s.z );

  					}

  					parent.add( object );

  				} else if ( data.nodeType === 'Shape' ) {

  					object = new Mesh();

  					if ( /DEF/.exec( data.string ) ) {

  						object.name = /DEF\s+([^\s]+)/.exec( data.string )[ 1 ];

  						defines[ object.name ] = object;

  					}

  					parent.add( object );

  				} else if ( data.nodeType === 'Background' ) {

  					var segments = 20;

  					// sky (full sphere):

  					var radius = 2e4;

  					var skyGeometry = new SphereBufferGeometry( radius, segments, segments );
  					var skyMaterial = new MeshBasicMaterial( { fog: false, side: BackSide } );

  					if ( data.skyColor.length > 1 ) {

  						paintFaces( skyGeometry, radius, data.skyAngle, data.skyColor, true );

  						skyMaterial.vertexColors = VertexColors;

  					} else {

  						var color = data.skyColor[ 0 ];
  						skyMaterial.color.setRGB( color.r, color.b, color.g );

  					}

  					scene.add( new Mesh( skyGeometry, skyMaterial ) );

  					// ground (half sphere):

  					if ( data.groundColor !== undefined ) {

  						radius = 1.2e4;

  						var groundGeometry = new SphereBufferGeometry( radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );
  						var groundMaterial = new MeshBasicMaterial( { fog: false, side: BackSide, vertexColors: VertexColors } );

  						paintFaces( groundGeometry, radius, data.groundAngle, data.groundColor, false );

  						scene.add( new Mesh( groundGeometry, groundMaterial ) );

  					}

  				} else if ( /geometry/.exec( data.string ) ) {

  					if ( data.nodeType === 'Box' ) {

  						var s = data.size;

  						parent.geometry = new BoxBufferGeometry( s.x, s.y, s.z );

  					} else if ( data.nodeType === 'Cylinder' ) {

  						parent.geometry = new CylinderBufferGeometry( data.radius, data.radius, data.height );

  					} else if ( data.nodeType === 'Cone' ) {

  						parent.geometry = new CylinderBufferGeometry( data.topRadius, data.bottomRadius, data.height );

  					} else if ( data.nodeType === 'Sphere' ) {

  						parent.geometry = new SphereBufferGeometry( data.radius );

  					} else if ( data.nodeType === 'IndexedFaceSet' ) {

  						var geometry = new BufferGeometry();

  						var positions = [];
  						var colors = [];
  						var normals = [];
  						var uvs = [];

  						var position, color, normal, uv;

  						var i, il, j, jl;

  						for ( i = 0, il = data.children.length; i < il; i ++ ) {

  							var child = data.children[ i ];

  							// uvs

  							if ( child.nodeType === 'TextureCoordinate' ) {

  								if ( child.points ) {

  									for ( j = 0, jl = child.points.length; j < jl; j ++ ) {

  										uv = child.points[ j ];
  										uvs.push( uv.x, uv.y );

  									}

  								}

  							}

  							// normals

  							if ( child.nodeType === 'Normal' ) {

  								if ( child.points ) {

  									for ( j = 0, jl = child.points.length; j < jl; j ++ ) {

  										normal = child.points[ j ];
  										normals.push( normal.x, normal.y, normal.z );

  									}

  								}

  							}

  							// colors

  							if ( child.nodeType === 'Color' ) {

  								if ( child.color ) {

  									for ( j = 0, jl = child.color.length; j < jl; j ++ ) {

  										color = child.color[ j ];
  										colors.push( color.r, color.g, color.b );

  									}

  								}

  							}

  							// positions

  							if ( child.nodeType === 'Coordinate' ) {

  								if ( child.points ) {

  									for ( j = 0, jl = child.points.length; j < jl; j ++ ) {

  										position = child.points[ j ];
  										positions.push( position.x, position.y, position.z );

  									}

  								}

  								if ( child.string.indexOf( 'DEF' ) > - 1 ) {

  									var name = /DEF\s+([^\s]+)/.exec( child.string )[ 1 ];

  									defines[ name ] = positions.slice( 0 );

  								}

  								if ( child.string.indexOf( 'USE' ) > - 1 ) {

  									var defineKey = /USE\s+([^\s]+)/.exec( child.string )[ 1 ];

  									positions = defines[ defineKey ];

  								}

  							}

  						}

  						// some shapes only have vertices for use in other shapes

  						if ( data.coordIndex ) {

  							function triangulateIndexArray( indexArray, ccw, colorPerVertex ) {

  								if ( ccw === undefined ) {

  									// ccw is true by default
  									ccw = true;

  								}

  								var triangulatedIndexArray = [];
  								var skip = 0;

  								for ( i = 0, il = indexArray.length; i < il; i ++ ) {

  									if ( colorPerVertex === false ) {

  										var colorIndices = indexArray[ i ];

  										for ( j = 0, jl = colorIndices.length; j < jl; j ++ ) {

  											var index = colorIndices[ j ];

  											triangulatedIndexArray.push( index, index, index );

  										}

  									} else {

  										var indexedFace = indexArray[ i ];

  										// VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here

  										skip = 0;

  										while ( indexedFace.length >= 3 && skip < ( indexedFace.length - 2 ) ) {

  											var i1 = indexedFace[ 0 ];
  											var i2 = indexedFace[ skip + ( ccw ? 1 : 2 ) ];
  											var i3 = indexedFace[ skip + ( ccw ? 2 : 1 ) ];

  											triangulatedIndexArray.push( i1, i2, i3 );

  											skip ++;

  										}

  									}

  								}

  								return triangulatedIndexArray;

  							}

  							var positionIndexes = data.coordIndex ? triangulateIndexArray( data.coordIndex, data.ccw ) : [];
  							var normalIndexes = data.normalIndex ? triangulateIndexArray( data.normalIndex, data.ccw ) : positionIndexes;
  							var colorIndexes = data.colorIndex ? triangulateIndexArray( data.colorIndex, data.ccw, data.colorPerVertex ) : [];
  							var uvIndexes = data.texCoordIndex ? triangulateIndexArray( data.texCoordIndex, data.ccw ) : positionIndexes;

  							var newIndexes = [];
  							var newPositions = [];
  							var newNormals = [];
  							var newColors = [];
  							var newUvs = [];

  							// if any other index array does not match the coordinate indexes, split any points that differ

  							var pointMap = Object.create( null );

  							for ( i = 0; i < positionIndexes.length; i ++ ) {

  								var pointAttributes = [];

  								var positionIndex = positionIndexes[ i ];
  								var normalIndex = normalIndexes[ i ];
  								var colorIndex = colorIndexes[ i ];
  								var uvIndex = uvIndexes[ i ];

  								var base = 10; // which base to use to represent each value

  								pointAttributes.push( positionIndex.toString( base ) );

  								if ( normalIndex !== undefined ) {

  									pointAttributes.push( normalIndex.toString( base ) );

  								}

  								if ( colorIndex !== undefined ) {

  									pointAttributes.push( colorIndex.toString( base ) );

  								}

  								if ( uvIndex !== undefined ) {

  									pointAttributes.push( uvIndex.toString( base ) );

  								}

  								var pointId = pointAttributes.join( ',' );
  								var newIndex = pointMap[ pointId ];

  								if ( newIndex === undefined ) {

  									newIndex = newPositions.length / 3;
  									pointMap[ pointId ] = newIndex;

  									newPositions.push(
  										positions[ positionIndex * 3 ],
  										positions[ positionIndex * 3 + 1 ],
  										positions[ positionIndex * 3 + 2 ]
  									);

  									if ( normalIndex !== undefined && normals.length > 0 ) {

  										newNormals.push(
  											normals[ normalIndex * 3 ],
  											normals[ normalIndex * 3 + 1 ],
  											normals[ normalIndex * 3 + 2 ]
  										);

  									}

  									if ( colorIndex !== undefined && colors.length > 0 ) {

  										newColors.push(
  											colors[ colorIndex * 3 ],
  											colors[ colorIndex * 3 + 1 ],
  											colors[ colorIndex * 3 + 2 ]
  										);

  									}

  									if ( uvIndex !== undefined && uvs.length > 0 ) {

  										newUvs.push(
  											uvs[ uvIndex * 2 ],
  											uvs[ uvIndex * 2 + 1 ]
  										);

  									}

  								}

  								newIndexes.push( newIndex );

  							}

  							positions = newPositions;
  							normals = newNormals;
  							colors = newColors;
  							uvs = newUvs;

  							geometry.setIndex( newIndexes );

  						} else {

  							// do not add dummy mesh to the scene

  							parent.parent.remove( parent );

  						}

  						if ( false === data.solid ) {

  							parent.material.side = DoubleSide;

  						}

  						// we need to store it on the geometry for use with defines
  						geometry.solid = data.solid;

  						geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  						if ( colors.length > 0 ) {

  							geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  							parent.material.vertexColors = VertexColors;

  						}

  						if ( uvs.length > 0 ) {

  							geometry.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  						}

  						if ( normals.length > 0 ) {

  							geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  						} else {

  							// convert geometry to non-indexed to get sharp normals
  							geometry = geometry.toNonIndexed();
  							geometry.computeVertexNormals();

  						}

  						geometry.computeBoundingSphere();

  						// see if it's a define
  						if ( /DEF/.exec( data.string ) ) {

  							geometry.name = /DEF ([^\s]+)/.exec( data.string )[ 1 ];
  							defines[ geometry.name ] = geometry;

  						}

  						parent.geometry = geometry;

  					}

  					return;

  				} else if ( /appearance/.exec( data.string ) ) {

  					for ( var i = 0; i < data.children.length; i ++ ) {

  						var child = data.children[ i ];

  						if ( child.nodeType === 'Material' ) {

  							var material = new MeshPhongMaterial();

  							if ( child.diffuseColor !== undefined ) {

  								var d = child.diffuseColor;

  								material.color.setRGB( d.r, d.g, d.b );

  							}

  							if ( child.emissiveColor !== undefined ) {

  								var e = child.emissiveColor;

  								material.emissive.setRGB( e.r, e.g, e.b );

  							}

  							if ( child.specularColor !== undefined ) {

  								var s = child.specularColor;

  								material.specular.setRGB( s.r, s.g, s.b );

  							}

  							if ( child.transparency !== undefined ) {

  								var t = child.transparency;

  								// transparency is opposite of opacity
  								material.opacity = Math.abs( 1 - t );

  								material.transparent = true;

  							}

  							if ( /DEF/.exec( data.string ) ) {

  								material.name = /DEF ([^\s]+)/.exec( data.string )[ 1 ];

  								defines[ material.name ] = material;

  							}

  							parent.material = material;

  						}

  						if ( child.nodeType === 'ImageTexture' ) {

  							var textureName = /"([^"]+)"/.exec( child.children[ 0 ] );

  							if ( textureName ) {

  								parent.material.name = textureName[ 1 ];

  								parent.material.map = textureLoader.load( textureName[ 1 ] );

  							}

  						}

  					}

  					return;

  				}

  				for ( var i = 0, l = data.children.length; i < l; i ++ ) {

  					parseNode( data.children[ i ], object );

  				}

  			}

  			parseNode( getTree( lines ), scene );

  		}

  		var scene = new Scene();

  		var lines = data.split( '\n' );

  		// some lines do not have breaks

  		for ( var i = lines.length - 1; i > - 1; i -- ) {

  			var line = lines[ i ];

  			// The # symbol indicates that all subsequent text, until the end of the line is a comment,
  			// and should be ignored. (see http://gun.teipir.gr/VRML-amgem/spec/part1/grammar.html)
  			line = line.replace( /(#.*)/, '' );

  			// split lines with {..{ or {..[ - some have both
  			if ( /{.*[{\[]/.test( line ) ) {

  				var parts = line.split( '{' ).join( '{\n' ).split( '\n' );
  				parts.unshift( 1 );
  				parts.unshift( i );
  				lines.splice.apply( lines, parts );

  			} else if ( /\].*}/.test( line ) ) {

  				// split lines with ]..}
  				var parts = line.split( ']' ).join( ']\n' ).split( '\n' );
  				parts.unshift( 1 );
  				parts.unshift( i );
  				lines.splice.apply( lines, parts );

  			}

  			if ( /}.*}/.test( line ) ) {

  				// split lines with }..}
  				var parts = line.split( '}' ).join( '}\n' ).split( '\n' );
  				parts.unshift( 1 );
  				parts.unshift( i );
  				lines.splice.apply( lines, parts );

  			}

  			if ( /^\b[^\s]+\b$/.test( line.trim() ) ) {

  				// prevent lines with single words like "coord" or "geometry", see #12209
  				lines[ i + 1 ] = line + ' ' + lines[ i + 1 ].trim();
  				lines.splice( i, 1 );

  			} else if ( ( line.indexOf( 'coord' ) > - 1 ) && ( line.indexOf( '[' ) < 0 ) && ( line.indexOf( '{' ) < 0 ) ) {

  				// force the parser to create Coordinate node for empty coords
  				// coord USE something -> coord USE something Coordinate {}

  				lines[ i ] += ' Coordinate {}';

  			}

  		}

  		var header = lines.shift();

  		if ( /V1.0/.exec( header ) ) {

  			console.warn( 'VRMLLoader: V1.0 not supported yet.' );

  		} else if ( /V2.0/.exec( header ) ) {

  			parseV2( lines, scene );

  		}

  		return scene;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // VRM Specification: https://dwango.github.io/vrm/vrm_spec/
  //
  // VRM is based on glTF 2.0 and VRM extension is defined
  // in top-level json.extensions.VRM

  var VRMLoader = ( function () {

  	function VRMLoader( manager ) {

  		if ( GLTFLoader === undefined ) {

  			throw new Error( 'VRMLoader: Import GLTFLoader.' );

  		}

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  		this.gltfLoader = new GLTFLoader( this.manager );

  	}

  	VRMLoader.prototype = {

  		constructor: VRMLoader,

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			this.gltfLoader.load( url, function ( gltf ) {

  				scope.parse( gltf, onLoad );

  			}, onProgress, onError );

  		},

  		setCrossOrigin: function ( value ) {

  			this.glTFLoader.setCrossOrigin( value );
  			return this;

  		},

  		setPath: function ( value ) {

  			this.glTFLoader.setPath( value );
  			return this;

  		},

  		setResourcePath: function ( value ) {

  			this.glTFLoader.setResourcePath( value );
  			return this;

  		},

  		setDRACOLoader: function ( dracoLoader ) {

  			this.glTFLoader.setDRACOLoader( dracoLoader );
  			return this;

  		},

  		parse: function ( gltf, onLoad ) {

  			var gltfParser = gltf.parser;
  			var gltfExtensions = gltf.userData.gltfExtensions || {};
  			var vrmExtension = gltfExtensions.VRM || {};

  			// handle VRM Extension here

  			onLoad( gltf );

  		}

  	};

  	return VRMLoader;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VTKLoader = function ( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  };

  Object.assign( VTKLoader.prototype, EventDispatcher.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( text ) );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	parse: function ( data ) {

  		function parseASCII( data ) {

  			// connectivity of the triangles
  			var indices = [];

  			// triangles vertices
  			var positions = [];

  			// red, green, blue colors in the range 0 to 1
  			var colors = [];

  			// normal vector, one per vertex
  			var normals = [];

  			var result;

  			// pattern for reading vertices, 3 floats or integers
  			var pat3Floats = /(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g;

  			// pattern for connectivity, an integer followed by any number of ints
  			// the first integer is the number of polygon nodes
  			var patConnectivity = /^(\d+)\s+([\s\d]*)/;

  			// indicates start of vertex data section
  			var patPOINTS = /^POINTS /;

  			// indicates start of polygon connectivity section
  			var patPOLYGONS = /^POLYGONS /;

  			// indicates start of triangle strips section
  			var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;

  			// POINT_DATA number_of_values
  			var patPOINT_DATA = /^POINT_DATA[ ]+(\d+)/;

  			// CELL_DATA number_of_polys
  			var patCELL_DATA = /^CELL_DATA[ ]+(\d+)/;

  			// Start of color section
  			var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\w+)[ ]+3/;

  			// NORMALS Normals float
  			var patNORMALS = /^NORMALS[ ]+(\w+)[ ]+(\w+)/;

  			var inPointsSection = false;
  			var inPolygonsSection = false;
  			var inTriangleStripSection = false;
  			var inPointDataSection = false;
  			var inCellDataSection = false;
  			var inColorSection = false;
  			var inNormalsSection = false;

  			var lines = data.split( '\n' );

  			for ( var i in lines ) {

  				var line = lines[ i ];

  				if ( inPointsSection ) {

  					// get the vertices
  					while ( ( result = pat3Floats.exec( line ) ) !== null ) {

  						var x = parseFloat( result[ 1 ] );
  						var y = parseFloat( result[ 2 ] );
  						var z = parseFloat( result[ 3 ] );
  						positions.push( x, y, z );

  					}

  				} else if ( inPolygonsSection ) {

  					if ( ( result = patConnectivity.exec( line ) ) !== null ) {

  						// numVertices i0 i1 i2 ...
  						var numVertices = parseInt( result[ 1 ] );
  						var inds = result[ 2 ].split( /\s+/ );

  						if ( numVertices >= 3 ) {

  							var i0 = parseInt( inds[ 0 ] );
  							var i1, i2;
  							var k = 1;
  							// split the polygon in numVertices - 2 triangles
  							for ( var j = 0; j < numVertices - 2; ++ j ) {

  								i1 = parseInt( inds[ k ] );
  								i2 = parseInt( inds[ k + 1 ] );
  								indices.push( i0, i1, i2 );
  								k ++;

  							}

  						}

  					}

  				} else if ( inTriangleStripSection ) {

  					if ( ( result = patConnectivity.exec( line ) ) !== null ) {

  						// numVertices i0 i1 i2 ...
  						var numVertices = parseInt( result[ 1 ] );
  						var inds = result[ 2 ].split( /\s+/ );

  						if ( numVertices >= 3 ) {

  							var i0, i1, i2;
  							// split the polygon in numVertices - 2 triangles
  							for ( var j = 0; j < numVertices - 2; j ++ ) {

  								if ( j % 2 === 1 ) {

  									i0 = parseInt( inds[ j ] );
  									i1 = parseInt( inds[ j + 2 ] );
  									i2 = parseInt( inds[ j + 1 ] );
  									indices.push( i0, i1, i2 );

  								} else {

  									i0 = parseInt( inds[ j ] );
  									i1 = parseInt( inds[ j + 1 ] );
  									i2 = parseInt( inds[ j + 2 ] );
  									indices.push( i0, i1, i2 );

  								}

  							}

  						}

  					}

  				} else if ( inPointDataSection || inCellDataSection ) {

  					if ( inColorSection ) {

  						// Get the colors

  						while ( ( result = pat3Floats.exec( line ) ) !== null ) {

  							var r = parseFloat( result[ 1 ] );
  							var g = parseFloat( result[ 2 ] );
  							var b = parseFloat( result[ 3 ] );
  							colors.push( r, g, b );

  						}

  					} else if ( inNormalsSection ) {

  						// Get the normal vectors

  						while ( ( result = pat3Floats.exec( line ) ) !== null ) {

  							var nx = parseFloat( result[ 1 ] );
  							var ny = parseFloat( result[ 2 ] );
  							var nz = parseFloat( result[ 3 ] );
  							normals.push( nx, ny, nz );

  						}

  					}

  				}

  				if ( patPOLYGONS.exec( line ) !== null ) {

  					inPolygonsSection = true;
  					inPointsSection = false;
  					inTriangleStripSection = false;

  				} else if ( patPOINTS.exec( line ) !== null ) {

  					inPolygonsSection = false;
  					inPointsSection = true;
  					inTriangleStripSection = false;

  				} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {

  					inPolygonsSection = false;
  					inPointsSection = false;
  					inTriangleStripSection = true;

  				} else if ( patPOINT_DATA.exec( line ) !== null ) {

  					inPointDataSection = true;
  					inPointsSection = false;
  					inPolygonsSection = false;
  					inTriangleStripSection = false;

  				} else if ( patCELL_DATA.exec( line ) !== null ) {

  					inCellDataSection = true;
  					inPointsSection = false;
  					inPolygonsSection = false;
  					inTriangleStripSection = false;

  				} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {

  					inColorSection = true;
  					inNormalsSection = false;
  					inPointsSection = false;
  					inPolygonsSection = false;
  					inTriangleStripSection = false;

  				} else if ( patNORMALS.exec( line ) !== null ) {

  					inNormalsSection = true;
  					inColorSection = false;
  					inPointsSection = false;
  					inPolygonsSection = false;
  					inTriangleStripSection = false;

  				}

  			}

  			var geometry = new BufferGeometry();
  			geometry.setIndex( indices );
  			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  			if ( normals.length === positions.length ) {

  				geometry.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

  			}

  			if ( colors.length !== indices.length ) {

  				// stagger

  				if ( colors.length === positions.length ) {

  					geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  				}

  			} else {

  				// cell

  				geometry = geometry.toNonIndexed();
  				var numTriangles = geometry.attributes.position.count / 3;

  				if ( colors.length === ( numTriangles * 3 ) ) {

  					var newColors = [];

  					for ( var i = 0; i < numTriangles; i ++ ) {

  						var r = colors[ 3 * i + 0 ];
  						var g = colors[ 3 * i + 1 ];
  						var b = colors[ 3 * i + 2 ];

  						newColors.push( r, g, b );
  						newColors.push( r, g, b );
  						newColors.push( r, g, b );

  					}

  					geometry.addAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );

  				}

  			}

  			return geometry;

  		}

  		function parseBinary( data ) {

  			var count, pointIndex, i, numberOfPoints, s;
  			var buffer = new Uint8Array( data );
  			var dataView = new DataView( data );

  			// Points and normals, by default, are empty
  			var points = [];
  			var normals = [];
  			var indices = [];
  			var index = 0;

  			function findString( buffer, start ) {

  				var index = start;
  				var c = buffer[ index ];
  				var s = [];
  				while ( c !== 10 ) {

  					s.push( String.fromCharCode( c ) );
  					index ++;
  					c = buffer[ index ];

  				}

  				return { start: start,
  					end: index,
  					next: index + 1,
  					parsedString: s.join( '' ) };

  			}

  			var state, line;

  			while ( true ) {

  				// Get a string
  				state = findString( buffer, index );
  				line = state.parsedString;

  				if ( line.indexOf( 'POINTS' ) === 0 ) {
  					// Add the points
  					numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );

  					// Each point is 3 4-byte floats
  					count = numberOfPoints * 4 * 3;

  					points = new Float32Array( numberOfPoints * 3 );

  					pointIndex = state.next;
  					for ( i = 0; i < numberOfPoints; i ++ ) {

  						points[ 3 * i ] = dataView.getFloat32( pointIndex, false );
  						points[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );
  						points[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );
  						pointIndex = pointIndex + 12;

  					}
  					// increment our next pointer
  					state.next = state.next + count + 1;

  				} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {

  					var numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );
  					var size = parseInt( line.split( ' ' )[ 2 ], 10 );
  					// 4 byte integers
  					count = size * 4;

  					indices = new Uint32Array( 3 * size - 9 * numberOfStrips );
  					var indicesIndex = 0;

  					pointIndex = state.next;
  					for ( i = 0; i < numberOfStrips; i ++ ) {

  						// For each strip, read the first value, then record that many more points
  						var indexCount = dataView.getInt32( pointIndex, false );
  						var strip = [];
  						pointIndex += 4;
  						for ( s = 0; s < indexCount; s ++ ) {

  							strip.push( dataView.getInt32( pointIndex, false ) );
  							pointIndex += 4;

  						}

  						// retrieves the n-2 triangles from the triangle strip
  						for ( var j = 0; j < indexCount - 2; j ++ ) {

  							if ( j % 2 ) {

  								indices[ indicesIndex ++ ] = strip[ j ];
  								indices[ indicesIndex ++ ] = strip[ j + 2 ];
  								indices[ indicesIndex ++ ] = strip[ j + 1 ];

  							} else {
  								indices[ indicesIndex ++ ] = strip[ j ];
  								indices[ indicesIndex ++ ] = strip[ j + 1 ];
  								indices[ indicesIndex ++ ] = strip[ j + 2 ];

  							}

  						}

  					}
  					// increment our next pointer
  					state.next = state.next + count + 1;

  				} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {

  					var numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );
  					var size = parseInt( line.split( ' ' )[ 2 ], 10 );
  					// 4 byte integers
  					count = size * 4;

  					indices = new Uint32Array( 3 * size - 9 * numberOfStrips );
  					var indicesIndex = 0;

  					pointIndex = state.next;
  					for ( i = 0; i < numberOfStrips; i ++ ) {

  						// For each strip, read the first value, then record that many more points
  						var indexCount = dataView.getInt32( pointIndex, false );
  						var strip = [];
  						pointIndex += 4;
  						for ( s = 0; s < indexCount; s ++ ) {

  							strip.push( dataView.getInt32( pointIndex, false ) );
  							pointIndex += 4;

  						}

  						// divide the polygon in n-2 triangle
  						for ( var j = 1; j < indexCount - 1; j ++ ) {

  							indices[ indicesIndex ++ ] = strip[ 0 ];
  							indices[ indicesIndex ++ ] = strip[ j ];
  							indices[ indicesIndex ++ ] = strip[ j + 1 ];

  						}

  					}
  					// increment our next pointer
  					state.next = state.next + count + 1;

  				} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {

  					numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );

  					// Grab the next line
  					state = findString( buffer, state.next );

  					// Now grab the binary data
  					count = numberOfPoints * 4 * 3;

  					normals = new Float32Array( numberOfPoints * 3 );
  					pointIndex = state.next;
  					for ( i = 0; i < numberOfPoints; i ++ ) {

  						normals[ 3 * i ] = dataView.getFloat32( pointIndex, false );
  						normals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );
  						normals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );
  						pointIndex += 12;

  					}

  					// Increment past our data
  					state.next = state.next + count;

  				}

  				// Increment index
  				index = state.next;

  				if ( index >= buffer.byteLength ) {

  					break;

  				}

  			}

  			var geometry = new BufferGeometry();
  			geometry.setIndex( new BufferAttribute( indices, 1 ) );
  			geometry.addAttribute( 'position', new BufferAttribute( points, 3 ) );

  			if ( normals.length === points.length ) {

  				geometry.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );

  			}

  			return geometry;

  		}

  		function Float32Concat( first, second ) {

  		    var firstLength = first.length, result = new Float32Array( firstLength + second.length );

  		    result.set( first );
  		    result.set( second, firstLength );

  		    return result;

  		}

  		function Int32Concat( first, second ) {

  		    var firstLength = first.length, result = new Int32Array( firstLength + second.length );

  		    result.set( first );
  		    result.set( second, firstLength );

  		    return result;

  		}

  		function parseXML( stringFile ) {

  			// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json

  			function xmlToJson( xml ) {

  				// Create the return object
  				var obj = {};

  				if ( xml.nodeType === 1 ) { // element

  					// do attributes

  					if ( xml.attributes ) {

  						if ( xml.attributes.length > 0 ) {

  							obj[ 'attributes' ] = {};

  							for ( var j = 0; j < xml.attributes.length; j ++ ) {

  								var attribute = xml.attributes.item( j );
  								obj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();

  							}

  						}

  					}

  				} else if ( xml.nodeType === 3 ) { // text

  					obj = xml.nodeValue.trim();

  				}

  				// do children
  				if ( xml.hasChildNodes() ) {

  					for ( var i = 0; i < xml.childNodes.length; i ++ ) {

  						var item = xml.childNodes.item( i );
  						var nodeName = item.nodeName;

  						if ( typeof obj[ nodeName ] === 'undefined' ) {

  							var tmp = xmlToJson( item );

  							if ( tmp !== '' ) { obj[ nodeName ] = tmp; }

  						} else {

  							if ( typeof obj[ nodeName ].push === 'undefined' ) {

  								var old = obj[ nodeName ];
  								obj[ nodeName ] = [ old ];

  							}

  							var tmp = xmlToJson( item );

  							if ( tmp !== '' ) { obj[ nodeName ].push( tmp ); }

  						}

  					}

  				}

  				return obj;

  			}

  			// Taken from Base64-js
  			function Base64toByteArray( b64 ) {

  				var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  				var i;
  				var lookup = [];
  				var revLookup = [];
  				var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  				var len = code.length;

  				for ( i = 0; i < len; i ++ ) {

  					lookup[ i ] = code[ i ];

  				}

  				for ( i = 0; i < len; ++ i ) {

  					revLookup[ code.charCodeAt( i ) ] = i;

  				}

  				revLookup[ '-'.charCodeAt( 0 ) ] = 62;
  				revLookup[ '_'.charCodeAt( 0 ) ] = 63;

  				var j, l, tmp, placeHolders, arr;
  				var len = b64.length;

  				if ( len % 4 > 0 ) {

  					throw new Error( 'Invalid string. Length must be a multiple of 4' );

  				}

  				placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;
  				arr = new Arr( len * 3 / 4 - placeHolders );
  				l = placeHolders > 0 ? len - 4 : len;

  				var L = 0;

  				for ( i = 0, j = 0; i < l; i += 4, j += 3 ) {

  					tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];
  					arr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;
  					arr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;
  					arr[ L ++ ] = tmp & 0xFF;

  				}

  				if ( placeHolders === 2 ) {

  					tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );
  					arr[ L ++ ] = tmp & 0xFF;

  				} else if ( placeHolders === 1 ) {

  					tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );
  					arr[ L ++ ] = ( tmp >> 8 ) & 0xFF;
  					arr[ L ++ ] = tmp & 0xFF;

  				}

  				return arr;

  			}

  			function parseDataArray( ele, compressed ) {

  				var numBytes = 0;

  				if ( json.attributes.header_type === 'UInt64' ) {

  					numBytes = 8;

  				}	else if ( json.attributes.header_type === 'UInt32' ) {

  					numBytes = 4;

  				}
  				// Check the format
  				if ( ele.attributes.format === 'binary' && compressed ) {

  					var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;

  					if ( ele.attributes.type === 'Float32' ) {

  						var txt = new Float32Array( );

  					} else if ( ele.attributes.type === 'Int64' ) {

  						var txt = new Int32Array( );

  					}

  					// VTP data with the header has the following structure:
  					// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]
  					//
  					// Each token is an integer value whose type is specified by "header_type" at the top of the file (UInt32 if no type specified). The token meanings are:
  					// [#blocks] = Number of blocks
  					// [#u-size] = Block size before compression
  					// [#p-size] = Size of last partial block (zero if it not needed)
  					// [#c-size-i] = Size in bytes of block i after compression
  					//
  					// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is
  					// computed by summing the compressed block sizes from preceding blocks according to the header.

  					rawData = ele[ '#text' ];

  					byteData = Base64toByteArray( rawData );

  					blocks = byteData[ 0 ];
  					for ( var i = 1; i < numBytes - 1; i ++ ) {

  						blocks = blocks | ( byteData[ i ] << ( i * numBytes ) );

  					}

  					headerSize = ( blocks + 3 ) * numBytes;
  					padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;
  					headerSize = headerSize + padding;

  					dataOffsets = [];
  					currentOffset = headerSize;
  					dataOffsets.push( currentOffset );

  					// Get the blocks sizes after the compression.
  					// There are three blocks before c-size-i, so we skip 3*numBytes
  					cSizeStart = 3 * numBytes;

  					for ( var i = 0; i < blocks; i ++ ) {

  						var currentBlockSize = byteData[ i * numBytes + cSizeStart ];

  						for ( var j = 1; j < numBytes - 1; j ++ ) {

  							// Each data point consists of 8 bytes regardless of the header type
  							currentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );

  						}

  						currentOffset = currentOffset + currentBlockSize;
  						dataOffsets.push( currentOffset );

  					}

  					for ( var i = 0; i < dataOffsets.length - 1; i ++ ) {

  						var inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef
  						content = inflate.decompress();
  						content = content.buffer;

  						if ( ele.attributes.type === 'Float32' ) {

  							content = new Float32Array( content );
  							txt = Float32Concat( txt, content );

  						} else if ( ele.attributes.type === 'Int64' ) {

  							content = new Int32Array( content );
  							txt = Int32Concat( txt, content );

  						}

  					}

  					delete ele[ '#text' ];

  					if ( ele.attributes.type === 'Int64' ) {

  						if ( ele.attributes.format === 'binary' ) {

  							txt = txt.filter( function ( el, idx ) {

  								if ( idx % 2 !== 1 ) { return true; }

  							} );

  						}

  					}

  				} else {

  					if ( ele.attributes.format === 'binary' && ! compressed ) {

  						var content = Base64toByteArray( ele[ '#text' ] );

  						//  VTP data for the uncompressed case has the following structure:
  						// [#bytes][DATA]
  						// where "[#bytes]" is an integer value specifying the number of bytes in the block of data following it.
  						content = content.slice( numBytes ).buffer;

  					} else {

  						if ( ele[ '#text' ] ) {

  							var content = ele[ '#text' ].split( /\s+/ ).filter( function ( el ) {

  								if ( el !== '' ) { return el; }

  							} );

  						} else {

  							var content = new Int32Array( 0 ).buffer;

  						}

  					}

  					delete ele[ '#text' ];

  					// Get the content and optimize it
  					if ( ele.attributes.type === 'Float32' ) {

  						var txt = new Float32Array( content );

  					} else if ( ele.attributes.type === 'Int32' ) {

  						var txt = new Int32Array( content );

  					} else if ( ele.attributes.type === 'Int64' ) {

  						var txt = new Int32Array( content );

  						if ( ele.attributes.format === 'binary' ) {

  							txt = txt.filter( function ( el, idx ) {

  								if ( idx % 2 !== 1 ) { return true; }

  							} );

  						}

  					}

  				} // endif ( ele.attributes.format === 'binary' && compressed )

  				return txt;

  			}

  			// Main part
  			// Get Dom
  			var dom = null;

  			if ( window.DOMParser ) {

  				try {

  					dom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );

  				} catch ( e ) {

  					dom = null;

  				}

  			} else if ( window.ActiveXObject ) {

  				try {

  					dom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef
  					dom.async = false;

  					if ( ! dom.loadXML(  ) ) {

  						throw new Error( dom.parseError.reason + dom.parseError.srcText );

  					}

  				} catch ( e ) {

  					dom = null;

  				}

  			} else {

  				throw new Error( 'Cannot parse xml string!' );

  			}

  			// Get the doc
  			var doc = dom.documentElement;
  			// Convert to json
  			var json = xmlToJson( doc );
  			var points = [];
  			var normals = [];
  			var indices = [];

  			if ( json.PolyData ) {

  				var piece = json.PolyData.Piece;
  				var compressed = json.attributes.hasOwnProperty( 'compressor' );

  				// Can be optimized
  				// Loop through the sections
  				var sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];
  				var sectionIndex = 0, numberOfSections = sections.length;

  				while ( sectionIndex < numberOfSections ) {

  					var section = piece[ sections[ sectionIndex ] ];

  					// If it has a DataArray in it

  					if ( section && section.DataArray ) {

  						// Depending on the number of DataArrays

  						if ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {

  							var arr = section.DataArray;

  						} else {

  							var arr = [ section.DataArray ];

  						}

  						var dataArrayIndex = 0, numberOfDataArrays = arr.length;

  						while ( dataArrayIndex < numberOfDataArrays ) {

  							// Parse the DataArray
  							if ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {

  								arr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );

  							}

  							dataArrayIndex ++;

  						}

  						switch ( sections[ sectionIndex ] ) {

  							// if iti is point data
  							case 'PointData':

  								var numberOfPoints = parseInt( piece.attributes.NumberOfPoints );
  								var normalsName = section.attributes.Normals;

  								if ( numberOfPoints > 0 ) {

  									for ( var i = 0, len = arr.length; i < len; i ++ ) {

  										if ( normalsName === arr[ i ].attributes.Name ) {

  											var components = arr[ i ].attributes.NumberOfComponents;
  											normals = new Float32Array( numberOfPoints * components );
  											normals.set( arr[ i ].text, 0 );

  										}

  									}

  								}

  								break;

  							// if it is points
  							case 'Points':

  								var numberOfPoints = parseInt( piece.attributes.NumberOfPoints );

  								if ( numberOfPoints > 0 ) {

  									var components = section.DataArray.attributes.NumberOfComponents;
  									points = new Float32Array( numberOfPoints * components );
  									points.set( section.DataArray.text, 0 );

  								}

  								break;

  							// if it is strips
  							case 'Strips':

  								var numberOfStrips = parseInt( piece.attributes.NumberOfStrips );

  								if ( numberOfStrips > 0 ) {

  									var connectivity = new Int32Array( section.DataArray[ 0 ].text.length );
  									var offset = new Int32Array( section.DataArray[ 1 ].text.length );
  									connectivity.set( section.DataArray[ 0 ].text, 0 );
  									offset.set( section.DataArray[ 1 ].text, 0 );

  									var size = numberOfStrips + connectivity.length;
  									indices = new Uint32Array( 3 * size - 9 * numberOfStrips );

  									var indicesIndex = 0;

  									for ( var i = 0, len = numberOfStrips; i < len; i ++ ) {

  										var strip = [];

  										for ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {

  											strip.push( connectivity[ s ] );

  											if ( i > 0 ) { len0 = offset[ i - 1 ]; }

  										}

  										for ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {

  											if ( j % 2 ) {

  												indices[ indicesIndex ++ ] = strip[ j ];
  												indices[ indicesIndex ++ ] = strip[ j + 2 ];
  												indices[ indicesIndex ++ ] = strip[ j + 1 ];

  											} else {

  												indices[ indicesIndex ++ ] = strip[ j ];
  												indices[ indicesIndex ++ ] = strip[ j + 1 ];
  												indices[ indicesIndex ++ ] = strip[ j + 2 ];

  											}

  											if ( i > 0 ) { len0 = offset[ i - 1 ]; }

  										}

  									}

  								}

  								break;

  							// if it is polys
  							case 'Polys':

  								var numberOfPolys = parseInt( piece.attributes.NumberOfPolys );

  								if ( numberOfPolys > 0 ) {

  									var connectivity = new Int32Array( section.DataArray[ 0 ].text.length );
  									var offset = new Int32Array( section.DataArray[ 1 ].text.length );
  									connectivity.set( section.DataArray[ 0 ].text, 0 );
  									offset.set( section.DataArray[ 1 ].text, 0 );

  									var size = numberOfPolys + connectivity.length;
  									indices = new Uint32Array( 3 * size - 9 * numberOfPolys );
  									var indicesIndex = 0, connectivityIndex = 0;
  									var i = 0, len = numberOfPolys, len0 = 0;

  									while ( i < len ) {

  										var poly = [];
  										var s = 0, len1 = offset[ i ];

  										while ( s < len1 - len0 ) {

  											poly.push( connectivity[ connectivityIndex ++ ] );
  											s ++;

  										}

  										var j = 1;

  										while ( j < len1 - len0 - 1 ) {

  											indices[ indicesIndex ++ ] = poly[ 0 ];
  											indices[ indicesIndex ++ ] = poly[ j ];
  											indices[ indicesIndex ++ ] = poly[ j + 1 ];
  											j ++;

  										}

  										i ++;
  										len0 = offset[ i - 1 ];

  									}

  								}

  								break;

  							default:
  								break;

  						}

  					}

  					sectionIndex ++;

  				}

  				var geometry = new BufferGeometry();
  				geometry.setIndex( new BufferAttribute( indices, 1 ) );
  				geometry.addAttribute( 'position', new BufferAttribute( points, 3 ) );

  				if ( normals.length === points.length ) {

  					geometry.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );

  				}

  				return geometry;

  			}

  		}

  		function getStringFile( data ) {

  			var stringFile = '';
  			var charArray = new Uint8Array( data );
  			var i = 0;
  			var len = charArray.length;

  			while ( len -- ) {

  				stringFile += String.fromCharCode( charArray[ i ++ ] );

  			}

  			return stringFile;

  		}

  		// get the 5 first lines of the files to check if there is the key word binary
  		var meta = LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\n' );

  		if ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {

  			return parseXML( getStringFile( data ) );

  		} else if ( meta[ 2 ].includes( 'ASCII' ) ) {

  			return parseASCII( getStringFile( data ) );

  		} else {

  			return parseBinary( data );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ImmediateRenderObject( material ) {

  	Object3D.call( this );

  	this.material = material;
  	this.render = function (  ) {};

  }

  ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MarchingCubes = function ( resolution, material, enableUvs, enableColors ) {

  	ImmediateRenderObject.call( this, material );

  	var scope = this;

  	// temp buffers used in polygonize

  	var vlist = new Float32Array( 12 * 3 );
  	var nlist = new Float32Array( 12 * 3 );
  	var clist = new Float32Array( 12 * 3 );

  	this.enableUvs = enableUvs !== undefined ? enableUvs : false;
  	this.enableColors = enableColors !== undefined ? enableColors : false;

  	// functions have to be object properties
  	// prototype functions kill performance
  	// (tested and it was 4x slower !!!)

  	this.init = function ( resolution ) {

  		this.resolution = resolution;

  		// parameters

  		this.isolation = 80.0;

  		// size of field, 32 is pushing it in Javascript :)

  		this.size = resolution;
  		this.size2 = this.size * this.size;
  		this.size3 = this.size2 * this.size;
  		this.halfsize = this.size / 2.0;

  		// deltas

  		this.delta = 2.0 / this.size;
  		this.yd = this.size;
  		this.zd = this.size2;

  		this.field = new Float32Array( this.size3 );
  		this.normal_cache = new Float32Array( this.size3 * 3 );
  		this.palette = new Float32Array( this.size3 * 3 );

  		// immediate render mode simulator

  		this.maxCount = 4096; // TODO: find the fastest size for this buffer
  		this.count = 0;

  		this.hasPositions = false;
  		this.hasNormals = false;
  		this.hasColors = false;
  		this.hasUvs = false;

  		this.positionArray = new Float32Array( this.maxCount * 3 );
  		this.normalArray = new Float32Array( this.maxCount * 3 );

  		if ( this.enableUvs ) {

  			this.uvArray = new Float32Array( this.maxCount * 2 );

  		}

  		if ( this.enableColors ) {

  			this.colorArray = new Float32Array( this.maxCount * 3 );

  		}

  	};

  	///////////////////////
  	// Polygonization
  	///////////////////////

  	function lerp( a, b, t ) {

  		return a + ( b - a ) * t;

  	}

  	function VIntX( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {

  		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
  			nc = scope.normal_cache;

  		vlist[ offset + 0 ] = x + mu * scope.delta;
  		vlist[ offset + 1 ] = y;
  		vlist[ offset + 2 ] = z;

  		nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q + 3 ], mu );
  		nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q + 4 ], mu );
  		nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q + 5 ], mu );

  		clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );
  		clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );
  		clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );

  	}

  	function VIntY( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {

  		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
  			nc = scope.normal_cache;

  		vlist[ offset + 0 ] = x;
  		vlist[ offset + 1 ] = y + mu * scope.delta;
  		vlist[ offset + 2 ] = z;

  		var q2 = q + scope.yd * 3;

  		nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );
  		nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );
  		nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );

  		clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );
  		clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );
  		clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );

  	}

  	function VIntZ( q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2 ) {

  		var mu = ( isol - valp1 ) / ( valp2 - valp1 ),
  			nc = scope.normal_cache;

  		vlist[ offset + 0 ] = x;
  		vlist[ offset + 1 ] = y;
  		vlist[ offset + 2 ] = z + mu * scope.delta;

  		var q2 = q + scope.zd * 3;

  		nlist[ offset + 0 ] = lerp( nc[ q + 0 ], nc[ q2 + 0 ], mu );
  		nlist[ offset + 1 ] = lerp( nc[ q + 1 ], nc[ q2 + 1 ], mu );
  		nlist[ offset + 2 ] = lerp( nc[ q + 2 ], nc[ q2 + 2 ], mu );

  		clist[ offset + 0 ] = lerp( scope.palette[ c_offset1 * 3 + 0 ], scope.palette[ c_offset2 * 3 + 0 ], mu );
  		clist[ offset + 1 ] = lerp( scope.palette[ c_offset1 * 3 + 1 ], scope.palette[ c_offset2 * 3 + 1 ], mu );
  		clist[ offset + 2 ] = lerp( scope.palette[ c_offset1 * 3 + 2 ], scope.palette[ c_offset2 * 3 + 2 ], mu );

  	}

  	function compNorm( q ) {

  		var q3 = q * 3;

  		if ( scope.normal_cache[ q3 ] === 0.0 ) {

  			scope.normal_cache[ q3 + 0 ] = scope.field[ q - 1 ] - scope.field[ q + 1 ];
  			scope.normal_cache[ q3 + 1 ] =
  				scope.field[ q - scope.yd ] - scope.field[ q + scope.yd ];
  			scope.normal_cache[ q3 + 2 ] =
  				scope.field[ q - scope.zd ] - scope.field[ q + scope.zd ];

  		}

  	}

  	// Returns total number of triangles. Fills triangles.
  	// (this is where most of time is spent - it's inner work of O(n3) loop )

  	function polygonize( fx, fy, fz, q, isol, renderCallback ) {

  		// cache indices
  		var q1 = q + 1,
  			qy = q + scope.yd,
  			qz = q + scope.zd,
  			q1y = q1 + scope.yd,
  			q1z = q1 + scope.zd,
  			qyz = q + scope.yd + scope.zd,
  			q1yz = q1 + scope.yd + scope.zd;

  		var cubeindex = 0,
  			field0 = scope.field[ q ],
  			field1 = scope.field[ q1 ],
  			field2 = scope.field[ qy ],
  			field3 = scope.field[ q1y ],
  			field4 = scope.field[ qz ],
  			field5 = scope.field[ q1z ],
  			field6 = scope.field[ qyz ],
  			field7 = scope.field[ q1yz ];

  		if ( field0 < isol ) { cubeindex |= 1; }
  		if ( field1 < isol ) { cubeindex |= 2; }
  		if ( field2 < isol ) { cubeindex |= 8; }
  		if ( field3 < isol ) { cubeindex |= 4; }
  		if ( field4 < isol ) { cubeindex |= 16; }
  		if ( field5 < isol ) { cubeindex |= 32; }
  		if ( field6 < isol ) { cubeindex |= 128; }
  		if ( field7 < isol ) { cubeindex |= 64; }

  		// if cube is entirely in/out of the surface - bail, nothing to draw

  		var bits = edgeTable[ cubeindex ];
  		if ( bits === 0 ) { return 0; }

  		var d = scope.delta,
  			fx2 = fx + d,
  			fy2 = fy + d,
  			fz2 = fz + d;

  		// top of the cube

  		if ( bits & 1 ) {

  			compNorm( q );
  			compNorm( q1 );
  			VIntX( q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1 );

  		}

  		if ( bits & 2 ) {

  			compNorm( q1 );
  			compNorm( q1y );
  			VIntY( q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y );

  		}

  		if ( bits & 4 ) {

  			compNorm( qy );
  			compNorm( q1y );
  			VIntX( qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y );

  		}

  		if ( bits & 8 ) {

  			compNorm( q );
  			compNorm( qy );
  			VIntY( q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy );

  		}

  		// bottom of the cube

  		if ( bits & 16 ) {

  			compNorm( qz );
  			compNorm( q1z );
  			VIntX( qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z );

  		}

  		if ( bits & 32 ) {

  			compNorm( q1z );
  			compNorm( q1yz );
  			VIntY(
  				q1z * 3,
  				15,
  				isol,
  				fx2,
  				fy,
  				fz2,
  				field5,
  				field7,
  				q1z,
  				q1yz
  			);

  		}

  		if ( bits & 64 ) {

  			compNorm( qyz );
  			compNorm( q1yz );
  			VIntX(
  				qyz * 3,
  				18,
  				isol,
  				fx,
  				fy2,
  				fz2,
  				field6,
  				field7,
  				qyz,
  				q1yz
  			);

  		}

  		if ( bits & 128 ) {

  			compNorm( qz );
  			compNorm( qyz );
  			VIntY( qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz );

  		}

  		// vertical lines of the cube
  		if ( bits & 256 ) {

  			compNorm( q );
  			compNorm( qz );
  			VIntZ( q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz );

  		}

  		if ( bits & 512 ) {

  			compNorm( q1 );
  			compNorm( q1z );
  			VIntZ( q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z );

  		}

  		if ( bits & 1024 ) {

  			compNorm( q1y );
  			compNorm( q1yz );
  			VIntZ(
  				q1y * 3,
  				30,
  				isol,
  				fx2,
  				fy2,
  				fz,
  				field3,
  				field7,
  				q1y,
  				q1yz
  			);

  		}

  		if ( bits & 2048 ) {

  			compNorm( qy );
  			compNorm( qyz );
  			VIntZ( qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz );

  		}

  		cubeindex <<= 4; // re-purpose cubeindex into an offset into triTable

  		var o1,
  			o2,
  			o3,
  			numtris = 0,
  			i = 0;

  		// here is where triangles are created

  		while ( triTable[ cubeindex + i ] != - 1 ) {

  			o1 = cubeindex + i;
  			o2 = o1 + 1;
  			o3 = o1 + 2;

  			posnormtriv(
  				vlist,
  				nlist,
  				clist,
  				3 * triTable[ o1 ],
  				3 * triTable[ o2 ],
  				3 * triTable[ o3 ],
  				renderCallback
  			);

  			i += 3;
  			numtris ++;

  		}

  		return numtris;

  	}

  	/////////////////////////////////////
  	// Immediate render mode simulator
  	/////////////////////////////////////

  	function posnormtriv( pos, norm, colors, o1, o2, o3, renderCallback ) {

  		var c = scope.count * 3;

  		// positions

  		scope.positionArray[ c + 0 ] = pos[ o1 ];
  		scope.positionArray[ c + 1 ] = pos[ o1 + 1 ];
  		scope.positionArray[ c + 2 ] = pos[ o1 + 2 ];

  		scope.positionArray[ c + 3 ] = pos[ o2 ];
  		scope.positionArray[ c + 4 ] = pos[ o2 + 1 ];
  		scope.positionArray[ c + 5 ] = pos[ o2 + 2 ];

  		scope.positionArray[ c + 6 ] = pos[ o3 ];
  		scope.positionArray[ c + 7 ] = pos[ o3 + 1 ];
  		scope.positionArray[ c + 8 ] = pos[ o3 + 2 ];

  		// normals

  		if ( scope.material.flatShading === true ) {

  			var nx = ( norm[ o1 + 0 ] + norm[ o2 + 0 ] + norm[ o3 + 0 ] ) / 3;
  			var ny = ( norm[ o1 + 1 ] + norm[ o2 + 1 ] + norm[ o3 + 1 ] ) / 3;
  			var nz = ( norm[ o1 + 2 ] + norm[ o2 + 2 ] + norm[ o3 + 2 ] ) / 3;

  			scope.normalArray[ c + 0 ] = nx;
  			scope.normalArray[ c + 1 ] = ny;
  			scope.normalArray[ c + 2 ] = nz;

  			scope.normalArray[ c + 3 ] = nx;
  			scope.normalArray[ c + 4 ] = ny;
  			scope.normalArray[ c + 5 ] = nz;

  			scope.normalArray[ c + 6 ] = nx;
  			scope.normalArray[ c + 7 ] = ny;
  			scope.normalArray[ c + 8 ] = nz;

  		} else {

  			scope.normalArray[ c + 0 ] = norm[ o1 + 0 ];
  			scope.normalArray[ c + 1 ] = norm[ o1 + 1 ];
  			scope.normalArray[ c + 2 ] = norm[ o1 + 2 ];

  			scope.normalArray[ c + 3 ] = norm[ o2 + 0 ];
  			scope.normalArray[ c + 4 ] = norm[ o2 + 1 ];
  			scope.normalArray[ c + 5 ] = norm[ o2 + 2 ];

  			scope.normalArray[ c + 6 ] = norm[ o3 + 0 ];
  			scope.normalArray[ c + 7 ] = norm[ o3 + 1 ];
  			scope.normalArray[ c + 8 ] = norm[ o3 + 2 ];

  		}

  		// uvs

  		if ( scope.enableUvs ) {

  			var d = scope.count * 2;

  			scope.uvArray[ d + 0 ] = pos[ o1 + 0 ];
  			scope.uvArray[ d + 1 ] = pos[ o1 + 2 ];

  			scope.uvArray[ d + 2 ] = pos[ o2 + 0 ];
  			scope.uvArray[ d + 3 ] = pos[ o2 + 2 ];

  			scope.uvArray[ d + 4 ] = pos[ o3 + 0 ];
  			scope.uvArray[ d + 5 ] = pos[ o3 + 2 ];

  		}

  		// colors

  		if ( scope.enableColors ) {

  			scope.colorArray[ c + 0 ] = colors[ o1 + 0 ];
  			scope.colorArray[ c + 1 ] = colors[ o1 + 1 ];
  			scope.colorArray[ c + 2 ] = colors[ o1 + 2 ];

  			scope.colorArray[ c + 3 ] = colors[ o2 + 0 ];
  			scope.colorArray[ c + 4 ] = colors[ o2 + 1 ];
  			scope.colorArray[ c + 5 ] = colors[ o2 + 2 ];

  			scope.colorArray[ c + 6 ] = colors[ o3 + 0 ];
  			scope.colorArray[ c + 7 ] = colors[ o3 + 1 ];
  			scope.colorArray[ c + 8 ] = colors[ o3 + 2 ];

  		}

  		scope.count += 3;

  		if ( scope.count >= scope.maxCount - 3 ) {

  			scope.hasPositions = true;
  			scope.hasNormals = true;

  			if ( scope.enableUvs ) {

  				scope.hasUvs = true;

  			}

  			if ( scope.enableColors ) {

  				scope.hasColors = true;

  			}

  			renderCallback( scope );

  		}

  	}

  	this.begin = function () {

  		this.count = 0;

  		this.hasPositions = false;
  		this.hasNormals = false;
  		this.hasUvs = false;
  		this.hasColors = false;

  	};

  	this.end = function ( renderCallback ) {
  		var this$1 = this;


  		if ( this.count === 0 ) { return; }

  		for ( var i = this.count * 3; i < this.positionArray.length; i ++ ) {

  			this$1.positionArray[ i ] = 0.0;

  		}

  		this.hasPositions = true;
  		this.hasNormals = true;

  		if ( this.enableUvs && this.material.map ) {

  			this.hasUvs = true;

  		}

  		if ( this.enableColors && this.material.vertexColors !== NoColors ) {

  			this.hasColors = true;

  		}

  		renderCallback( this );

  	};

  	/////////////////////////////////////
  	// Metaballs
  	/////////////////////////////////////

  	// Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after
  	// a fixed distance, determined by strength and subtract.

  	this.addBall = function ( ballx, bally, ballz, strength, subtract, colors ) {
  		var this$1 = this;


  		var sign = Math.sign( strength );
  		strength = Math.abs( strength );
  		var userDefineColor = ! ( colors === undefined || colors === null );
  		var ballColor = new Color( ballx, bally, ballz );
  		if ( userDefineColor ) {

  			try {

  				ballColor =
  					colors instanceof Color
  						? colors
  						: Array.isArray( colors )
  							? new Color(
  								Math.min( Math.abs( colors[ 0 ] ), 1 ),
  								Math.min( Math.abs( colors[ 1 ] ), 1 ),
  								Math.min( Math.abs( colors[ 2 ] ), 1 )
  						  )
  							: new Color( colors );

  			} catch ( err ) {

  				userDefineColor = false;
  				ballColor = new Color( ballx, bally, ballz );

  			}

  		}

  		// Let's solve the equation to find the radius:
  		// 1.0 / (0.000001 + radius^2) * strength - subtract = 0
  		// strength / (radius^2) = subtract
  		// strength = subtract * radius^2
  		// radius^2 = strength / subtract
  		// radius = sqrt(strength / subtract)

  		var radius = this.size * Math.sqrt( strength / subtract ),
  			zs = ballz * this.size,
  			ys = bally * this.size,
  			xs = ballx * this.size;

  		var min_z = Math.floor( zs - radius );
  		if ( min_z < 1 ) { min_z = 1; }
  		var max_z = Math.floor( zs + radius );
  		if ( max_z > this.size - 1 ) { max_z = this.size - 1; }
  		var min_y = Math.floor( ys - radius );
  		if ( min_y < 1 ) { min_y = 1; }
  		var max_y = Math.floor( ys + radius );
  		if ( max_y > this.size - 1 ) { max_y = this.size - 1; }
  		var min_x = Math.floor( xs - radius );
  		if ( min_x < 1 ) { min_x = 1; }
  		var max_x = Math.floor( xs + radius );
  		if ( max_x > this.size - 1 ) { max_x = this.size - 1; }

  		// Don't polygonize in the outer layer because normals aren't
  		// well-defined there.

  		var x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
  		for ( z = min_z; z < max_z; z ++ ) {

  			z_offset = this$1.size2 * z;
  			fz = z / this$1.size - ballz;
  			fz2 = fz * fz;

  			for ( y = min_y; y < max_y; y ++ ) {

  				y_offset = z_offset + this$1.size * y;
  				fy = y / this$1.size - bally;
  				fy2 = fy * fy;

  				for ( x = min_x; x < max_x; x ++ ) {

  					fx = x / this$1.size - ballx;
  					val = strength / ( 0.000001 + fx * fx + fy2 + fz2 ) - subtract;
  					if ( val > 0.0 ) {

  						this$1.field[ y_offset + x ] += val * sign;

  						// optimization
  						// http://www.geisswerks.com/ryan/BLOBS/blobs.html
  						var ratio =
  							Math.sqrt( ( x - xs ) * ( x - xs ) + ( y - ys ) * ( y - ys ) + ( z - zs ) * ( z - zs ) ) / radius;
  						var contrib =
  							1 - ratio * ratio * ratio * ( ratio * ( ratio * 6 - 15 ) + 10 );
  						this$1.palette[ ( y_offset + x ) * 3 + 0 ] += ballColor.r * contrib;
  						this$1.palette[ ( y_offset + x ) * 3 + 1 ] += ballColor.g * contrib;
  						this$1.palette[ ( y_offset + x ) * 3 + 2 ] += ballColor.b * contrib;

  					}

  				}

  			}

  		}

  	};

  	this.addPlaneX = function ( strength, subtract ) {

  		var x,
  			y,
  			z,
  			xx,
  			val,
  			xdiv,
  			cxy,
  			// cache attribute lookups
  			size = this.size,
  			yd = this.yd,
  			zd = this.zd,
  			field = this.field,
  			dist = size * Math.sqrt( strength / subtract );

  		if ( dist > size ) { dist = size; }

  		for ( x = 0; x < dist; x ++ ) {

  			xdiv = x / size;
  			xx = xdiv * xdiv;
  			val = strength / ( 0.0001 + xx ) - subtract;

  			if ( val > 0.0 ) {

  				for ( y = 0; y < size; y ++ ) {

  					cxy = x + y * yd;

  					for ( z = 0; z < size; z ++ ) {

  						field[ zd * z + cxy ] += val;

  					}

  				}

  			}

  		}

  	};

  	this.addPlaneY = function ( strength, subtract ) {

  		var x,
  			y,
  			z,
  			yy,
  			val,
  			ydiv,
  			cy,
  			cxy,
  			// cache attribute lookups
  			size = this.size,
  			yd = this.yd,
  			zd = this.zd,
  			field = this.field,
  			dist = size * Math.sqrt( strength / subtract );

  		if ( dist > size ) { dist = size; }

  		for ( y = 0; y < dist; y ++ ) {

  			ydiv = y / size;
  			yy = ydiv * ydiv;
  			val = strength / ( 0.0001 + yy ) - subtract;

  			if ( val > 0.0 ) {

  				cy = y * yd;

  				for ( x = 0; x < size; x ++ ) {

  					cxy = cy + x;

  					for ( z = 0; z < size; z ++ ) { field[ zd * z + cxy ] += val; }

  				}

  			}

  		}

  	};

  	this.addPlaneZ = function ( strength, subtract ) {

  		var x,
  			y,
  			z,
  			zz,
  			val,
  			zdiv,
  			cz,
  			cyz,
  			// cache attribute lookups
  			size = this.size,
  			yd = this.yd,
  			zd = this.zd,
  			field = this.field,
  			dist = size * Math.sqrt( strength / subtract );

  		if ( dist > size ) { dist = size; }

  		for ( z = 0; z < dist; z ++ ) {

  			zdiv = z / size;
  			zz = zdiv * zdiv;
  			val = strength / ( 0.0001 + zz ) - subtract;
  			if ( val > 0.0 ) {

  				cz = zd * z;

  				for ( y = 0; y < size; y ++ ) {

  					cyz = cz + y * yd;

  					for ( x = 0; x < size; x ++ ) { field[ cyz + x ] += val; }

  				}

  			}

  		}

  	};

  	/////////////////////////////////////
  	// Updates
  	/////////////////////////////////////

  	this.reset = function () {
  		var this$1 = this;


  		var i;

  		// wipe the normal cache

  		for ( i = 0; i < this.size3; i ++ ) {

  			this$1.normal_cache[ i * 3 ] = 0.0;
  			this$1.field[ i ] = 0.0;
  			this$1.palette[ i * 3 ] = this$1.palette[ i * 3 + 1 ] = this$1.palette[
  				i * 3 + 2
  			] = 0.0;

  		}

  	};

  	this.render = function ( renderCallback ) {
  		var this$1 = this;


  		this.begin();

  		// Triangulate. Yeah, this is slow.

  		var smin2 = this.size - 2;

  		for ( var z = 1; z < smin2; z ++ ) {

  			var z_offset = this$1.size2 * z;
  			var fz = ( z - this$1.halfsize ) / this$1.halfsize; //+ 1

  			for ( var y = 1; y < smin2; y ++ ) {

  				var y_offset = z_offset + this$1.size * y;
  				var fy = ( y - this$1.halfsize ) / this$1.halfsize; //+ 1

  				for ( var x = 1; x < smin2; x ++ ) {

  					var fx = ( x - this$1.halfsize ) / this$1.halfsize; //+ 1
  					var q = y_offset + x;

  					polygonize( fx, fy, fz, q, this$1.isolation, renderCallback );

  				}

  			}

  		}

  		this.end( renderCallback );

  	};

  	this.generateGeometry = function () {

  		console.warn(
  			"MarchingCubes: generateGeometry() now returns BufferGeometry"
  		);
  		return this.generateBufferGeometry();

  	};

  	function concatenate( a, b, length ) {

  		var result = new Float32Array( a.length + length );
  		result.set( a, 0 );
  		result.set( b.slice( 0, length ), a.length );
  		return result;

  	}

  	this.generateBufferGeometry = function () {

  		var geo = new BufferGeometry();
  		var posArray = new Float32Array();
  		var normArray = new Float32Array();
  		var colorArray = new Float32Array();
  		var uvArray = new Float32Array();
  		var scope = this;

  		var geo_callback = function ( object ) {

  			if ( scope.hasPositions )
  				{ posArray = concatenate(
  					posArray,
  					object.positionArray,
  					object.count * 3
  				); }
  			if ( scope.hasNormals )
  				{ normArray = concatenate(
  					normArray,
  					object.normalArray,
  					object.count * 3
  				); }
  			if ( scope.hasColors )
  				{ colorArray = concatenate(
  					colorArray,
  					object.colorArray,
  					object.count * 3
  				); }
  			if ( scope.hasUvs )
  				{ uvArray = concatenate( uvArray, object.uvArray, object.count * 2 ); }

  			object.count = 0;

  		};

  		this.render( geo_callback );

  		if ( this.hasPositions )
  			{ geo.addAttribute( "position", new BufferAttribute( posArray, 3 ) ); }
  		if ( this.hasNormals )
  			{ geo.addAttribute( "normal", new BufferAttribute( normArray, 3 ) ); }
  		if ( this.hasColors )
  			{ geo.addAttribute( "color", new BufferAttribute( colorArray, 3 ) ); }
  		if ( this.hasUvs )
  			{ geo.addAttribute( "uv", new BufferAttribute( uvArray, 2 ) ); }

  		return geo;

  	};

  	this.init( resolution );

  };

  MarchingCubes.prototype = Object.create( ImmediateRenderObject.prototype );
  MarchingCubes.prototype.constructor = MarchingCubes;
  /////////////////////////////////////
  // Marching cubes lookup tables
  /////////////////////////////////////

  // These tables are straight from Paul Bourke's page:
  // http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
  // who in turn got them from Cory Gene Bloyd.

  var edgeTable = new Int32Array( [
  	0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
  	0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
  	0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
  	0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
  	0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
  	0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
  	0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
  	0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
  	0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
  	0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
  	0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
  	0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
  	0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
  	0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
  	0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
  	0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
  	0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
  	0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
  	0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
  	0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
  	0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
  	0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
  	0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
  	0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
  	0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
  	0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
  	0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
  	0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
  	0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
  	0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
  	0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
  	0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0 ] );

  var triTable = new Int32Array( [
  	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 8, 3, 9, 8, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 2, 10, 0, 2, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 8, 3, 2, 10, 8, 10, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 11, 2, 8, 11, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 9, 0, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 11, 2, 1, 9, 11, 9, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 10, 1, 11, 10, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 10, 1, 0, 8, 10, 8, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 9, 0, 3, 11, 9, 11, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 3, 0, 7, 3, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 1, 9, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 1, 9, 4, 7, 1, 7, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 4, 7, 3, 0, 4, 1, 2, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 2, 10, 9, 0, 2, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,
  	8, 4, 7, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 4, 7, 11, 2, 4, 2, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 0, 1, 8, 4, 7, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, - 1, - 1, - 1, - 1,
  	3, 10, 1, 3, 11, 10, 7, 8, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, - 1, - 1, - 1, - 1,
  	4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,
  	4, 7, 11, 4, 11, 9, 9, 11, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 5, 4, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 5, 4, 1, 5, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 5, 4, 8, 3, 5, 3, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 0, 8, 1, 2, 10, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 2, 10, 5, 4, 2, 4, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, - 1, - 1, - 1, - 1,
  	9, 5, 4, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 11, 2, 0, 8, 11, 4, 9, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 5, 4, 0, 1, 5, 2, 3, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, - 1, - 1, - 1, - 1,
  	10, 3, 11, 10, 1, 3, 9, 5, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, - 1, - 1, - 1, - 1,
  	5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, - 1, - 1, - 1, - 1,
  	5, 4, 8, 5, 8, 10, 10, 8, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 7, 8, 5, 7, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 3, 0, 9, 5, 3, 5, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 7, 8, 0, 1, 7, 1, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 7, 8, 9, 5, 7, 10, 1, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, - 1, - 1, - 1, - 1,
  	8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, - 1, - 1, - 1, - 1,
  	2, 10, 5, 2, 5, 3, 3, 5, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 9, 5, 7, 8, 9, 3, 11, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,
  	2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, - 1, - 1, - 1, - 1,
  	11, 2, 1, 11, 1, 7, 7, 1, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, - 1, - 1, - 1, - 1,
  	5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, - 1,
  	11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, - 1,
  	11, 10, 5, 7, 11, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 0, 1, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 8, 3, 1, 9, 8, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 6, 5, 2, 6, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 6, 5, 1, 2, 6, 3, 0, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 6, 5, 9, 0, 6, 0, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, - 1, - 1, - 1, - 1,
  	2, 3, 11, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 0, 8, 11, 2, 0, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 1, 9, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, - 1, - 1, - 1, - 1,
  	6, 3, 11, 6, 5, 3, 5, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,
  	3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, - 1, - 1, - 1, - 1,
  	6, 5, 9, 6, 9, 11, 11, 9, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 10, 6, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 3, 0, 4, 7, 3, 6, 5, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 9, 0, 5, 10, 6, 8, 4, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, - 1, - 1, - 1, - 1,
  	6, 1, 2, 6, 5, 1, 4, 7, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, - 1, - 1, - 1, - 1,
  	8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, - 1, - 1, - 1, - 1,
  	7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, - 1,
  	3, 11, 2, 7, 8, 4, 10, 6, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, - 1, - 1, - 1, - 1,
  	0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, - 1, - 1, - 1, - 1,
  	9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, - 1,
  	8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, - 1, - 1, - 1, - 1,
  	5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, - 1,
  	0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, - 1,
  	6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, - 1, - 1, - 1, - 1,
  	10, 4, 9, 6, 4, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 10, 6, 4, 9, 10, 0, 8, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 0, 1, 10, 6, 0, 6, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,
  	1, 4, 9, 1, 2, 4, 2, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, - 1, - 1, - 1, - 1,
  	0, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 3, 2, 8, 2, 4, 4, 2, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 4, 9, 10, 6, 4, 11, 2, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, - 1, - 1, - 1, - 1,
  	3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, - 1, - 1, - 1, - 1,
  	6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, - 1,
  	9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, - 1, - 1, - 1, - 1,
  	8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, - 1,
  	3, 11, 6, 3, 6, 0, 0, 6, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	6, 4, 8, 11, 6, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 10, 6, 7, 8, 10, 8, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, - 1, - 1, - 1, - 1,
  	10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, - 1, - 1, - 1, - 1,
  	10, 6, 7, 10, 7, 1, 1, 7, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,
  	2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, - 1,
  	7, 8, 0, 7, 0, 6, 6, 0, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 3, 2, 6, 7, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, - 1, - 1, - 1, - 1,
  	2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, - 1,
  	1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, - 1,
  	11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, - 1, - 1, - 1, - 1,
  	8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, - 1,
  	0, 9, 1, 11, 6, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, - 1, - 1, - 1, - 1,
  	7, 11, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 0, 8, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 1, 9, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 1, 9, 8, 3, 1, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 1, 2, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, 3, 0, 8, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 9, 0, 2, 10, 9, 6, 11, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, - 1, - 1, - 1, - 1,
  	7, 2, 3, 6, 2, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	7, 0, 8, 7, 6, 0, 6, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 7, 6, 2, 3, 7, 0, 1, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, - 1, - 1, - 1, - 1,
  	10, 7, 6, 10, 1, 7, 1, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, - 1, - 1, - 1, - 1,
  	0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, - 1, - 1, - 1, - 1,
  	7, 6, 10, 7, 10, 8, 8, 10, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	6, 8, 4, 11, 8, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 6, 11, 3, 0, 6, 0, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 6, 11, 8, 4, 6, 9, 0, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, - 1, - 1, - 1, - 1,
  	6, 8, 4, 6, 11, 8, 2, 10, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, - 1, - 1, - 1, - 1,
  	4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, - 1, - 1, - 1, - 1,
  	10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, - 1,
  	8, 2, 3, 8, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 4, 2, 4, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, - 1, - 1, - 1, - 1,
  	1, 9, 4, 1, 4, 2, 2, 4, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, - 1, - 1, - 1, - 1,
  	10, 1, 0, 10, 0, 6, 6, 0, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, - 1,
  	10, 9, 4, 6, 10, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 9, 5, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, 4, 9, 5, 11, 7, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 0, 1, 5, 4, 0, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, - 1, - 1, - 1, - 1,
  	9, 5, 4, 10, 1, 2, 7, 6, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, - 1, - 1, - 1, - 1,
  	7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, - 1, - 1, - 1, - 1,
  	3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, - 1,
  	7, 2, 3, 7, 6, 2, 5, 4, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, - 1, - 1, - 1, - 1,
  	3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, - 1, - 1, - 1, - 1,
  	6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, - 1,
  	9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, - 1, - 1, - 1, - 1,
  	1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, - 1,
  	4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, - 1,
  	7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, - 1, - 1, - 1, - 1,
  	6, 9, 5, 6, 11, 9, 11, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, - 1, - 1, - 1, - 1,
  	0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, - 1, - 1, - 1, - 1,
  	6, 11, 3, 6, 3, 5, 5, 3, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, - 1, - 1, - 1, - 1,
  	0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, - 1,
  	11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, - 1,
  	6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, - 1, - 1, - 1, - 1,
  	5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, - 1, - 1, - 1, - 1,
  	9, 5, 6, 9, 6, 0, 0, 6, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, - 1,
  	1, 5, 6, 2, 1, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, - 1,
  	10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, - 1, - 1, - 1, - 1,
  	0, 3, 8, 5, 6, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 5, 6, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 5, 10, 7, 5, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 5, 10, 11, 7, 5, 8, 3, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 11, 7, 5, 10, 11, 1, 9, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, - 1, - 1, - 1, - 1,
  	11, 1, 2, 11, 7, 1, 7, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, - 1, - 1, - 1, - 1,
  	9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, - 1, - 1, - 1, - 1,
  	7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, - 1,
  	2, 5, 10, 2, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, - 1, - 1, - 1, - 1,
  	9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, - 1, - 1, - 1, - 1,
  	9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, - 1,
  	1, 3, 5, 3, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 7, 0, 7, 1, 1, 7, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 0, 3, 9, 3, 5, 5, 3, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 8, 7, 5, 9, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 8, 4, 5, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, - 1, - 1, - 1, - 1,
  	0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, - 1, - 1, - 1, - 1,
  	10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, - 1,
  	2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, - 1, - 1, - 1, - 1,
  	0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, - 1,
  	0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, - 1,
  	9, 4, 5, 2, 11, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, - 1, - 1, - 1, - 1,
  	5, 10, 2, 5, 2, 4, 4, 2, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, - 1,
  	5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, - 1, - 1, - 1, - 1,
  	8, 4, 5, 8, 5, 3, 3, 5, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 4, 5, 1, 0, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, - 1, - 1, - 1, - 1,
  	9, 4, 5, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 11, 7, 4, 9, 11, 9, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, - 1, - 1, - 1, - 1,
  	1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, - 1, - 1, - 1, - 1,
  	3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, - 1,
  	4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, - 1, - 1, - 1, - 1,
  	9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, - 1,
  	11, 7, 4, 11, 4, 2, 2, 4, 0, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, - 1, - 1, - 1, - 1,
  	2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, - 1, - 1, - 1, - 1,
  	9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, - 1,
  	3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, - 1,
  	1, 10, 2, 8, 7, 4, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 9, 1, 4, 1, 7, 7, 1, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, - 1, - 1, - 1, - 1,
  	4, 0, 3, 7, 4, 3, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	4, 8, 7, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 10, 8, 10, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 0, 9, 3, 9, 11, 11, 9, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 1, 10, 0, 10, 8, 8, 10, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 1, 10, 11, 3, 10, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 2, 11, 1, 11, 9, 9, 11, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, - 1, - 1, - 1, - 1,
  	0, 2, 11, 8, 0, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	3, 2, 11, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 3, 8, 2, 8, 10, 10, 8, 9, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	9, 10, 2, 0, 9, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, - 1, - 1, - 1, - 1,
  	1, 10, 2, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	1, 3, 8, 9, 1, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 9, 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	0, 3, 8, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
  	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1 ] );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColorConverter = {

  	setHSV: function ( color, h, s, v ) {

  		// https://gist.github.com/xpansive/1337890#file-index-js

  		h = _Math.euclideanModulo( h, 1 );
  		s = _Math.clamp( s, 0, 1 );
  		v = _Math.clamp( v, 0, 1 );

  		return color.setHSL( h, ( s * v ) / ( ( h = ( 2 - s ) * v ) < 1 ? h : ( 2 - h ) ), h * 0.5 );

  	},

  	getHSV: function() {

  		var hsl = {};

  		return function getHSV( color, target ) {

  			if ( target === undefined ) {

  				console.warn( 'ColorConverter: .getHSV() target is now required' );
  				target = { h: 0, s: 0, l: 0 };

  			}

  			color.getHSL( hsl );

  			// based on https://gist.github.com/xpansive/1337890#file-index-js
  			hsl.s *= ( hsl.l < 0.5 ) ? hsl.l : ( 1 - hsl.l );

  			target.h = hsl.h;
  			target.s = 2 * hsl.s / ( hsl.l + hsl.s );
  			target.v = hsl.l + hsl.s;

  			return target;

  		};

  	}(),

  	// where c, m, y, k is between 0 and 1
  	
  	setCMYK: function ( color, c, m, y, k ) {

  		var r = ( 1 - c ) * ( 1 - k );
  		var g = ( 1 - m ) * ( 1 - k );
  		var b = ( 1 - y ) * ( 1 - k );

  		return color.setRGB( r, g, b );

  	},

  	getCMYK: function ( color, target ) {

  		if ( target === undefined ) {

  			console.warn( 'ColorConverter: .getCMYK() target is now required' );
  			target = { c: 0, m: 0, y: 0, k:0 };

  		}

  		var r = color.r;
  		var g = color.g;
  		var b = color.b;

  		var k = 1 - Math.max( r, g, b );
  		var c = ( 1 - r - k ) / ( 1 - k );
  		var m = ( 1 - g - k ) / ( 1 - k );
  		var y = ( 1 - b - k ) / ( 1 - k );

  		target.c = c;
  		target.m = m;
  		target.y = y;
  		target.k = k;

  		return target;

  	}
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.needsUpdate = true;

  }

  CanvasTexture.prototype = Object.create( Texture.prototype );
  CanvasTexture.prototype.constructor = CanvasTexture;
  CanvasTexture.prototype.isCanvasTexture = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var geometry;

  function Sprite( material ) {

  	Object3D.call( this );

  	this.type = 'Sprite';

  	if ( geometry === undefined ) {

  		geometry = new BufferGeometry();

  		var float32Array = new Float32Array( [
  			- 0.5, - 0.5, 0, 0, 0,
  			0.5, - 0.5, 0, 1, 0,
  			0.5, 0.5, 0, 1, 1,
  			- 0.5, 0.5, 0, 0, 1
  		] );

  		var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

  		geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
  		geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
  		geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

  	}

  	this.geometry = geometry;
  	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

  	this.center = new Vector2( 0.5, 0.5 );

  }

  Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Sprite,

  	isSprite: true,

  	raycast: ( function () {

  		var intersectPoint = new Vector3();
  		var worldScale = new Vector3();
  		var mvPosition = new Vector3();

  		var alignedPosition = new Vector2();
  		var rotatedPosition = new Vector2();
  		var viewWorldMatrix = new Matrix4();

  		var vA = new Vector3();
  		var vB = new Vector3();
  		var vC = new Vector3();

  		var uvA = new Vector2();
  		var uvB = new Vector2();
  		var uvC = new Vector2();

  		function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

  			// compute position in camera space
  			alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

  			// to check if rotation is not zero
  			if ( sin !== undefined ) {

  				rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
  				rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

  			} else {

  				rotatedPosition.copy( alignedPosition );

  			}
  			vertexPosition.copy( mvPosition );
  			vertexPosition.x += rotatedPosition.x;
  			vertexPosition.y += rotatedPosition.y;

  			// transform to world space
  			vertexPosition.applyMatrix4( viewWorldMatrix );

  		}

  		return function raycast( raycaster, intersects ) {

  			worldScale.setFromMatrixScale( this.matrixWorld );
  			viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
  			mvPosition.setFromMatrixPosition( this.modelViewMatrix );

  			var rotation = this.material.rotation;
  			var sin, cos;
  			if ( rotation !== 0 ) {

  				cos = Math.cos( rotation );
  				sin = Math.sin( rotation );

  			}

  			var center = this.center;

  			transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  			transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  			transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

  			uvA.set( 0, 0 );
  			uvB.set( 1, 0 );
  			uvC.set( 1, 1 );

  			// check first triangle
  			var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

  			if ( intersect === null ) {

  				// check second triangle
  				transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  				uvB.set( 0, 1 );

  				intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
  				if ( intersect === null ) {

  					return;

  				}

  			}

  			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  			intersects.push( {

  				distance: distance,
  				point: intersectPoint.clone(),
  				uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
  				face: null,
  				object: this

  			} );

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.material ).copy( this );

  	},

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		if ( source.center !== undefined ) { this.center.copy( source.center ); }

  		return this;

  	}
  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Lut = function ( colormap, numberofcolors ) {
  	var this$1 = this;


  	this.lut = [];
  	this.map = ColorMapKeywords[ colormap ];
  	this.n = numberofcolors;
  	this.mapname = colormap;

  	var step = 1.0 / this.n;

  	for ( var i = 0; i <= 1; i += step ) {

  		for ( var j = 0; j < this.map.length - 1; j ++ ) {

  			if ( i >= this$1.map[ j ][ 0 ] && i < this$1.map[ j + 1 ][ 0 ] ) {

  				var min = this$1.map[ j ][ 0 ];
  				var max = this$1.map[ j + 1 ][ 0 ];

  				var minColor = new Color( 0xffffff ).setHex( this$1.map[ j ][ 1 ] );
  				var maxColor = new Color( 0xffffff ).setHex( this$1.map[ j + 1 ][ 1 ] );

  				var color = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );

  				this$1.lut.push( color );

  			}

  		}

  	}

  	return this.set( this );

  };

  Lut.prototype = {

  	constructor: Lut,

  	lut: [], map: [], mapname: 'rainbow', n: 256, minV: 0, maxV: 1, legend: null,

  	set: function ( value ) {

  		if ( value instanceof Lut ) {

  			this.copy( value );

  		}

  		return this;

  	},

  	setMin: function ( min ) {

  		this.minV = min;

  		return this;

  	},

  	setMax: function ( max ) {

  		this.maxV = max;

  		return this;

  	},

  	changeNumberOfColors: function ( numberofcolors ) {

  		this.n = numberofcolors;

  		return new Lut( this.mapname, this.n );

  	},

  	changeColorMap: function ( colormap ) {

  		this.mapname = colormap;

  		return new Lut( this.mapname, this.n );

  	},

  	copy: function ( lut ) {

  		this.lut = lut.lut;
  		this.mapname = lut.mapname;
  		this.map = lut.map;
  		this.n = lut.n;
  		this.minV = lut.minV;
  		this.maxV = lut.maxV;

  		return this;

  	},

  	getColor: function ( alpha ) {

  		if ( alpha <= this.minV ) {

  			alpha = this.minV;

  		} else if ( alpha >= this.maxV ) {

  			alpha = this.maxV;

  		}

  		alpha = ( alpha - this.minV ) / ( this.maxV - this.minV );

  		var colorPosition = Math.round( alpha * this.n );
  		colorPosition == this.n ? colorPosition -= 1 : colorPosition;

  		return this.lut[ colorPosition ];

  	},

  	addColorMap: function ( colormapName, arrayOfColors ) {

  		ColorMapKeywords[ colormapName ] = arrayOfColors;

  	},

  	setLegendOn: function ( parameters ) {
  		var this$1 = this;


  		if ( parameters === undefined ) {

  			parameters = {};

  		}

  		this.legend = {};

  		this.legend.layout = parameters.hasOwnProperty( 'layout' ) ? parameters[ 'layout' ] : 'vertical';

  		this.legend.position = parameters.hasOwnProperty( 'position' ) ? parameters[ 'position' ] : { 'x': 4, 'y': 0, 'z': 0 };

  		this.legend.dimensions = parameters.hasOwnProperty( 'dimensions' ) ? parameters[ 'dimensions' ] : { 'width': 0.5, 'height': 3 };

  		this.legend.canvas = document.createElement( 'canvas' );

  		this.legend.canvas.setAttribute( 'id', 'legend' );
  		this.legend.canvas.setAttribute( 'hidden', true );

  		document.body.appendChild( this.legend.canvas );

  		this.legend.ctx = this.legend.canvas.getContext( '2d' );

  		this.legend.canvas.setAttribute( 'width', 1 );
  		this.legend.canvas.setAttribute( 'height', this.n );

  		this.legend.texture = new Texture( this.legend.canvas );

  		var imageData = this.legend.ctx.getImageData( 0, 0, 1, this.n );

  		var data = imageData.data;

  		this.map = ColorMapKeywords[ this.mapname ];

  		var k = 0;

  		var step = 1.0 / this.n;

  		for ( var i = 1; i >= 0; i -= step ) {

  			for ( var j = this.map.length - 1; j >= 0; j -- ) {

  				if ( i < this$1.map[ j ][ 0 ] && i >= this$1.map[ j - 1 ][ 0 ] ) {

  					var min = this$1.map[ j - 1 ][ 0 ];
  					var max = this$1.map[ j ][ 0 ];

  					var minColor = new Color( 0xffffff ).setHex( this$1.map[ j - 1 ][ 1 ] );
  					var maxColor = new Color( 0xffffff ).setHex( this$1.map[ j ][ 1 ] );

  					var color = minColor.lerp( maxColor, ( i - min ) / ( max - min ) );

  					data[ k * 4 ] = Math.round( color.r * 255 );
  					data[ k * 4 + 1 ] = Math.round( color.g * 255 );
  					data[ k * 4 + 2 ] = Math.round( color.b * 255 );
  					data[ k * 4 + 3 ] = 255;

  					k += 1;

  				}

  			}

  		}

  		this.legend.ctx.putImageData( imageData, 0, 0 );
  		this.legend.texture.needsUpdate = true;

  		this.legend.legendGeometry = new PlaneBufferGeometry( this.legend.dimensions.width, this.legend.dimensions.height );
  		this.legend.legendMaterial = new MeshBasicMaterial( { map: this.legend.texture, side: DoubleSide } );

  		this.legend.mesh = new Mesh( this.legend.legendGeometry, this.legend.legendMaterial );

  		if ( this.legend.layout == 'horizontal' ) {

  			this.legend.mesh.rotation.z = - 90 * ( Math.PI / 180 );

  		}

  		this.legend.mesh.position.copy( this.legend.position );

  		return this.legend.mesh;

  	},

  	setLegendOff: function () {

  		this.legend = null;

  		return this.legend;

  	},

  	setLegendLayout: function ( layout ) {

  		if ( ! this.legend ) {

  			return false;

  		}

  		if ( this.legend.layout == layout ) {

  			return false;

  		}

  		if ( layout != 'horizontal' && layout != 'vertical' ) {

  			return false;

  		}

  		this.layout = layout;

  		if ( layout == 'horizontal' ) {

  			this.legend.mesh.rotation.z = 90 * ( Math.PI / 180 );

  		}

  		if ( layout == 'vertical' ) {

  			this.legend.mesh.rotation.z = - 90 * ( Math.PI / 180 );

  		}

  		return this.legend.mesh;

  	},

  	setLegendPosition: function ( position ) {

  		this.legend.position = new Vector3( position.x, position.y, position.z );

  		return this.legend;

  	},

  	setLegendLabels: function ( parameters, callback ) {
  		var this$1 = this;


  		if ( ! this.legend ) {

  			return false;

  		}

  		if ( typeof parameters === 'function' ) {

  			callback = parameters;

  		}

  		if ( parameters === undefined ) {

  			parameters = {};

  		}

  		this.legend.labels = {};

  		this.legend.labels.fontsize = parameters.hasOwnProperty( 'fontsize' ) ? parameters[ 'fontsize' ] : 24;

  		this.legend.labels.fontface = parameters.hasOwnProperty( 'fontface' ) ? parameters[ 'fontface' ] : 'Arial';

  		this.legend.labels.title = parameters.hasOwnProperty( 'title' ) ? parameters[ 'title' ] : '';

  		this.legend.labels.um = parameters.hasOwnProperty( 'um' ) ? ' [ ' + parameters[ 'um' ] + ' ]' : '';

  		this.legend.labels.ticks = parameters.hasOwnProperty( 'ticks' ) ? parameters[ 'ticks' ] : 0;

  		this.legend.labels.decimal = parameters.hasOwnProperty( 'decimal' ) ? parameters[ 'decimal' ] : 2;

  		this.legend.labels.notation = parameters.hasOwnProperty( 'notation' ) ? parameters[ 'notation' ] : 'standard';

  		var backgroundColor = { r: 255, g: 100, b: 100, a: 0.8 };
  		var borderColor = { r: 255, g: 0, b: 0, a: 1.0 };
  		var borderThickness = 4;

  		var canvasTitle = document.createElement( 'canvas' );
  		var contextTitle = canvasTitle.getContext( '2d' );

  		contextTitle.font = 'Normal ' + this.legend.labels.fontsize * 1.2 + 'px ' + this.legend.labels.fontface;

  		contextTitle.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';

  		contextTitle.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';

  		contextTitle.lineWidth = borderThickness;

  		contextTitle.fillStyle = 'rgba( 0, 0, 0, 1.0 )';

  		contextTitle.fillText( this.legend.labels.title.toString() + this.legend.labels.um.toString(), borderThickness, this.legend.labels.fontsize + borderThickness );

  		var txtTitle = new CanvasTexture( canvasTitle );
  		txtTitle.minFilter = LinearFilter;

  		var spriteMaterialTitle = new SpriteMaterial( { map: txtTitle } );

  		var spriteTitle = new Sprite( spriteMaterialTitle );

  		spriteTitle.scale.set( 2, 1, 1.0 );

  		if ( this.legend.layout == 'vertical' ) {

  			spriteTitle.position.set( this.legend.position.x + this.legend.dimensions.width, this.legend.position.y + ( this.legend.dimensions.height * 0.45 ), this.legend.position.z );

  		}

  		if ( this.legend.layout == 'horizontal' ) {

  			spriteTitle.position.set( this.legend.position.x * 1.015, this.legend.position.y + ( this.legend.dimensions.height * 0.03 ), this.legend.position.z );

  		}

  		if ( this.legend.labels.ticks > 0 ) {

  			var ticks = {};
  			var lines = {};

  			if ( this.legend.layout == 'vertical' ) {

  				var topPositionY = this.legend.position.y + ( this.legend.dimensions.height * 0.36 );
  				var bottomPositionY = this.legend.position.y - ( this.legend.dimensions.height * 0.61 );

  			}

  			if ( this.legend.layout == 'horizontal' ) {

  				var topPositionX = this.legend.position.x + ( this.legend.dimensions.height * 0.75 );
  				var bottomPositionX = this.legend.position.x - ( this.legend.dimensions.width * 1.2 );

  			}

  			for ( var i = 0; i < this.legend.labels.ticks; i ++ ) {

  				var value = ( this$1.maxV - this$1.minV ) / ( this$1.legend.labels.ticks - 1 ) * i + this$1.minV;

  				if ( callback ) {

  					value = callback( value );

  				} else {

  					if ( this$1.legend.labels.notation == 'scientific' ) {

  						value = value.toExponential( this$1.legend.labels.decimal );

  					} else {

  						value = value.toFixed( this$1.legend.labels.decimal );

  					}

  				}

  				var canvasTick = document.createElement( 'canvas' );
  				var contextTick = canvasTick.getContext( '2d' );

  				contextTick.font = 'Normal ' + this$1.legend.labels.fontsize + 'px ' + this$1.legend.labels.fontface;

  				contextTick.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + backgroundColor.a + ')';

  				contextTick.strokeStyle = 'rgba(' + borderColor.r + ',' + borderColor.g + ',' + borderColor.b + ',' + borderColor.a + ')';

  				contextTick.lineWidth = borderThickness;

  				contextTick.fillStyle = 'rgba( 0, 0, 0, 1.0 )';

  				contextTick.fillText( value.toString(), borderThickness, this$1.legend.labels.fontsize + borderThickness );

  				var txtTick = new CanvasTexture( canvasTick );
  				txtTick.minFilter = LinearFilter;

  				var spriteMaterialTick = new SpriteMaterial( { map: txtTick } );

  				var spriteTick = new Sprite( spriteMaterialTick );

  				spriteTick.scale.set( 2, 1, 1.0 );

  				if ( this$1.legend.layout == 'vertical' ) {

  					var position = bottomPositionY + ( topPositionY - bottomPositionY ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) );

  					spriteTick.position.set( this$1.legend.position.x + ( this$1.legend.dimensions.width * 2.7 ), position, this$1.legend.position.z );

  				}

  				if ( this$1.legend.layout == 'horizontal' ) {

  					var position = bottomPositionX + ( topPositionX - bottomPositionX ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) );

  					if ( this$1.legend.labels.ticks > 5 ) {

  						if ( i % 2 === 0 ) {

  							var offset = 1.7;

  						} else {

  							var offset = 2.1;

  						}

  					} else {

  						var offset = 1.7;

  					}

  					spriteTick.position.set( position, this$1.legend.position.y - this$1.legend.dimensions.width * offset, this$1.legend.position.z );

  				}

  				var material = new LineBasicMaterial( { color: 0x000000, linewidth: 2 } );

  				var points = [];
  				if ( this$1.legend.layout == 'vertical' ) {

  					var linePosition = ( this$1.legend.position.y - ( this$1.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this$1.legend.dimensions.height ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) * 0.99 );

  					points.push( new Vector3( this$1.legend.position.x + this$1.legend.dimensions.width * 0.55, linePosition, this$1.legend.position.z ) );

  					points.push( new Vector3( this$1.legend.position.x + this$1.legend.dimensions.width * 0.7, linePosition, this$1.legend.position.z ) );

  				}

  				if ( this$1.legend.layout == 'horizontal' ) {

  					var linePosition = ( this$1.legend.position.x - ( this$1.legend.dimensions.height * 0.5 ) + 0.01 ) + ( this$1.legend.dimensions.height ) * ( ( value - this$1.minV ) / ( this$1.maxV - this$1.minV ) * 0.99 );

  					points.push( new Vector3( linePosition, this$1.legend.position.y - this$1.legend.dimensions.width * 0.55, this$1.legend.position.z ) );

  					points.push( new Vector3( linePosition, this$1.legend.position.y - this$1.legend.dimensions.width * 0.7, this$1.legend.position.z ) );

  				}

  				var geometry = new BufferGeometry().setFromPoints( points );

  				var line = new Line( geometry, material );

  				lines[ i ] = line;
  				ticks[ i ] = spriteTick;

  			}

  		}

  		return { 'title': spriteTitle, 'ticks': ticks, 'lines': lines };

  	}

  };
  var ColorMapKeywords = {

  	"rainbow": [[ 0.0, '0x0000FF' ], [ 0.2, '0x00FFFF' ], [ 0.5, '0x00FF00' ], [ 0.8, '0xFFFF00' ], [ 1.0, '0xFF0000' ]],
  	"cooltowarm": [[ 0.0, '0x3C4EC2' ], [ 0.2, '0x9BBCFF' ], [ 0.5, '0xDCDCDC' ], [ 0.8, '0xF6A385' ], [ 1.0, '0xB40426' ]],
  	"blackbody": [[ 0.0, '0x000000' ], [ 0.2, '0x780000' ], [ 0.5, '0xE63200' ], [ 0.8, '0xFFFF00' ], [ 1.0, '0xFFFFFF' ]],
  	"grayscale": [[ 0.0, '0x000000' ], [ 0.2, '0x404040' ], [ 0.5, '0x7F7F80' ], [ 0.8, '0xBFBFBF' ], [ 1.0, '0xFFFFFF' ]]

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MD2Character = function () {

  	var scope = this;

  	this.scale = 1;
  	this.animationFPS = 6;

  	this.root = new Object3D();

  	this.meshBody = null;
  	this.meshWeapon = null;

  	this.skinsBody = [];
  	this.skinsWeapon = [];

  	this.weapons = [];

  	this.activeAnimation = null;

  	this.mixer = null;

  	this.onLoadComplete = function () {};

  	this.loadCounter = 0;

  	this.loadParts = function ( config ) {

  		this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;

  		var weaponsTextures = [];
  		for ( var i = 0; i < config.weapons.length; i ++ ) { weaponsTextures[ i ] = config.weapons[ i ][ 1 ]; }
  		// SKINS

  		this.skinsBody = loadTextures( config.baseUrl + "skins/", config.skins );
  		this.skinsWeapon = loadTextures( config.baseUrl + "skins/", weaponsTextures );

  		// BODY

  		var loader = new MD2Loader();

  		loader.load( config.baseUrl + config.body, function ( geo ) {

  			geo.computeBoundingBox();
  			scope.root.position.y = - scope.scale * geo.boundingBox.min.y;

  			var mesh = createPart( geo, scope.skinsBody[ 0 ] );
  			mesh.scale.set( scope.scale, scope.scale, scope.scale );

  			scope.root.add( mesh );

  			scope.meshBody = mesh;

  			scope.meshBody.clipOffset = 0;
  			scope.activeAnimationClipName = mesh.geometry.animations[ 0 ].name;

  			scope.mixer = new AnimationMixer( mesh );

  			checkLoadingComplete();

  		} );

  		// WEAPONS

  		var generateCallback = function ( index, name ) {

  			return function ( geo ) {

  				var mesh = createPart( geo, scope.skinsWeapon[ index ] );
  				mesh.scale.set( scope.scale, scope.scale, scope.scale );
  				mesh.visible = false;

  				mesh.name = name;

  				scope.root.add( mesh );

  				scope.weapons[ index ] = mesh;
  				scope.meshWeapon = mesh;

  				checkLoadingComplete();

  			};

  		};

  		for ( var i = 0; i < config.weapons.length; i ++ ) {

  			loader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );

  		}

  	};

  	this.setPlaybackRate = function ( rate ) {

  		if ( rate !== 0 ) {

  			this.mixer.timeScale = 1 / rate;

  		} else {

  			this.mixer.timeScale = 0;

  		}

  	};

  	this.setWireframe = function ( wireframeEnabled ) {

  		if ( wireframeEnabled ) {

  			if ( this.meshBody ) { this.meshBody.material = this.meshBody.materialWireframe; }
  			if ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialWireframe; }

  		} else {

  			if ( this.meshBody ) { this.meshBody.material = this.meshBody.materialTexture; }
  			if ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialTexture; }

  		}

  	};

  	this.setSkin = function ( index ) {

  		if ( this.meshBody && this.meshBody.material.wireframe === false ) {

  			this.meshBody.material.map = this.skinsBody[ index ];

  		}

  	};

  	this.setWeapon = function ( index ) {
  		var this$1 = this;


  		for ( var i = 0; i < this.weapons.length; i ++ ) { this$1.weapons[ i ].visible = false; }

  		var activeWeapon = this.weapons[ index ];

  		if ( activeWeapon ) {

  			activeWeapon.visible = true;
  			this.meshWeapon = activeWeapon;

  			scope.syncWeaponAnimation();

  		}

  	};

  	this.setAnimation = function ( clipName ) {

  		if ( this.meshBody ) {

  			if ( this.meshBody.activeAction ) {

  				this.meshBody.activeAction.stop();
  				this.meshBody.activeAction = null;

  			}

  			var action = this.mixer.clipAction( clipName, this.meshBody );

  			if ( action ) {

  				this.meshBody.activeAction = action.play();

  			}

  		}

  		scope.activeClipName = clipName;

  		scope.syncWeaponAnimation();

  	};

  	this.syncWeaponAnimation = function () {

  		var clipName = scope.activeClipName;

  		if ( scope.meshWeapon ) {

  			if ( this.meshWeapon.activeAction ) {

  				this.meshWeapon.activeAction.stop();
  				this.meshWeapon.activeAction = null;

  			}

  			var action = this.mixer.clipAction( clipName, this.meshWeapon );

  			if ( action ) {

  				this.meshWeapon.activeAction = action.syncWith( this.meshBody.activeAction ).play();

  			}

  		}

  	};

  	this.update = function ( delta ) {

  		if ( this.mixer ) { this.mixer.update( delta ); }

  	};

  	function loadTextures( baseUrl, textureUrls ) {

  		var textureLoader = new TextureLoader();
  		var textures = [];

  		for ( var i = 0; i < textureUrls.length; i ++ ) {

  			textures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );
  			textures[ i ].mapping = UVMapping;
  			textures[ i ].name = textureUrls[ i ];

  		}

  		return textures;

  	}

  	function createPart( geometry, skinMap ) {

  		var materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true, morphTargets: true, morphNormals: true } );
  		var materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap, morphTargets: true, morphNormals: true } );

  		//

  		var mesh = new Mesh( geometry, materialTexture );
  		mesh.rotation.y = - Math.PI / 2;

  		mesh.castShadow = true;
  		mesh.receiveShadow = true;

  		//

  		mesh.materialTexture = materialTexture;
  		mesh.materialWireframe = materialWireframe;

  		return mesh;

  	}

  	function checkLoadingComplete() {

  		scope.loadCounter -= 1;

  		if ( scope.loadCounter === 0 ) { scope.onLoadComplete(); }

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MorphBlendMesh = function ( geometry, material ) {

  	Mesh.call( this, geometry, material );

  	this.animationsMap = {};
  	this.animationsList = [];

  	// prepare default animation
  	// (all frames played together in 1 second)

  	var numFrames = Object.keys( this.morphTargetDictionary ).length;

  	var name = '__default';

  	var startFrame = 0;
  	var endFrame = numFrames - 1;

  	var fps = numFrames / 1;

  	this.createAnimation( name, startFrame, endFrame, fps );
  	this.setAnimationWeight( name, 1 );

  };

  MorphBlendMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: MorphBlendMesh,

  	createAnimation: function ( name, start, end, fps ) {

  		var animation = {

  			start: start,
  			end: end,

  			length: end - start + 1,

  			fps: fps,
  			duration: ( end - start ) / fps,

  			lastFrame: 0,
  			currentFrame: 0,

  			active: false,

  			time: 0,
  			direction: 1,
  			weight: 1,

  			directionBackwards: false,
  			mirroredLoop: false

  		};

  		this.animationsMap[ name ] = animation;
  		this.animationsList.push( animation );

  	},

  	autoCreateAnimations: function ( fps ) {
  		var this$1 = this;


  		var pattern = /([a-z]+)_?(\d+)/i;

  		var firstAnimation, frameRanges = {};

  		var i = 0;

  		for ( var key in this$1.morphTargetDictionary ) {

  			var chunks = key.match( pattern );

  			if ( chunks && chunks.length > 1 ) {

  				var name = chunks[ 1 ];

  				if ( ! frameRanges[ name ] ) { frameRanges[ name ] = { start: Infinity, end: - Infinity }; }

  				var range = frameRanges[ name ];

  				if ( i < range.start ) { range.start = i; }
  				if ( i > range.end ) { range.end = i; }

  				if ( ! firstAnimation ) { firstAnimation = name; }

  			}

  			i ++;

  		}

  		for ( var name in frameRanges ) {

  			var range = frameRanges[ name ];
  			this$1.createAnimation( name, range.start, range.end, fps );

  		}

  		this.firstAnimation = firstAnimation;

  	},

  	setAnimationDirectionForward: function ( name ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.direction = 1;
  			animation.directionBackwards = false;

  		}

  	},

  	setAnimationDirectionBackward: function ( name ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.direction = - 1;
  			animation.directionBackwards = true;

  		}

  	},

  	setAnimationFPS: function ( name, fps ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.fps = fps;
  			animation.duration = ( animation.end - animation.start ) / animation.fps;

  		}

  	},

  	setAnimationDuration: function ( name, duration ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.duration = duration;
  			animation.fps = ( animation.end - animation.start ) / animation.duration;

  		}

  	},

  	setAnimationWeight: function ( name, weight ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.weight = weight;

  		}

  	},

  	setAnimationTime: function ( name, time ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.time = time;

  		}

  	},

  	getAnimationTime: function ( name ) {

  		var time = 0;

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			time = animation.time;

  		}

  		return time;

  	},

  	getAnimationDuration: function ( name ) {

  		var duration = - 1;

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			duration = animation.duration;

  		}

  		return duration;

  	},

  	playAnimation: function ( name ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.time = 0;
  			animation.active = true;

  		} else {

  			console.warn( "MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  		}

  	},

  	stopAnimation: function ( name ) {

  		var animation = this.animationsMap[ name ];

  		if ( animation ) {

  			animation.active = false;

  		}

  	},

  	update: function ( delta ) {
  		var this$1 = this;


  		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

  			var animation = this$1.animationsList[ i ];

  			if ( ! animation.active ) { continue; }

  			var frameTime = animation.duration / animation.length;

  			animation.time += animation.direction * delta;

  			if ( animation.mirroredLoop ) {

  				if ( animation.time > animation.duration || animation.time < 0 ) {

  					animation.direction *= - 1;

  					if ( animation.time > animation.duration ) {

  						animation.time = animation.duration;
  						animation.directionBackwards = true;

  					}

  					if ( animation.time < 0 ) {

  						animation.time = 0;
  						animation.directionBackwards = false;

  					}

  				}

  			} else {

  				animation.time = animation.time % animation.duration;

  				if ( animation.time < 0 ) { animation.time += animation.duration; }

  			}

  			var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
  			var weight = animation.weight;

  			if ( keyframe !== animation.currentFrame ) {

  				this$1.morphTargetInfluences[ animation.lastFrame ] = 0;
  				this$1.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

  				this$1.morphTargetInfluences[ keyframe ] = 0;

  				animation.lastFrame = animation.currentFrame;
  				animation.currentFrame = keyframe;

  			}

  			var mix = ( animation.time % frameTime ) / frameTime;

  			if ( animation.directionBackwards ) { mix = 1 - mix; }

  			if ( animation.currentFrame !== animation.lastFrame ) {

  				this$1.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
  				this$1.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

  			} else {

  				this$1.morphTargetInfluences[ animation.currentFrame ] = weight;

  			}

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MD2CharacterComplex = function () {

  	var scope = this;

  	this.scale = 1;

  	// animation parameters

  	this.animationFPS = 6;
  	this.transitionFrames = 15;

  	// movement model parameters

  	this.maxSpeed = 275;
  	this.maxReverseSpeed = - 275;

  	this.frontAcceleration = 600;
  	this.backAcceleration = 600;

  	this.frontDecceleration = 600;

  	this.angularSpeed = 2.5;

  	// rig

  	this.root = new Object3D();

  	this.meshBody = null;
  	this.meshWeapon = null;

  	this.controls = null;

  	// skins

  	this.skinsBody = [];
  	this.skinsWeapon = [];

  	this.weapons = [];

  	this.currentSkin = undefined;

  	//

  	this.onLoadComplete = function () {};

  	// internals

  	this.meshes = [];
  	this.animations = {};

  	this.loadCounter = 0;

  	// internal movement control variables

  	this.speed = 0;
  	this.bodyOrientation = 0;

  	this.walkSpeed = this.maxSpeed;
  	this.crouchSpeed = this.maxSpeed * 0.5;

  	// internal animation parameters

  	this.activeAnimation = null;
  	this.oldAnimation = null;

  	// API

  	this.enableShadows = function ( enable ) {
  		var this$1 = this;


  		for ( var i = 0; i < this.meshes.length; i ++ ) {

  			this$1.meshes[ i ].castShadow = enable;
  			this$1.meshes[ i ].receiveShadow = enable;

  		}

  	};

  	this.setVisible = function ( enable ) {
  		var this$1 = this;


  		for ( var i = 0; i < this.meshes.length; i ++ ) {

  			this$1.meshes[ i ].visible = enable;
  			this$1.meshes[ i ].visible = enable;

  		}

  	};
  	this.shareParts = function ( original ) {
  		var this$1 = this;


  		this.animations = original.animations;
  		this.walkSpeed = original.walkSpeed;
  		this.crouchSpeed = original.crouchSpeed;

  		this.skinsBody = original.skinsBody;
  		this.skinsWeapon = original.skinsWeapon;

  		// BODY

  		var mesh = createPart( original.meshBody.geometry, this.skinsBody[ 0 ] );
  		mesh.scale.set( this.scale, this.scale, this.scale );

  		this.root.position.y = original.root.position.y;
  		this.root.add( mesh );

  		this.meshBody = mesh;

  		this.meshes.push( mesh );

  		// WEAPONS

  		for ( var i = 0; i < original.weapons.length; i ++ ) {

  			var meshWeapon = createPart( original.weapons[ i ].geometry, this$1.skinsWeapon[ i ] );
  			meshWeapon.scale.set( this$1.scale, this$1.scale, this$1.scale );
  			meshWeapon.visible = false;

  			meshWeapon.name = original.weapons[ i ].name;

  			this$1.root.add( meshWeapon );

  			this$1.weapons[ i ] = meshWeapon;
  			this$1.meshWeapon = meshWeapon;

  			this$1.meshes.push( meshWeapon );

  		}

  	};

  	this.loadParts = function ( config ) {

  		this.animations = config.animations;
  		this.walkSpeed = config.walkSpeed;
  		this.crouchSpeed = config.crouchSpeed;

  		this.loadCounter = config.weapons.length * 2 + config.skins.length + 1;

  		var weaponsTextures = [];
  		for ( var i = 0; i < config.weapons.length; i ++ ) { weaponsTextures[ i ] = config.weapons[ i ][ 1 ]; }

  		// SKINS

  		this.skinsBody = loadTextures( config.baseUrl + "skins/", config.skins );
  		this.skinsWeapon = loadTextures( config.baseUrl + "skins/", weaponsTextures );

  		// BODY

  		var loader = new MD2Loader();

  		loader.load( config.baseUrl + config.body, function( geo ) {

  			geo.computeBoundingBox();
  			scope.root.position.y = - scope.scale * geo.boundingBox.min.y;

  			var mesh = createPart( geo, scope.skinsBody[ 0 ] );
  			mesh.scale.set( scope.scale, scope.scale, scope.scale );

  			scope.root.add( mesh );

  			scope.meshBody = mesh;
  			scope.meshes.push( mesh );

  			checkLoadingComplete();

  		} );

  		// WEAPONS

  		var generateCallback = function ( index, name ) {

  			return function( geo ) {

  				var mesh = createPart( geo, scope.skinsWeapon[ index ] );
  				mesh.scale.set( scope.scale, scope.scale, scope.scale );
  				mesh.visible = false;

  				mesh.name = name;

  				scope.root.add( mesh );

  				scope.weapons[ index ] = mesh;
  				scope.meshWeapon = mesh;
  				scope.meshes.push( mesh );

  				checkLoadingComplete();

  			}

  		};

  		for ( var i = 0; i < config.weapons.length; i ++ ) {

  			loader.load( config.baseUrl + config.weapons[ i ][ 0 ], generateCallback( i, config.weapons[ i ][ 0 ] ) );

  		}

  	};

  	this.setPlaybackRate = function ( rate ) {

  		if ( this.meshBody ) { this.meshBody.duration = this.meshBody.baseDuration / rate; }
  		if ( this.meshWeapon ) { this.meshWeapon.duration = this.meshWeapon.baseDuration / rate; }

  	};

  	this.setWireframe = function ( wireframeEnabled ) {

  		if ( wireframeEnabled ) {

  			if ( this.meshBody ) { this.meshBody.material = this.meshBody.materialWireframe; }
  			if ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialWireframe; }

  		} else {

  			if ( this.meshBody ) { this.meshBody.material = this.meshBody.materialTexture; }
  			if ( this.meshWeapon ) { this.meshWeapon.material = this.meshWeapon.materialTexture; }

  		}

  	};

  	this.setSkin = function( index ) {

  		if ( this.meshBody && this.meshBody.material.wireframe === false ) {

  			this.meshBody.material.map = this.skinsBody[ index ];
  			this.currentSkin = index;

  		}

  	};

  	this.setWeapon = function ( index ) {
  		var this$1 = this;


  		for ( var i = 0; i < this.weapons.length; i ++ ) { this$1.weapons[ i ].visible = false; }

  		var activeWeapon = this.weapons[ index ];

  		if ( activeWeapon ) {

  			activeWeapon.visible = true;
  			this.meshWeapon = activeWeapon;

  			if ( this.activeAnimation ) {

  				activeWeapon.playAnimation( this.activeAnimation );
  				this.meshWeapon.setAnimationTime( this.activeAnimation, this.meshBody.getAnimationTime( this.activeAnimation ) );

  			}

  		}

  	};

  	this.setAnimation = function ( animationName ) {

  		if ( animationName === this.activeAnimation || ! animationName ) { return; }

  		if ( this.meshBody ) {

  			this.meshBody.setAnimationWeight( animationName, 0 );
  			this.meshBody.playAnimation( animationName );

  			this.oldAnimation = this.activeAnimation;
  			this.activeAnimation = animationName;

  			this.blendCounter = this.transitionFrames;

  		}

  		if ( this.meshWeapon ) {

  			this.meshWeapon.setAnimationWeight( animationName, 0 );
  			this.meshWeapon.playAnimation( animationName );

  		}
  	};

  	this.update = function ( delta ) {

  		if ( this.controls ) { this.updateMovementModel( delta ); }

  		if ( this.animations ) {

  			this.updateBehaviors( delta );
  			this.updateAnimations( delta );

  		}

  	};

  	this.updateAnimations = function ( delta ) {

  		var mix = 1;

  		if ( this.blendCounter > 0 ) {

  			mix = ( this.transitionFrames - this.blendCounter ) / this.transitionFrames;
  			this.blendCounter -= 1;

  		}

  		if ( this.meshBody ) {

  			this.meshBody.update( delta );

  			this.meshBody.setAnimationWeight( this.activeAnimation, mix );
  			this.meshBody.setAnimationWeight( this.oldAnimation,  1 - mix );

  		}

  		if ( this.meshWeapon ) {

  			this.meshWeapon.update( delta );

  			this.meshWeapon.setAnimationWeight( this.activeAnimation, mix );
  			this.meshWeapon.setAnimationWeight( this.oldAnimation,  1 - mix );

  		}

  	};

  	this.updateBehaviors = function ( delta ) {

  		var controls = this.controls;
  		var animations = this.animations;

  		var moveAnimation, idleAnimation;

  		// crouch vs stand

  		if ( controls.crouch ) {

  			moveAnimation = animations[ "crouchMove" ];
  			idleAnimation = animations[ "crouchIdle" ];

  		} else {

  			moveAnimation = animations[ "move" ];
  			idleAnimation = animations[ "idle" ];

  		}

  		// actions

  		if ( controls.jump ) {

  			moveAnimation = animations[ "jump" ];
  			idleAnimation = animations[ "jump" ];

  		}

  		if ( controls.attack ) {

  			if ( controls.crouch ) {

  				moveAnimation = animations[ "crouchAttack" ];
  				idleAnimation = animations[ "crouchAttack" ];

  			} else {

  				moveAnimation = animations[ "attack" ];
  				idleAnimation = animations[ "attack" ];

  			}

  		}

  		// set animations

  		if ( controls.moveForward || controls.moveBackward || controls.moveLeft || controls.moveRight ) {

  			if ( this.activeAnimation !== moveAnimation ) {

  				this.setAnimation( moveAnimation );

  			}

  		}
  		if ( Math.abs( this.speed ) < 0.2 * this.maxSpeed && ! ( controls.moveLeft || controls.moveRight || controls.moveForward || controls.moveBackward ) ) {

  			if ( this.activeAnimation !== idleAnimation ) {

  				this.setAnimation( idleAnimation );

  			}

  		}

  		// set animation direction

  		if ( controls.moveForward ) {

  			if ( this.meshBody ) {

  				this.meshBody.setAnimationDirectionForward( this.activeAnimation );
  				this.meshBody.setAnimationDirectionForward( this.oldAnimation );

  			}

  			if ( this.meshWeapon ) {

  				this.meshWeapon.setAnimationDirectionForward( this.activeAnimation );
  				this.meshWeapon.setAnimationDirectionForward( this.oldAnimation );

  			}

  		}

  		if ( controls.moveBackward ) {

  			if ( this.meshBody ) {

  				this.meshBody.setAnimationDirectionBackward( this.activeAnimation );
  				this.meshBody.setAnimationDirectionBackward( this.oldAnimation );

  			}

  			if ( this.meshWeapon ) {

  				this.meshWeapon.setAnimationDirectionBackward( this.activeAnimation );
  				this.meshWeapon.setAnimationDirectionBackward( this.oldAnimation );

  			}

  		}

  	};

  	this.updateMovementModel = function ( delta ) {

  		var controls = this.controls;

  		// speed based on controls

  		if ( controls.crouch ) 	{ this.maxSpeed = this.crouchSpeed; }
  		else { this.maxSpeed = this.walkSpeed; }

  		this.maxReverseSpeed = - this.maxSpeed;

  		if ( controls.moveForward )  { this.speed = _Math.clamp( this.speed + delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed ); }
  		if ( controls.moveBackward ) { this.speed = _Math.clamp( this.speed - delta * this.backAcceleration, this.maxReverseSpeed, this.maxSpeed ); }

  		// orientation based on controls
  		// (don't just stand while turning)

  		var dir = 1;

  		if ( controls.moveLeft ) {

  			this.bodyOrientation += delta * this.angularSpeed;
  			this.speed = _Math.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );

  		}

  		if ( controls.moveRight ) {

  			this.bodyOrientation -= delta * this.angularSpeed;
  			this.speed = _Math.clamp( this.speed + dir * delta * this.frontAcceleration, this.maxReverseSpeed, this.maxSpeed );

  		}

  		// speed decay

  		if ( ! ( controls.moveForward || controls.moveBackward ) ) {

  			if ( this.speed > 0 ) {

  				var k = exponentialEaseOut( this.speed / this.maxSpeed );
  				this.speed = _Math.clamp( this.speed - k * delta * this.frontDecceleration, 0, this.maxSpeed );

  			} else {

  				var k = exponentialEaseOut( this.speed / this.maxReverseSpeed );
  				this.speed = _Math.clamp( this.speed + k * delta * this.backAcceleration, this.maxReverseSpeed, 0 );

  			}

  		}

  		// displacement

  		var forwardDelta = this.speed * delta;

  		this.root.position.x += Math.sin( this.bodyOrientation ) * forwardDelta;
  		this.root.position.z += Math.cos( this.bodyOrientation ) * forwardDelta;

  		// steering

  		this.root.rotation.y = this.bodyOrientation;

  	};

  	// internal helpers

  	function loadTextures( baseUrl, textureUrls ) {

  		var textureLoader = new TextureLoader();
  		var textures = [];

  		for ( var i = 0; i < textureUrls.length; i ++ ) {

  			textures[ i ] = textureLoader.load( baseUrl + textureUrls[ i ], checkLoadingComplete );
  			textures[ i ].mapping = UVMapping;
  			textures[ i ].name = textureUrls[ i ];

  		}

  		return textures;

  	}

  	function createPart( geometry, skinMap ) {

  		var materialWireframe = new MeshLambertMaterial( { color: 0xffaa00, wireframe: true, morphTargets: true, morphNormals: true } );
  		var materialTexture = new MeshLambertMaterial( { color: 0xffffff, wireframe: false, map: skinMap, morphTargets: true, morphNormals: true } );

  		//

  		var mesh = new MorphBlendMesh( geometry, materialTexture );
  		mesh.rotation.y = - Math.PI / 2;

  		//

  		mesh.materialTexture = materialTexture;
  		mesh.materialWireframe = materialWireframe;

  		//

  		mesh.autoCreateAnimations( scope.animationFPS );

  		return mesh;

  	}

  	function checkLoadingComplete() {

  		scope.loadCounter -= 1;
  		if ( scope.loadCounter === 0 ) 	{ scope.onLoadComplete(); }

  	}

  	function exponentialEaseOut( k ) {

  		return k === 1 ? 1 : - Math.pow( 2, - 10 * k ) + 1;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ExplodeModifier = function () {

  };

  ExplodeModifier.prototype.modify = function ( geometry ) {

  	var vertices = [];

  	for ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {

  		var n = vertices.length;

  		var face = geometry.faces[ i ];

  		var a = face.a;
  		var b = face.b;
  		var c = face.c;

  		var va = geometry.vertices[ a ];
  		var vb = geometry.vertices[ b ];
  		var vc = geometry.vertices[ c ];

  		vertices.push( va.clone() );
  		vertices.push( vb.clone() );
  		vertices.push( vc.clone() );

  		face.a = n;
  		face.b = n + 1;
  		face.c = n + 2;

  	}

  	geometry.vertices = vertices;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SimplifyModifier = function () {};

  ( function () {

  	var cb = new Vector3(), ab = new Vector3();

  	function pushIfUnique( array, object ) {

  		if ( array.indexOf( object ) === - 1 ) { array.push( object ); }

  	}

  	function removeFromArray( array, object ) {

  		var k = array.indexOf( object );
  		if ( k > - 1 ) { array.splice( k, 1 ); }

  	}

  	function computeEdgeCollapseCost( u, v ) {

  		// if we collapse edge uv by moving u to v then how
  		// much different will the model change, i.e. the "error".

  		var edgelength = v.position.distanceTo( u.position );
  		var curvature = 0;

  		var sideFaces = [];
  		var i, il = u.faces.length, face, sideFace;

  		// find the "sides" triangles that are on the edge uv
  		for ( i = 0; i < il; i ++ ) {

  			face = u.faces[ i ];

  			if ( face.hasVertex( v ) ) {

  				sideFaces.push( face );

  			}

  		}

  		// use the triangle facing most away from the sides
  		// to determine our curvature term
  		for ( i = 0; i < il; i ++ ) {

  			var minCurvature = 1;
  			face = u.faces[ i ];

  			for ( var j = 0; j < sideFaces.length; j ++ ) {

  				sideFace = sideFaces[ j ];
  				// use dot product of face normals.
  				var dotProd = face.normal.dot( sideFace.normal );
  				minCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );

  			}

  			curvature = Math.max( curvature, minCurvature );

  		}

  		// crude approach in attempt to preserve borders
  		// though it seems not to be totally correct
  		var borders = 0;
  		if ( sideFaces.length < 2 ) {

  			// we add some arbitrary cost for borders,
  			// borders += 10;
  			curvature = 1;

  		}

  		var amt = edgelength * curvature + borders;

  		return amt;

  	}

  	function computeEdgeCostAtVertex( v ) {

  		// compute the edge collapse cost for all edges that start
  		// from vertex v.  Since we are only interested in reducing
  		// the object by selecting the min cost edge at each step, we
  		// only cache the cost of the least cost edge at this vertex
  		// (in member variable collapse) as well as the value of the
  		// cost (in member variable collapseCost).

  		if ( v.neighbors.length === 0 ) {

  			// collapse if no neighbors.
  			v.collapseNeighbor = null;
  			v.collapseCost = - 0.01;

  			return;

  		}

  		v.collapseCost = 100000;
  		v.collapseNeighbor = null;

  		// search all neighboring edges for "least cost" edge
  		for ( var i = 0; i < v.neighbors.length; i ++ ) {

  			var collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );

  			if ( ! v.collapseNeighbor ) {

  				v.collapseNeighbor = v.neighbors[ i ];
  				v.collapseCost = collapseCost;
  				v.minCost = collapseCost;
  				v.totalCost = 0;
  				v.costCount = 0;

  			}

  			v.costCount ++;
  			v.totalCost += collapseCost;

  			if ( collapseCost < v.minCost ) {

  				v.collapseNeighbor = v.neighbors[ i ];
  				v.minCost = collapseCost;

  			}

  		}

  		// we average the cost of collapsing at this vertex
  		v.collapseCost = v.totalCost / v.costCount;
  		// v.collapseCost = v.minCost;

  	}

  	function removeVertex( v, vertices ) {

  		console.assert( v.faces.length === 0 );

  		while ( v.neighbors.length ) {

  			var n = v.neighbors.pop();
  			removeFromArray( n.neighbors, v );

  		}

  		removeFromArray( vertices, v );

  	}

  	function removeFace( f, faces ) {

  		removeFromArray( faces, f );

  		if ( f.v1 ) { removeFromArray( f.v1.faces, f ); }
  		if ( f.v2 ) { removeFromArray( f.v2.faces, f ); }
  		if ( f.v3 ) { removeFromArray( f.v3.faces, f ); }

  		// TODO optimize this!
  		var vs = [ f.v1, f.v2, f.v3 ];
  		var v1, v2;

  		for ( var i = 0; i < 3; i ++ ) {

  			v1 = vs[ i ];
  			v2 = vs[ ( i + 1 ) % 3 ];

  			if ( ! v1 || ! v2 ) { continue; }

  			v1.removeIfNonNeighbor( v2 );
  			v2.removeIfNonNeighbor( v1 );

  		}

  	}

  	function collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge

  		// Collapse the edge uv by moving vertex u onto v

  		if ( ! v ) {

  			// u is a vertex all by itself so just delete it..
  			removeVertex( u, vertices );
  			return;

  		}

  		var i;
  		var tmpVertices = [];

  		for ( i = 0; i < u.neighbors.length; i ++ ) {

  			tmpVertices.push( u.neighbors[ i ] );

  		}
  		// delete triangles on edge uv:
  		for ( i = u.faces.length - 1; i >= 0; i -- ) {

  			if ( u.faces[ i ].hasVertex( v ) ) {

  				removeFace( u.faces[ i ], faces );

  			}

  		}

  		// update remaining triangles to have v instead of u
  		for ( i = u.faces.length - 1; i >= 0; i -- ) {

  			u.faces[ i ].replaceVertex( u, v );

  		}
  		removeVertex( u, vertices );

  		// recompute the edge collapse costs in neighborhood
  		for ( i = 0; i < tmpVertices.length; i ++ ) {

  			computeEdgeCostAtVertex( tmpVertices[ i ] );

  		}

  	}
  	function minimumCostEdge( vertices ) {

  		// O(n * n) approach. TODO optimize this

  		var least = vertices[ 0 ];

  		for ( var i = 0; i < vertices.length; i ++ ) {

  			if ( vertices[ i ].collapseCost < least.collapseCost ) {

  				least = vertices[ i ];

  			}

  		}

  		return least;

  	}

  	// we use a triangle class to represent structure of face slightly differently

  	function Triangle( v1, v2, v3, a, b, c ) {

  		this.a = a;
  		this.b = b;
  		this.c = c;

  		this.v1 = v1;
  		this.v2 = v2;
  		this.v3 = v3;

  		this.normal = new Vector3();

  		this.computeNormal();

  		v1.faces.push( this );
  		v1.addUniqueNeighbor( v2 );
  		v1.addUniqueNeighbor( v3 );

  		v2.faces.push( this );
  		v2.addUniqueNeighbor( v1 );
  		v2.addUniqueNeighbor( v3 );
  		v3.faces.push( this );
  		v3.addUniqueNeighbor( v1 );
  		v3.addUniqueNeighbor( v2 );

  	}

  	Triangle.prototype.computeNormal = function () {

  		var vA = this.v1.position;
  		var vB = this.v2.position;
  		var vC = this.v3.position;

  		cb.subVectors( vC, vB );
  		ab.subVectors( vA, vB );
  		cb.cross( ab ).normalize();

  		this.normal.copy( cb );

  	};

  	Triangle.prototype.hasVertex = function ( v ) {

  		return v === this.v1 || v === this.v2 || v === this.v3;

  	};

  	Triangle.prototype.replaceVertex = function ( oldv, newv ) {

  		if ( oldv === this.v1 ) { this.v1 = newv; }
  		else if ( oldv === this.v2 ) { this.v2 = newv; }
  		else if ( oldv === this.v3 ) { this.v3 = newv; }

  		removeFromArray( oldv.faces, this );
  		newv.faces.push( this );
  		oldv.removeIfNonNeighbor( this.v1 );
  		this.v1.removeIfNonNeighbor( oldv );

  		oldv.removeIfNonNeighbor( this.v2 );
  		this.v2.removeIfNonNeighbor( oldv );

  		oldv.removeIfNonNeighbor( this.v3 );
  		this.v3.removeIfNonNeighbor( oldv );

  		this.v1.addUniqueNeighbor( this.v2 );
  		this.v1.addUniqueNeighbor( this.v3 );

  		this.v2.addUniqueNeighbor( this.v1 );
  		this.v2.addUniqueNeighbor( this.v3 );

  		this.v3.addUniqueNeighbor( this.v1 );
  		this.v3.addUniqueNeighbor( this.v2 );

  		this.computeNormal();

  	};

  	function Vertex( v, id ) {

  		this.position = v;

  		this.id = id; // old index id

  		this.faces = []; // faces vertex is connected
  		this.neighbors = []; // neighbouring vertices aka "adjacentVertices"

  		// these will be computed in computeEdgeCostAtVertex()
  		this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist
  		this.collapseNeighbor = null; // best candinate for collapsing

  	}

  	Vertex.prototype.addUniqueNeighbor = function ( vertex ) {

  		pushIfUnique( this.neighbors, vertex );

  	};

  	Vertex.prototype.removeIfNonNeighbor = function ( n ) {

  		var neighbors = this.neighbors;
  		var faces = this.faces;

  		var offset = neighbors.indexOf( n );
  		if ( offset === - 1 ) { return; }
  		for ( var i = 0; i < faces.length; i ++ ) {

  			if ( faces[ i ].hasVertex( n ) ) { return; }

  		}

  		neighbors.splice( offset, 1 );

  	};

  	SimplifyModifier.prototype.modify = function ( geometry, count ) {

  		if ( geometry.isBufferGeometry ) {

  			geometry = new Geometry().fromBufferGeometry( geometry );

  		}

  		geometry.mergeVertices();

  		var oldVertices = geometry.vertices; // Three Position
  		var oldFaces = geometry.faces; // Three Face

  		// conversion
  		var vertices = [];
  		var faces = [];

  		var i, il;

  		//
  		// put data of original geometry in different data structures
  		//

  		// add vertices

  		for ( i = 0, il = oldVertices.length; i < il; i ++ ) {

  			var vertex = new Vertex( oldVertices[ i ], i );
  			vertices.push( vertex );

  		}

  		// add faces

  		for ( i = 0, il = oldFaces.length; i < il; i ++ ) {

  			var face = oldFaces[ i ];

  			var a = face.a;
  			var b = face.b;
  			var c = face.c;

  			var triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );
  			faces.push( triangle );

  		}

  		// compute all edge collapse costs

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			computeEdgeCostAtVertex( vertices[ i ] );

  		}

  		var nextVertex;

  		var z = count;

  		while ( z -- ) {

  			nextVertex = minimumCostEdge( vertices );

  			if ( ! nextVertex ) {

  				console.log( 'SimplifyModifier: No next vertex' );
  				break;

  			}

  			collapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );

  		}

  		//

  		var simplifiedGeometry = new BufferGeometry();
  		var position = [];
  		var index = [];

  		//

  		for ( i = 0; i < vertices.length; i ++ ) {

  			var vertex = vertices[ i ].position;
  			position.push( vertex.x, vertex.y, vertex.z );

  		}

  		//

  		for ( i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			var a = vertices.indexOf( face.v1 );
  			var b = vertices.indexOf( face.v2 );
  			var c = vertices.indexOf( face.v3 );

  			index.push( a, b, c );

  		}

  		//

  		simplifiedGeometry.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
  		simplifiedGeometry.setIndex( index );

  		return simplifiedGeometry;

  	};

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SubdivisionModifier = function ( subdivisions ) {

  	this.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;

  };

  // Applies the "modify" pattern
  SubdivisionModifier.prototype.modify = function ( geometry ) {
  	var this$1 = this;


  	if ( geometry.isBufferGeometry ) {

  		geometry = new Geometry().fromBufferGeometry( geometry );

  	} else {

  		geometry = geometry.clone();

  	}

  	geometry.mergeVertices();

  	var repeats = this.subdivisions;

  	while ( repeats -- > 0 ) {

  		this$1.smooth( geometry );

  	}

  	geometry.computeFaceNormals();
  	geometry.computeVertexNormals();

  	return geometry;

  };

  ( function () {
  	var ABC = [ 'a', 'b', 'c' ];
  	function getEdge( a, b, map ) {

  		var vertexIndexA = Math.min( a, b );
  		var vertexIndexB = Math.max( a, b );

  		var key = vertexIndexA + "_" + vertexIndexB;

  		return map[ key ];

  	}
  	function processEdge( a, b, vertices, map, face, metaVertices ) {

  		var vertexIndexA = Math.min( a, b );
  		var vertexIndexB = Math.max( a, b );

  		var key = vertexIndexA + "_" + vertexIndexB;

  		var edge;

  		if ( key in map ) {

  			edge = map[ key ];

  		} else {

  			var vertexA = vertices[ vertexIndexA ];
  			var vertexB = vertices[ vertexIndexB ];

  			edge = {

  				a: vertexA, // pointer reference
  				b: vertexB,
  				newEdge: null,
  				// aIndex: a, // numbered reference
  				// bIndex: b,
  				faces: [] // pointers to face

  			};

  			map[ key ] = edge;

  		}

  		edge.faces.push( face );

  		metaVertices[ a ].edges.push( edge );
  		metaVertices[ b ].edges.push( edge );
  	}

  	function generateLookups( vertices, faces, metaVertices, edges ) {

  		var i, il, face;

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			metaVertices[ i ] = { edges: [] };

  		}

  		for ( i = 0, il = faces.length; i < il; i ++ ) {

  			face = faces[ i ];

  			processEdge( face.a, face.b, vertices, edges, face, metaVertices );
  			processEdge( face.b, face.c, vertices, edges, face, metaVertices );
  			processEdge( face.c, face.a, vertices, edges, face, metaVertices );

  		}

  	}

  	function newFace( newFaces, a, b, c, materialIndex ) {

  		newFaces.push( new Face3( a, b, c, undefined, undefined, materialIndex ) );

  	}

  	function midpoint( a, b ) {

  		return ( Math.abs( b - a ) / 2 ) + Math.min( a, b );

  	}

  	function newUv( newUvs, a, b, c ) {

  		newUvs.push( [ a.clone(), b.clone(), c.clone() ] );

  	}

  	/////////////////////////////

  	// Performs one iteration of Subdivision
  	SubdivisionModifier.prototype.smooth = function ( geometry ) {

  		var tmp = new Vector3();

  		var oldVertices, oldFaces, oldUvs;
  		var newVertices, newFaces, newUVs = [];

  		var n, i, il, j, k;
  		var metaVertices, sourceEdges;

  		// new stuff.
  		var sourceEdges, newEdgeVertices, newSourceVertices;

  		oldVertices = geometry.vertices; // { x, y, z}
  		oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }
  		oldUvs = geometry.faceVertexUvs[ 0 ];

  		var hasUvs = oldUvs !== undefined && oldUvs.length > 0;
  		metaVertices = new Array( oldVertices.length );
  		sourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }

  		generateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );
  		newEdgeVertices = [];
  		var other, currentEdge, newEdge, face;
  		var edgeVertexWeight, adjacentVertexWeight, connectedFaces;

  		for ( i in sourceEdges ) {

  			currentEdge = sourceEdges[ i ];
  			newEdge = new Vector3();

  			edgeVertexWeight = 3 / 8;
  			adjacentVertexWeight = 1 / 8;

  			connectedFaces = currentEdge.faces.length;

  			// check how many linked faces. 2 should be correct.
  			if ( connectedFaces != 2 ) {

  				// if length is not 2, handle condition
  				edgeVertexWeight = 0.5;
  				adjacentVertexWeight = 0;

  			}

  			newEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );

  			tmp.set( 0, 0, 0 );

  			for ( j = 0; j < connectedFaces; j ++ ) {

  				face = currentEdge.faces[ j ];

  				for ( k = 0; k < 3; k ++ ) {

  					other = oldVertices[ face[ ABC[ k ] ] ];
  					if ( other !== currentEdge.a && other !== currentEdge.b ) { break; }

  				}

  				tmp.add( other );

  			}

  			tmp.multiplyScalar( adjacentVertexWeight );
  			newEdge.add( tmp );

  			currentEdge.newEdge = newEdgeVertices.length;
  			newEdgeVertices.push( newEdge );

  			// console.log(currentEdge, newEdge);

  		}
  		var beta, sourceVertexWeight, connectingVertexWeight;
  		var connectingEdge, connectingEdges, oldVertex, newSourceVertex;
  		newSourceVertices = [];

  		for ( i = 0, il = oldVertices.length; i < il; i ++ ) {

  			oldVertex = oldVertices[ i ];

  			// find all connecting edges (using lookupTable)
  			connectingEdges = metaVertices[ i ].edges;
  			n = connectingEdges.length;

  			if ( n == 3 ) {

  				beta = 3 / 16;

  			} else if ( n > 3 ) {

  				beta = 3 / ( 8 * n ); // Warren's modified formula

  			}

  			// Loop's original beta formula
  			// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );

  			sourceVertexWeight = 1 - n * beta;
  			connectingVertexWeight = beta;

  			if ( n <= 2 ) {

  				// crease and boundary rules
  				// console.warn('crease and boundary rules');

  				if ( n == 2 ) {
  					sourceVertexWeight = 3 / 4;
  					connectingVertexWeight = 1 / 8;

  					// sourceVertexWeight = 1;
  					// connectingVertexWeight = 0;

  				}

  			}

  			newSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );

  			tmp.set( 0, 0, 0 );

  			for ( j = 0; j < n; j ++ ) {

  				connectingEdge = connectingEdges[ j ];
  				other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;
  				tmp.add( other );

  			}

  			tmp.multiplyScalar( connectingVertexWeight );
  			newSourceVertex.add( tmp );

  			newSourceVertices.push( newSourceVertex );

  		}
  		newVertices = newSourceVertices.concat( newEdgeVertices );
  		var sl = newSourceVertices.length, edge1, edge2, edge3;
  		newFaces = [];

  		var uv, x0, x1, x2;
  		var x3 = new Vector2();
  		var x4 = new Vector2();
  		var x5 = new Vector2();

  		for ( i = 0, il = oldFaces.length; i < il; i ++ ) {

  			face = oldFaces[ i ];

  			// find the 3 new edges vertex of each old face

  			edge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;
  			edge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;
  			edge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;

  			// create 4 faces.

  			newFace( newFaces, edge1, edge2, edge3, face.materialIndex );
  			newFace( newFaces, face.a, edge1, edge3, face.materialIndex );
  			newFace( newFaces, face.b, edge2, edge1, face.materialIndex );
  			newFace( newFaces, face.c, edge3, edge2, face.materialIndex );

  			// create 4 new uv's

  			if ( hasUvs ) {

  				uv = oldUvs[ i ];

  				x0 = uv[ 0 ];
  				x1 = uv[ 1 ];
  				x2 = uv[ 2 ];

  				x3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );
  				x4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );
  				x5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );

  				newUv( newUVs, x3, x4, x5 );
  				newUv( newUVs, x0, x3, x5 );

  				newUv( newUVs, x1, x4, x3 );
  				newUv( newUVs, x2, x5, x4 );

  			}

  		}

  		// Overwrite old arrays
  		geometry.vertices = newVertices;
  		geometry.faces = newFaces;
  		if ( hasUvs ) { geometry.faceVertexUvs[ 0 ] = newUVs; }

  		// console.log('done');

  	};

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TessellateModifier = function ( maxEdgeLength ) {

  	this.maxEdgeLength = maxEdgeLength;

  };

  TessellateModifier.prototype.modify = function ( geometry ) {

  	var edge;

  	var faces = [];
  	var faceVertexUvs = [];
  	var maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;

  	for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

  		faceVertexUvs[ i ] = [];

  	}

  	for ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {

  		var face = geometry.faces[ i ];

  		if ( face instanceof Face3 ) {

  			var a = face.a;
  			var b = face.b;
  			var c = face.c;

  			var va = geometry.vertices[ a ];
  			var vb = geometry.vertices[ b ];
  			var vc = geometry.vertices[ c ];

  			var dab = va.distanceToSquared( vb );
  			var dbc = vb.distanceToSquared( vc );
  			var dac = va.distanceToSquared( vc );

  			if ( dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared ) {

  				var m = geometry.vertices.length;

  				var triA = face.clone();
  				var triB = face.clone();

  				if ( dab >= dbc && dab >= dac ) {

  					var vm = va.clone();
  					vm.lerp( vb, 0.5 );

  					triA.a = a;
  					triA.b = m;
  					triA.c = c;

  					triB.a = m;
  					triB.b = b;
  					triB.c = c;

  					if ( face.vertexNormals.length === 3 ) {

  						var vnm = face.vertexNormals[ 0 ].clone();
  						vnm.lerp( face.vertexNormals[ 1 ], 0.5 );

  						triA.vertexNormals[ 1 ].copy( vnm );
  						triB.vertexNormals[ 0 ].copy( vnm );

  					}

  					if ( face.vertexColors.length === 3 ) {

  						var vcm = face.vertexColors[ 0 ].clone();
  						vcm.lerp( face.vertexColors[ 1 ], 0.5 );

  						triA.vertexColors[ 1 ].copy( vcm );
  						triB.vertexColors[ 0 ].copy( vcm );

  					}

  					edge = 0;

  				} else if ( dbc >= dab && dbc >= dac ) {

  					var vm = vb.clone();
  					vm.lerp( vc, 0.5 );

  					triA.a = a;
  					triA.b = b;
  					triA.c = m;

  					triB.a = m;
  					triB.b = c;
  					triB.c = a;

  					if ( face.vertexNormals.length === 3 ) {

  						var vnm = face.vertexNormals[ 1 ].clone();
  						vnm.lerp( face.vertexNormals[ 2 ], 0.5 );

  						triA.vertexNormals[ 2 ].copy( vnm );

  						triB.vertexNormals[ 0 ].copy( vnm );
  						triB.vertexNormals[ 1 ].copy( face.vertexNormals[ 2 ] );
  						triB.vertexNormals[ 2 ].copy( face.vertexNormals[ 0 ] );

  					}

  					if ( face.vertexColors.length === 3 ) {

  						var vcm = face.vertexColors[ 1 ].clone();
  						vcm.lerp( face.vertexColors[ 2 ], 0.5 );

  						triA.vertexColors[ 2 ].copy( vcm );

  						triB.vertexColors[ 0 ].copy( vcm );
  						triB.vertexColors[ 1 ].copy( face.vertexColors[ 2 ] );
  						triB.vertexColors[ 2 ].copy( face.vertexColors[ 0 ] );

  					}

  					edge = 1;

  				} else {

  					var vm = va.clone();
  					vm.lerp( vc, 0.5 );

  					triA.a = a;
  					triA.b = b;
  					triA.c = m;

  					triB.a = m;
  					triB.b = b;
  					triB.c = c;

  					if ( face.vertexNormals.length === 3 ) {

  						var vnm = face.vertexNormals[ 0 ].clone();
  						vnm.lerp( face.vertexNormals[ 2 ], 0.5 );

  						triA.vertexNormals[ 2 ].copy( vnm );
  						triB.vertexNormals[ 0 ].copy( vnm );

  					}

  					if ( face.vertexColors.length === 3 ) {

  						var vcm = face.vertexColors[ 0 ].clone();
  						vcm.lerp( face.vertexColors[ 2 ], 0.5 );

  						triA.vertexColors[ 2 ].copy( vcm );
  						triB.vertexColors[ 0 ].copy( vcm );

  					}

  					edge = 2;

  				}

  				faces.push( triA, triB );
  				geometry.vertices.push( vm );

  				for ( var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

  					if ( geometry.faceVertexUvs[ j ].length ) {

  						var uvs = geometry.faceVertexUvs[ j ][ i ];

  						var uvA = uvs[ 0 ];
  						var uvB = uvs[ 1 ];
  						var uvC = uvs[ 2 ];

  						// AB

  						if ( edge === 0 ) {

  							var uvM = uvA.clone();
  							uvM.lerp( uvB, 0.5 );

  							var uvsTriA = [ uvA.clone(), uvM.clone(), uvC.clone() ];
  							var uvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];

  						// BC

  						} else if ( edge === 1 ) {

  							var uvM = uvB.clone();
  							uvM.lerp( uvC, 0.5 );

  							var uvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];
  							var uvsTriB = [ uvM.clone(), uvC.clone(), uvA.clone() ];

  						// AC

  						} else {

  							var uvM = uvA.clone();
  							uvM.lerp( uvC, 0.5 );

  							var uvsTriA = [ uvA.clone(), uvB.clone(), uvM.clone() ];
  							var uvsTriB = [ uvM.clone(), uvB.clone(), uvC.clone() ];

  						}

  						faceVertexUvs[ j ].push( uvsTriA, uvsTriB );

  					}

  				}

  			} else {

  				faces.push( face );

  				for ( var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

  					faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

  				}

  			}

  		}

  	}

  	geometry.faces = faces;
  	geometry.faceVertexUvs = faceVertexUvs;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MorphAnimMesh = function ( geometry, material ) {

  	Mesh.call( this, geometry, material );

  	this.type = 'MorphAnimMesh';

  	this.mixer = new AnimationMixer( this );
  	this.activeAction = null;
  };

  MorphAnimMesh.prototype = Object.create( Mesh.prototype );
  MorphAnimMesh.prototype.constructor = MorphAnimMesh;

  MorphAnimMesh.prototype.setDirectionForward = function () {

  	this.mixer.timeScale = 1.0;

  };

  MorphAnimMesh.prototype.setDirectionBackward = function () {

  	this.mixer.timeScale = -1.0;

  };

  MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

  	if( this.activeAction ) {

  		this.activeAction.stop();
  		this.activeAction = null;
  		
  	}

  	var clip = AnimationClip.findByName( this, label );

  	if ( clip ) {

  		var action = this.mixer.clipAction( clip );
  		action.timeScale = ( clip.tracks.length * fps ) / clip.duration;
  		this.activeAction = action.play();

  	} else {

  		throw new Error( 'MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()' );

  	}

  };

  MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

  	this.mixer.update( delta );

  };

  MorphAnimMesh.prototype.copy = function ( source ) {

  	Mesh.prototype.copy.call( this, source );

  	this.mixer = new AnimationMixer( this );

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Node$1( type ) {

  	this.uuid = _Math.generateUUID();

  	this.name = "";

  	this.type = type;

  	this.userData = {};

  }

  Node$1.prototype = {

  	constructor: Node$1,

  	isNode: true,

  	parse: function ( builder, settings ) {

  		settings = settings || {};

  		builder.parsing = true;

  		this.build( builder.addFlow( settings.slot, settings.cache, settings.context ), 'v4' );

  		builder.clearVertexNodeCode();
  		builder.clearFragmentNodeCode();

  		builder.removeFlow();

  		builder.parsing = false;

  	},

  	parseAndBuildCode: function ( builder, output, settings ) {

  		settings = settings || {};

  		this.parse( builder, settings );

  		return this.buildCode( builder, output, settings );

  	},

  	buildCode: function ( builder, output, settings ) {

  		settings = settings || {};

  		var data = { result: this.build( builder.addFlow( settings.slot, settings.cache, settings.context ), output ) };

  		data.code = builder.clearNodeCode();

  		builder.removeFlow();

  		return data;

  	},

  	build: function ( builder, output, uuid ) {

  		output = output || this.getType( builder, output );

  		var data = builder.getNodeData( uuid || this );

  		if ( builder.parsing ) {

  			this.appendDepsNode( builder, data, output );

  		}

  		if ( builder.nodes.indexOf( this ) === - 1 ) {

  			builder.nodes.push( this );

  		}

  		if ( this.updateFrame !== undefined && builder.updaters.indexOf( this ) === - 1 ) {

  			builder.updaters.push( this );

  		}

  		return this.generate( builder, output, uuid );

  	},

  	appendDepsNode: function ( builder, data, output ) {

  		data.deps = ( data.deps || 0 ) + 1;

  		var outputLen = builder.getTypeLength( output );

  		if ( outputLen > ( data.outputMax || 0 ) || this.getType( builder, output ) ) {

  			data.outputMax = outputLen;
  			data.output = output;

  		}

  	},

  	setName: function ( name ) {

  		this.name = name;

  		return this;

  	},

  	getName: function ( builder ) {

  		return this.name;

  	},

  	getType: function ( builder, output ) {

  		return output === 'sampler2D' || output === 'samplerCube' ? output : this.type;

  	},

  	getJSONNode: function ( meta ) {

  		var isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( ! isRootObject && meta.nodes[ this.uuid ] !== undefined ) {

  			return meta.nodes[ this.uuid ];

  		}

  	},

  	copy: function ( source ) {

  		if ( source.name !== undefined ) { this.name = source.name; }

  		if ( source.userData !== undefined ) { this.userData = JSON.parse( JSON.stringify( source.userData ) ); }

  	},

  	createJSONNode: function ( meta ) {

  		var isRootObject = ( meta === undefined || typeof meta === 'string' );

  		var data = {};

  		if ( typeof this.nodeType !== "string" ) { throw new Error( "Node does not allow serialization." ); }

  		data.uuid = this.uuid;
  		data.nodeType = this.nodeType;

  		if ( this.name !== "" ) { data.name = this.name; }

  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		if ( ! isRootObject ) {

  			meta.nodes[ this.uuid ] = data;

  		}

  		return data;

  	},

  	toJSON: function ( meta ) {

  		return this.getJSONNode( meta ) || this.createJSONNode( meta );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TempNode( type, params ) {

  	Node$1.call( this, type );

  	params = params || {};

  	this.shared = params.shared !== undefined ? params.shared : true;
  	this.unique = params.unique !== undefined ? params.unique : false;

  }

  TempNode.prototype = Object.create( Node$1.prototype );
  TempNode.prototype.constructor = TempNode;

  TempNode.prototype.build = function ( builder, output, uuid, ns ) {

  	output = output || this.getType( builder );

  	if ( this.getShared( builder, output ) ) {

  		var isUnique = this.getUnique( builder, output );

  		if ( isUnique && this.constructor.uuid === undefined ) {

  			this.constructor.uuid = _Math.generateUUID();

  		}

  		uuid = builder.getUuid( uuid || this.getUuid(), ! isUnique );

  		var data = builder.getNodeData( uuid ),
  			type = data.output || this.getType( builder );

  		if ( builder.parsing ) {

  			if ( ( data.deps || 0 ) > 0 || this.getLabel() ) {

  				this.appendDepsNode( builder, data, output );

  				return this.generate( builder, output, uuid );

  			}

  			return Node$1.prototype.build.call( this, builder, output, uuid );

  		} else if ( isUnique ) {

  			data.name = data.name || Node$1.prototype.build.call( this, builder, output, uuid );

  			return data.name;

  		} else if ( ! this.getLabel() && ( ! this.getShared( builder, type ) || ( ! builder.optimize || data.deps === 1 ) ) ) {

  			return Node$1.prototype.build.call( this, builder, output, uuid );

  		}

  		uuid = this.getUuid( false );

  		var name = this.getTemp( builder, uuid );

  		if ( name ) {

  			return builder.format( name, type, output );

  		} else {

  			name = TempNode.prototype.generate.call( this, builder, output, uuid, data.output, ns );

  			var code = this.generate( builder, type, uuid );

  			builder.addNodeCode( name + ' = ' + code + ';' );

  			return builder.format( name, type, output );

  		}

  	}

  	return Node$1.prototype.build.call( this, builder, output, uuid );

  };

  TempNode.prototype.getShared = function ( builder, output ) {

  	return output !== 'sampler2D' && output !== 'samplerCube' && this.shared;

  };

  TempNode.prototype.getUnique = function ( builder, output ) {

  	return this.unique;

  };

  TempNode.prototype.setLabel = function ( name ) {

  	this.label = name;

  	return this;

  };

  TempNode.prototype.getLabel = function ( builder ) {

  	return this.label;

  };

  TempNode.prototype.getUuid = function ( unique ) {

  	var uuid = unique || unique == undefined ? this.constructor.uuid || this.uuid : this.uuid;

  	if ( typeof this.scope === "string" ) { uuid = this.scope + '-' + uuid; }

  	return uuid;

  };

  TempNode.prototype.getTemp = function ( builder, uuid ) {

  	uuid = uuid || this.uuid;

  	var tempVar = builder.getVars()[ uuid ];

  	return tempVar ? tempVar.name : undefined;

  };

  TempNode.prototype.generate = function ( builder, output, uuid, type, ns ) {

  	if ( ! this.getShared( builder, output ) ) { console.error( "TempNode is not shared!" ); }

  	uuid = uuid || this.uuid;

  	return builder.getTempVar( uuid, type || this.getType( builder ), ns, this.getLabel() ).name;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NodeLib = {

  	nodes: {},
  	keywords: {},

  	add: function ( node ) {

  		this.nodes[ node.name ] = node;

  	},

  	addKeyword: function ( name, callback, cache ) {

  		cache = cache !== undefined ? cache : true;

  		this.keywords[ name ] = { callback: callback, cache: cache };

  	},

  	remove: function ( node ) {

  		delete this.nodes[ node.name ];

  	},

  	removeKeyword: function ( name ) {

  		delete this.keywords[ name ];

  	},

  	get: function ( name ) {

  		return this.nodes[ name ];

  	},

  	getKeyword: function ( name, material ) {

  		return this.keywords[ name ].callback.call( this, material );

  	},

  	getKeywordData: function ( name ) {

  		return this.keywords[ name ];

  	},

  	contains: function ( name ) {

  		return this.nodes[ name ] != undefined;

  	},

  	containsKeyword: function ( name ) {

  		return this.keywords[ name ] != undefined;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var declarationRegexp = /^([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
  	propertiesRegexp = /[a-z_0-9]+/ig;

  function FunctionNode( src, includes, extensions, keywords, type ) {

  	this.isMethod = type === undefined;

  	TempNode.call( this, type );

  	this.eval( src, includes, extensions, keywords );

  }

  FunctionNode.prototype = Object.create( TempNode.prototype );
  FunctionNode.prototype.constructor = FunctionNode;
  FunctionNode.prototype.nodeType = "Function";

  FunctionNode.prototype.useKeywords = true;

  FunctionNode.prototype.getShared = function ( builder, output ) {

  	return ! this.isMethod;

  };

  FunctionNode.prototype.getType = function ( builder ) {

  	return builder.getTypeByFormat( this.type );

  };

  FunctionNode.prototype.getInputByName = function ( name ) {
  	var this$1 = this;


  	var i = this.inputs.length;

  	while ( i -- ) {

  		if ( this$1.inputs[ i ].name === name ) {

  			return this$1.inputs[ i ];

  		}

  	}

  };

  FunctionNode.prototype.getIncludeByName = function ( name ) {
  	var this$1 = this;


  	var i = this.includes.length;

  	while ( i -- ) {

  		if ( this$1.includes[ i ].name === name ) {

  			return this$1.includes[ i ];

  		}

  	}

  };

  FunctionNode.prototype.generate = function ( builder, output ) {
  	var this$1 = this;


  	var match, offset = 0, src = this.src;

  	for ( var i = 0; i < this.includes.length; i ++ ) {

  		builder.include( this$1.includes[ i ], this$1 );

  	}

  	for ( var ext in this$1.extensions ) {

  		builder.extensions[ ext ] = true;

  	}

  	while ( match = propertiesRegexp.exec( this.src ) ) {

  		var prop = match[ 0 ],
  			isGlobal = this$1.isMethod ? ! this$1.getInputByName( prop ) : true,
  			reference = prop;

  		if ( this$1.keywords[ prop ] || ( this$1.useKeywords && isGlobal && NodeLib.containsKeyword( prop ) ) ) {

  			var node = this$1.keywords[ prop ];

  			if ( ! node ) {

  				var keyword = NodeLib.getKeywordData( prop );

  				if ( keyword.cache ) { node = builder.keywords[ prop ]; }

  				node = node || NodeLib.getKeyword( prop, builder );

  				if ( keyword.cache ) { builder.keywords[ prop ] = node; }

  			}

  			reference = node.build( builder );

  		}

  		if ( prop != reference ) {

  			src = src.substring( 0, match.index + offset ) + reference + src.substring( match.index + prop.length + offset );

  			offset += reference.length - prop.length;

  		}

  		if ( this$1.getIncludeByName( reference ) === undefined && NodeLib.contains( reference ) ) {

  			builder.include( NodeLib.get( reference ) );

  		}

  	}

  	if ( output === 'source' ) {

  		return src;

  	} else if ( this.isMethod ) {

  		builder.include( this, false, src );

  		return this.name;

  	} else {

  		return builder.format( '( ' + src + ' )', this.getType( builder ), output );

  	}

  };

  FunctionNode.prototype.eval = function ( src, includes, extensions, keywords ) {
  	var this$1 = this;


  	this.src = src || '';

  	this.includes = includes || [];
  	this.extensions = extensions || {};
  	this.keywords = keywords || {};

  	if ( this.isMethod ) {

  		var match = this.src.match( declarationRegexp );

  		this.inputs = [];

  		if ( match && match.length == 4 ) {

  			this.type = match[ 1 ];
  			this.name = match[ 2 ];

  			var inputs = match[ 3 ].match( propertiesRegexp );

  			if ( inputs ) {

  				var i = 0;

  				while ( i < inputs.length ) {

  					var qualifier = inputs[ i ++ ];
  					var type, name;

  					if ( qualifier == 'in' || qualifier == 'out' || qualifier == 'inout' ) {

  						type = inputs[ i ++ ];

  					} else {

  						type = qualifier;
  						qualifier = '';

  					}

  					name = inputs[ i ++ ];

  					this$1.inputs.push( {
  						name: name,
  						type: type,
  						qualifier: qualifier
  					} );

  				}

  			}

  		} else {

  			this.type = '';
  			this.name = '';

  		}

  	}

  };

  FunctionNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.isMethod = source.isMethod;
  	this.useKeywords = source.useKeywords;

  	this.eval( source.src, source.includes, source.extensions, source.keywords );

  	if ( source.type !== undefined ) { this.type = source.type; }

  };

  FunctionNode.prototype.toJSON = function ( meta ) {
  	var this$1 = this;


  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.src = this.src;
  		data.isMethod = this.isMethod;
  		data.useKeywords = this.useKeywords;

  		if ( ! this.isMethod ) { data.type = this.type; }

  		data.extensions = JSON.parse( JSON.stringify( this.extensions ) );
  		data.keywords = {};

  		for ( var keyword in this$1.keywords ) {

  			data.keywords[ keyword ] = this$1.keywords[ keyword ].toJSON( meta ).uuid;

  		}

  		if ( this.includes.length ) {

  			data.includes = [];

  			for ( var i = 0; i < this.includes.length; i ++ ) {

  				data.includes.push( this$1.includes[ i ].toJSON( meta ).uuid );

  			}

  		}

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InputNode( type, params ) {

  	params = params || {};
  	params.shared = params.shared !== undefined ? params.shared : false;

  	TempNode.call( this, type, params );

  	this.readonly = false;

  }

  InputNode.prototype = Object.create( TempNode.prototype );
  InputNode.prototype.constructor = InputNode;

  InputNode.prototype.setReadonly = function ( value ) {

  	this.readonly = value;

  	return this;

  };

  InputNode.prototype.getReadonly = function ( builder ) {

  	return this.readonly;

  };

  InputNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	if ( source.readonly !== undefined ) { this.readonly = source.readonly; }

  };

  InputNode.prototype.createJSONNode = function ( meta ) {

  	var data = TempNode.prototype.createJSONNode.call( this, meta );

  	if ( this.readonly === true ) { data.readonly = this.readonly; }

  	return data;

  };

  InputNode.prototype.generate = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	uuid = builder.getUuid( uuid || this.getUuid() );
  	type = type || this.getType( builder );

  	var data = builder.getNodeData( uuid ),
  		readonly = this.getReadonly( builder ) && this.generateReadonly !== undefined;

  	if ( readonly ) {

  		return this.generateReadonly( builder, output, uuid, type, ns, needsUpdate );

  	} else {

  		if ( builder.isShader( 'vertex' ) ) {

  			if ( ! data.vertex ) {

  				data.vertex = builder.createVertexUniform( type, this, ns, needsUpdate, this.getLabel() );

  			}

  			return builder.format( data.vertex.name, type, output );

  		} else {

  			if ( ! data.fragment ) {

  				data.fragment = builder.createFragmentUniform( type, this, ns, needsUpdate, this.getLabel() );

  			}

  			return builder.format( data.fragment.name, type, output );

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function FloatNode( value ) {

  	InputNode.call( this, 'f' );

  	this.value = value || 0;

  }

  FloatNode.prototype = Object.create( InputNode.prototype );
  FloatNode.prototype.constructor = FloatNode;
  FloatNode.prototype.nodeType = "Float";

  FloatNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( this.value + ( this.value % 1 ? '' : '.0' ), type, output );

  };

  FloatNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value = source.value;

  };

  FloatNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PositionNode( scope ) {

  	TempNode.call( this, 'v3' );

  	this.scope = scope || PositionNode.LOCAL;

  }

  PositionNode.LOCAL = 'local';
  PositionNode.WORLD = 'world';
  PositionNode.VIEW = 'view';
  PositionNode.PROJECTION = 'projection';

  PositionNode.prototype = Object.create( TempNode.prototype );
  PositionNode.prototype.constructor = PositionNode;
  PositionNode.prototype.nodeType = "Position";

  PositionNode.prototype.getType = function ( ) {

  	switch ( this.scope ) {

  		case PositionNode.PROJECTION:

  			return 'v4';

  	}

  	return this.type;

  };

  PositionNode.prototype.getShared = function ( builder ) {

  	switch ( this.scope ) {

  		case PositionNode.LOCAL:
  		case PositionNode.WORLD:

  			return false;

  	}

  	return true;

  };

  PositionNode.prototype.generate = function ( builder, output ) {

  	var result;

  	switch ( this.scope ) {

  		case PositionNode.LOCAL:

  			builder.requires.position = true;

  			result = builder.isShader( 'vertex' ) ? 'transformed' : 'vPosition';

  			break;

  		case PositionNode.WORLD:

  			builder.requires.worldPosition = true;

  			result = 'vWPosition';

  			break;

  		case PositionNode.VIEW:

  			result = builder.isShader( 'vertex' ) ? '-mvPosition.xyz' : 'vViewPosition';

  			break;

  		case PositionNode.PROJECTION:

  			result = builder.isShader( 'vertex' ) ? '( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )' : 'vec4( 0.0 )';

  			break;

  	}

  	return builder.format( result, this.getType( builder ), output );

  };

  PositionNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.scope = source.scope;

  };

  PositionNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;

  	}

  	return data;

  };

  NodeLib.addKeyword( 'position', function () {

  	return new PositionNode();

  } );

  NodeLib.addKeyword( 'worldPosition', function () {

  	return new PositionNode( PositionNode.WORLD );

  } );

  NodeLib.addKeyword( 'viewPosition', function () {

  	return new PositionNode( NormalNode.VIEW );

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CameraNode( scope, camera ) {

  	TempNode.call( this, 'v3' );

  	this.setScope( scope || CameraNode.POSITION );
  	this.setCamera( camera );

  }

  CameraNode.Nodes = ( function () {

  	var depthColor = new FunctionNode( [
  		"float depthColor( float mNear, float mFar ) {",

  		"	#ifdef USE_LOGDEPTHBUF_EXT",

  		"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

  		"	#else",

  		"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

  		"	#endif",

  		"	return 1.0 - smoothstep( mNear, mFar, depth );",

  		"}"
  	].join( "\n" ) );

  	return {
  		depthColor: depthColor
  	};

  } )();

  CameraNode.POSITION = 'position';
  CameraNode.DEPTH = 'depth';
  CameraNode.TO_VERTEX = 'toVertex';

  CameraNode.prototype = Object.create( TempNode.prototype );
  CameraNode.prototype.constructor = CameraNode;
  CameraNode.prototype.nodeType = "Camera";

  CameraNode.prototype.setCamera = function ( camera ) {

  	this.camera = camera;
  	this.updateFrame = camera !== undefined ? this.onUpdateFrame : undefined;

  };

  CameraNode.prototype.setScope = function ( scope ) {

  	switch ( this.scope ) {

  		case CameraNode.DEPTH:

  			delete this.near;
  			delete this.far;

  			break;

  	}

  	this.scope = scope;

  	switch ( scope ) {

  		case CameraNode.DEPTH:

  			var camera = this.camera;

  			this.near = new FloatNode( camera ? camera.near : 1 );
  			this.far = new FloatNode( camera ? camera.far : 1200 );

  			break;

  	}

  };

  CameraNode.prototype.getType = function ( builder ) {

  	switch ( this.scope ) {

  		case CameraNode.DEPTH:

  			return 'f';

  	}

  	return this.type;

  };

  CameraNode.prototype.getUnique = function ( builder ) {

  	switch ( this.scope ) {

  		case CameraNode.DEPTH:
  		case CameraNode.TO_VERTEX:

  			return true;

  	}

  	return false;

  };

  CameraNode.prototype.getShared = function ( builder ) {

  	switch ( this.scope ) {

  		case CameraNode.POSITION:

  			return false;

  	}

  	return true;

  };

  CameraNode.prototype.generate = function ( builder, output ) {

  	var result;

  	switch ( this.scope ) {

  		case CameraNode.POSITION:

  			result = 'cameraPosition';

  			break;

  		case CameraNode.DEPTH:

  			var depthColor = builder.include( CameraNode.Nodes.depthColor );

  			result = depthColor + '( ' + this.near.build( builder, 'f' ) + ', ' + this.far.build( builder, 'f' ) + ' )';

  			break;

  		case CameraNode.TO_VERTEX:

  			result = 'normalize( ' + new PositionNode( PositionNode.WORLD ).build( builder, 'v3' ) + ' - cameraPosition )';

  			break;

  	}

  	return builder.format( result, this.getType( builder ), output );

  };

  CameraNode.prototype.onUpdateFrame = function ( frame ) {

  	switch ( this.scope ) {

  		case CameraNode.DEPTH:

  			var camera = this.camera;

  			this.near.value = camera.near;
  			this.far.value = camera.far;

  			break;

  	}

  };

  CameraNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.setScope( source.scope );

  	if ( source.camera ) {

  		this.setCamera( source.camera );

  	}

  	switch ( source.scope ) {

  		case CameraNode.DEPTH:

  			this.near.number = source.near;
  			this.far.number = source.far;

  			break;

  	}

  };

  CameraNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;

  		if ( this.camera ) { data.camera = this.camera.uuid; }

  		switch ( this.scope ) {

  			case CameraNode.DEPTH:

  				data.near = this.near.value;
  				data.far = this.far.value;

  				break;

  		}

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var vertexDict = [ 'color', 'color2' ],
  	fragmentDict = [ 'vColor', 'vColor2' ];

  function ColorsNode( index ) {

  	TempNode.call( this, 'v4', { shared: false } );

  	this.index = index || 0;

  }

  ColorsNode.prototype = Object.create( TempNode.prototype );
  ColorsNode.prototype.constructor = ColorsNode;

  ColorsNode.prototype.generate = function ( builder, output ) {

  	builder.requires.color[ this.index ] = true;

  	var result = builder.isShader( 'vertex' ) ? vertexDict[ this.index ] : fragmentDict[ this.index ];

  	return builder.format( result, this.getType( builder ), output );

  };

  ColorsNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.index = source.index;

  };

  ColorsNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.index = this.index;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LightNode( scope ) {

  	TempNode.call( this, 'v3', { shared: false } );

  	this.scope = scope || LightNode.TOTAL;

  }

  LightNode.TOTAL = 'total';

  LightNode.prototype = Object.create( TempNode.prototype );
  LightNode.prototype.constructor = LightNode;
  LightNode.prototype.nodeType = "Light";

  LightNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isCache( 'light' ) ) {

  		return builder.format( 'reflectedLight.directDiffuse', this.type, output );

  	} else {

  		console.warn( "LightNode is only compatible in \"light\" channel." );

  		return builder.format( 'vec3( 0.0 )', this.type, output );

  	}

  };

  LightNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.scope = source.scope;

  };

  LightNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NormalNode$1( scope ) {

  	TempNode.call( this, 'v3' );

  	this.scope = scope || NormalNode$1.LOCAL;

  }

  NormalNode$1.LOCAL = 'local';
  NormalNode$1.WORLD = 'world';
  NormalNode$1.VIEW = 'view';

  NormalNode$1.prototype = Object.create( TempNode.prototype );
  NormalNode$1.prototype.constructor = NormalNode$1;
  NormalNode$1.prototype.nodeType = "Normal";

  NormalNode$1.prototype.getShared = function ( builder ) {

  	switch ( this.scope ) {

  		case NormalNode$1.WORLD:

  			return true;

  	}

  	return false;

  };

  NormalNode$1.prototype.generate = function ( builder, output ) {

  	var result;

  	switch ( this.scope ) {

  		case NormalNode$1.LOCAL:

  			builder.requires.normal = true;

  			result = 'normal';

  			break;

  		case NormalNode$1.WORLD:

  			builder.requires.worldNormal = true;

  			result = builder.isShader( 'vertex' ) ? '( modelMatrix * vec4( objectNormal, 0.0 ) ).xyz' : 'vWNormal';

  			break;

  		case NormalNode$1.VIEW:

  			result = 'vNormal';

  			break;

  	}

  	return builder.format( result, this.getType( builder ), output );

  };

  NormalNode$1.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.scope = source.scope;

  };

  NormalNode$1.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;

  	}

  	return data;

  };

  NodeLib.addKeyword( 'normal', function () {

  	return new NormalNode$1();

  } );

  NodeLib.addKeyword( 'worldNormal', function () {

  	return new NormalNode$1( NormalNode$1.WORLD );

  } );

  NodeLib.addKeyword( 'viewNormal', function () {

  	return new NormalNode$1( NormalNode$1.VIEW );

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ReflectNode( scope ) {

  	TempNode.call( this, 'v3', { unique: true } );

  	this.scope = scope || ReflectNode.CUBE;

  }

  ReflectNode.CUBE = 'cube';
  ReflectNode.SPHERE = 'sphere';
  ReflectNode.VECTOR = 'vector';

  ReflectNode.prototype = Object.create( TempNode.prototype );
  ReflectNode.prototype.constructor = ReflectNode;
  ReflectNode.prototype.nodeType = "Reflect";

  ReflectNode.prototype.getType = function ( builder ) {

  	switch ( this.scope ) {

  		case ReflectNode.SPHERE:

  			return 'v2';

  	}

  	return this.type;

  };

  ReflectNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		var result;

  		switch ( this.scope ) {

  			case ReflectNode.VECTOR:

  				builder.addNodeCode( 'vec3 reflectVec = inverseTransformDirection( reflect( -normalize( vViewPosition ), normal ), viewMatrix );' );

  				result = 'reflectVec';

  				break;

  			case ReflectNode.CUBE:

  				var reflectVec = new ReflectNode( ReflectNode.VECTOR ).build( builder, 'v3' );

  				builder.addNodeCode( 'vec3 reflectCubeVec = vec3( -1.0 * ' + reflectVec + '.x, ' + reflectVec + '.yz );' );

  				result = 'reflectCubeVec';

  				break;

  			case ReflectNode.SPHERE:

  				var reflectVec = new ReflectNode( ReflectNode.VECTOR ).build( builder, 'v3' );

  				builder.addNodeCode( 'vec2 reflectSphereVec = normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5;' );

  				result = 'reflectSphereVec';

  				break;

  		}

  		return builder.format( result, this.getType( builder ), output );

  	} else {

  		console.warn( "ReflectNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec3( 0.0 )', this.type, output );

  	}

  };

  ReflectNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NodeUtils = {

  	elements: [ 'x', 'y', 'z', 'w' ],

  	addShortcuts: function () {

  		function applyShortcut( proxy, property, subProperty ) {

  			if ( subProperty ) {

  				return {

  					get: function () {

  						return this[ proxy ][ property ][ subProperty ];

  					},

  					set: function ( val ) {

  						this[ proxy ][ property ][ subProperty ] = val;

  					}

  				};

  			} else {

  				return {

  					get: function () {

  						return this[ proxy ][ property ];

  					},

  					set: function ( val ) {

  						this[ proxy ][ property ] = val;

  					}

  				};

  			}

  		}

  		return function addShortcuts( proto, proxy, list ) {

  			var shortcuts = {};

  			for ( var i = 0; i < list.length; ++ i ) {

  				var data = list[ i ].split( "." ),
  					property = data[ 0 ],
  					subProperty = data[ 1 ];

  				shortcuts[ property ] = applyShortcut( proxy, property, subProperty );

  			}

  			Object.defineProperties( proto, shortcuts );

  		};

  	}()

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector2Node( x, y ) {

  	InputNode.call( this, 'v2' );

  	this.value = x instanceof Vector2 ? x : new Vector2( x, y );

  }

  Vector2Node.prototype = Object.create( InputNode.prototype );
  Vector2Node.prototype.constructor = Vector2Node;
  Vector2Node.prototype.nodeType = "Vector2";

  NodeUtils.addShortcuts( Vector2Node.prototype, 'value', [ 'x', 'y' ] );

  Vector2Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "vec2( " + this.x + ", " + this.y + " )", type, output );

  };

  Vector2Node.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value.copy( source );

  };

  Vector2Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.x = this.x;
  		data.y = this.y;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ResolutionNode() {

  	Vector2Node.call( this );

  }

  ResolutionNode.prototype = Object.create( Vector2Node.prototype );
  ResolutionNode.prototype.constructor = ResolutionNode;
  ResolutionNode.prototype.nodeType = "Resolution";

  ResolutionNode.prototype.updateFrame = function ( frame ) {

  	if ( frame.renderer ) {

  		var size = frame.renderer.getSize(),
  			pixelRatio = frame.renderer.getPixelRatio();

  		this.x = size.width * pixelRatio;
  		this.y = size.height * pixelRatio;

  	} else {

  		console.warn( "ResolutionNode need a renderer in NodeFrame" );

  	}

  };

  ResolutionNode.prototype.copy = function ( source ) {

  	Vector2Node.prototype.copy.call( this, source );

  	this.renderer = source.renderer;

  };

  ResolutionNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.renderer = this.renderer.uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ScreenUVNode( resolution ) {

  	TempNode.call( this, 'v2' );

  	this.resolution = resolution || new ResolutionNode();

  }

  ScreenUVNode.prototype = Object.create( TempNode.prototype );
  ScreenUVNode.prototype.constructor = ScreenUVNode;
  ScreenUVNode.prototype.nodeType = "ScreenUV";

  ScreenUVNode.prototype.generate = function ( builder, output ) {

  	var result;

  	if ( builder.isShader( 'fragment' ) ) {

  		result = '( gl_FragCoord.xy / ' + this.resolution.build( builder, 'v2' ) + ')';

  	} else {

  		console.warn( "ScreenUVNode is not compatible with " + builder.shader + " shader." );

  		result = 'vec2( 0.0 )';

  	}

  	return builder.format( result, this.getType( builder ), output );

  };

  ScreenUVNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.resolution = source.resolution;

  };

  ScreenUVNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.resolution = this.resolution.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var vertexDict$1 = [ 'uv', 'uv2' ],
  	fragmentDict$1 = [ 'vUv', 'vUv2' ];

  function UVNode( index ) {

  	TempNode.call( this, 'v2', { shared: false } );

  	this.index = index || 0;

  }

  UVNode.prototype = Object.create( TempNode.prototype );
  UVNode.prototype.constructor = UVNode;
  UVNode.prototype.nodeType = "UV";

  UVNode.prototype.generate = function ( builder, output ) {

  	builder.requires.uv[ this.index ] = true;

  	var result = builder.isShader( 'vertex' ) ? vertexDict$1[ this.index ] : fragmentDict$1[ this.index ];

  	return builder.format( result, this.getType( builder ), output );

  };

  UVNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.index = source.index;

  };

  UVNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.index = this.index;

  	}

  	return data;

  };

  NodeLib.addKeyword( 'uv', function () {

  	return new UVNode();

  } );

  NodeLib.addKeyword( 'uv2', function () {

  	return new UVNode( 1 );

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BlinnShininessExponentNode() {

  	TempNode.call( this, 'f' );

  }

  BlinnShininessExponentNode.prototype = Object.create( TempNode.prototype );
  BlinnShininessExponentNode.prototype.constructor = BlinnShininessExponentNode;
  BlinnShininessExponentNode.prototype.nodeType = "BlinnShininessExponent";

  BlinnShininessExponentNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isCache( 'clearCoat' ) ) {

  		return builder.format( 'Material_ClearCoat_BlinnShininessExponent( material )', this.type, output );

  	} else {

  		return builder.format( 'Material_BlinnShininessExponent( material )', this.type, output );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BlinnExponentToRoughnessNode( blinnExponent ) {

  	TempNode.call( this, 'f' );

  	this.blinnExponent = blinnExponent || new BlinnShininessExponentNode();

  }

  BlinnExponentToRoughnessNode.prototype = Object.create( TempNode.prototype );
  BlinnExponentToRoughnessNode.prototype.constructor = BlinnExponentToRoughnessNode;
  BlinnExponentToRoughnessNode.prototype.nodeType = "BlinnExponentToRoughness";

  BlinnExponentToRoughnessNode.prototype.generate = function ( builder, output ) {

  	return builder.format( 'BlinnExponentToGGXRoughness( ' + this.blinnExponent.build( builder, 'f' ) + ' )', this.type, output );

  };

  BlinnExponentToRoughnessNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.blinnExponent = source.blinnExponent;

  };

  BlinnExponentToRoughnessNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.blinnExponent = this.blinnExponent;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MaxMIPLevelNode( texture ) {

  	FloatNode.call( this );

  	this.texture = texture;

  	this.maxMIPLevel = 0;

  }

  MaxMIPLevelNode.prototype = Object.create( FloatNode.prototype );
  MaxMIPLevelNode.prototype.constructor = MaxMIPLevelNode;
  MaxMIPLevelNode.prototype.nodeType = "MaxMIPLevel";

  Object.defineProperties( MaxMIPLevelNode.prototype, {

  	value: {

  		get: function () {

  			if ( this.maxMIPLevel === 0 ) {

  				var image = this.texture.value.image ? this.texture.value.image[ 0 ] : undefined;

  				this.maxMIPLevel = image !== undefined ? Math.log( Math.max( image.width, image.height ) ) * Math.LOG2E : 0;

  			}

  			return this.maxMIPLevel;

  		},

  		set: function () { }

  	}

  } );

  MaxMIPLevelNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.texture = this.texture.uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RoughnessToBlinnExponentNode( texture ) {

  	TempNode.call( this, 'f' );

  	this.texture = texture;

  	this.maxMIPLevel = new MaxMIPLevelNode( texture );
  	this.blinnShininessExponent = new BlinnShininessExponentNode();

  }

  RoughnessToBlinnExponentNode.Nodes = ( function () {

  	var getSpecularMIPLevel = new FunctionNode( [
  		// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
  		"float getSpecularMIPLevel( const in float blinnShininessExponent, const in float maxMIPLevelScalar ) {",

  		//	float envMapWidth = pow( 2.0, maxMIPLevelScalar );
  		//	float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );

  		"	float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",

  		// clamp to allowable LOD ranges.
  		"	return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );",

  		"}"
  	].join( "\n" ) );

  	return {
  		getSpecularMIPLevel: getSpecularMIPLevel
  	};

  } )();

  RoughnessToBlinnExponentNode.prototype = Object.create( TempNode.prototype );
  RoughnessToBlinnExponentNode.prototype.constructor = RoughnessToBlinnExponentNode;
  RoughnessToBlinnExponentNode.prototype.nodeType = "RoughnessToBlinnExponent";

  RoughnessToBlinnExponentNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		this.maxMIPLevel.texture = this.texture;

  		var getSpecularMIPLevel = builder.include( RoughnessToBlinnExponentNode.Nodes.getSpecularMIPLevel );

  		return builder.format( getSpecularMIPLevel + '( ' + this.blinnShininessExponent.build( builder, 'f' ) + ', ' + this.maxMIPLevel.build( builder, 'f' ) + ' )', this.type, output );

  	} else {

  		console.warn( "RoughnessToBlinnExponentNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( '0.0', this.type, output );

  	}

  };

  RoughnessToBlinnExponentNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.texture = source.texture;

  };

  RoughnessToBlinnExponentNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.texture = this.texture;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AttributeNode( name, type ) {

  	Node$1.call( this, type );

  	this.name = name;

  }

  AttributeNode.prototype = Object.create( Node$1.prototype );
  AttributeNode.prototype.constructor = AttributeNode;
  AttributeNode.prototype.nodeType = "Attribute";

  AttributeNode.prototype.getAttributeType = function ( builder ) {

  	return typeof this.type === 'number' ? builder.getConstructorFromLength( this.type ) : this.type;

  };

  AttributeNode.prototype.getType = function ( builder ) {

  	var type = this.getAttributeType( builder );

  	return builder.getTypeByFormat( type );

  };

  AttributeNode.prototype.generate = function ( builder, output ) {

  	var type = this.getAttributeType( builder );

  	var attribute = builder.getAttribute( this.name, type ),
  		name = builder.isShader( 'vertex' ) ? this.name : attribute.varying.name;

  	console.log( attribute );

  	return builder.format( name, this.getType( builder ), output );

  };

  AttributeNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	this.type = source.type;

  };

  AttributeNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.type = this.type;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var declarationRegexp$1 = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i;

  function ConstNode( src, useDefine ) {

  	TempNode.call( this );

  	this.eval( src || ConstNode.PI, useDefine );

  }

  ConstNode.PI = 'PI';
  ConstNode.PI2 = 'PI2';
  ConstNode.RECIPROCAL_PI = 'RECIPROCAL_PI';
  ConstNode.RECIPROCAL_PI2 = 'RECIPROCAL_PI2';
  ConstNode.LOG2 = 'LOG2';
  ConstNode.EPSILON = 'EPSILON';

  ConstNode.prototype = Object.create( TempNode.prototype );
  ConstNode.prototype.constructor = ConstNode;
  ConstNode.prototype.nodeType = "Const";

  ConstNode.prototype.getType = function ( builder ) {

  	return builder.getTypeByFormat( this.type );

  };

  ConstNode.prototype.eval = function ( src, useDefine ) {

  	this.src = src || '';

  	var name, type, value = "";

  	var match = this.src.match( declarationRegexp$1 );

  	this.useDefine = useDefine || this.src.charAt( 0 ) === '#';

  	if ( match && match.length > 1 ) {

  		type = match[ 1 ];
  		name = match[ 2 ];
  		value = match[ 3 ];

  	} else {

  		name = this.src;
  		type = 'f';

  	}

  	this.name = name;
  	this.type = type;
  	this.value = value;

  };

  ConstNode.prototype.build = function ( builder, output ) {

  	if ( output === 'source' ) {

  		if ( this.value ) {

  			if ( this.useDefine ) {

  				return '#define ' + this.name + ' ' + this.value;

  			}

  			return 'const ' + this.type + ' ' + this.name + ' = ' + this.value + ';';

  		} else if ( this.useDefine ) {

  			return this.src;

  		}

  	} else {

  		builder.include( this );

  		return builder.format( this.name, this.getType( builder ), output );

  	}

  };

  ConstNode.prototype.generate = function ( builder, output ) {

  	return builder.format( this.name, this.getType( builder ), output );

  };

  ConstNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.eval( source.src, source.useDefine );

  };

  ConstNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.src = this.src;

  		if ( data.useDefine === true ) { data.useDefine = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ExpressionNode( src, type, keywords, extensions, includes ) {

  	FunctionNode.call( this, src, includes, extensions, keywords, type );

  }

  ExpressionNode.prototype = Object.create( FunctionNode.prototype );
  ExpressionNode.prototype.constructor = ExpressionNode;
  ExpressionNode.prototype.nodeType = "Expression";

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function FunctionCallNode( func, inputs ) {

  	TempNode.call( this );

  	this.setFunction( func, inputs );

  }

  FunctionCallNode.prototype = Object.create( TempNode.prototype );
  FunctionCallNode.prototype.constructor = FunctionCallNode;
  FunctionCallNode.prototype.nodeType = "FunctionCall";

  FunctionCallNode.prototype.setFunction = function ( func, inputs ) {

  	this.value = func;
  	this.inputs = inputs || [];

  };

  FunctionCallNode.prototype.getFunction = function () {

  	return this.value;

  };

  FunctionCallNode.prototype.getType = function ( builder ) {

  	return this.value.getType( builder );

  };

  FunctionCallNode.prototype.generate = function ( builder, output ) {
  	var this$1 = this;


  	var type = this.getType( builder ),
  		func = this.value;

  	var code = func.build( builder, output ) + '( ',
  		params = [];

  	for ( var i = 0; i < func.inputs.length; i ++ ) {

  		var inpt = func.inputs[ i ],
  			param = this$1.inputs[ i ] || this$1.inputs[ inpt.name ];

  		params.push( param.build( builder, builder.getTypeByFormat( inpt.type ) ) );

  	}

  	code += params.join( ', ' ) + ' )';

  	return builder.format( code, type, output );

  };

  FunctionCallNode.prototype.copy = function ( source ) {
  	var this$1 = this;


  	TempNode.prototype.copy.call( this, source );

  	for ( var prop in source.inputs ) {

  		this$1.inputs[ prop ] = source.inputs[ prop ];

  	}

  	this.value = source.value;

  };

  FunctionCallNode.prototype.toJSON = function ( meta ) {
  	var this$1 = this;


  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		var func = this.value;

  		data = this.createJSONNode( meta );

  		data.value = this.value.toJSON( meta ).uuid;

  		if ( func.inputs.length ) {

  			data.inputs = {};

  			for ( var i = 0; i < func.inputs.length; i ++ ) {

  				var inpt = func.inputs[ i ],
  					node = this$1.inputs[ i ] || this$1.inputs[ inpt.name ];

  				data.inputs[ inpt.name ] = node.toJSON( meta ).uuid;

  			}

  		}

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NodeUniform( params ) {

  	params = params || {};

  	this.name = params.name;
  	this.type = params.type;
  	this.node = params.node;
  	this.needsUpdate = params.needsUpdate;

  }

  Object.defineProperties( NodeUniform.prototype, {

  	value: {

  		get: function () {

  			return this.node.value;

  		},

  		set: function ( val ) {

  			this.node.value = val;

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var declarationRegexp$2 = /^struct\s*([a-z_0-9]+)\s*{\s*((.|\n)*?)}/img,
  	propertiesRegexp$1 = /\s*(\w*?)\s*(\w*?)(\=|\;)/img;

  function StructNode( src ) {

  	TempNode.call( this );

  	this.eval( src );

  }

  StructNode.prototype = Object.create( TempNode.prototype );
  StructNode.prototype.constructor = StructNode;
  StructNode.prototype.nodeType = "Struct";

  StructNode.prototype.getType = function ( builder ) {

  	return builder.getTypeByFormat( this.name );

  };

  StructNode.prototype.getInputByName = function ( name ) {
  	var this$1 = this;


  	var i = this.inputs.length;

  	while ( i -- ) {

  		if ( this$1.inputs[ i ].name === name ) {

  			return this$1.inputs[ i ];

  		}

  	}

  };

  StructNode.prototype.generate = function ( builder, output ) {

  	if ( output === 'source' ) {

  		return this.src + ';';

  	} else {

  		return builder.format( '( ' + this.src + ' )', this.getType( builder ), output );

  	}

  };

  StructNode.prototype.eval = function ( src ) {
  	var this$1 = this;


  	this.src = src || '';

  	this.inputs = [];

  	var declaration = declarationRegexp$2.exec( this.src );

  	if ( declaration ) {

  		var properties = declaration[ 2 ], match;

  		while ( match = propertiesRegexp$1.exec( properties ) ) {

  			this$1.inputs.push( {
  				type: match[ 1 ],
  				name: match[ 2 ]
  			} );

  		}

  		this.name = declaration[ 1 ];

  	} else {

  		this.name = '';

  	}

  	this.type = this.name;

  };

  StructNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.src = this.src;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector3Node( x, y, z ) {

  	InputNode.call( this, 'v3' );

  	this.value = x instanceof Vector3 ? x : new Vector3( x, y, z );

  }

  Vector3Node.prototype = Object.create( InputNode.prototype );
  Vector3Node.prototype.constructor = Vector3Node;
  Vector3Node.prototype.nodeType = "Vector3";

  NodeUtils.addShortcuts( Vector3Node.prototype, 'value', [ 'x', 'y', 'z' ] );

  Vector3Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "vec3( " + this.x + ", " + this.y + ", " + this.z + " )", type, output );

  };

  Vector3Node.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value.copy( source );

  };

  Vector3Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.x = this.x;
  		data.y = this.y;
  		data.z = this.z;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Vector4Node( x, y, z, w ) {

  	InputNode.call( this, 'v4' );

  	this.value = x instanceof Vector4 ? x : new Vector4( x, y, z, w );

  }

  Vector4Node.prototype = Object.create( InputNode.prototype );
  Vector4Node.prototype.constructor = Vector4Node;
  Vector4Node.prototype.nodeType = "Vector4";

  NodeUtils.addShortcuts( Vector4Node.prototype, 'value', [ 'x', 'y', 'z', 'w' ] );

  Vector4Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "vec4( " + this.x + ", " + this.y + ", " + this.z + ", " + this.w + " )", type, output );

  };

  Vector4Node.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value.copy( source );

  };

  Vector4Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.x = this.x;
  		data.y = this.y;
  		data.z = this.z;
  		data.w = this.w;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ColorSpaceNode( input, method ) {

  	TempNode.call( this, 'v4' );

  	this.input = input;

  	this.method = method || ColorSpaceNode.LINEAR;

  }

  ColorSpaceNode.Nodes = ( function () {

  	// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

  	var LinearToLinear = new FunctionNode( [
  		"vec4 LinearToLinear( in vec4 value ) {",

  		"	return value;",

  		"}"
  	].join( "\n" ) );

  	var GammaToLinear = new FunctionNode( [
  		"vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {",

  		"	return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );",

  		"}"
  	].join( "\n" ) );

  	var LinearToGamma = new FunctionNode( [
  		"vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {",

  		"	return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );",

  		"}"
  	].join( "\n" ) );

  	var sRGBToLinear = new FunctionNode( [
  		"vec4 sRGBToLinear( in vec4 value ) {",

  		"	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",

  		"}"
  	].join( "\n" ) );

  	var LinearTosRGB = new FunctionNode( [
  		"vec4 LinearTosRGB( in vec4 value ) {",

  		"	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",

  		"}"
  	].join( "\n" ) );

  	var RGBEToLinear = new FunctionNode( [
  		"vec4 RGBEToLinear( in vec4 value ) {",

  		"	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );",

  		"}"
  	].join( "\n" ) );

  	var LinearToRGBE = new FunctionNode( [
  		"vec4 LinearToRGBE( in vec4 value ) {",

  		"	float maxComponent = max( max( value.r, value.g ), value.b );",
  		"	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );",
  		"	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );",
  		//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );

  		"}"
  	].join( "\n" ) );

  	// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html

  	var RGBMToLinear = new FunctionNode( [
  		"vec3 RGBMToLinear( in vec4 value, in float maxRange ) {",

  		"	return vec4( value.xyz * value.w * maxRange, 1.0 );",

  		"}"
  	].join( "\n" ) );

  	var LinearToRGBM = new FunctionNode( [
  		"vec3 LinearToRGBM( in vec4 value, in float maxRange ) {",

  		"	float maxRGB = max( value.x, max( value.g, value.b ) );",
  		"	float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );",
  		"	M            = ceil( M * 255.0 ) / 255.0;",
  		"	return vec4( value.rgb / ( M * maxRange ), M );",

  		"}"
  	].join( "\n" ) );

  	// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html

  	var RGBDToLinear = new FunctionNode( [
  		"vec3 RGBDToLinear( in vec4 value, in float maxRange ) {",

  		"	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );",

  		"}"
  	].join( "\n" ) );
  	var LinearToRGBD = new FunctionNode( [
  		"vec3 LinearToRGBD( in vec4 value, in float maxRange ) {",

  		"	float maxRGB = max( value.x, max( value.g, value.b ) );",
  		"	float D      = max( maxRange / maxRGB, 1.0 );",
  		"	D            = min( floor( D ) / 255.0, 1.0 );",
  		"	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );",

  		"}"
  	].join( "\n" ) );

  	// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

  	// M matrix, for encoding

  	var cLogLuvM = new ConstNode( "const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );" );

  	var LinearToLogLuv = new FunctionNode( [
  		"vec4 LinearToLogLuv( in vec4 value ) {",

  		"	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;",
  		"	Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));",
  		"	vec4 vResult;",
  		"	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;",
  		"	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;",
  		"	vResult.w = fract(Le);",
  		"	vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;",
  		"	return vResult;",

  		"}"
  	].join( "\n" ), [ cLogLuvM ] );

  	// Inverse M matrix, for decoding

  	var cLogLuvInverseM = new ConstNode( "const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );" );

  	var LogLuvToLinear = new FunctionNode( [
  		"vec4 LogLuvToLinear( in vec4 value ) {",

  		"	float Le = value.z * 255.0 + value.w;",
  		"	vec3 Xp_Y_XYZp;",
  		"	Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
  		"	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;",
  		"	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;",
  		"	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;",
  		"	return vec4( max(vRGB, 0.0), 1.0 );",

  		"}"
  	].join( "\n" ), [ cLogLuvInverseM ] );

  	return {
  		LinearToLinear: LinearToLinear,
  		GammaToLinear: GammaToLinear,
  		LinearToGamma: LinearToGamma,
  		sRGBToLinear: sRGBToLinear,
  		LinearTosRGB: LinearTosRGB,
  		RGBEToLinear: RGBEToLinear,
  		LinearToRGBE: LinearToRGBE,
  		RGBMToLinear: RGBMToLinear,
  		LinearToRGBM: LinearToRGBM,
  		RGBDToLinear: RGBDToLinear,
  		LinearToRGBD: LinearToRGBD,
  		cLogLuvM: cLogLuvM,
  		LinearToLogLuv: LinearToLogLuv,
  		cLogLuvInverseM: cLogLuvInverseM,
  		LogLuvToLinear: LogLuvToLinear
  	};

  } )();

  ColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';

  ColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';
  ColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';

  ColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';
  ColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';

  ColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';
  ColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';

  ColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';
  ColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';

  ColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';
  ColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';

  ColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';
  ColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';

  ColorSpaceNode.prototype = Object.create( TempNode.prototype );
  ColorSpaceNode.prototype.constructor = ColorSpaceNode;
  ColorSpaceNode.prototype.nodeType = "ColorAdjustment";

  ColorSpaceNode.prototype.generate = function ( builder, output ) {

  	var input = builder.context.input || this.input.build( builder, 'v4' ),
  		encodingMethod = builder.context.encoding !== undefined ? this.getEncodingMethod( builder.context.encoding ) : [ this.method ],
  		factor = this.factor ? this.factor.build( builder, 'f' ) : encodingMethod[ 1 ];

  	var method = builder.include( ColorSpaceNode.Nodes[ encodingMethod[ 0 ] ] );

  	if ( factor ) {

  		return builder.format( method + '( ' + input + ', ' + factor + ' )', this.getType( builder ), output );

  	} else {

  		return builder.format( method + '( ' + input + ' )', this.getType( builder ), output );

  	}

  };

  ColorSpaceNode.prototype.getDecodingMethod = function ( encoding ) {

  	var components = this.getEncodingComponents( encoding );

  	components[ 0 ] += 'ToLinear';

  	return components;

  };

  ColorSpaceNode.prototype.getEncodingMethod = function ( encoding ) {

  	var components = this.getEncodingComponents( encoding );

  	components[ 0 ] = 'LinearTo' + components[ 0 ];

  	return components;

  };

  ColorSpaceNode.prototype.getEncodingComponents = function ( encoding ) {

  	switch ( encoding ) {

  		case LinearEncoding:
  			return [ 'Linear' ];
  		case sRGBEncoding:
  			return [ 'sRGB' ];
  		case RGBEEncoding:
  			return [ 'RGBE' ];
  		case RGBM7Encoding:
  			return [ 'RGBM', '7.0' ];
  		case RGBM16Encoding:
  			return [ 'RGBM', '16.0' ];
  		case RGBDEncoding:
  			return [ 'RGBD', '256.0' ];
  		case GammaEncoding:
  			return [ 'Gamma', 'float( GAMMA_FACTOR )' ];

  	}

  };

  ColorSpaceNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.input = source.input;
  	this.method = source.method;

  };

  ColorSpaceNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.input = this.input.toJSON( meta ).uuid;
  		data.method = this.method;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TextureNode( value, uv, bias, project ) {

  	InputNode.call( this, 'v4', { shared: true } );

  	this.value = value;
  	this.uv = uv || new UVNode();
  	this.bias = bias;
  	this.project = project !== undefined ? project : false;

  }

  TextureNode.prototype = Object.create( InputNode.prototype );
  TextureNode.prototype.constructor = TextureNode;
  TextureNode.prototype.nodeType = "Texture";

  TextureNode.prototype.getTexture = function ( builder, output ) {

  	return InputNode.prototype.generate.call( this, builder, output, this.value.uuid, 't' );

  };

  TextureNode.prototype.generate = function ( builder, output ) {

  	if ( output === 'sampler2D' ) {

  		return this.getTexture( builder, output );

  	}

  	var tex = this.getTexture( builder, output ),
  		uv = this.uv.build( builder, this.project ? 'v4' : 'v2' ),
  		bias = this.bias ? this.bias.build( builder, 'f' ) : undefined;

  	if ( bias == undefined && builder.context.bias ) {

  		bias = new builder.context.bias( this ).build( builder, 'f' );

  	}

  	var method, code;

  	if ( this.project ) { method = 'texture2DProj'; }
  	else { method = bias ? 'tex2DBias' : 'tex2D'; }

  	if ( bias ) { code = method + '( ' + tex + ', ' + uv + ', ' + bias + ' )'; }
  	else { code = method + '( ' + tex + ', ' + uv + ' )'; }

  	// add this context to replace ColorSpaceNode.input to code

  	builder.addContext( { input: code, encoding: builder.getTextureEncodingFromMap( this.value ), include: builder.isShader( 'vertex' ) } );

  	this.colorSpace = this.colorSpace || new ColorSpaceNode( this );
  	code = this.colorSpace.build( builder, this.type );

  	builder.removeContext();

  	return builder.format( code, this.type, output );

  };

  TextureNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	if ( source.value ) { this.value = source.value; }

  	this.uv = source.uv;

  	if ( source.bias ) { this.bias = source.bias; }
  	if ( source.project !== undefined ) { this.project = source.project; }

  };

  TextureNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		if ( this.value ) { data.value = this.value.uuid; }

  		data.uv = this.uv.toJSON( meta ).uuid;
  		data.project = this.project;

  		if ( this.bias ) { data.bias = this.bias.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubeTextureNode( value, uv, bias ) {

  	InputNode.call( this, 'v4', { shared: true } );

  	this.value = value;
  	this.uv = uv || new ReflectNode();
  	this.bias = bias;

  }

  CubeTextureNode.prototype = Object.create( InputNode.prototype );
  CubeTextureNode.prototype.constructor = CubeTextureNode;
  CubeTextureNode.prototype.nodeType = "CubeTexture";

  CubeTextureNode.prototype.getTexture = function ( builder, output ) {

  	return InputNode.prototype.generate.call( this, builder, output, this.value.uuid, 'tc' );

  };

  CubeTextureNode.prototype.generate = function ( builder, output ) {

  	if ( output === 'samplerCube' ) {

  		return this.getTexture( builder, output );

  	}

  	var cubetex = this.getTexture( builder, output );
  	var uv = this.uv.build( builder, 'v3' );
  	var bias = this.bias ? this.bias.build( builder, 'f' ) : undefined;

  	if ( bias === undefined && builder.context.bias ) {

  		bias = new builder.context.bias( this ).build( builder, 'f' );

  	}

  	var code;

  	if ( bias ) { code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )'; }
  	else { code = 'texCube( ' + cubetex + ', ' + uv + ' )'; }

  	// add this context to replace ColorSpaceNode.input to code

  	builder.addContext( { input: code, encoding: builder.getTextureEncodingFromMap( this.value ), include: builder.isShader( 'vertex' ) } );

  	this.colorSpace = this.colorSpace || new ColorSpaceNode( this );
  	code = this.colorSpace.build( builder, this.type );

  	builder.removeContext();

  	return builder.format( code, this.type, output );

  };

  CubeTextureNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	if ( source.value ) { this.value = source.value; }

  	this.uv = source.uv;

  	if ( source.bias ) { this.bias = source.bias; }

  };

  CubeTextureNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value.uuid;
  		data.uv = this.uv.toJSON( meta ).uuid;

  		if ( this.bias ) { data.bias = this.bias.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TextureCubeUVNode( uv, textureSize, blinnExponentToRoughness ) {

  	TempNode.call( this, 'TextureCubeUVData' ); // TextureCubeUVData is type as StructNode

  	this.uv = uv || new ReflectNode( ReflectNode.VECTOR );
  	this.textureSize = textureSize || new FloatNode( 1024 );
  	this.blinnExponentToRoughness = blinnExponentToRoughness || new BlinnExponentToRoughnessNode();

  }

  TextureCubeUVNode.Nodes = ( function () {

  	var TextureCubeUVData = new StructNode( [
  		"struct TextureCubeUVData {",
  		"	vec2 uv_10;",
  		"	vec2 uv_20;",
  		"	float t;",
  		"}"
  	].join( "\n" ) );

  	var getFaceFromDirection = new FunctionNode( [
  		"int getFaceFromDirection(vec3 direction) {",
  		"	vec3 absDirection = abs(direction);",
  		"	int face = -1;",
  		"	if( absDirection.x > absDirection.z ) {",
  		"		if(absDirection.x > absDirection.y )",
  		"			face = direction.x > 0.0 ? 0 : 3;",
  		"		else",
  		"			face = direction.y > 0.0 ? 1 : 4;",
  		"	}",
  		"	else {",
  		"		if(absDirection.z > absDirection.y )",
  		"			face = direction.z > 0.0 ? 2 : 5;",
  		"		else",
  		"			face = direction.y > 0.0 ? 1 : 4;",
  		"	}",
  		"	return face;",
  		"}"
  	].join( "\n" ) );

  	var cubeUV_maxLods1 = new ConstNode( "#define cubeUV_maxLods1 ( log2( cubeUV_textureSize * 0.25 ) - 1.0 )" );
  	var cubeUV_rangeClamp = new ConstNode( "#define cubeUV_rangeClamp ( exp2( ( 6.0 - 1.0 ) * 2.0 ) )" );

  	var MipLevelInfo = new FunctionNode( [
  		"vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness, in float cubeUV_textureSize ) {",
  		"	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);",
  		"	float dxRoughness = dFdx(roughness);",
  		"	float dyRoughness = dFdy(roughness);",
  		"	vec3 dx = dFdx( vec * scale * dxRoughness );",
  		"	vec3 dy = dFdy( vec * scale * dyRoughness );",
  		"	float d = max( dot( dx, dx ), dot( dy, dy ) );",
  		// Clamp the value to the max mip level counts. hard coded to 6 mips"
  		"	d = clamp(d, 1.0, cubeUV_rangeClamp);",
  		"	float mipLevel = 0.5 * log2(d);",
  		"	return vec2(floor(mipLevel), fract(mipLevel));",
  		"}"
  	].join( "\n" ), [ cubeUV_maxLods1, cubeUV_rangeClamp ], { derivatives: true } );

  	var cubeUV_maxLods2 = new ConstNode( "#define cubeUV_maxLods2 ( log2( cubeUV_textureSize * 0.25 ) - 2.0 )" );
  	var cubeUV_rcpTextureSize = new ConstNode( "#define cubeUV_rcpTextureSize ( 1.0 / cubeUV_textureSize )" );

  	var getCubeUV = new FunctionNode( [
  		"vec2 getCubeUV( vec3 direction, float roughnessLevel, float mipLevel, in float cubeUV_textureSize ) {",
  		"	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;",
  		"	float a = 16.0 * cubeUV_rcpTextureSize;",
  		"",
  		"	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );",
  		"	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;",
  		// float powScale = exp2(roughnessLevel + mipLevel);"
  		"	float powScale = exp2_packed.x * exp2_packed.y;",
  		// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);"
  		"	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;",
  		// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);"
  		"	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;",
  		"",
  		"	bool bRes = mipLevel == 0.0;",
  		"	scale =  bRes && (scale < a) ? a : scale;",
  		"",
  		"	vec3 r;",
  		"	vec2 offset;",
  		"	int face = getFaceFromDirection(direction);",
  		"",
  		"	float rcpPowScale = 1.0 / powScale;",
  		"",
  		"	if( face == 0) {",
  		"		r = vec3(direction.x, -direction.z, direction.y);",
  		"		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;",
  		"	}",
  		"	else if( face == 1) {",
  		"		r = vec3(direction.y, direction.x, direction.z);",
  		"		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;",
  		"	}",
  		"	else if( face == 2) {",
  		"		r = vec3(direction.z, direction.x, direction.y);",
  		"		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;",
  		"	}",
  		"	else if( face == 3) {",
  		"		r = vec3(direction.x, direction.z, direction.y);",
  		"		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;",
  		"	}",
  		"	else if( face == 4) {",
  		"		r = vec3(direction.y, direction.x, -direction.z);",
  		"		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;",
  		"	}",
  		"	else {",
  		"		r = vec3(direction.z, -direction.x, direction.y);",
  		"		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);",
  		"		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;",
  		"	}",
  		"	r = normalize(r);",
  		"	float texelOffset = 0.5 * cubeUV_rcpTextureSize;",
  		"	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;",
  		"	vec2 base = offset + vec2( texelOffset );",
  		"	return base + s * ( scale - 2.0 * texelOffset );",
  		"}"
  	].join( "\n" ), [ cubeUV_maxLods2, cubeUV_rcpTextureSize, getFaceFromDirection ] );

  	var cubeUV_maxLods3 = new ConstNode( "#define cubeUV_maxLods3 ( log2( cubeUV_textureSize * 0.25 ) - 3.0 )" );

  	var textureCubeUV = new FunctionNode( [
  		"TextureCubeUVData textureCubeUV( vec3 reflectedDirection, float roughness, in float cubeUV_textureSize ) {",
  		"	float roughnessVal = roughness * cubeUV_maxLods3;",
  		"	float r1 = floor(roughnessVal);",
  		"	float r2 = r1 + 1.0;",
  		"	float t = fract(roughnessVal);",
  		"	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness, cubeUV_textureSize);",
  		"	float s = mipInfo.y;",
  		"	float level0 = mipInfo.x;",
  		"	float level1 = level0 + 1.0;",
  		"	level1 = level1 > 5.0 ? 5.0 : level1;",
  		"",
  		// round to nearest mipmap if we are not interpolating."
  		"	level0 += min( floor( s + 0.5 ), 5.0 );",
  		"",
  		// Tri linear interpolation."
  		"	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0, cubeUV_textureSize);",
  		"	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0, cubeUV_textureSize);",
  		"",
  		"	return TextureCubeUVData(uv_10, uv_20, t);",
  		"}"
  	].join( "\n" ), [ TextureCubeUVData, cubeUV_maxLods3, MipLevelInfo, getCubeUV ] );

  	return {
  		TextureCubeUVData: TextureCubeUVData,
  		textureCubeUV: textureCubeUV
  	};

  } )();

  TextureCubeUVNode.prototype = Object.create( TempNode.prototype );
  TextureCubeUVNode.prototype.constructor = TextureCubeUVNode;
  TextureCubeUVNode.prototype.nodeType = "TextureCubeUV";

  TextureCubeUVNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		var textureCubeUV = builder.include( TextureCubeUVNode.Nodes.textureCubeUV );

  		return builder.format( textureCubeUV + '( ' + this.uv.build( builder, 'v3' ) + ', ' +
  			this.blinnExponentToRoughness.build( builder, 'f' ) + ', ' +
  			this.textureSize.build( builder, 'f' ) + ' )', this.getType( builder ), output );

  	} else {

  		console.warn( "TextureCubeUVNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec4( 0.0 )', this.getType( builder ), output );

  	}

  };

  TextureCubeUVNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.uv = this.uv.toJSON( meta ).uuid;
  		data.textureSize = this.textureSize.toJSON( meta ).uuid;
  		data.blinnExponentToRoughness = this.blinnExponentToRoughness.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TextureCubeNode( value, uv ) {

  	TempNode.call( this, 'v4' );

  	this.value = value;
  	this.uv = uv || new TextureCubeUVNode();

  }

  TextureCubeNode.prototype = Object.create( TempNode.prototype );
  TextureCubeNode.prototype.constructor = TextureCubeNode;
  TextureCubeNode.prototype.nodeType = "TextureCube";

  TextureCubeNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		var uv_10 = this.uv.build( builder ) + '.uv_10',
  			uv_20 = this.uv.build( builder ) + '.uv_20',
  			t = this.uv.build( builder ) + '.t';

  		var color10 = builder.getTexelDecodingFunctionFromTexture( 'texture2D( ' + this.value.build( builder, 'sampler2D' ) + ', ' + uv_10 + ' )', this.value.value ),
  			color20 = builder.getTexelDecodingFunctionFromTexture( 'texture2D( ' + this.value.build( builder, 'sampler2D' ) + ', ' + uv_20 + ' )', this.value.value );

  		return builder.format( 'vec4( mix( ' + color10 + ', ' + color20 + ', ' + t + ' ).rgb, 1.0 )', this.getType( builder ), output );

  	} else {

  		console.warn( "TextureCubeNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec4( 0.0 )', this.getType( builder ), output );

  	}

  };

  TextureCubeNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.uv = this.uv.toJSON( meta ).uuid;
  		data.textureSize = this.textureSize.toJSON( meta ).uuid;
  		data.blinnExponentToRoughness = this.blinnExponentToRoughness.toJSON( meta ).uuid;

  		if ( this.roughness ) { data.roughness = this.roughness.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var elements = NodeUtils.elements,
  	constructors = [ 'float', 'vec2', 'vec3', 'vec4' ],
  	convertFormatToType = {
  		float: 'f',
  		vec2: 'v2',
  		vec3: 'v3',
  		vec4: 'v4',
  		mat4: 'v4',
  		int: 'i',
  		bool: 'b'
  	},
  	convertTypeToFormat = {
  		t: 'sampler2D',
  		tc: 'samplerCube',
  		b: 'bool',
  		i: 'int',
  		f: 'float',
  		c: 'vec3',
  		v2: 'vec2',
  		v3: 'vec3',
  		v4: 'vec4',
  		m3: 'mat3',
  		m4: 'mat4'
  	};

  function NodeBuilder() {

  	this.slots = [];
  	this.caches = [];
  	this.contexts = [];

  	this.keywords = {};

  	this.nodeData = {};

  	this.requires = {
  		uv: [],
  		color: [],
  		lights: false,
  		fog: false
  	};

  	this.includes = {
  		consts: [],
  		functions: [],
  		structs: []
  	};

  	this.attributes = {};

  	this.prefixCode = [
  		"#ifdef TEXTURE_LOD_EXT",

  		"	#define texCube(a, b) textureCube(a, b)",
  		"	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",

  		"	#define tex2D(a, b) texture2D(a, b)",
  		"	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",

  		"#else",

  		"	#define texCube(a, b) textureCube(a, b)",
  		"	#define texCubeBias(a, b, c) textureCube(a, b, c)",

  		"	#define tex2D(a, b) texture2D(a, b)",
  		"	#define tex2DBias(a, b, c) texture2D(a, b, c)",

  		"#endif",

  		"#include <packing>",
  		"#include <common>"

  	].join( "\n" );

  	this.parsCode = {
  		vertex: '',
  		fragment: ''
  	};

  	this.code = {
  		vertex: '',
  		fragment: ''
  	};

  	this.nodeCode = {
  		vertex: '',
  		fragment: ''
  	};

  	this.resultCode = {
  		vertex: '',
  		fragment: ''
  	};

  	this.finalCode = {
  		vertex: '',
  		fragment: ''
  	};

  	this.inputs = {
  		uniforms: {
  			list: [],
  			vertex: [],
  			fragment: []
  		},
  		vars: {
  			varying: [],
  			vertex: [],
  			fragment: []
  		}
  	};

  	// send to material

  	this.defines = {};

  	this.uniforms = {};

  	this.extensions = {};

  	this.updaters = [];

  	this.nodes = [];

  	// --

  	this.parsing = false;
  	this.optimize = true;

  }

  NodeBuilder.prototype = {

  	constructor: NodeBuilder,

  	build: function ( vertex, fragment ) {

  		this.buildShader( 'vertex', vertex );
  		this.buildShader( 'fragment', fragment );

  		if ( this.requires.uv[ 0 ] ) {

  			this.addVaryCode( 'varying vec2 vUv;' );

  			this.addVertexFinalCode( 'vUv = uv;' );

  		}

  		if ( this.requires.uv[ 1 ] ) {

  			this.addVaryCode( 'varying vec2 vUv2;' );
  			this.addVertexParsCode( 'attribute vec2 uv2;' );

  			this.addVertexFinalCode( 'vUv2 = uv2;' );

  		}

  		if ( this.requires.color[ 0 ] ) {

  			this.addVaryCode( 'varying vec4 vColor;' );
  			this.addVertexParsCode( 'attribute vec4 color;' );

  			this.addVertexFinalCode( 'vColor = color;' );

  		}

  		if ( this.requires.color[ 1 ] ) {

  			this.addVaryCode( 'varying vec4 vColor2;' );
  			this.addVertexParsCode( 'attribute vec4 color2;' );

  			this.addVertexFinalCode( 'vColor2 = color2;' );

  		}

  		if ( this.requires.position ) {

  			this.addVaryCode( 'varying vec3 vPosition;' );

  			this.addVertexFinalCode( 'vPosition = transformed;' );

  		}

  		if ( this.requires.worldPosition ) {

  			this.addVaryCode( 'varying vec3 vWPosition;' );

  			this.addVertexFinalCode( 'vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;' );

  		}

  		if ( this.requires.normal ) {

  			this.addVaryCode( 'varying vec3 vObjectNormal;' );

  			this.addVertexFinalCode( 'vObjectNormal = normal;' );

  		}

  		if ( this.requires.worldNormal ) {

  			this.addVaryCode( 'varying vec3 vWNormal;' );

  			this.addVertexFinalCode( 'vWNormal = ( modelMatrix * vec4( objectNormal, 0.0 ) ).xyz;' );

  		}

  		return this;

  	},

  	buildShader: function ( shader, node ) {

  		this.resultCode[ shader ] = node.build( this.setShader( shader ), 'v4' );

  	},

  	setMaterial: function ( material, renderer ) {

  		this.material = material;
  		this.renderer = renderer;

  		this.requires.lights = material.lights;
  		this.requires.fog = material.fog;

  		this.mergeDefines( material.defines );

  		return this;

  	},

  	addFlow: function ( slot, cache, context ) {

  		return this.addSlot( slot ).addCache( cache ).addContext( context );

  	},

  	removeFlow: function () {

  		return this.removeSlot().removeCache().removeContext();

  	},

  	addCache: function ( name ) {

  		this.cache = name || '';
  		this.caches.push( this.cache );

  		return this;

  	},

  	removeCache: function () {

  		this.caches.pop();
  		this.cache = this.caches[ this.caches.length - 1 ] || '';

  		return this;

  	},

  	addContext: function ( context ) {

  		this.context = Object.assign( {}, this.context, context );
  		this.contexts.push( this.context );

  		return this;

  	},

  	removeContext: function () {

  		this.contexts.pop();
  		this.context = this.contexts[ this.contexts.length - 1 ] || {};

  		return this;

  	},

  	addSlot: function ( name ) {

  		this.slot = name || '';
  		this.slots.push( this.slot );

  		return this;

  	},

  	removeSlot: function () {

  		this.slots.pop();
  		this.slot = this.slots[ this.slots.length - 1 ] || '';

  		return this;

  	},
  	addVertexCode: function ( code ) {

  		this.addCode( code, 'vertex' );

  	},

  	addFragmentCode: function ( code ) {

  		this.addCode( code, 'fragment' );

  	},

  	addCode: function ( code, shader ) {

  		this.code[ shader || this.shader ] += code + '\n';

  	},
  	addVertexNodeCode: function ( code ) {

  		this.addNodeCode( code, 'vertex' );

  	},

  	addFragmentNodeCode: function ( code ) {

  		this.addNodeCode( code, 'fragment' );

  	},

  	addNodeCode: function ( code, shader ) {

  		this.nodeCode[ shader || this.shader ] += code + '\n';

  	},

  	clearNodeCode: function ( shader ) {

  		shader = shader || this.shader;

  		var code = this.nodeCode[ shader ];

  		this.nodeCode[ shader ] = '';

  		return code;

  	},

  	clearVertexNodeCode: function ( ) {

  		return this.clearNodeCode( 'vertex' );

  	},

  	clearFragmentNodeCode: function ( ) {

  		return this.clearNodeCode( 'fragment' );

  	},

  	addVertexFinalCode: function ( code ) {

  		this.addFinalCode( code, 'vertex' );

  	},

  	addFragmentFinalCode: function ( code ) {

  		this.addFinalCode( code, 'fragment' );

  	},

  	addFinalCode: function ( code, shader ) {

  		this.finalCode[ shader || this.shader ] += code + '\n';

  	},
  	addVertexParsCode: function ( code ) {

  		this.addParsCode( code, 'vertex' );

  	},

  	addFragmentParsCode: function ( code ) {

  		this.addParsCode( code, 'fragment' );

  	},

  	addParsCode: function ( code, shader ) {

  		this.parsCode[ shader || this.shader ] += code + '\n';

  	},
  	addVaryCode: function ( code ) {

  		this.addVertexParsCode( code );
  		this.addFragmentParsCode( code );

  	},
  	isCache: function ( name ) {

  		return this.caches.indexOf( name ) !== - 1;

  	},

  	isSlot: function ( name ) {

  		return this.slots.indexOf( name ) !== - 1;

  	},

  	define: function ( name, value ) {

  		this.defines[ name ] = value === undefined ? 1 : value;

  	},

  	isDefined: function ( name ) {

  		return this.defines[ name ] !== undefined;

  	},

  	getVar: function ( uuid, type, ns, shader, prefix, label ) {
  		if ( shader === void 0 ) shader = 'varying';
  		if ( prefix === void 0 ) prefix = 'V';
  		if ( label === void 0 ) label = '';


  		var vars = this.getVars( shader ),
  			data = vars[ uuid ];

  		if ( ! data ) {

  			var index = vars.length,
  				name = ns ? ns : 'node' + prefix + index + ( label ? '_' + label : '' );

  			data = { name: name, type: type };

  			vars.push( data );
  			vars[ uuid ] = data;

  		}

  		return data;

  	},

  	getTempVar: function ( uuid, type, ns, label ) {

  		return this.getVar( uuid, type, ns, this.shader, 'T', label );

  	},

  	getAttribute: function ( name, type ) {

  		if ( ! this.attributes[ name ] ) {

  			var varying = this.getVar( name, type );

  			this.addVertexParsCode( 'attribute ' + type + ' ' + name + ';' );
  			this.addVertexFinalCode( varying.name + ' = ' + name + ';' );

  			this.attributes[ name ] = { varying: varying, name: name, type: type };

  		}

  		return this.attributes[ name ];

  	},

  	getCode: function ( shader ) {

  		return [
  			this.prefixCode,
  			this.parsCode[ shader ],
  			this.getVarListCode( this.getVars( 'varying' ), 'varying' ),
  			this.getVarListCode( this.inputs.uniforms[ shader ], 'uniform' ),
  			this.getIncludesCode( 'consts', shader ),
  			this.getIncludesCode( 'structs', shader ),
  			this.getIncludesCode( 'functions', shader ),
  			'void main() {',
  			this.getVarListCode( this.getVars( shader ) ),
  			this.code[ shader ],
  			this.resultCode[ shader ],
  			this.finalCode[ shader ],
  			'}'
  		].join( "\n" );

  	},

  	getVarListCode: function ( vars, prefix ) {
  		var this$1 = this;


  		prefix = prefix || '';

  		var code = '';

  		for ( var i = 0, l = vars.length; i < l; ++ i ) {

  			var nVar = vars[ i ],
  				type = nVar.type,
  				name = nVar.name;

  			var formatType = this$1.getFormatByType( type );

  			if ( formatType === undefined ) {

  				throw new Error( "Node pars " + formatType + " not found." );

  			}

  			code += prefix + ' ' + formatType + ' ' + name + ';\n';

  		}

  		return code;

  	},

  	getVars: function ( shader ) {

  		return this.inputs.vars[ shader || this.shader ];

  	},

  	getNodeData: function ( node ) {

  		var uuid = node.isNode ? node.uuid : node;

  		return this.nodeData[ uuid ] = this.nodeData[ uuid ] || {};

  	},

  	createUniform: function ( shader, type, node, ns, needsUpdate, label ) {

  		var uniforms = this.inputs.uniforms,
  			index = uniforms.list.length;

  		var uniform = new NodeUniform( {
  			type: type,
  			name: ns ? ns : 'nodeU' + index + ( label ? '_' + label : '' ),
  			node: node,
  			needsUpdate: needsUpdate
  		} );

  		uniforms.list.push( uniform );

  		uniforms[ shader ].push( uniform );
  		uniforms[ shader ][ uniform.name ] = uniform;

  		this.uniforms[ uniform.name ] = uniform;

  		return uniform;

  	},

  	createVertexUniform: function ( type, node, ns, needsUpdate, label ) {

  		return this.createUniform( 'vertex', type, node, ns, needsUpdate, label );

  	},

  	createFragmentUniform: function ( type, node, ns, needsUpdate, label ) {

  		return this.createUniform( 'fragment', type, node, ns, needsUpdate, label );

  	},

  	include: function ( node, parent, source ) {
  		var this$1 = this;


  		var includesStruct;

  		node = typeof node === 'string' ? NodeLib.get( node ) : node;

  		if ( this.context.include === false ) {

  			return node.name;

  		}
  		if ( node instanceof FunctionNode ) {

  			includesStruct = this.includes.functions;

  		} else if ( node instanceof ConstNode ) {

  			includesStruct = this.includes.consts;

  		} else if ( node instanceof StructNode ) {

  			includesStruct = this.includes.structs;

  		}

  		var includes = includesStruct[ this.shader ] = includesStruct[ this.shader ] || [];

  		if ( node ) {

  			var included = includes[ node.name ];

  			if ( ! included ) {

  				included = includes[ node.name ] = {
  					node: node,
  					deps: []
  				};

  				includes.push( included );

  				included.src = node.build( this, 'source' );

  			}

  			if ( node instanceof FunctionNode && parent && includes[ parent.name ] && includes[ parent.name ].deps.indexOf( node ) == - 1 ) {

  				includes[ parent.name ].deps.push( node );

  				if ( node.includes && node.includes.length ) {

  					var i = 0;

  					do {

  						this$1.include( node.includes[ i ++ ], parent );

  					} while ( i < node.includes.length );

  				}

  			}

  			if ( source ) {

  				included.src = source;

  			}

  			return node.name;

  		} else {

  			throw new Error( "Include not found." );

  		}

  	},

  	colorToVectorProperties: function ( color ) {

  		return color.replace( 'r', 'x' ).replace( 'g', 'y' ).replace( 'b', 'z' ).replace( 'a', 'w' );

  	},

  	colorToVector: function ( color ) {

  		return color.replace( /c/g, 'v3' );

  	},

  	getIncludes: function ( type, shader ) {

  		return this.includes[ type ][ shader || this.shader ];

  	},

  	getIncludesCode: function () {

  		function sortByPosition( a, b ) {

  			return a.deps.length - b.deps.length;

  		}

  		return function getIncludesCode( type, shader ) {

  			var includes = this.getIncludes( type, shader );

  			if ( ! includes ) { return ''; }

  			var code = '',
  				includes = includes.sort( sortByPosition );

  			for ( var i = 0; i < includes.length; i ++ ) {

  				if ( includes[ i ].src ) { code += includes[ i ].src + '\n'; }

  			}

  			return code;

  		};

  	}(),

  	getConstructorFromLength: function ( len ) {

  		return constructors[ len - 1 ];

  	},

  	isTypeMatrix: function ( format ) {

  		return /^m/.test( format );

  	},

  	getTypeLength: function ( type ) {

  		if ( type === 'f' ) { return 1; }

  		return parseInt( this.colorToVector( type ).substr( 1 ) );

  	},

  	getTypeFromLength: function ( len ) {

  		if ( len === 1 ) { return 'f'; }

  		return 'v' + len;

  	},

  	findNode: function () {
  		var arguments$1 = arguments;


  		for ( var i = 0; i < arguments.length; i ++ ) {

  			var nodeCandidate = arguments$1[ i ];

  			if ( nodeCandidate !== undefined && nodeCandidate.isNode ) {

  				return nodeCandidate;

  			}

  		}

  	},

  	resolve: function () {
  		var arguments$1 = arguments;


  		for ( var i = 0; i < arguments.length; i ++ ) {

  			var nodeCandidate = arguments$1[ i ];

  			if ( nodeCandidate !== undefined ) {

  				if ( nodeCandidate.isNode ) {

  					return nodeCandidate;

  				} else if ( nodeCandidate.isTexture ) {

  					switch ( nodeCandidate.mapping ) {

  						case CubeReflectionMapping:
  						case CubeRefractionMapping:

  							return new CubeTextureNode( nodeCandidate );

  							break;

  						case CubeUVReflectionMapping:
  						case CubeUVRefractionMapping:

  							return new TextureCubeNode( new TextureNode( nodeCandidate ) );

  							break;

  						default:

  							return new TextureNode( nodeCandidate );

  					}

  				} else if ( nodeCandidate.isVector2 ) {

  					return new Vector2Node( nodeCandidate );

  				} else if ( nodeCandidate.isVector3 ) {

  					return new Vector3Node( nodeCandidate );

  				} else if ( nodeCandidate.isVector4 ) {

  					return new Vector4Node( nodeCandidate );

  				}

  			}

  		}

  	},

  	format: function ( code, from, to ) {

  		var typeToType = this.colorToVector( to + ' <- ' + from );

  		switch ( typeToType ) {

  			case 'f <- v2' : return code + '.x';
  			case 'f <- v3' : return code + '.x';
  			case 'f <- v4' : return code + '.x';
  			case 'f <- i' :
  			case 'f <- b' :	return 'float( ' + code + ' )';

  			case 'v2 <- f' : return 'vec2( ' + code + ' )';
  			case 'v2 <- v3': return code + '.xy';
  			case 'v2 <- v4': return code + '.xy';
  			case 'v2 <- i' :
  			case 'v2 <- b' : return 'vec2( float( ' + code + ' ) )';

  			case 'v3 <- f' : return 'vec3( ' + code + ' )';
  			case 'v3 <- v2': return 'vec3( ' + code + ', 0.0 )';
  			case 'v3 <- v4': return code + '.xyz';
  			case 'v3 <- i' :
  			case 'v3 <- b' : return 'vec2( float( ' + code + ' ) )';

  			case 'v4 <- f' : return 'vec4( ' + code + ' )';
  			case 'v4 <- v2': return 'vec4( ' + code + ', 0.0, 1.0 )';
  			case 'v4 <- v3': return 'vec4( ' + code + ', 1.0 )';
  			case 'v4 <- i' :
  			case 'v4 <- b' : return 'vec4( float( ' + code + ' ) )';

  			case 'i <- f' :
  			case 'i <- b' : return 'int( ' + code + ' )';
  			case 'i <- v2' : return 'int( ' + code + '.x )';
  			case 'i <- v3' : return 'int( ' + code + '.x )';
  			case 'i <- v4' : return 'int( ' + code + '.x )';

  			case 'b <- f' : return '( ' + code + ' != 0.0 )';
  			case 'b <- v2' : return '( ' + code + ' != vec2( 0.0 ) )';
  			case 'b <- v3' : return '( ' + code + ' != vec3( 0.0 ) )';
  			case 'b <- v4' : return '( ' + code + ' != vec4( 0.0 ) )';
  			case 'b <- i' : return '( ' + code + ' != 0 )';

  		}

  		return code;

  	},

  	getTypeByFormat: function ( format ) {

  		return convertFormatToType[ format ] || format;

  	},

  	getFormatByType: function ( type ) {

  		return convertTypeToFormat[ type ] || type;

  	},

  	getUuid: function ( uuid, useCache ) {

  		useCache = useCache !== undefined ? useCache : true;

  		if ( useCache && this.cache ) { uuid = this.cache + '-' + uuid; }

  		return uuid;

  	},

  	getElementByIndex: function ( index ) {

  		return elements[ index ];

  	},

  	getIndexByElement: function ( elm ) {

  		return elements.indexOf( elm );

  	},

  	isShader: function ( shader ) {

  		return this.shader === shader;

  	},

  	setShader: function ( shader ) {

  		this.shader = shader;

  		return this;

  	},

  	mergeDefines: function ( defines ) {
  		var this$1 = this;


  		for ( var name in defines ) {

  			this$1.defines[ name ] = defines[ name ];

  		}

  		return this.defines;

  	},

  	mergeUniform: function ( uniforms ) {
  		var this$1 = this;


  		for ( var name in uniforms ) {

  			this$1.uniforms[ name ] = uniforms[ name ];

  		}

  		return this.uniforms;

  	},

  	getTextureEncodingFromMap: function ( map, gammaOverrideLinear ) {

  		gammaOverrideLinear = gammaOverrideLinear !== undefined ? gammaOverrideLinear : this.context.gamma && ( this.renderer ? this.renderer.gammaInput : false );

  		var encoding;

  		if ( ! map ) {

  			encoding = LinearEncoding;

  		} else if ( map.isTexture ) {

  			encoding = map.encoding;

  		} else if ( map.isWebGLRenderTarget ) {

  			console.warn( "WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
  			encoding = map.texture.encoding;

  		}

  		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

  			encoding = GammaEncoding;

  		}

  		return encoding;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NodeFrame( time ) {

  	this.time = time !== undefined ? time : 0;

  	this.id = 0;

  }

  NodeFrame.prototype = {

  	constructor: NodeFrame,

  	update: function ( delta ) {

  		++ this.id;

  		this.time += delta;
  		this.delta = delta;

  		return this;

  	},

  	setRenderer: function ( renderer ) {

  		this.renderer = renderer;

  		return this;

  	},

  	setRenderTexture: function ( renderTexture ) {

  		this.renderTexture = renderTexture;

  		return this;

  	},

  	updateNode: function ( node ) {

  		if ( node.frameId === this.id ) { return this; }

  		node.updateFrame( this );

  		node.frameId = this.id;

  		return this;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function VarNode( type, value ) {

  	Node$1.call( this, type );

  	this.value = value;

  }

  VarNode.prototype = Object.create( Node$1.prototype );
  VarNode.prototype.constructor = VarNode;
  VarNode.prototype.nodeType = "Var";

  VarNode.prototype.getType = function ( builder ) {

  	return builder.getTypeByFormat( this.type );

  };

  VarNode.prototype.generate = function ( builder, output ) {

  	var varying = builder.getVar( this.uuid, this.type );

  	if ( this.value && builder.isShader( 'vertex' ) ) {

  		builder.addNodeCode( varying.name + ' = ' + this.value.build( builder, this.getType( builder ) ) + ';' );

  	}

  	return builder.format( varying.name, this.getType( builder ), output );

  };

  VarNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	this.type = source.type;
  	this.value = source.value;

  };

  VarNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.type = this.type;

  		if ( this.value ) { data.value = this.value.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BlurNode( value, uv, radius, size ) {

  	TempNode.call( this, 'v4' );

  	this.value = value;
  	this.uv = uv || new UVNode();
  	this.radius = new Vector2Node( 1, 1 );

  	this.size = size;

  	this.blurX = true;
  	this.blurY = true;

  	this.horizontal = new FloatNode( 1 / 64 );
  	this.vertical = new FloatNode( 1 / 64 );

  }

  BlurNode.Nodes = ( function () {

  	var blurX = new FunctionNode( [
  		"vec4 blurX( sampler2D texture, vec2 uv, float s ) {",
  		"	vec4 sum = vec4( 0.0 );",
  		"	sum += texture2D( texture, vec2( uv.x - 4.0 * s, uv.y ) ) * 0.051;",
  		"	sum += texture2D( texture, vec2( uv.x - 3.0 * s, uv.y ) ) * 0.0918;",
  		"	sum += texture2D( texture, vec2( uv.x - 2.0 * s, uv.y ) ) * 0.12245;",
  		"	sum += texture2D( texture, vec2( uv.x - 1.0 * s, uv.y ) ) * 0.1531;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y ) ) * 0.1633;",
  		"	sum += texture2D( texture, vec2( uv.x + 1.0 * s, uv.y ) ) * 0.1531;",
  		"	sum += texture2D( texture, vec2( uv.x + 2.0 * s, uv.y ) ) * 0.12245;",
  		"	sum += texture2D( texture, vec2( uv.x + 3.0 * s, uv.y ) ) * 0.0918;",
  		"	sum += texture2D( texture, vec2( uv.x + 4.0 * s, uv.y ) ) * 0.051;",
  		"	return sum * .667;",
  		"}"
  	].join( "\n" ) );

  	var blurY = new FunctionNode( [
  		"vec4 blurY( sampler2D texture, vec2 uv, float s ) {",
  		"	vec4 sum = vec4( 0.0 );",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y - 4.0 * s ) ) * 0.051;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y - 3.0 * s ) ) * 0.0918;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y - 2.0 * s ) ) * 0.12245;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y - 1.0 * s ) ) * 0.1531;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y ) ) * 0.1633;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y + 1.0 * s ) ) * 0.1531;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y + 2.0 * s ) ) * 0.12245;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y + 3.0 * s ) ) * 0.0918;",
  		"	sum += texture2D( texture, vec2( uv.x, uv.y + 4.0 * s ) ) * 0.051;",
  		"	return sum * .667;",
  		"}"
  	].join( "\n" ) );

  	return {
  		blurX: blurX,
  		blurY: blurY
  	};

  } )();
  BlurNode.prototype = Object.create( TempNode.prototype );
  BlurNode.prototype.constructor = BlurNode;
  BlurNode.prototype.nodeType = "Blur";

  BlurNode.prototype.updateFrame = function ( frame ) {

  	if ( this.size ) {

  		this.horizontal.value = this.radius.x / this.size.x;
  		this.vertical.value = this.radius.y / this.size.y;

  	} else if ( this.value.value && this.value.value.image ) {

  		var image = this.value.value.image;

  		this.horizontal.value = this.radius.x / image.width;
  		this.vertical.value = this.radius.y / image.height;

  	}

  };

  BlurNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		var blurCode = [], code;

  		var blurX = builder.include( BlurNode.Nodes.blurX ),
  			blurY = builder.include( BlurNode.Nodes.blurY );

  		if ( this.blurX ) {

  			blurCode.push( blurX + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' + this.uv.build( builder, 'v2' ) + ', ' + this.horizontal.build( builder, 'f' ) + ' )' );

  		}

  		if ( this.blurY ) {

  			blurCode.push( blurY + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' + this.uv.build( builder, 'v2' ) + ', ' + this.vertical.build( builder, 'f' ) + ' )' );

  		}

  		if ( blurCode.length == 2 ) { code = '( ' + blurCode.join( ' + ' ) + ' / 2.0 )'; }
  		else if ( blurCode.length ) { code = '( ' + blurCode[ 0 ] + ' )'; }
  		else { code = 'vec4( 0.0 )'; }

  		return builder.format( code, this.getType( builder ), output );

  	} else {

  		console.warn( "BlurNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec4( 0.0 )', this.getType( builder ), output );

  	}

  };

  BlurNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.value = source.value;
  	this.uv = source.uv;
  	this.radius = source.radius;

  	if ( source.size !== undefined ) { this.size = new Vector2( source.size.x, source.size.y ); }

  	this.blurX = source.blurX;
  	this.blurY = source.blurY;

  };

  BlurNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value.toJSON( meta ).uuid;
  		data.uv = this.uv.toJSON( meta ).uuid;
  		data.radius = this.radius.toJSON( meta ).uuid;

  		if ( this.size ) { data.size = { x: this.size.x, y: this.size.y }; }

  		data.blurX = this.blurX;
  		data.blurY = this.blurY;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LuminanceNode( rgb ) {

  	TempNode.call( this, 'f' );

  	this.rgb = rgb;

  }

  LuminanceNode.Nodes = ( function () {

  	var LUMA = new ConstNode( "vec3 LUMA vec3( 0.2125, 0.7154, 0.0721 )" );

  	var luminance = new FunctionNode( [
  		// Algorithm from Chapter 10 of Graphics Shaders
  		"float luminance( vec3 rgb ) {",

  		"	return dot( rgb, LUMA );",

  		"}"
  	].join( "\n" ), [ LUMA ] );

  	return {
  		LUMA: LUMA,
  		luminance: luminance
  	};

  } )();

  LuminanceNode.prototype = Object.create( TempNode.prototype );
  LuminanceNode.prototype.constructor = LuminanceNode;
  LuminanceNode.prototype.nodeType = "Luminance";

  LuminanceNode.prototype.generate = function ( builder, output ) {

  	var luminance = builder.include( LuminanceNode.Nodes.luminance );

  	return builder.format( luminance + '( ' + this.rgb.build( builder, 'v3' ) + ' )', this.getType( builder ), output );

  };

  LuminanceNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.rgb = source.rgb;

  };

  LuminanceNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.rgb = this.rgb.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ColorAdjustmentNode( rgb, adjustment, method ) {

  	TempNode.call( this, 'v3' );

  	this.rgb = rgb;
  	this.adjustment = adjustment;

  	this.method = method || ColorAdjustmentNode.SATURATION;

  }

  ColorAdjustmentNode.Nodes = ( function () {

  	var hue = new FunctionNode( [
  		"vec3 hue(vec3 rgb, float adjustment) {",

  		"	const mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);",
  		"	const mat3 YIQtoRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);",

  		"	vec3 yiq = RGBtoYIQ * rgb;",

  		"	float hue = atan(yiq.z, yiq.y) + adjustment;",
  		"	float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);",

  		"	return YIQtoRGB * vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));",

  		"}"
  	].join( "\n" ) );

  	var saturation = new FunctionNode( [
  		// Algorithm from Chapter 16 of OpenGL Shading Language
  		"vec3 saturation(vec3 rgb, float adjustment) {",

  		"	vec3 intensity = vec3( luminance( rgb ) );",

  		"	return mix( intensity, rgb, adjustment );",

  		"}"
  	].join( "\n" ), [ LuminanceNode.Nodes.luminance ] ); // include LuminanceNode function

  	var vibrance = new FunctionNode( [
  		// Shader by Evan Wallace adapted by @lo-th
  		"vec3 vibrance(vec3 rgb, float adjustment) {",

  		"	float average = (rgb.r + rgb.g + rgb.b) / 3.0;",

  		"	float mx = max(rgb.r, max(rgb.g, rgb.b));",
  		"	float amt = (mx - average) * (-3.0 * adjustment);",

  		"	return mix(rgb.rgb, vec3(mx), amt);",

  		"}"
  	].join( "\n" ) );

  	return {
  		hue: hue,
  		saturation: saturation,
  		vibrance: vibrance
  	};

  } )();

  ColorAdjustmentNode.SATURATION = 'saturation';
  ColorAdjustmentNode.HUE = 'hue';
  ColorAdjustmentNode.VIBRANCE = 'vibrance';
  ColorAdjustmentNode.BRIGHTNESS = 'brightness';
  ColorAdjustmentNode.CONTRAST = 'contrast';

  ColorAdjustmentNode.prototype = Object.create( TempNode.prototype );
  ColorAdjustmentNode.prototype.constructor = ColorAdjustmentNode;
  ColorAdjustmentNode.prototype.nodeType = "ColorAdjustment";

  ColorAdjustmentNode.prototype.generate = function ( builder, output ) {

  	var rgb = this.rgb.build( builder, 'v3' ),
  		adjustment = this.adjustment.build( builder, 'f' );

  	switch ( this.method ) {

  		case ColorAdjustmentNode.BRIGHTNESS:

  			return builder.format( '( ' + rgb + ' + ' + adjustment + ' )', this.getType( builder ), output );

  			break;

  		case ColorAdjustmentNode.CONTRAST:

  			return builder.format( '( ' + rgb + ' * ' + adjustment + ' )', this.getType( builder ), output );

  			break;

  	}

  	var method = builder.include( ColorAdjustmentNode.Nodes[ this.method ] );

  	return builder.format( method + '( ' + rgb + ', ' + adjustment + ' )', this.getType( builder ), output );

  };

  ColorAdjustmentNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.rgb = source.rgb;
  	this.adjustment = source.adjustment;
  	this.method = source.method;

  };

  ColorAdjustmentNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.rgb = this.rgb.toJSON( meta ).uuid;
  		data.adjustment = this.adjustment.toJSON( meta ).uuid;
  		data.method = this.method;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BoolNode( value ) {

  	InputNode.call( this, 'b' );

  	this.value = Boolean( value );

  }

  BoolNode.prototype = Object.create( InputNode.prototype );
  BoolNode.prototype.constructor = BoolNode;
  BoolNode.prototype.nodeType = "Bool";

  BoolNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( this.value, type, output );

  };

  BoolNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value = source.value;

  };

  BoolNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ColorNode( color, g, b ) {

  	InputNode.call( this, 'c' );

  	this.value = color instanceof Color ? color : new Color( color || 0, g, b );

  }

  ColorNode.prototype = Object.create( InputNode.prototype );
  ColorNode.prototype.constructor = ColorNode;
  ColorNode.prototype.nodeType = "Color";

  NodeUtils.addShortcuts( ColorNode.prototype, 'value', [ 'r', 'g', 'b' ] );

  ColorNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "vec3( " + this.r + ", " + this.g + ", " + this.b + " )", type, output );

  };

  ColorNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value.copy( source );

  };

  ColorNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.r = this.r;
  		data.g = this.g;
  		data.b = this.b;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function IntNode( value ) {

  	InputNode.call( this, 'i' );

  	this.value = Math.floor( value || 0 );

  }

  IntNode.prototype = Object.create( InputNode.prototype );
  IntNode.prototype.constructor = IntNode;
  IntNode.prototype.nodeType = "Int";

  IntNode.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( this.value, type, output );

  };

  IntNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value = source.value;

  };

  IntNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value;

  		if ( this.readonly === true ) { data.readonly = true; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Matrix3Node( matrix ) {

  	InputNode.call( this, 'm3' );

  	this.value = matrix || new Matrix3();

  }

  Matrix3Node.prototype = Object.create( InputNode.prototype );
  Matrix3Node.prototype.constructor = Matrix3Node;
  Matrix3Node.prototype.nodeType = "Matrix3";

  Object.defineProperties( Matrix3Node.prototype, {

  	elements: {

  		set: function ( val ) {

  			this.value.elements = val;

  		},

  		get: function () {

  			return this.value.elements;

  		}

  	}

  } );

  Matrix3Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "mat3( " + this.value.elements.join( ", " ) + " )", type, output );

  };
  Matrix3Node.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.value.fromArray( source.elements );

  };

  Matrix3Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.elements = this.value.elements.concat();

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Matrix4Node( matrix ) {

  	InputNode.call( this, 'm4' );

  	this.value = matrix || new Matrix4();

  }

  Matrix4Node.prototype = Object.create( InputNode.prototype );
  Matrix4Node.prototype.constructor = Matrix4Node;
  Matrix4Node.prototype.nodeType = "Matrix4";

  Object.defineProperties( Matrix4Node.prototype, {

  	elements: {

  		set: function ( val ) {

  			this.value.elements = val;

  		},

  		get: function () {

  			return this.value.elements;

  		}

  	}

  } );

  Matrix4Node.prototype.generateReadonly = function ( builder, output, uuid, type, ns, needsUpdate ) {

  	return builder.format( "mat4( " + this.value.elements.join( ", " ) + " )", type, output );

  };

  Matrix4Node.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.scope.value.fromArray( source.elements );

  };

  Matrix4Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.elements = this.value.elements.concat();

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PropertyNode( object, property, type ) {

  	InputNode.call( this, type );

  	this.object = object;
  	this.property = property;

  }

  PropertyNode.prototype = Object.create( InputNode.prototype );
  PropertyNode.prototype.constructor = PropertyNode;
  PropertyNode.prototype.nodeType = "Property";

  Object.defineProperties( PropertyNode.prototype, {

  	value: {

  		get: function () {

  			return this.object[ this.property ];

  		},

  		set: function ( val ) {

  			this.object[ this.property ] = val;

  		}

  	}

  } );

  PropertyNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value;
  		data.property = this.property;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function OperatorNode( a, b, op ) {

  	TempNode.call( this );

  	this.a = a;
  	this.b = b;
  	this.op = op;

  }

  OperatorNode.ADD = '+';
  OperatorNode.SUB = '-';
  OperatorNode.MUL = '*';
  OperatorNode.DIV = '/';

  OperatorNode.prototype = Object.create( TempNode.prototype );
  OperatorNode.prototype.constructor = OperatorNode;
  OperatorNode.prototype.nodeType = "Operator";

  OperatorNode.prototype.getType = function ( builder ) {

  	var a = this.a.getType( builder ),
  		b = this.b.getType( builder );

  	if ( builder.isTypeMatrix( a ) ) {

  		return 'v4';

  	} else if ( builder.getTypeLength( b ) > builder.getTypeLength( a ) ) {

  		// use the greater length vector

  		return b;

  	}

  	return a;

  };

  OperatorNode.prototype.generate = function ( builder, output ) {

  	var data = builder.getNodeData( this ),
  		type = this.getType( builder );

  	var a = this.a.build( builder, type ),
  		b = this.b.build( builder, type );

  	return builder.format( '( ' + a + ' ' + this.op + ' ' + b + ' )', type, output );

  };

  OperatorNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.a = source.a;
  	this.b = source.b;
  	this.op = source.op;

  };

  OperatorNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.a = this.a.toJSON( meta ).uuid;
  		data.b = this.b.toJSON( meta ).uuid;
  		data.op = this.op;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ReflectorNode( mirror ) {

  	TempNode.call( this, 'v4' );

  	if ( mirror ) { this.setMirror( mirror ); }

  }

  ReflectorNode.prototype = Object.create( TempNode.prototype );
  ReflectorNode.prototype.constructor = ReflectorNode;
  ReflectorNode.prototype.nodeType = "Reflector";

  ReflectorNode.prototype.setMirror = function ( mirror ) {

  	this.mirror = mirror;

  	this.textureMatrix = new Matrix4Node( this.mirror.material.uniforms.textureMatrix.value );

  	this.localPosition = new PositionNode( PositionNode.LOCAL );

  	this.uv = new OperatorNode( this.textureMatrix, this.localPosition, OperatorNode.MUL );
  	this.uvResult = new OperatorNode( null, this.uv, OperatorNode.ADD );

  	this.texture = new TextureNode( this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true );

  };

  ReflectorNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		this.uvResult.a = this.offset;
  		this.texture.uv = this.offset ? this.uvResult : this.uv;

  		if ( output === 'sampler2D' ) {

  			return this.texture.build( builder, output );

  		}

  		return builder.format( this.texture.build( builder, this.type ), this.type, output );

  	} else {

  		console.warn( "ReflectorNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec4( 0.0 )', this.type, output );

  	}

  };

  ReflectorNode.prototype.copy = function ( source ) {

  	InputNode.prototype.copy.call( this, source );

  	this.scope.mirror = source.mirror;

  };

  ReflectorNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.mirror = this.mirror.uuid;

  		if ( this.offset ) { data.offset = this.offset.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RawNode( value ) {

  	Node$1.call( this, 'v4' );

  	this.value = value;

  }

  RawNode.prototype = Object.create( Node$1.prototype );
  RawNode.prototype.constructor = RawNode;
  RawNode.prototype.nodeType = "Raw";

  RawNode.prototype.generate = function ( builder ) {

  	var data = this.value.parseAndBuildCode( builder, this.type ),
  		code = data.code + '\n';

  	if ( builder.isShader( 'vertex' ) ) {

  		code += 'gl_Position = ' + data.result + ';';

  	} else {

  		code += 'gl_FragColor = ' + data.result + ';';

  	}

  	return code;

  };

  RawNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	this.value = source.value;

  };

  RawNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NodeMaterial( vertex, fragment ) {

  	ShaderMaterial.call( this );

  	this.vertex = vertex || new RawNode( new PositionNode( PositionNode.PROJECTION ) );
  	this.fragment = fragment || new RawNode( new ColorNode( 0xFF0000 ) );

  	this.updaters = [];

  }

  NodeMaterial.prototype = Object.create( ShaderMaterial.prototype );
  NodeMaterial.prototype.constructor = NodeMaterial;
  NodeMaterial.prototype.type = "NodeMaterial";

  NodeMaterial.prototype.isNodeMaterial = true;

  Object.defineProperties( NodeMaterial.prototype, {

  	properties: {

  		get: function () {

  			return this.fragment.properties;

  		}

  	}

  } );

  NodeMaterial.prototype.updateFrame = function ( frame ) {
  	var this$1 = this;


  	for ( var i = 0; i < this.updaters.length; ++ i ) {

  		frame.updateNode( this$1.updaters[ i ] );

  	}

  };

  NodeMaterial.prototype.onBeforeCompile = function ( shader, renderer ) {

  	if ( this.needsUpdate ) {

  		this.build( { renderer: renderer } );

  		shader.uniforms = this.uniforms;
  		shader.vertexShader = this.vertexShader;
  		shader.fragmentShader = this.fragmentShader;

  	}

  };

  NodeMaterial.prototype.build = function ( params ) {

  	params = params || {};

  	var builder = params.builder || new NodeBuilder();

  	builder.setMaterial( this, params.renderer );
  	builder.build( this.vertex, this.fragment );

  	this.vertexShader = builder.getCode( 'vertex' );
  	this.fragmentShader = builder.getCode( 'fragment' );

  	this.defines = builder.defines;
  	this.uniforms = builder.uniforms;
  	this.extensions = builder.extensions;
  	this.updaters = builder.updaters;

  	this.fog = builder.requires.fog;
  	this.lights = builder.requires.lights;

  	this.transparent = builder.requires.transparent || this.blending > NormalBlending;

  	this.needsUpdate = false;

  	return this;

  };

  NodeMaterial.prototype.copy = function ( source ) {
  	var this$1 = this;


  	var uuid = this.uuid;

  	for ( var name in source ) {

  		this$1[ name ] = source[ name ];

  	}

  	this.uuid = uuid;

  	if ( source.userData !== undefined ) {

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  	}

  };

  NodeMaterial.prototype.toJSON = function ( meta ) {

  	var isRootObject = ( meta === undefined || typeof meta === 'string' );

  	if ( isRootObject ) {

  		meta = {
  			nodes: {}
  		};

  	}

  	if ( meta && ! meta.materials ) { meta.materials = {}; }

  	if ( ! meta.materials[ this.uuid ] ) {

  		var data = {};

  		data.uuid = this.uuid;
  		data.type = this.type;

  		meta.materials[ data.uuid ] = data;

  		if ( this.name !== "" ) { data.name = this.name; }

  		if ( this.size !== undefined ) { data.size = this.size; }
  		if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

  		if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
  		if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
  		if ( this.side !== FrontSide ) { data.side = this.side; }
  		if ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }

  		if ( this.depthFunc !== LessEqualDepth ) { data.depthFunc = this.depthFunc; }
  		if ( this.depthTest === false ) { data.depthTest = this.depthTest; }
  		if ( this.depthWrite === false ) { data.depthWrite = this.depthWrite; }

  		if ( this.linewidth !== 1 ) { data.linewidth = this.linewidth; }
  		if ( this.dashSize !== undefined ) { data.dashSize = this.dashSize; }
  		if ( this.gapSize !== undefined ) { data.gapSize = this.gapSize; }
  		if ( this.scale !== undefined ) { data.scale = this.scale; }

  		if ( this.dithering === true ) { data.dithering = true; }

  		if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
  		if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
  		if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
  		if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

  		if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
  		if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

  		if ( this.morphTargets === true ) { data.morphTargets = true; }
  		if ( this.skinning === true ) { data.skinning = true; }

  		if ( this.visible === false ) { data.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		data.fog = this.fog;
  		data.lights = this.lights;

  		data.vertex = this.vertex.toJSON( meta ).uuid;
  		data.fragment = this.fragment.toJSON( meta ).uuid;

  	}

  	meta.material = this.uuid;

  	return meta;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RTTNode( width, height, input, options ) {

  	options = options || {};

  	this.input = input;

  	this.clear = options.clear !== undefined ? options.clear : true;

  	this.renderTarget = new WebGLRenderTarget( width, height, options );

  	this.material = new NodeMaterial();

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.material );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  	this.render = true;

  	TextureNode.call( this, this.renderTarget.texture );

  }

  RTTNode.prototype = Object.create( TextureNode.prototype );
  RTTNode.prototype.constructor = RTTNode;
  RTTNode.prototype.nodeType = "RTT";

  RTTNode.prototype.build = function ( builder, output, uuid ) {

  	var rttBuilder = new NodeBuilder();
  	rttBuilder.nodes = builder.nodes;
  	rttBuilder.updaters = builder.updaters;

  	this.material.fragment.value = this.input;
  	this.material.build( { builder: rttBuilder } );

  	return TextureNode.prototype.build.call( this, builder, output, uuid );

  };

  RTTNode.prototype.updateFramesaveTo = function ( frame ) {

  	this.saveTo.render = false;

  	if ( this.saveTo !== this.saveToCurrent ) {

  		if ( this.saveToMaterial ) { this.saveToMaterial.dispose(); }

  		var material = new NodeMaterial();
  		material.fragment.value = this;
  		material.build();

  		var scene = new Scene();

  		var quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), material );
  		quad.frustumCulled = false; // Avoid getting clipped
  		scene.add( quad );

  		this.saveToScene = scene;
  		this.saveToMaterial = material;

  	}

  	this.saveToCurrent = this.saveTo;

  	frame.renderer.setRenderTarget( this.saveTo.renderTarget );
  	if ( this.saveTo.clear ) { frame.renderer.clear(); }
  	frame.renderer.render( this.saveToScene, this.camera );

  };

  RTTNode.prototype.updateFrame = function ( frame ) {

  	if ( frame.renderer ) {

  		// from the second frame

  		if ( this.saveTo && this.saveTo.render === false ) {

  			this.updateFramesaveTo( frame );

  		}

  		if ( this.render ) {

  			if ( this.material.uniforms.renderTexture ) {

  				this.material.uniforms.renderTexture.value = frame.renderTexture;

  			}

  			frame.renderer.setRenderTarget( this.renderTarget );
  			if ( this.clear ) { frame.renderer.clear(); }
  			frame.renderer.render( this.scene, this.camera );

  		}

  		// first frame

  		if ( this.saveTo && this.saveTo.render === true ) {

  			this.updateFramesaveTo( frame );

  		}

  	} else {

  		console.warn( "RTTNode need a renderer in NodeFrame" );

  	}

  };

  RTTNode.prototype.copy = function ( source ) {

  	TextureNode.prototype.copy.call( this, source );

  	this.saveTo = source.saveTo;

  };

  RTTNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = TextureNode.prototype.toJSON.call( this, meta );

  		if ( this.saveTo ) { data.saveTo = this.saveTo.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ScreenNode( uv ) {

  	TextureNode.call( this, undefined, uv );

  }

  ScreenNode.prototype = Object.create( TextureNode.prototype );
  ScreenNode.prototype.constructor = ScreenNode;
  ScreenNode.prototype.nodeType = "Screen";

  ScreenNode.prototype.getUnique = function () {

  	return true;

  };

  ScreenNode.prototype.getTexture = function ( builder, output ) {

  	return InputNode.prototype.generate.call( this, builder, output, this.getUuid(), 't', 'renderTexture' );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function StandardNode() {

  	Node$1.call( this );

  	this.color = new ColorNode( 0xEEEEEE );
  	this.roughness = new FloatNode( 0.5 );
  	this.metalness = new FloatNode( 0.5 );

  }

  StandardNode.prototype = Object.create( Node$1.prototype );
  StandardNode.prototype.constructor = StandardNode;
  StandardNode.prototype.nodeType = "Standard";

  StandardNode.prototype.build = function ( builder ) {

  	var code;

  	builder.define( this.clearCoat || this.clearCoatRoughness ? 'PHYSICAL' : 'STANDARD' );

  	builder.requires.lights = true;

  	builder.extensions.shaderTextureLOD = true;

  	if ( builder.isShader( 'vertex' ) ) {

  		var position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;

  		builder.mergeUniform( UniformsUtils.merge( [

  			UniformsLib.fog,
  			UniformsLib.lights

  		] ) );

  		builder.addParsCode( [
  			"varying vec3 vViewPosition;",

  			"#ifndef FLAT_SHADED",

  			"	varying vec3 vNormal;",

  			"#endif",

  			//"#include <encodings_pars_fragment>", // encoding functions
  			"#include <fog_pars_vertex>",
  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",
  			"#include <shadowmap_pars_vertex>",
  			"#include <logdepthbuf_pars_vertex>",
  			"#include <clipping_planes_pars_vertex>"

  		].join( "\n" ) );

  		var output = [
  			"#include <beginnormal_vertex>",
  			"#include <morphnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",

  			"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

  			"	vNormal = normalize( transformedNormal );",

  			"#endif",

  			"#include <begin_vertex>"
  		];

  		if ( position ) {

  			output.push(
  				position.code,
  				position.result ? "transformed = " + position.result + ";" : ''
  			);

  		}

  		output.push(
  			"#include <morphtarget_vertex>",
  			"#include <skinning_vertex>",
  			"#include <project_vertex>",
  			"#include <fog_vertex>",
  			"#include <logdepthbuf_vertex>",
  			"#include <clipping_planes_vertex>",

  			"	vViewPosition = - mvPosition.xyz;",

  			"#include <worldpos_vertex>",
  			"#include <shadowmap_vertex>"
  		);

  		code = output.join( "\n" );

  	} else {

  		var contextEnvironment = {
  			bias: RoughnessToBlinnExponentNode,
  			gamma: true
  		};

  		var contextGammaOnly = {
  			gamma: true
  		};

  		var useClearCoat = ! builder.isDefined( 'STANDARD' );

  		// parse all nodes to reuse generate codes

  		if ( this.mask ) { this.mask.parse( builder ); }

  		this.color.parse( builder, { slot: 'color', context: contextGammaOnly } );
  		this.roughness.parse( builder );
  		this.metalness.parse( builder );

  		if ( this.alpha ) { this.alpha.parse( builder ); }

  		if ( this.normal ) { this.normal.parse( builder ); }

  		if ( this.clearCoat ) { this.clearCoat.parse( builder ); }
  		if ( this.clearCoatRoughness ) { this.clearCoatRoughness.parse( builder ); }

  		if ( this.reflectivity ) { this.reflectivity.parse( builder ); }

  		if ( this.light ) { this.light.parse( builder, { cache: 'light' } ); }

  		if ( this.ao ) { this.ao.parse( builder ); }
  		if ( this.ambient ) { this.ambient.parse( builder ); }
  		if ( this.shadow ) { this.shadow.parse( builder ); }
  		if ( this.emissive ) { this.emissive.parse( builder, { slot: 'emissive' } ); }

  		if ( this.environment ) { this.environment.parse( builder, { cache: 'env', context: contextEnvironment, slot: 'environment' } ); } // isolate environment from others inputs ( see TextureNode, CubeTextureNode )

  		// build code

  		var mask = this.mask ? this.mask.buildCode( builder, 'b' ) : undefined;

  		var color = this.color.buildCode( builder, 'c', { slot: 'color', context: contextGammaOnly } );
  		var roughness = this.roughness.buildCode( builder, 'f' );
  		var metalness = this.metalness.buildCode( builder, 'f' );

  		var alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined;

  		var normal = this.normal ? this.normal.buildCode( builder, 'v3' ) : undefined;

  		var clearCoat = this.clearCoat ? this.clearCoat.buildCode( builder, 'f' ) : undefined;
  		var clearCoatRoughness = this.clearCoatRoughness ? this.clearCoatRoughness.buildCode( builder, 'f' ) : undefined;

  		var reflectivity = this.reflectivity ? this.reflectivity.buildCode( builder, 'f' ) : undefined;

  		var light = this.light ? this.light.buildCode( builder, 'v3', { cache: 'light' } ) : undefined;

  		var ao = this.ao ? this.ao.buildCode( builder, 'f' ) : undefined;
  		var ambient = this.ambient ? this.ambient.buildCode( builder, 'c' ) : undefined;
  		var shadow = this.shadow ? this.shadow.buildCode( builder, 'c' ) : undefined;
  		var emissive = this.emissive ? this.emissive.buildCode( builder, 'c', { slot: 'emissive' } ) : undefined;

  		var environment = this.environment ? this.environment.buildCode( builder, 'c', { cache: 'env', context: contextEnvironment, slot: 'environment' } ) : undefined;

  		var clearCoatEnv = useClearCoat && environment ? this.environment.buildCode( builder, 'c', { cache: 'clearCoat', context: contextEnvironment, slot: 'environment' } ) : undefined;

  		builder.requires.transparent = alpha !== undefined;

  		builder.addParsCode( [

  			"varying vec3 vViewPosition;",

  			"#ifndef FLAT_SHADED",

  			"	varying vec3 vNormal;",

  			"#endif",

  			"#include <dithering_pars_fragment>",
  			"#include <fog_pars_fragment>",
  			"#include <bsdfs>",
  			"#include <lights_pars_begin>",
  			"#include <lights_physical_pars_fragment>",
  			"#include <shadowmap_pars_fragment>",
  			"#include <logdepthbuf_pars_fragment>"
  		].join( "\n" ) );

  		var output = [
  			"#include <clipping_planes_fragment>",

  			// add before: prevent undeclared normal
  			"	#include <normal_fragment_begin>",

  			// add before: prevent undeclared material
  			"	PhysicalMaterial material;",
  			"	material.diffuseColor = vec3( 1.0 );"
  		];

  		if ( mask ) {

  			output.push(
  				mask.code,
  				'if ( ! ' + mask.result + ' ) discard;'
  			);

  		}

  		output.push(
  			color.code,
  			"	vec3 diffuseColor = " + color.result + ";",
  			"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",

  			"#include <logdepthbuf_fragment>",

  			roughness.code,
  			"	float roughnessFactor = " + roughness.result + ";",

  			metalness.code,
  			"	float metalnessFactor = " + metalness.result + ";"
  		);

  		if ( alpha ) {

  			output.push(
  				alpha.code,
  				'#ifdef ALPHATEST',

  				'	if ( ' + alpha.result + ' <= ALPHATEST ) discard;',

  				'#endif'
  			);

  		}

  		if ( normal ) {

  			output.push(
  				normal.code,
  				'normal = ' + normal.result + ';'
  			);

  		}

  		// optimization for now

  		output.push(
  			'material.diffuseColor = ' + ( light ? 'vec3( 1.0 )' : 'diffuseColor * (1.0 - metalnessFactor)' ) + ';',
  			'material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );'
  		);

  		if ( clearCoat ) {

  			output.push(
  				clearCoat.code,
  				'material.clearCoat = saturate( ' + clearCoat.result + ' );'
  			);

  		} else if ( useClearCoat ) {

  			output.push( 'material.clearCoat = 0.0;' );

  		}

  		if ( clearCoatRoughness ) {

  			output.push(
  				clearCoatRoughness.code,
  				'material.clearCoatRoughness = clamp( ' + clearCoatRoughness.result + ', 0.04, 1.0 );'
  			);

  		} else if ( useClearCoat ) {

  			output.push( 'material.clearCoatRoughness = 0.0;' );

  		}

  		if ( reflectivity ) {

  			output.push(
  				reflectivity.code,
  				'material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( ' + reflectivity.result + ' ) ), diffuseColor, metalnessFactor );'
  			);

  		} else {

  			output.push(
  				'material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor, metalnessFactor );'
  			);

  		}

  		output.push(
  			"#include <lights_fragment_begin>"
  		);

  		if ( light ) {

  			output.push(
  				light.code,
  				"reflectedLight.directDiffuse = " + light.result + ";"
  			);

  			// apply color

  			output.push(
  				"diffuseColor *= 1.0 - metalnessFactor;",

  				"reflectedLight.directDiffuse *= diffuseColor;",
  				"reflectedLight.indirectDiffuse *= diffuseColor;"
  			);

  		}

  		if ( ao ) {

  			output.push(
  				ao.code,
  				"reflectedLight.indirectDiffuse *= " + ao.result + ";",
  				"float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );",
  				"reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, " + ao.result + ", material.specularRoughness );"
  			);

  		}

  		if ( ambient ) {

  			output.push(
  				ambient.code,
  				"reflectedLight.indirectDiffuse += " + ambient.result + ";"
  			);

  		}

  		if ( shadow ) {

  			output.push(
  				shadow.code,
  				"reflectedLight.directDiffuse *= " + shadow.result + ";",
  				"reflectedLight.directSpecular *= " + shadow.result + ";"
  			);

  		}

  		if ( emissive ) {

  			output.push(
  				emissive.code,
  				"reflectedLight.directDiffuse += " + emissive.result + ";"
  			);

  		}

  		if ( environment ) {

  			output.push( environment.code );

  			if ( clearCoatEnv ) {

  				output.push(
  					clearCoatEnv.code,
  					"clearCoatRadiance += " + clearCoatEnv.result + ";"
  				);

  			}

  			output.push( "radiance += " + environment.result + ";" );

  		}

  		output.push(
  			"#include <lights_fragment_end>"
  		);

  		output.push( "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;" );

  		if ( alpha ) {

  			output.push( "gl_FragColor = vec4( outgoingLight, " + alpha.result + " );" );

  		} else {

  			output.push( "gl_FragColor = vec4( outgoingLight, 1.0 );" );

  		}

  		output.push(
  			"#include <tonemapping_fragment>",
  			"#include <encodings_fragment>",
  			"#include <fog_fragment>",
  			"#include <premultiplied_alpha_fragment>",
  			"#include <dithering_fragment>"
  		);

  		code = output.join( "\n" );

  	}

  	return code;

  };

  StandardNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	// vertex

  	if ( source.position ) { this.position = source.position; }

  	// fragment

  	this.color = source.color;
  	this.roughness = source.roughness;
  	this.metalness = source.metalness;

  	if ( source.mask ) { this.mask = source.mask; }

  	if ( source.alpha ) { this.alpha = source.alpha; }

  	if ( source.normal ) { this.normal = source.normal; }

  	if ( source.clearCoat ) { this.clearCoat = source.clearCoat; }
  	if ( source.clearCoatRoughness ) { this.clearCoatRoughness = source.clearCoatRoughness; }

  	if ( source.reflectivity ) { this.reflectivity = source.reflectivity; }

  	if ( source.light ) { this.light = source.light; }
  	if ( source.shadow ) { this.shadow = source.shadow; }

  	if ( source.ao ) { this.ao = source.ao; }

  	if ( source.emissive ) { this.emissive = source.emissive; }
  	if ( source.ambient ) { this.ambient = source.ambient; }

  	if ( source.environment ) { this.environment = source.environment; }

  };

  StandardNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		// vertex

  		if ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }

  		// fragment

  		data.color = this.color.toJSON( meta ).uuid;
  		data.roughness = this.roughness.toJSON( meta ).uuid;
  		data.metalness = this.metalness.toJSON( meta ).uuid;

  		if ( this.mask ) { data.mask = this.mask.toJSON( meta ).uuid; }

  		if ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }

  		if ( this.normal ) { data.normal = this.normal.toJSON( meta ).uuid; }

  		if ( this.clearCoat ) { data.clearCoat = this.clearCoat.toJSON( meta ).uuid; }
  		if ( this.clearCoatRoughness ) { data.clearCoatRoughness = this.clearCoatRoughness.toJSON( meta ).uuid; }

  		if ( this.reflectivity ) { data.reflectivity = this.reflectivity.toJSON( meta ).uuid; }

  		if ( this.light ) { data.light = this.light.toJSON( meta ).uuid; }
  		if ( this.shadow ) { data.shadow = this.shadow.toJSON( meta ).uuid; }

  		if ( this.ao ) { data.ao = this.ao.toJSON( meta ).uuid; }

  		if ( this.emissive ) { data.emissive = this.emissive.toJSON( meta ).uuid; }
  		if ( this.ambient ) { data.ambient = this.ambient.toJSON( meta ).uuid; }

  		if ( this.environment ) { data.environment = this.environment.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SwitchNode( node, components ) {

  	Node$1.call( this );

  	this.node = node;
  	this.components = components || 'x';

  }

  SwitchNode.prototype = Object.create( Node$1.prototype );
  SwitchNode.prototype.constructor = SwitchNode;
  SwitchNode.prototype.nodeType = "Switch";

  SwitchNode.prototype.getType = function ( builder ) {

  	return builder.getTypeFromLength( this.components.length );

  };

  SwitchNode.prototype.generate = function ( builder, output ) {

  	var type = this.node.getType( builder ),
  		node = this.node.build( builder, type ),
  		inputLength = builder.getTypeLength( type ) - 1;

  	if ( inputLength > 0 ) {

  		// get max length

  		var outputLength = 0,
  			components = builder.colorToVectorProperties( this.components );

  		var i, len = components.length;

  		for ( i = 0; i < len; i ++ ) {

  			outputLength = Math.max( outputLength, builder.getIndexByElement( components.charAt( i ) ) );

  		}

  		if ( outputLength > inputLength ) { outputLength = inputLength; }

  		// split

  		node += '.';

  		for ( i = 0; i < len; i ++ ) {

  			var elm = components.charAt( i );
  			var idx = builder.getIndexByElement( components.charAt( i ) );

  			if ( idx > outputLength ) { idx = outputLength; }

  			node += builder.getElementByIndex( idx );

  		}

  		return builder.format( node, this.getType( builder ), output );

  	} else {

  		// join

  		return builder.format( node, type, output );

  	}

  };

  SwitchNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	this.node = source.node;
  	this.components = source.components;

  };

  SwitchNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.node = this.node.toJSON( meta ).uuid;
  		data.components = this.components;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NormalMapNode( value, scale ) {

  	TempNode.call( this, 'v3' );

  	this.value = value;
  	this.scale = scale || new Vector2Node( 1, 1 );

  }

  NormalMapNode.Nodes = ( function () {

  	var perturbNormal2Arb = new FunctionNode( [

  		// Per-Pixel Tangent Space Normal Mapping
  		// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  		"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 mUv, vec2 normalScale ) {",

  		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

  		"	vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );",
  		"	vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );",
  		"	vec2 st0 = dFdx( mUv.st );",
  		"	vec2 st1 = dFdy( mUv.st );",

  		"	float scale = sign( st1.t * st0.s - st0.t * st1.s );", // we do not care about the magnitude

  		"	vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );",
  		"	vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );",
  		"	vec3 N = normalize( surf_norm );",
  		"	mat3 tsn = mat3( S, T, N );",

  		"	vec3 mapN = map * 2.0 - 1.0;",

  		"	mapN.xy *= normalScale;",
  		"	mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );",

  		"	return normalize( tsn * mapN );",

  		"}"

  	].join( "\n" ), null, { derivatives: true } );

  	return {
  		perturbNormal2Arb: perturbNormal2Arb
  	};

  } )();

  NormalMapNode.prototype = Object.create( TempNode.prototype );
  NormalMapNode.prototype.constructor = NormalMapNode;
  NormalMapNode.prototype.nodeType = "NormalMap";

  NormalMapNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		var perturbNormal2Arb = builder.include( NormalMapNode.Nodes.perturbNormal2Arb );

  		this.normal = this.normal || new NormalNode$1();
  		this.position = this.position || new PositionNode( PositionNode.VIEW );
  		this.uv = this.uv || new UVNode();

  		return builder.format( perturbNormal2Arb + '( -' + this.position.build( builder, 'v3' ) + ', ' +
  			this.normal.build( builder, 'v3' ) + ', ' +
  			this.value.build( builder, 'v3' ) + ', ' +
  			this.uv.build( builder, 'v2' ) + ', ' +
  			this.scale.build( builder, 'v2' ) + ' )', this.getType( builder ), output );

  	} else {

  		console.warn( "NormalMapNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec3( 0.0 )', this.getType( builder ), output );

  	}

  };

  NormalMapNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.value = source.value;
  	this.scale = source.scale;

  };

  NormalMapNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value.toJSON( meta ).uuid;
  		data.scale = this.scale.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshStandardNode() {

  	StandardNode.call( this );

  	this.properties = {
  		color: new Color( 0xffffff ),
  		roughness: 0.5,
  		metalness: 0.5,
  		normalScale: new Vector2( 1, 1 )
  	};

  	this.inputs = {
  		color: new PropertyNode( this.properties, 'color', 'c' ),
  		roughness: new PropertyNode( this.properties, 'roughness', 'f' ),
  		metalness: new PropertyNode( this.properties, 'metalness', 'f' ),
  		normalScale: new PropertyNode( this.properties, 'normalScale', 'v2' )
  	};

  }

  MeshStandardNode.prototype = Object.create( StandardNode.prototype );
  MeshStandardNode.prototype.constructor = MeshStandardNode;
  MeshStandardNode.prototype.nodeType = "MeshStandard";

  MeshStandardNode.prototype.build = function ( builder ) {

  	var props = this.properties,
  		inputs = this.inputs;

  	if ( builder.isShader( 'fragment' ) ) {

  		// slots
  		// * color
  		// * map

  		var color = builder.findNode( props.color, inputs.color ),
  			map = builder.resolve( props.map );

  		this.color = map ? new OperatorNode( color, map, OperatorNode.MUL ) : color;

  		// slots
  		// * roughness
  		// * roughnessMap

  		var roughness = builder.findNode( props.roughness, inputs.roughness ),
  			roughnessMap = builder.resolve( props.roughnessMap );

  		this.roughness = roughnessMap ? new OperatorNode( roughness, new SwitchNode( roughnessMap, "g" ), OperatorNode.MUL ) : roughness;

  		// slots
  		// * metalness
  		// * metalnessMap

  		var metalness = builder.findNode( props.metalness, inputs.metalness ),
  			metalnessMap = builder.resolve( props.metalnessMap );

  		this.metalness = metalnessMap ? new OperatorNode( metalness, new SwitchNode( metalnessMap, "b" ), OperatorNode.MUL ) : metalness;

  		// slots
  		// * normalMap
  		// * normalScale

  		if ( props.normalMap ) {

  			this.normal = new NormalMapNode( builder.resolve( props.normalMap ) );
  			this.normal.scale = builder.findNode( props.normalScale, inputs.normalScale );

  		} else {

  			this.normal = undefined;

  		}

  		// slots
  		// * envMap

  		this.environment = builder.resolve( props.envMap );

  	}

  	// build code

  	return StandardNode.prototype.build.call( this, builder );

  };

  MeshStandardNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		console.warn( ".toJSON not implemented in", this );

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshStandardNodeMaterial() {

  	var node = new MeshStandardNode();

  	NodeMaterial.call( this, node, node );

  	this.type = "MeshStandardNodeMaterial";

  }

  MeshStandardNodeMaterial.prototype = Object.create( NodeMaterial.prototype );
  MeshStandardNodeMaterial.prototype.constructor = MeshStandardNodeMaterial;

  NodeUtils.addShortcuts( MeshStandardNodeMaterial.prototype, 'properties', [
  	"color",
  	"roughness",
  	"metalness",
  	"map",
  	"normalMap",
  	"normalScale",
  	"metalnessMap",
  	"roughnessMap",
  	"envMap"
  ] );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PhongNode() {

  	Node$1.call( this );

  	this.color = new ColorNode( 0xEEEEEE );
  	this.specular = new ColorNode( 0x111111 );
  	this.shininess = new FloatNode( 30 );

  }

  PhongNode.prototype = Object.create( Node$1.prototype );
  PhongNode.prototype.constructor = PhongNode;
  PhongNode.prototype.nodeType = "Phong";

  PhongNode.prototype.build = function ( builder ) {

  	var code;

  	builder.define( 'PHONG' );

  	builder.requires.lights = true;

  	if ( builder.isShader( 'vertex' ) ) {

  		var position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;

  		builder.mergeUniform( UniformsUtils.merge( [

  			UniformsLib.fog,
  			UniformsLib.lights

  		] ) );

  		builder.addParsCode( [
  			"varying vec3 vViewPosition;",

  			"#ifndef FLAT_SHADED",

  			"	varying vec3 vNormal;",

  			"#endif",

  			//"#include <encodings_pars_fragment>", // encoding functions
  			"#include <fog_pars_vertex>",
  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",
  			"#include <shadowmap_pars_vertex>",
  			"#include <logdepthbuf_pars_vertex>",
  			"#include <clipping_planes_pars_vertex>"
  		].join( "\n" ) );

  		var output = [
  			"#include <beginnormal_vertex>",
  			"#include <morphnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",

  			"#ifndef FLAT_SHADED", // normal computed with derivatives when FLAT_SHADED

  			"	vNormal = normalize( transformedNormal );",

  			"#endif",

  			"#include <begin_vertex>"
  		];

  		if ( position ) {

  			output.push(
  				position.code,
  				position.result ? "transformed = " + position.result + ";" : ''
  			);

  		}

  		output.push(
  			"	#include <morphtarget_vertex>",
  			"	#include <skinning_vertex>",
  			"	#include <project_vertex>",
  			"	#include <fog_vertex>",
  			"	#include <logdepthbuf_vertex>",
  			"	#include <clipping_planes_vertex>",

  			"	vViewPosition = - mvPosition.xyz;",

  			"	#include <worldpos_vertex>",
  			"	#include <shadowmap_vertex>",
  			"	#include <fog_vertex>"
  		);

  		code = output.join( "\n" );

  	} else {

  		// parse all nodes to reuse generate codes

  		if ( this.mask ) { this.mask.parse( builder ); }

  		this.color.parse( builder, { slot: 'color' } );
  		this.specular.parse( builder );
  		this.shininess.parse( builder );

  		if ( this.alpha ) { this.alpha.parse( builder ); }

  		if ( this.normal ) { this.normal.parse( builder ); }

  		if ( this.light ) { this.light.parse( builder, { cache: 'light' } ); }

  		if ( this.ao ) { this.ao.parse( builder ); }
  		if ( this.ambient ) { this.ambient.parse( builder ); }
  		if ( this.shadow ) { this.shadow.parse( builder ); }
  		if ( this.emissive ) { this.emissive.parse( builder, { slot: 'emissive' } ); }

  		if ( this.environment ) { this.environment.parse( builder, { slot: 'environment' } ); }
  		if ( this.environmentAlpha && this.environment ) { this.environmentAlpha.parse( builder ); }

  		// build code

  		var mask = this.mask ? this.mask.buildCode( builder, 'b' ) : undefined;

  		var color = this.color.buildCode( builder, 'c', { slot: 'color' } );
  		var specular = this.specular.buildCode( builder, 'c' );
  		var shininess = this.shininess.buildCode( builder, 'f' );

  		var alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined;

  		var normal = this.normal ? this.normal.buildCode( builder, 'v3' ) : undefined;

  		var light = this.light ? this.light.buildCode( builder, 'v3', { cache: 'light' } ) : undefined;

  		var ao = this.ao ? this.ao.buildCode( builder, 'f' ) : undefined;
  		var ambient = this.ambient ? this.ambient.buildCode( builder, 'c' ) : undefined;
  		var shadow = this.shadow ? this.shadow.buildCode( builder, 'c' ) : undefined;
  		var emissive = this.emissive ? this.emissive.buildCode( builder, 'c', { slot: 'emissive' } ) : undefined;

  		var environment = this.environment ? this.environment.buildCode( builder, 'c', { slot: 'environment' } ) : undefined;
  		var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.buildCode( builder, 'f' ) : undefined;

  		builder.requires.transparent = alpha != undefined;

  		builder.addParsCode( [
  			"#include <fog_pars_fragment>",
  			"#include <bsdfs>",
  			"#include <lights_pars_begin>",
  			"#include <lights_phong_pars_fragment>",
  			"#include <shadowmap_pars_fragment>",
  			"#include <logdepthbuf_pars_fragment>"
  		].join( "\n" ) );

  		var output = [
  			// prevent undeclared normal
  			"#include <normal_fragment_begin>",

  			// prevent undeclared material
  			"	BlinnPhongMaterial material;"
  		];

  		if ( mask ) {

  			output.push(
  				mask.code,
  				'if ( ! ' + mask.result + ' ) discard;'
  			);

  		}

  		output.push(
  			color.code,
  			"	vec3 diffuseColor = " + color.result + ";",
  			"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",

  			"#include <logdepthbuf_fragment>",

  			specular.code,
  			"	vec3 specular = " + specular.result + ";",

  			shininess.code,
  			"	float shininess = max( 0.0001, " + shininess.result + " );",

  			"	float specularStrength = 1.0;" // Ignored in MaterialNode ( replace to specular )
  		);

  		if ( alpha ) {

  			output.push(
  				alpha.code,
  				'#ifdef ALPHATEST',

  				'if ( ' + alpha.result + ' <= ALPHATEST ) discard;',

  				'#endif'
  			);

  		}

  		if ( normal ) {

  			output.push(
  				normal.code,
  				'normal = ' + normal.result + ';'
  			);

  		}

  		// optimization for now

  		output.push( 'material.diffuseColor = ' + ( light ? 'vec3( 1.0 )' : 'diffuseColor' ) + ';' );

  		output.push(
  			// accumulation
  			'material.specularColor = specular;',
  			'material.specularShininess = shininess;',
  			'material.specularStrength = specularStrength;',

  			"#include <lights_fragment_begin>",
  			"#include <lights_fragment_end>"
  		);

  		if ( light ) {

  			output.push(
  				light.code,
  				"reflectedLight.directDiffuse = " + light.result + ";"
  			);

  			// apply color

  			output.push(
  				"reflectedLight.directDiffuse *= diffuseColor;",
  				"reflectedLight.indirectDiffuse *= diffuseColor;"
  			);

  		}

  		if ( ao ) {

  			output.push(
  				ao.code,
  				"reflectedLight.indirectDiffuse *= " + ao.result + ";"
  			);

  		}

  		if ( ambient ) {

  			output.push(
  				ambient.code,
  				"reflectedLight.indirectDiffuse += " + ambient.result + ";"
  			);

  		}

  		if ( shadow ) {

  			output.push(
  				shadow.code,
  				"reflectedLight.directDiffuse *= " + shadow.result + ";",
  				"reflectedLight.directSpecular *= " + shadow.result + ";"
  			);

  		}

  		if ( emissive ) {

  			output.push(
  				emissive.code,
  				"reflectedLight.directDiffuse += " + emissive.result + ";"
  			);

  		}

  		output.push( "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;" );

  		if ( environment ) {

  			output.push( environment.code );

  			if ( environmentAlpha ) {

  				output.push(
  					environmentAlpha.code,
  					"outgoingLight = mix( outgoingLight, " + environment.result + ", " + environmentAlpha.result + " );"
  				);

  			} else {

  				output.push( "outgoingLight = " + environment.result + ";" );

  			}

  		}
  		
  		if ( alpha ) {

  			output.push( "gl_FragColor = vec4( outgoingLight, " + alpha.result + " );" );

  		} else {

  			output.push( "gl_FragColor = vec4( outgoingLight, 1.0 );" );

  		}

  		output.push(
  			"#include <premultiplied_alpha_fragment>",
  			"#include <tonemapping_fragment>",
  			"#include <encodings_fragment>",
  			"#include <fog_fragment>"
  		);

  		code = output.join( "\n" );

  	}

  	return code;

  };

  PhongNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	// vertex

  	if ( source.position ) { this.position = source.position; }

  	// fragment

  	this.color = source.color;
  	this.specular = source.specular;
  	this.shininess = source.shininess;

  	if ( source.mask ) { this.mask = source.mask; }

  	if ( source.alpha ) { this.alpha = source.alpha; }

  	if ( source.normal ) { this.normal = source.normal; }

  	if ( source.light ) { this.light = source.light; }
  	if ( source.shadow ) { this.shadow = source.shadow; }

  	if ( source.ao ) { this.ao = source.ao; }

  	if ( source.emissive ) { this.emissive = source.emissive; }
  	if ( source.ambient ) { this.ambient = source.ambient; }

  	if ( source.environment ) { this.environment = source.environment; }
  	if ( source.environmentAlpha ) { this.environmentAlpha = source.environmentAlpha; }

  };

  PhongNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		// vertex

  		if ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }

  		// fragment

  		data.color = this.color.toJSON( meta ).uuid;
  		data.specular = this.specular.toJSON( meta ).uuid;
  		data.shininess = this.shininess.toJSON( meta ).uuid;

  		if ( this.mask ) { data.mask = this.mask.toJSON( meta ).uuid; }

  		if ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }

  		if ( this.normal ) { data.normal = this.normal.toJSON( meta ).uuid; }

  		if ( this.light ) { data.light = this.light.toJSON( meta ).uuid; }

  		if ( this.ao ) { data.ao = this.ao.toJSON( meta ).uuid; }
  		if ( this.ambient ) { data.ambient = this.ambient.toJSON( meta ).uuid; }
  		if ( this.shadow ) { data.shadow = this.shadow.toJSON( meta ).uuid; }
  		if ( this.emissive ) { data.emissive = this.emissive.toJSON( meta ).uuid; }

  		if ( this.environment ) { data.environment = this.environment.toJSON( meta ).uuid; }
  		if ( this.environmentAlpha ) { data.environmentAlpha = this.environmentAlpha.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpriteNode() {

  	Node$1.call( this );

  	this.color = new ColorNode( 0xEEEEEE );
  	this.spherical = true;

  }

  SpriteNode.prototype = Object.create( Node$1.prototype );
  SpriteNode.prototype.constructor = SpriteNode;
  SpriteNode.prototype.nodeType = "Sprite";

  SpriteNode.prototype.build = function ( builder ) {

  	var output;

  	builder.define( 'SPRITE' );

  	builder.requires.lights = false;
  	builder.requires.transparent = this.alpha !== undefined;

  	if ( builder.isShader( 'vertex' ) ) {

  		var position = this.position ? this.position.parseAndBuildCode( builder, 'v3', { cache: 'position' } ) : undefined;

  		builder.mergeUniform( UniformsUtils.merge( [
  			UniformsLib.fog
  		] ) );

  		builder.addParsCode( [
  			"#include <fog_pars_vertex>",
  			"#include <logdepthbuf_pars_vertex>",
  			"#include <clipping_planes_pars_vertex>"
  		].join( "\n" ) );

  		output = [
  			"#include <clipping_planes_fragment>",
  			"#include <begin_vertex>"
  		];

  		if ( position ) {

  			output.push(
  				position.code,
  				position.result ? "transformed = " + position.result + ";" : ''
  			);

  		}

  		output.push(
  			"#include <project_vertex>",
  			"#include <fog_vertex>",

  			'mat4 modelViewMtx = modelViewMatrix;',
  			'mat4 modelMtx = modelMatrix;',

  			// ignore position from modelMatrix (use vary position)
  			'modelMtx[3][0] = 0.0;',
  			'modelMtx[3][1] = 0.0;',
  			'modelMtx[3][2] = 0.0;'
  		);

  		if ( ! this.spherical ) {

  			output.push(
  				'modelMtx[1][1] = 1.0;'
  			);

  		}

  		output.push(
  			// http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/
  			// First colunm.
  			'modelViewMtx[0][0] = 1.0;',
  			'modelViewMtx[0][1] = 0.0;',
  			'modelViewMtx[0][2] = 0.0;'
  		);

  		if ( this.spherical ) {

  			output.push(
  				// Second colunm.
  				'modelViewMtx[1][0] = 0.0;',
  				'modelViewMtx[1][1] = 1.0;',
  				'modelViewMtx[1][2] = 0.0;'
  			);

  		}

  		output.push(
  			// Thrid colunm.
  			'modelViewMtx[2][0] = 0.0;',
  			'modelViewMtx[2][1] = 0.0;',
  			'modelViewMtx[2][2] = 1.0;',

  			"gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );",

  			"#include <logdepthbuf_vertex>",
  			"#include <clipping_planes_vertex>",
  			"#include <fog_vertex>"
  		);

  	} else {

  		builder.addParsCode( [
  			"#include <fog_pars_fragment>",
  			"#include <logdepthbuf_pars_fragment>",
  			"#include <clipping_planes_pars_fragment>"
  		].join( "\n" ) );

  		builder.addCode( [
  			"#include <clipping_planes_fragment>",
  			"#include <logdepthbuf_fragment>"
  		].join( "\n" ) );

  		// parse all nodes to reuse generate codes

  		if ( this.mask ) { this.mask.parse( builder ); }

  		if ( this.alpha ) { this.alpha.parse( builder ); }

  		this.color.parse( builder, { slot: 'color' } );

  		// build code

  		var mask = this.mask ? this.mask.buildCode( builder, 'b' ) : undefined,
  			alpha = this.alpha ? this.alpha.buildCode( builder, 'f' ) : undefined,
  			color = this.color.buildCode( builder, 'c', { slot: 'color' } ),
  			output = [];

  		if ( mask ) {

  			output.push(
  				mask.code,
  				'if ( ! ' + mask.result + ' ) discard;'
  			);

  		}

  		if ( alpha ) {

  			output.push(
  				alpha.code,
  				'#ifdef ALPHATEST',

  				'if ( ' + alpha.result + ' <= ALPHATEST ) discard;',

  				'#endif',
  				color.code,
  				"gl_FragColor = vec4( " + color.result + ", " + alpha.result + " );"
  			);

  		} else {

  			output.push(
  				color.code,
  				"gl_FragColor = vec4( " + color.result + ", 1.0 );"
  			);

  		}

  		output.push(
  			"#include <tonemapping_fragment>",
  			"#include <encodings_fragment>",
  			"#include <fog_fragment>"
  		);

  	}

  	return output.join( "\n" );

  };

  SpriteNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	// vertex

  	if ( source.position ) { this.position = source.position; }

  	// fragment

  	this.color = source.color;

  	if ( source.spherical !== undefined ) { this.spherical = source.spherical; }

  	if ( source.mask ) { this.mask = source.mask; }

  	if ( source.alpha ) { this.alpha = source.alpha; }

  };

  SpriteNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		// vertex

  		if ( this.position ) { data.position = this.position.toJSON( meta ).uuid; }

  		// fragment

  		data.color = this.color.toJSON( meta ).uuid;

  		if ( this.spherical === false ) { data.spherical = false; }

  		if ( this.mask ) { data.mask = this.mask.toJSON( meta ).uuid; }

  		if ( this.alpha ) { data.alpha = this.alpha.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PhongNodeMaterial() {

  	var node = new PhongNode();

  	NodeMaterial.call( this, node, node );

  	this.type = "PhongNodeMaterial";

  }

  PhongNodeMaterial.prototype = Object.create( NodeMaterial.prototype );
  PhongNodeMaterial.prototype.constructor = PhongNodeMaterial;

  NodeUtils.addShortcuts( PhongNodeMaterial.prototype, 'fragment', [
  	'color',
  	'alpha',
  	'specular',
  	'shininess',
  	'normal',
  	'emissive',
  	'ambient',
  	'light',
  	'shadow',
  	'ao',
  	'environment',
  	'environmentAlpha',
  	'mask',
  	'position'
  ] );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpriteNodeMaterial() {

  	var node = new SpriteNode();

  	NodeMaterial.call( this, node, node );

  	this.type = "SpriteNodeMaterial";

  }

  SpriteNodeMaterial.prototype = Object.create( NodeMaterial.prototype );
  SpriteNodeMaterial.prototype.constructor = SpriteNodeMaterial;

  NodeUtils.addShortcuts( SpriteNodeMaterial.prototype, 'fragment', [
  	'color',
  	'alpha',
  	'mask',
  	'position',
  	'spherical'
  ] );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function StandardNodeMaterial() {

  	var node = new StandardNode();

  	NodeMaterial.call( this, node, node );

  	this.type = "StandardNodeMaterial";

  }

  StandardNodeMaterial.prototype = Object.create( NodeMaterial.prototype );
  StandardNodeMaterial.prototype.constructor = StandardNodeMaterial;

  NodeUtils.addShortcuts( StandardNodeMaterial.prototype, 'fragment', [
  	'color',
  	'alpha',
  	'roughness',
  	'metalness',
  	'reflectivity',
  	'clearCoat',
  	'clearCoatRoughness',
  	'normal',
  	'emissive',
  	'ambient',
  	'light',
  	'shadow',
  	'ao',
  	'environment',
  	'mask',
  	'position'
  ] );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CondNode( a, b, op, ifNode, elseNode ) {

  	TempNode.call( this );

  	this.a = a;
  	this.b = b;

  	this.op = op;
  	
  	this.ifNode = ifNode;
  	this.elseNode = elseNode;

  }

  CondNode.EQUAL = '==';
  CondNode.NOT_EQUAL = '!=';
  CondNode.GREATER = '>';
  CondNode.GREATER_EQUAL = '>=';
  CondNode.LESS = '<';
  CondNode.LESS_EQUAL = '<=';

  CondNode.prototype = Object.create( TempNode.prototype );
  CondNode.prototype.constructor = CondNode;
  CondNode.prototype.nodeType = "Cond";

  CondNode.prototype.getType = function ( builder ) {

  	if (this.ifNode) {
  		
  		var ifType = this.ifNode.getType( builder );
  		var elseType = this.elseNode.getType( builder );
  		
  		if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

  			return elseType;

  		}

  		return ifType;
  		
  	}
  	
  	return 'b';

  };

  CondNode.prototype.getCondType = function ( builder ) {

  	if ( builder.getTypeLength( this.b.getType( builder ) ) > builder.getTypeLength( this.a.getType( builder ) ) ) {

  		return this.b.getType( builder );

  	}

  	return this.a.getType( builder );

  };

  CondNode.prototype.generate = function ( builder, output ) {

  	var type = this.getType( builder ),
  		condType = this.getCondType( builder ),
  		a = this.a.build( builder, condType ),
  		b = this.b.build( builder, condType ),
  		code;
  		
  	if (this.ifNode) {
  		
  		var ifCode = this.ifNode.build( builder, type ),
  			elseCode = this.elseNode.build( builder, type );
  		
  		code = '( ' + [ a, this.op, b, '?', ifCode, ':', elseCode ].join( ' ' ) + ' )';
  		
  	} else {

  		code = '( ' + a + ' ' + this.op + ' ' +  b  + ' )';
  		
  	}

  	return builder.format( code, this.getType( builder ), output );

  };

  CondNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.a = source.a;
  	this.b = source.b;

  	this.op = source.op;

  	this.ifNode = source.ifNode;
  	this.elseNode = source.elseNode;

  };

  CondNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.a = this.a.toJSON( meta ).uuid;
  		data.b = this.b.toJSON( meta ).uuid;

  		data.op = this.op;

  		if ( data.ifNode ) { data.ifNode = this.ifNode.toJSON( meta ).uuid; }
  		if ( data.elseNode ) { data.elseNode = this.elseNode.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Math1Node( a, method ) {

  	TempNode.call( this );

  	this.a = a;

  	this.method = method;

  }

  Math1Node.RAD = 'radians';
  Math1Node.DEG = 'degrees';
  Math1Node.EXP = 'exp';
  Math1Node.EXP2 = 'exp2';
  Math1Node.LOG = 'log';
  Math1Node.LOG2 = 'log2';
  Math1Node.SQRT = 'sqrt';
  Math1Node.INV_SQRT = 'inversesqrt';
  Math1Node.FLOOR = 'floor';
  Math1Node.CEIL = 'ceil';
  Math1Node.NORMALIZE = 'normalize';
  Math1Node.FRACT = 'fract';
  Math1Node.SATURATE = 'saturate';
  Math1Node.SIN = 'sin';
  Math1Node.COS = 'cos';
  Math1Node.TAN = 'tan';
  Math1Node.ASIN = 'asin';
  Math1Node.ACOS = 'acos';
  Math1Node.ARCTAN = 'atan';
  Math1Node.ABS = 'abs';
  Math1Node.SIGN = 'sign';
  Math1Node.LENGTH = 'length';
  Math1Node.NEGATE = 'negate';
  Math1Node.INVERT = 'invert';

  Math1Node.prototype = Object.create( TempNode.prototype );
  Math1Node.prototype.constructor = Math1Node;
  Math1Node.prototype.nodeType = "Math1";

  Math1Node.prototype.getType = function ( builder ) {

  	switch ( this.method ) {

  		case Math1Node.LENGTH:

  			return 'f';

  	}

  	return this.a.getType( builder );

  };

  Math1Node.prototype.generate = function ( builder, output ) {

  	var type = this.getType( builder ),
  		result = this.a.build( builder, type );

  	switch ( this.method ) {

  		case Math1Node.NEGATE:

  			result = '( -' + result + ' )';

  			break;

  		case Math1Node.INVERT:

  			result = '( 1.0 - ' + result + ' )';

  			break;

  		default:

  			result = this.method + '( ' + result + ' )';

  			break;

  	}

  	return builder.format( result, type, output );

  };

  Math1Node.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.a = source.a;
  	this.method = source.method;

  };

  Math1Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.a = this.a.toJSON( meta ).uuid;
  		data.method = this.method;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Math2Node( a, b, method ) {

  	TempNode.call( this );

  	this.a = a;
  	this.b = b;

  	this.method = method;

  }

  Math2Node.MIN = 'min';
  Math2Node.MAX = 'max';
  Math2Node.MOD = 'mod';
  Math2Node.STEP = 'step';
  Math2Node.REFLECT = 'reflect';
  Math2Node.DISTANCE = 'distance';
  Math2Node.DOT = 'dot';
  Math2Node.CROSS = 'cross';
  Math2Node.POW = 'pow';

  Math2Node.prototype = Object.create( TempNode.prototype );
  Math2Node.prototype.constructor = Math2Node;
  Math2Node.prototype.nodeType = "Math2";

  Math2Node.prototype.getInputType = function ( builder ) {

  	// use the greater length vector

  	if ( builder.getTypeLength( this.b.getType( builder ) ) > builder.getTypeLength( this.a.getType( builder ) ) ) {

  		return this.b.getType( builder );

  	}

  	return this.a.getType( builder );

  };

  Math2Node.prototype.getType = function ( builder ) {

  	switch ( this.method ) {

  		case Math2Node.DISTANCE:
  		case Math2Node.DOT:

  			return 'f';

  		case Math2Node.CROSS:

  			return 'v3';

  	}

  	return this.getInputType( builder );

  };

  Math2Node.prototype.generate = function ( builder, output ) {

  	var a, b,
  		type = this.getInputType( builder ),
  		al = builder.getTypeLength( this.a.getType( builder ) ),
  		bl = builder.getTypeLength( this.b.getType( builder ) );

  	// optimzer

  	switch ( this.method ) {

  		case Math2Node.CROSS:

  			a = this.a.build( builder, 'v3' );
  			b = this.b.build( builder, 'v3' );

  			break;

  		case Math2Node.STEP:

  			a = this.a.build( builder, al === 1 ? 'f' : type );
  			b = this.b.build( builder, type );

  			break;

  		case Math2Node.MIN:
  		case Math2Node.MAX:
  		case Math2Node.MOD:

  			a = this.a.build( builder, type );
  			b = this.b.build( builder, bl === 1 ? 'f' : type );

  			break;

  		default:

  			a = this.a.build( builder, type );
  			b = this.b.build( builder, type );

  			break;

  	}

  	return builder.format( this.method + '( ' + a + ', ' + b + ' )', this.getType( builder ), output );

  };

  Math2Node.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.a = source.a;
  	this.b = source.b;
  	this.method = source.method;

  };

  Math2Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.a = this.a.toJSON( meta ).uuid;
  		data.b = this.b.toJSON( meta ).uuid;
  		data.method = this.method;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Math3Node( a, b, c, method ) {

  	TempNode.call( this );

  	this.a = a;
  	this.b = b;
  	this.c = c;

  	this.method = method;

  }

  Math3Node.MIX = 'mix';
  Math3Node.CLAMP = 'clamp';
  Math3Node.REFRACT = 'refract';
  Math3Node.SMOOTHSTEP = 'smoothstep';
  Math3Node.FACEFORWARD = 'faceforward';

  Math3Node.prototype = Object.create( TempNode.prototype );
  Math3Node.prototype.constructor = Math3Node;
  Math3Node.prototype.nodeType = "Math3";

  Math3Node.prototype.getType = function ( builder ) {

  	var a = builder.getTypeLength( this.a.getType( builder ) );
  	var b = builder.getTypeLength( this.b.getType( builder ) );
  	var c = builder.getTypeLength( this.c.getType( builder ) );

  	if ( a > b && a > c ) {

  		return this.a.getType( builder );

  	} else if ( b > c ) {

  		return this.b.getType( builder );

  	}

  	return this.c.getType( builder );

  };

  Math3Node.prototype.generate = function ( builder, output ) {

  	var a, b, c,
  		al = builder.getTypeLength( this.a.getType( builder ) ),
  		bl = builder.getTypeLength( this.b.getType( builder ) ),
  		cl = builder.getTypeLength( this.c.getType( builder ) ),
  		type = this.getType( builder );

  	// optimzer

  	switch ( this.method ) {

  		case Math3Node.REFRACT:

  			a = this.a.build( builder, type );
  			b = this.b.build( builder, type );
  			c = this.c.build( builder, 'f' );

  			break;

  		case Math3Node.MIX:

  			a = this.a.build( builder, type );
  			b = this.b.build( builder, type );
  			c = this.c.build( builder, cl === 1 ? 'f' : type );

  			break;

  		default:

  			a = this.a.build( builder, type );
  			b = this.b.build( builder, type );
  			c = this.c.build( builder, type );

  			break;

  	}

  	return builder.format( this.method + '( ' + a + ', ' + b + ', ' + c + ' )', type, output );

  };

  Math3Node.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.a = source.a;
  	this.b = source.b;
  	this.c = source.c;
  	this.method = source.method;

  };

  Math3Node.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.a = this.a.toJSON( meta ).uuid;
  		data.b = this.b.toJSON( meta ).uuid;
  		data.c = this.c.toJSON( meta ).uuid;
  		data.method = this.method;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BumpMapNode( value, scale ) {

  	TempNode.call( this, 'v3' );

  	this.value = value;
  	this.scale = scale || new FloatNode( 1 );

  	this.toNormalMap = false;

  }

  BumpMapNode.Nodes = ( function () {

  	var dHdxy_fwd = new FunctionNode( [

  		// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
  		// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

  		// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

  		"vec2 dHdxy_fwd( sampler2D bumpMap, vec2 vUv, float bumpScale ) {",

  		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

  		"	vec2 dSTdx = dFdx( vUv );",
  		"	vec2 dSTdy = dFdy( vUv );",

  		"	float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
  		"	float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
  		"	float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",

  		"	return vec2( dBx, dBy );",

  		"}"

  	].join( "\n" ), null, { derivatives: true } );

  	var perturbNormalArb = new FunctionNode( [

  		"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

  		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

  		"	vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );",
  		"	vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );",
  		"	vec3 vN = surf_norm;", // normalized

  		"	vec3 R1 = cross( vSigmaY, vN );",
  		"	vec3 R2 = cross( vN, vSigmaX );",

  		"	float fDet = dot( vSigmaX, R1 );",

  		"	fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );",

  		"	vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",

  		"	return normalize( abs( fDet ) * surf_norm - vGrad );",

  		"}"

  	].join( "\n" ), [ dHdxy_fwd ], { derivatives: true } );

  	var bumpToNormal = new FunctionNode( [
  		"vec3 bumpToNormal( sampler2D bumpMap, vec2 uv, float scale ) {",

  		"	vec2 dSTdx = dFdx( uv );",
  		"	vec2 dSTdy = dFdy( uv );",

  		"	float Hll = texture2D( bumpMap, uv ).x;",
  		"	float dBx = texture2D( bumpMap, uv + dSTdx ).x - Hll;",
  		"	float dBy = texture2D( bumpMap, uv + dSTdy ).x - Hll;",

  		"	return vec3( .5 - ( dBx * scale ), .5 - ( dBy * scale ), 1.0 );",

  		"}"
  	].join( "\n" ), null, { derivatives: true } );

  	return {
  		dHdxy_fwd: dHdxy_fwd,
  		perturbNormalArb: perturbNormalArb,
  		bumpToNormal: bumpToNormal
  	};

  } )();

  BumpMapNode.prototype = Object.create( TempNode.prototype );
  BumpMapNode.prototype.constructor = BumpMapNode;
  BumpMapNode.prototype.nodeType = "BumpMap";

  BumpMapNode.prototype.generate = function ( builder, output ) {

  	if ( builder.isShader( 'fragment' ) ) {

  		if ( this.toNormalMap ) {

  			var bumpToNormal = builder.include( BumpMapNode.Nodes.bumpToNormal );

  			return builder.format( bumpToNormal + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' +
  				this.value.uv.build( builder, 'v2' ) + ', ' +
  				this.scale.build( builder, 'f' ) + ' )', this.getType( builder ), output );

  		} else {

  			var derivativeHeight = builder.include( BumpMapNode.Nodes.dHdxy_fwd ),
  				perturbNormalArb = builder.include( BumpMapNode.Nodes.perturbNormalArb );

  			this.normal = this.normal || new NormalNode$1();
  			this.position = this.position || new PositionNode( PositionNode.VIEW );

  			var derivativeHeightCode = derivativeHeight + '( ' + this.value.build( builder, 'sampler2D' ) + ', ' +
  				this.value.uv.build( builder, 'v2' ) + ', ' +
  				this.scale.build( builder, 'f' ) + ' )';

  			return builder.format( perturbNormalArb + '( -' + this.position.build( builder, 'v3' ) + ', ' +
  				this.normal.build( builder, 'v3' ) + ', ' +
  				derivativeHeightCode + ' )', this.getType( builder ), output );

  		}

  	} else {

  		console.warn( "BumpMapNode is not compatible with " + builder.shader + " shader." );

  		return builder.format( 'vec3( 0.0 )', this.getType( builder ), output );

  	}

  };

  BumpMapNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.value = source.value;
  	this.scale = source.scale;

  };

  BumpMapNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.value = this.value.toJSON( meta ).uuid;
  		data.scale = this.scale.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Pass = function () {

  	// if set to true, the pass is processed by the composer
  	this.enabled = true;

  	// if set to true, the pass indicates to swap read and write buffer after rendering
  	this.needsSwap = true;

  	// if set to true, the pass clears its buffer before rendering
  	this.clear = false;

  	// if set to true, the result of the pass is rendered to screen
  	this.renderToScreen = false;

  };

  Object.assign( Pass.prototype, {

  	setSize: function ( width, height ) {},

  	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

  		console.error( 'Pass: .render() must be implemented in derived pass.' );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderPass = function ( shader, textureID ) {

  	Pass.call( this );

  	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

  	if ( shader instanceof ShaderMaterial ) {

  		this.uniforms = shader.uniforms;

  		this.material = shader;

  	} else if ( shader ) {

  		this.uniforms = UniformsUtils.clone( shader.uniforms );

  		this.material = new ShaderMaterial( {

  			defines: Object.assign( {}, shader.defines ),
  			uniforms: this.uniforms,
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader

  		} );

  	}

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  ShaderPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: ShaderPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		if ( this.uniforms[ this.textureID ] ) {

  			this.uniforms[ this.textureID ].value = readBuffer.texture;

  		}

  		this.quad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  			if ( this.clear ) { renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil ); }
  			renderer.render( this.scene, this.camera );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NodePass() {

  	ShaderPass.call( this );

  	this.name = "";
  	this.uuid = _Math.generateUUID();

  	this.userData = {};

  	this.textureID = 'renderTexture';

  	this.input = new ScreenNode();

  	this.material = new NodeMaterial();

  	this.needsUpdate = true;

  }

  NodePass.prototype = Object.create( ShaderPass.prototype );
  NodePass.prototype.constructor = NodePass;

  NodePass.prototype.render = function () {

  	if ( this.needsUpdate ) {

  		this.material.dispose();

  		this.material.fragment.value = this.input;

  		this.needsUpdate = false;

  	}

  	this.uniforms = this.material.uniforms;

  	ShaderPass.prototype.render.apply( this, arguments );

  };

  NodePass.prototype.copy = function ( source ) {

  	this.input = source.input;

  };

  NodePass.prototype.toJSON = function ( meta ) {

  	var isRootObject = ( meta === undefined || typeof meta === 'string' );

  	if ( isRootObject ) {

  		meta = {
  			nodes: {}
  		};

  	}

  	if ( meta && ! meta.passes ) { meta.passes = {}; }

  	if ( ! meta.passes[ this.uuid ] ) {

  		var data = {};

  		data.uuid = this.uuid;
  		data.type = "NodePass";

  		meta.passes[ this.uuid ] = data;

  		if ( this.name !== "" ) { data.name = this.name; }

  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		data.input = this.input.toJSON( meta ).uuid;

  	}

  	meta.pass = this.uuid;

  	return meta;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NodePostProcessing( renderer, renderTarget ) {

  	if ( renderTarget === undefined ) {

  		var parameters = {
  			minFilter: LinearFilter,
  			magFilter: LinearFilter,
  			format: RGBAFormat,
  			stencilBuffer: false
  		};

  		var size = renderer.getDrawingBufferSize( new Vector2() );
  		renderTarget = new WebGLRenderTarget( size.width, size.height, parameters );

  	}

  	this.renderer = renderer;
  	this.renderTarget = renderTarget;

  	this.output = new ScreenNode();
  	this.material = new NodeMaterial();

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.material );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  	this.needsUpdate = true;

  }

  NodePostProcessing.prototype = {

  	constructor: NodePostProcessing,

  	render: function ( scene, camera, frame ) {

  		if ( this.needsUpdate ) {

  			this.material.dispose();

  			this.material.fragment.value = this.output;
  			this.material.build();

  			if ( this.material.uniforms.renderTexture ) {

  				this.material.uniforms.renderTexture.value = this.renderTarget.texture;

  			}

  			this.needsUpdate = false;

  		}

  		frame.setRenderer( this.renderer )
  			.setRenderTexture( this.renderTarget.texture );

  		this.renderer.setRenderTarget( this.renderTarget );
  		this.renderer.render( scene, camera );

  		frame.updateNode( this.material );

  		this.renderer.setRenderTarget( null );
  		this.renderer.render( this.scene, this.camera );

  	},

  	setSize: function ( width, height ) {

  		this.renderTarget.setSize( width, height );

  		this.renderer.setSize( width, height );

  	},

  	copy: function ( source ) {

  		this.output = source.output;

  	},

  	toJSON: function ( meta ) {

  		var isRootObject = ( meta === undefined || typeof meta === 'string' );

  		if ( isRootObject ) {

  			meta = {
  				nodes: {}
  			};

  		}

  		if ( meta && ! meta.post ) { meta.post = {}; }

  		if ( ! meta.post[ this.uuid ] ) {

  			var data = {};

  			data.uuid = this.uuid;
  			data.type = "NodePostProcessing";

  			meta.post[ this.uuid ] = data;

  			if ( this.name !== "" ) { data.name = this.name; }

  			if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  			data.output = this.output.toJSON( meta ).uuid;

  		}

  		meta.post = this.uuid;

  		return meta;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CheckerNode( uv ) {

  	TempNode.call( this, 'f' );

  	this.uv = uv || new UVNode();

  }

  CheckerNode.prototype = Object.create( TempNode.prototype );
  CheckerNode.prototype.constructor = CheckerNode;
  CheckerNode.prototype.nodeType = "Noise";

  CheckerNode.Nodes = ( function () {

  	// https://github.com/mattdesl/glsl-checker/blob/master/index.glsl

  	var checker = new FunctionNode( [
  		"float checker( vec2 uv ) {",

  		"	float cx = floor( uv.x );",
  		"	float cy = floor( uv.y ); ",
  		"	float result = mod( cx + cy, 2.0 );",

  		"	return sign( result );",

  		"}"
  	].join( "\n" ) );

  	return {
  		checker: checker
  	};

  } )();

  CheckerNode.prototype.generate = function ( builder, output ) {

  	var snoise = builder.include( CheckerNode.Nodes.checker );

  	return builder.format( snoise + '( ' + this.uv.build( builder, 'v2' ) + ' )', this.getType( builder ), output );

  };

  CheckerNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.uv = source.uv;

  };

  CheckerNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.uv = this.uv.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function NoiseNode( uv ) {

  	TempNode.call( this, 'f' );

  	this.uv = uv || new UVNode();

  }

  NoiseNode.prototype = Object.create( TempNode.prototype );
  NoiseNode.prototype.constructor = NoiseNode;
  NoiseNode.prototype.nodeType = "Noise";

  NoiseNode.Nodes = ( function () {

  	var snoise = new FunctionNode( [
  		"float snoise(vec2 co) {",

  		"	return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",

  		"}"
  	].join( "\n" ) );

  	return {
  		snoise: snoise
  	};

  } )();

  NoiseNode.prototype.generate = function ( builder, output ) {

  	var snoise = builder.include( NoiseNode.Nodes.snoise );

  	return builder.format( snoise + '( ' + this.uv.build( builder, 'v2' ) + ' )', this.getType( builder ), output );

  };

  NoiseNode.prototype.copy = function ( source ) {

  	TempNode.prototype.copy.call( this, source );

  	this.uv = source.uv;

  };

  NoiseNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.uv = this.uv.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BypassNode( code, value ) {

  	Node$1.call( this );

  	this.code = code;
  	this.value = value;

  }

  BypassNode.prototype = Object.create( Node$1.prototype );
  BypassNode.prototype.constructor = BypassNode;
  BypassNode.prototype.nodeType = "Bypass";

  BypassNode.prototype.getType = function ( builder ) {

  	if ( this.value ) {

  		return this.value.getType( builder );

  	} else if ( builder.isShader( 'fragment' ) ) {

  		return 'f';

  	}

  	return 'void';

  };

  BypassNode.prototype.generate = function ( builder, output ) {

  	var code = this.code.build( builder, output ) + ';';

  	builder.addNodeCode( code );

  	if ( builder.isShader( 'vertex' ) ) {

  		if ( this.value ) {

  			return this.value.build( builder, output );

  		}

  	} else {

  		return this.value ? this.value.build( builder, output ) : builder.format( '0.0', 'f', output );

  	}

  };

  BypassNode.prototype.copy = function ( source ) {

  	Node$1.prototype.copy.call( this, source );

  	this.code = source.code;
  	this.value = source.value;

  };

  BypassNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.code = this.code.toJSON( meta ).uuid;

  		if ( this.value ) { data.value = this.value.toJSON( meta ).uuid; }

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var inputs = NodeUtils.elements;

  function JoinNode( x, y, z, w ) {

  	TempNode.call( this, 'f' );

  	this.x = x;
  	this.y = y;
  	this.z = z;
  	this.w = w;

  }

  JoinNode.prototype = Object.create( TempNode.prototype );
  JoinNode.prototype.constructor = JoinNode;
  JoinNode.prototype.nodeType = "Join";

  JoinNode.prototype.getNumElements = function () {
  	var this$1 = this;


  	var i = inputs.length;

  	while ( i -- ) {

  		if ( this$1[ inputs[ i ] ] !== undefined ) {

  			++ i;

  			break;

  		}

  	}

  	return Math.max( i, 2 );

  };

  JoinNode.prototype.getType = function ( builder ) {

  	return builder.getTypeFromLength( this.getNumElements() );

  };

  JoinNode.prototype.generate = function ( builder, output ) {
  	var this$1 = this;


  	var type = this.getType( builder ),
  		length = this.getNumElements(),
  		outputs = [];

  	for ( var i = 0; i < length; i ++ ) {

  		var elm = this$1[ inputs[ i ] ];

  		outputs.push( elm ? elm.build( builder, 'f' ) : '0.0' );

  	}

  	var code = ( length > 1 ? builder.getConstructorFromLength( length ) : '' ) + '( ' + outputs.join( ', ' ) + ' )';

  	return builder.format( code, type, output );

  };

  JoinNode.prototype.copy = function ( source ) {
  	var this$1 = this;


  	TempNode.prototype.copy.call( this, source );

  	for ( var prop in source.inputs ) {

  		this$1[ prop ] = source.inputs[ prop ];

  	}

  };

  JoinNode.prototype.toJSON = function ( meta ) {
  	var this$1 = this;


  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.inputs = {};

  		var length = this.getNumElements();

  		for ( var i = 0; i < length; i ++ ) {

  			var elm = this$1[ inputs[ i ] ];

  			if ( elm ) {

  				data.inputs[ inputs[ i ] ] = elm.toJSON( meta ).uuid;

  			}

  		}
  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function TimerNode( scale, scope, timeScale ) {

  	FloatNode.call( this );

  	this.scale = scale !== undefined ? scale : 1;
  	this.scope = scope || TimerNode.GLOBAL;

  	this.timeScale = timeScale !== undefined ? timeScale : scale !== undefined;

  }

  TimerNode.GLOBAL = 'global';
  TimerNode.LOCAL = 'local';
  TimerNode.DELTA = 'delta';

  TimerNode.prototype = Object.create( FloatNode.prototype );
  TimerNode.prototype.constructor = TimerNode;
  TimerNode.prototype.nodeType = "Timer";

  TimerNode.prototype.getReadonly = function () {

  	// never use TimerNode as readonly but aways as "uniform"

  	return false;

  };

  TimerNode.prototype.getUnique = function () {

  	// share TimerNode "uniform" input if is used on more time with others TimerNode

  	return this.timeScale && ( this.scope === TimerNode.GLOBAL || this.scope === TimerNode.DELTA );

  };

  TimerNode.prototype.updateFrame = function ( frame ) {

  	var scale = this.timeScale ? this.scale : 1;

  	switch ( this.scope ) {

  		case TimerNode.LOCAL:

  			this.value += frame.delta * scale;

  			break;

  		case TimerNode.DELTA:

  			this.value = frame.delta * scale;

  			break;

  		default:

  			this.value = frame.time * scale;

  	}

  };

  TimerNode.prototype.copy = function ( source ) {

  	FloatNode.prototype.copy.call( this, source );

  	this.scope = source.scope;
  	this.scale = source.scale;

  	this.timeScale = source.timeScale;

  };

  TimerNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.scope = this.scope;
  		data.scale = this.scale;

  		data.timeScale = this.timeScale;

  	}

  	return data;

  };

  NodeLib.addKeyword( 'time', function () {

  	return new TimerNode();

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function UVTransformNode( uv, position ) {

  	ExpressionNode.call( this, "( uvTransform * vec3( uvNode, 1 ) ).xy", "vec2" );

  	this.uv = uv || new UVNode();
  	this.position = position || new Matrix3Node();

  }

  UVTransformNode.prototype = Object.create( ExpressionNode.prototype );
  UVTransformNode.prototype.constructor = UVTransformNode;
  UVTransformNode.prototype.nodeType = "UVTransform";

  UVTransformNode.prototype.generate = function ( builder, output ) {

  	this.keywords[ "uvNode" ] = this.uv;
  	this.keywords[ "uvTransform" ] = this.position;

  	return ExpressionNode.prototype.generate.call( this, builder, output );

  };

  UVTransformNode.prototype.setUvTransform = function ( tx, ty, sx, sy, rotation, cx, cy ) {

  	cx = cx !== undefined ? cx : .5;
  	cy = cy !== undefined ? cy : .5;

  	this.position.value.setUvTransform( tx, ty, sx, sy, rotation, cx, cy );

  };

  UVTransformNode.prototype.copy = function ( source ) {

  	ExpressionNode.prototype.copy.call( this, source );

  	this.uv = source.uv;
  	this.position = source.position;

  };

  UVTransformNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		data.uv = this.uv.toJSON( meta ).uuid;
  		data.position = this.position.toJSON( meta ).uuid;

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function VelocityNode( target, params ) {

  	Vector3Node.call( this );

  	this.params = {};

  	this.velocity = new Vector3();

  	this.setTarget( target );
  	this.setParams( params );

  }

  VelocityNode.prototype = Object.create( Vector3Node.prototype );
  VelocityNode.prototype.constructor = VelocityNode;
  VelocityNode.prototype.nodeType = "Velocity";

  VelocityNode.prototype.getReadonly = function ( builder ) {

  	return false;

  };

  VelocityNode.prototype.setParams = function ( params ) {

  	switch ( this.params.type ) {

  		case "elastic":

  			delete this.moment;

  			delete this.speed;
  			delete this.springVelocity;

  			delete this.lastVelocity;

  			break;

  	}

  	this.params = params || {};

  	switch ( this.params.type ) {

  		case "elastic":

  			this.moment = new Vector3();

  			this.speed = new Vector3();
  			this.springVelocity = new Vector3();

  			this.lastVelocity = new Vector3();

  			break;

  	}

  };

  VelocityNode.prototype.setTarget = function ( target ) {

  	if ( this.target ) {

  		delete this.position;
  		delete this.oldPosition;

  	}

  	this.target = target;

  	if ( target ) {

  		this.position = target.getWorldPosition( this.position || new Vector3() );
  		this.oldPosition = this.position.clone();

  	}

  };

  VelocityNode.prototype.updateFrameVelocity = function ( frame ) {

  	if ( this.target ) {

  		this.position = this.target.getWorldPosition( this.position || new Vector3() );
  		this.velocity.subVectors( this.position, this.oldPosition );
  		this.oldPosition.copy( this.position );

  	}

  };

  VelocityNode.prototype.updateFrame = function ( frame ) {

  	this.updateFrameVelocity( frame );

  	switch ( this.params.type ) {

  		case "elastic":

  			// convert to real scale: 0 at 1 values
  			var deltaFps = frame.delta * ( this.params.fps || 60 );

  			var spring = Math.pow( this.params.spring, deltaFps ),
  				damping = Math.pow( this.params.damping, deltaFps );

  			// fix relative frame-rate
  			this.velocity.multiplyScalar( Math.exp( - this.params.damping * deltaFps ) );

  			// elastic
  			this.velocity.add( this.springVelocity );
  			this.velocity.add( this.speed.multiplyScalar( damping ).multiplyScalar( 1 - spring ) );

  			// speed
  			this.speed.subVectors( this.velocity, this.lastVelocity );

  			// spring velocity
  			this.springVelocity.add( this.speed );
  			this.springVelocity.multiplyScalar( spring );

  			// moment
  			this.moment.add( this.springVelocity );

  			// damping
  			this.moment.multiplyScalar( damping );

  			this.lastVelocity.copy( this.velocity );
  			this.value.copy( this.moment );

  			break;

  		default:

  			this.value.copy( this.velocity );

  	}

  };

  VelocityNode.prototype.copy = function ( source ) {

  	Vector3Node.prototype.copy.call( this, source );

  	if ( source.target ) { object.setTarget( source.target ); }

  	object.setParams( source.params );

  };

  VelocityNode.prototype.toJSON = function ( meta ) {

  	var data = this.getJSONNode( meta );

  	if ( ! data ) {

  		data = this.createJSONNode( meta );

  		if ( this.target ) { data.target = this.target.uuid; }

  		// clone params
  		data.params = JSON.parse( JSON.stringify( this.params ) );

  	}

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Clock( autoStart ) {

  	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  	this.startTime = 0;
  	this.oldTime = 0;
  	this.elapsedTime = 0;

  	this.running = false;

  }

  Object.assign( Clock.prototype, {

  	start: function () {

  		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

  		this.oldTime = this.startTime;
  		this.elapsedTime = 0;
  		this.running = true;

  	},

  	stop: function () {

  		this.getElapsedTime();
  		this.running = false;
  		this.autoStart = false;

  	},

  	getElapsedTime: function () {

  		this.getDelta();
  		return this.elapsedTime;

  	},

  	getDelta: function () {

  		var diff = 0;

  		if ( this.autoStart && ! this.running ) {

  			this.start();
  			return 0;

  		}

  		if ( this.running ) {

  			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

  			diff = ( newTime - this.oldTime ) / 1000;
  			this.oldTime = newTime;

  			this.elapsedTime += diff;

  		}

  		return diff;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Fire = function ( geometry, options ) {

  	Mesh.call( this, geometry );

  	this.type = 'Fire';

  	this.clock = new Clock();

  	options = options || {};

  	var textureWidth = options.textureWidth || 512;
  	var textureHeight = options.textureHeight || 512;
  	var oneOverWidth = 1.0 / textureWidth;
  	var oneOverHeight = 1.0 / textureHeight;

  	var debug = ( options.debug === undefined ) ? false : options.debug;
  	this.color1 = options.color1 || new Color( 0xffffff );
  	this.color2 = options.color2 || new Color( 0xffa000 );
  	this.color3 = options.color3 || new Color( 0x000000 );
  	this.colorBias = ( options.colorBias === undefined ) ? 0.8 : options.colorBias;
  	this.diffuse = ( options.diffuse === undefined ) ? 1.33 : options.diffuse;
  	this.viscosity = ( options.viscosity === undefined ) ? 0.25 : options.viscosity;
  	this.expansion = ( options.expansion === undefined ) ? - 0.25 : options.expansion;
  	this.swirl = ( options.swirl === undefined ) ? 50.0 : options.swirl;
  	this.burnRate = ( options.burnRate === undefined ) ? 0.3 : options.burnRate;
  	this.drag = ( options.drag === undefined ) ? 0.35 : options.drag;
  	this.airSpeed = ( options.airSpeed === undefined ) ? 6.0 : options.airSpeed;
  	this.windVector = options.windVector || new Vector2( 0.0, 0.75 );
  	this.speed = ( options.speed === undefined ) ? 500.0 : options.speed;
  	this.massConservation = ( options.massConservation === undefined ) ? false : options.massConservation;

  	var size = textureWidth * textureHeight;
  	this.sourceData = new Uint8Array( 4 * size );

  	this.clearSources = function () {
  		var this$1 = this;


  		for ( var y = 0; y < textureHeight; y ++ ) {

  			for ( var x = 0; x < textureWidth; x ++ ) {

  				var i = y * textureWidth + x;
  				var stride = i * 4;

  				this$1.sourceData[ stride ] = 0;
  				this$1.sourceData[ stride + 1 ] = 0;
  				this$1.sourceData[ stride + 2 ] = 0;
  				this$1.sourceData[ stride + 3 ] = 0;

  			}

  		}

  		this.sourceMaterial.uniforms[ "sourceMap" ].value = this.internalSource;
  		this.sourceMaterial.needsUpdate = true;

  		return this.sourceData;

  	};

  	this.addSource = function ( u, v, radius, density, windX, windY ) {
  		var this$1 = this;
  		if ( density === void 0 ) density = null;
  		if ( windX === void 0 ) windX = null;
  		if ( windY === void 0 ) windY = null;


  		var startX = Math.max( Math.floor( ( u - radius ) * textureWidth ), 0 );
  		var startY = Math.max( Math.floor( ( v - radius ) * textureHeight ), 0 );
  		var endX = Math.min( Math.floor( ( u + radius ) * textureWidth ), textureWidth );
  		var endY = Math.min( Math.floor( ( v + radius ) * textureHeight ), textureHeight );

  		for ( var y = startY; y < endY; y ++ ) {

  			for ( var x = startX; x < endX; x ++ ) {

  				var diffX = x * oneOverWidth - u;
  				var diffY = y * oneOverHeight - v;

  				if ( diffX * diffX + diffY * diffY < radius * radius ) {

  					var i = y * textureWidth + x;
  					var stride = i * 4;

  					if ( density != null ) {

  						this$1.sourceData[ stride ] = Math.min( Math.max( density, 0.0 ), 1.0 ) * 255;

  					}
  					if ( windX != null ) {

  						var wind = Math.min( Math.max( windX, - 1.0 ), 1.0 );
  						wind = ( wind < 0.0 ) ? Math.floor( wind * 127 ) + 255 : Math.floor( wind * 127 );
  						this$1.sourceData[ stride + 1 ] = wind;

  					}
  					if ( windY != null ) {

  						var wind = Math.min( Math.max( windY, - 1.0 ), 1.0 );
  						wind = ( wind < 0.0 ) ? Math.floor( wind * 127 ) + 255 : Math.floor( wind * 127 );
  						this$1.sourceData[ stride + 2 ] = wind;

  					}

  				}

  			}

  		}

  		this.internalSource.needsUpdate = true;

  		return this.sourceData;

  	};

  	// When setting source map, red channel is density. Green and blue channels
  	// encode x and y velocity respectively as signed chars:
  	// (0 -> 127 = 0.0 -> 1.0, 128 -> 255 = -1.0 -> 0.0 )
  	this.setSourceMap = function ( texture ) {

  		this.sourceMaterial.uniforms[ "sourceMap" ].value = texture;

  	};

  	var parameters = {
  		minFilter: NearestFilter,
  		magFilter: NearestFilter,
  		depthBuffer: false,
  		stencilBuffer: false
  	};
  	this.field0 = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	this.field0.background = new Color( 0x000000 );

  	this.field1 = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	this.field0.background = new Color( 0x000000 );

  	this.fieldProj = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	this.field0.background = new Color( 0x000000 );

  	if ( ! _Math.isPowerOfTwo( textureWidth ) ||
  		 ! _Math.isPowerOfTwo( textureHeight ) ) {

  		this.field0.texture.generateMipmaps = false;
  		this.field1.texture.generateMipmaps = false;
  		this.fieldProj.texture.generateMipmaps = false;

  	}
  	this.fieldScene = new Scene();
  	this.fieldScene.background = new Color( 0x000000 );

  	this.orthoCamera = new OrthographicCamera( textureWidth / - 2, textureWidth / 2, textureHeight / 2, textureHeight / - 2, 1, 2 );
  	this.orthoCamera.position.z = 1;

  	this.fieldGeometry = new PlaneBufferGeometry( textureWidth, textureHeight );

  	this.internalSource = new DataTexture( this.sourceData, textureWidth, textureHeight, RGBAFormat );

  	// Source Shader

  	var shader = Fire.SourceShader;
  	this.sourceMaterial = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );

  	this.clearSources();

  	this.sourceMesh = new Mesh( this.fieldGeometry, this.sourceMaterial );
  	this.fieldScene.add( this.sourceMesh );

  	// Diffuse Shader

  	var shader = Fire.DiffuseShader;
  	this.diffuseMaterial = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );

  	this.diffuseMaterial.uniforms[ "oneOverWidth" ].value = oneOverWidth;
  	this.diffuseMaterial.uniforms[ "oneOverHeight" ].value = oneOverHeight;

  	this.diffuseMesh = new Mesh( this.fieldGeometry, this.diffuseMaterial );
  	this.fieldScene.add( this.diffuseMesh );

  	// Drift Shader

  	shader = Fire.DriftShader;
  	this.driftMaterial = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );

  	this.driftMaterial.uniforms[ "oneOverWidth" ].value = oneOverWidth;
  	this.driftMaterial.uniforms[ "oneOverHeight" ].value = oneOverHeight;

  	this.driftMesh = new Mesh( this.fieldGeometry, this.driftMaterial );
  	this.fieldScene.add( this.driftMesh );

  	// Projection Shader 1

  	shader = Fire.ProjectionShader1;
  	this.projMaterial1 = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );

  	this.projMaterial1.uniforms[ "oneOverWidth" ].value = oneOverWidth;
  	this.projMaterial1.uniforms[ "oneOverHeight" ].value = oneOverHeight;

  	this.projMesh1 = new Mesh( this.fieldGeometry, this.projMaterial1 );
  	this.fieldScene.add( this.projMesh1 );

  	// Projection Shader 2

  	shader = Fire.ProjectionShader2;
  	this.projMaterial2 = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );
  	this.projMaterial2.uniforms[ "oneOverWidth" ].value = oneOverWidth;
  	this.projMaterial2.uniforms[ "oneOverHeight" ].value = oneOverHeight;

  	this.projMesh2 = new Mesh( this.fieldGeometry, this.projMaterial2 );
  	this.fieldScene.add( this.projMesh2 );

  	// Projection Shader 3

  	shader = Fire.ProjectionShader3;
  	this.projMaterial3 = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: false
  	} );
  	this.projMaterial3.uniforms[ "oneOverWidth" ].value = oneOverWidth;
  	this.projMaterial3.uniforms[ "oneOverHeight" ].value = oneOverHeight;

  	this.projMesh3 = new Mesh( this.fieldGeometry, this.projMaterial3 );
  	this.fieldScene.add( this.projMesh3 );

  	// Color Shader

  	if ( debug ) {

  		shader = Fire.DebugShader;

  	} else {

  		shader = Fire.ColorShader;

  	}
  	this.material = new ShaderMaterial( {
  		uniforms: shader.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: true
  	} );

  	this.material.uniforms[ "densityMap" ].value = this.field1.texture;

  	this.configShaders = function ( dt ) {

  		this.diffuseMaterial.uniforms[ "diffuse" ].value = dt * 0.05 * this.diffuse;
  		this.diffuseMaterial.uniforms[ "viscosity" ].value = dt * 0.05 * this.viscosity;
  		this.diffuseMaterial.uniforms[ "expansion" ].value = Math.exp( this.expansion * - 1.0 );
  		this.diffuseMaterial.uniforms[ "swirl" ].value = Math.exp( this.swirl * - 0.1 );
  		this.diffuseMaterial.uniforms[ "drag" ].value = Math.exp( this.drag * - 0.1 );
  		this.diffuseMaterial.uniforms[ "burnRate" ].value = this.burnRate * dt * 0.01;
  		this.driftMaterial.uniforms[ "windVector" ].value = this.windVector;
  		this.driftMaterial.uniforms[ "airSpeed" ].value = dt * this.airSpeed * 0.001 * textureHeight;
  		this.material.uniforms[ "color1" ].value = this.color1;
  		this.material.uniforms[ "color2" ].value = this.color2;
  		this.material.uniforms[ "color3" ].value = this.color3;
  		this.material.uniforms[ "colorBias" ].value = this.colorBias;

  	};

  	this.clearDiffuse = function () {

  		this.diffuseMaterial.uniforms[ "expansion" ].value = 1.0;
  		this.diffuseMaterial.uniforms[ "swirl" ].value = 1.0;
  		this.diffuseMaterial.uniforms[ "drag" ].value = 1.0;
  		this.diffuseMaterial.uniforms[ "burnRate" ].value = 0.0;

  	};

  	this.swapTextures = function () {

  		var swap = this.field0;
  		this.field0 = this.field1;
  		this.field1 = swap;

  	};

  	this.saveRenderState = function ( renderer ) {

  		this.savedRenderTarget = renderer.getRenderTarget();
  		this.savedVrEnabled = renderer.vr.enabled;
  		this.savedShadowAutoUpdate = renderer.shadowMap.autoUpdate;
  		this.savedAntialias = renderer.antialias;
  		this.savedToneMapping = renderer.toneMapping;

  	};

  	this.restoreRenderState = function ( renderer ) {

  		renderer.vr.enabled = this.savedVrEnabled;
  		renderer.shadowMap.autoUpdate = this.savedShadowAutoUpdate;
  		renderer.setRenderTarget( this.savedRenderTarget );
  		renderer.antialias = this.savedAntialias;
  		renderer.toneMapping = this.savedToneMapping;

  	};

  	this.renderSource = function ( renderer ) {

  		this.sourceMesh.visible = true;

  		this.sourceMaterial.uniforms[ "densityMap" ].value = this.field0.texture;

  		renderer.setRenderTarget( this.field1 );
  		renderer.render( this.fieldScene, this.orthoCamera );

  		this.sourceMesh.visible = false;

  		this.swapTextures();

  	};

  	this.renderDiffuse = function ( renderer ) {

  		this.diffuseMesh.visible = true;

  		this.diffuseMaterial.uniforms[ "densityMap" ].value = this.field0.texture;

  		renderer.setRenderTarget( this.field1 );
  		renderer.render( this.fieldScene, this.orthoCamera );

  		this.diffuseMesh.visible = false;

  		this.swapTextures();

  	};

  	this.renderDrift = function ( renderer ) {

  		this.driftMesh.visible = true;

  		this.driftMaterial.uniforms[ "densityMap" ].value = this.field0.texture;

  		renderer.setRenderTarget( this.field1 );
  		renderer.render( this.fieldScene, this.orthoCamera );

  		this.driftMesh.visible = false;

  		this.swapTextures();

  	};

  	this.renderProject = function ( renderer ) {
  		var this$1 = this;


  		// Projection pass 1

  		this.projMesh1.visible = true;

  		this.projMaterial1.uniforms[ "densityMap" ].value = this.field0.texture;

  		renderer.setRenderTarget( this.fieldProj );
  		renderer.render( this.fieldScene, this.orthoCamera );

  		this.projMesh1.visible = false;

  		this.projMaterial2.uniforms[ "densityMap" ].value = this.fieldProj.texture;

  		// Projection pass 2

  		this.projMesh2.visible = true;

  		for ( var i = 0; i < 20; i ++ ) {

  			renderer.setRenderTarget( this$1.field1 );
  			renderer.render( this$1.fieldScene, this$1.orthoCamera );

  			var temp = this$1.field1;
  			this$1.field1 = this$1.fieldProj;
  			this$1.fieldProj = temp;

  			this$1.projMaterial2.uniforms[ "densityMap" ].value = this$1.fieldProj.texture;

  		}

  		this.projMesh2.visible = false;

  		this.projMaterial3.uniforms[ "densityMap" ].value = this.field0.texture;
  		this.projMaterial3.uniforms[ "projMap" ].value = this.fieldProj.texture;

  		// Projection pass 3

  		this.projMesh3.visible = true;

  		renderer.setRenderTarget( this.field1 );
  		renderer.render( this.fieldScene, this.orthoCamera );

  		this.projMesh3.visible = false;

  		this.swapTextures();

  	};

  	this.onBeforeRender = function ( renderer, scene, camera ) {
  		var this$1 = this;


  		var delta = this.clock.getDelta();
  		if ( delta > 0.1 ) {

  			delta = 0.1;

  		}
  		var dt = delta * ( this.speed * 0.1 );

  		this.configShaders( dt );

  		this.saveRenderState( renderer );

  		renderer.vr.enabled = false; // Avoid camera modification and recursion
  		renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows
  		renderer.antialias = false;
  		renderer.toneMapping = NoToneMapping;

  		this.sourceMesh.visible = false;
  		this.diffuseMesh.visible = false;
  		this.driftMesh.visible = false;
  		this.projMesh1.visible = false;
  		this.projMesh2.visible = false;
  		this.projMesh3.visible = false;

  		this.renderSource( renderer );

  		this.clearDiffuse();
  		for ( var i = 0; i < 21; i ++ ) {

  			this$1.renderDiffuse( renderer );

  		}
  		this.configShaders( dt );
  		this.renderDiffuse( renderer );

  		this.renderDrift( renderer );

  		if ( this.massConservation ) {

  			this.renderProject( renderer );
  			this.renderProject( renderer );

  		}

  		// Final result out for coloring

  		this.material.map = this.field1.texture;
  		this.material.transparent = true;
  		this.material.minFilter = LinearFilter,
  		this.material.magFilter = LinearFilter,

  		this.restoreRenderState( renderer );

  	};

  };
  Fire.prototype = Object.create( Mesh.prototype );
  Fire.prototype.constructor = Fire;

  Fire.SourceShader = {

  	uniforms: {
  		'sourceMap': {
  			type: 't',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform sampler2D sourceMap;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    vec4 source = texture2D( sourceMap, vUv );',
  		'    vec4 current = texture2D( densityMap, vUv );',

  		'    vec2 v0 = (current.gb - step(0.5, current.gb)) * 2.0;',
  		'    vec2 v1 = (source.gb - step(0.5, source.gb)) * 2.0;',

  		'    vec2 newVel = v0 + v1;',

  		'    newVel = clamp(newVel, -0.99, 0.99);',
  		'    newVel = newVel * 0.5 + step(0.0, -newVel);',

  		'    float newDensity = source.r + current.a;',
  		'    float newTemp = source.r + current.r;',

  		'    newDensity = clamp(newDensity, 0.0, 1.0);',
  		'    newTemp = clamp(newTemp, 0.0, 1.0);',

  		'    gl_FragColor = vec4(newTemp, newVel.xy, newDensity);',

  		'}'

  	].join( "\n" )
  };
  Fire.DiffuseShader = {

  	uniforms: {
  		'oneOverWidth': {
  			type: 'f',
  			value: null
  		},
  		'oneOverHeight': {
  			type: 'f',
  			value: null
  		},
  		'diffuse': {
  			type: 'f',
  			value: null
  		},
  		'viscosity': {
  			type: 'f',
  			value: null
  		},
  		'expansion': {
  			type: 'f',
  			value: null
  		},
  		'swirl': {
  			type: 'f',
  			value: null
  		},
  		'drag': {
  			type: 'f',
  			value: null
  		},
  		'burnRate': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform float oneOverWidth;',
  		'uniform float oneOverHeight;',
  		'uniform float diffuse;',
  		'uniform float viscosity;',
  		'uniform float expansion;',
  		'uniform float swirl;',
  		'uniform float burnRate;',
  		'uniform float drag;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',

  		'    vec4 dC = texture2D( densityMap, vUv );',
  		'    vec4 dL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) );',
  		'    vec4 dR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) );',
  		'    vec4 dU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) );',
  		'    vec4 dD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) );',
  		'    vec4 dUL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y - oneOverHeight) );',
  		'    vec4 dUR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y - oneOverHeight) );',
  		'    vec4 dDL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y + oneOverHeight) );',
  		'    vec4 dDR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y + oneOverHeight) );',

  		'    dC.yz = (dC.yz - step(0.5, dC.yz)) * 2.0;',
  		'    dL.yz = (dL.yz - step(0.5, dL.yz)) * 2.0;',
  		'    dR.yz = (dR.yz - step(0.5, dR.yz)) * 2.0;',
  		'    dU.yz = (dU.yz - step(0.5, dU.yz)) * 2.0;',
  		'    dD.yz = (dD.yz - step(0.5, dD.yz)) * 2.0;',
  		'    dUL.yz = (dUL.yz - step(0.5, dUL.yz)) * 2.0;',
  		'    dUR.yz = (dUR.yz - step(0.5, dUR.yz)) * 2.0;',
  		'    dDL.yz = (dDL.yz - step(0.5, dDL.yz)) * 2.0;',
  		'    dDR.yz = (dDR.yz - step(0.5, dDR.yz)) * 2.0;',

  		'    vec4 result = (dC + vec4(diffuse, viscosity, viscosity, diffuse) * ( dL + dR + dU + dD + dUL + dUR + dDL + dDR )) / (1.0 + 8.0 * vec4(diffuse, viscosity, viscosity, diffuse)) - vec4(0.0, 0.0, 0.0, 0.001);',

  		'    float temperature = result.r;',
  		'    temperature = clamp(temperature - burnRate, 0.0, 1.0);',

  		'    vec2 velocity = result.yz;',

  		'    vec2 expansionVec = vec2(dL.w - dR.w, dU.w - dD.w);',

  		'    vec2 swirlVec = vec2((dL.z - dR.z) * 0.5, (dU.y - dD.y) * 0.5);',

  		'    velocity = velocity + (1.0 - expansion) * expansionVec + (1.0 - swirl) * swirlVec;',

  		'    velocity = velocity - (1.0 - drag) * velocity;',

  		'    gl_FragColor = vec4(temperature, velocity * 0.5 + step(0.0, -velocity), result.w);',

  		'    gl_FragColor = gl_FragColor * step(oneOverWidth, vUv.x);',
  		'    gl_FragColor = gl_FragColor * step(oneOverHeight, vUv.y);',
  		'    gl_FragColor = gl_FragColor * step(vUv.x, 1.0 - oneOverWidth);',
  		'    gl_FragColor = gl_FragColor * step(vUv.y, 1.0 - oneOverHeight);',

  		'}'

  	].join( "\n" )
  };

  Fire.DriftShader = {

  	uniforms: {
  		'oneOverWidth': {
  			type: 'f',
  			value: null
  		},
  		'oneOverHeight': {
  			type: 'f',
  			value: null
  		},
  		'windVector': {
  			type: 'v2',
  			value: new Vector2( 0.0, 0.0 )
  		},
  		'airSpeed': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform float oneOverWidth;',
  		'uniform float oneOverHeight;',
  		'uniform vec2 windVector;',
  		'uniform float airSpeed;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    vec2 velocity = texture2D( densityMap, vUv ).gb;',
  		'    velocity = (velocity - step(0.5, velocity)) * 2.0;',

  		'    velocity = velocity + windVector;',

  		'    vec2 sourcePos = vUv - airSpeed * vec2(oneOverWidth, oneOverHeight) * velocity;',

  		'    vec2 units = sourcePos / vec2(oneOverWidth, oneOverHeight);',

  		'    vec2 intPos = floor(units);',
  		'    vec2 frac = units - intPos;',
  		'    intPos = intPos * vec2(oneOverWidth, oneOverHeight);',

  		'    vec4 dX0Y0 = texture2D( densityMap, intPos + vec2(0.0, -oneOverHeight) );',
  		'    vec4 dX1Y0 = texture2D( densityMap, intPos + vec2(oneOverWidth, 0.0) );',
  		'    vec4 dX0Y1 = texture2D( densityMap, intPos + vec2(0.0, oneOverHeight) );',
  		'    vec4 dX1Y1 = texture2D( densityMap, intPos + vec2(oneOverWidth, oneOverHeight) );',
  		'    dX0Y0.gb = (dX0Y0.gb - step(0.5, dX0Y0.gb)) * 2.0;',
  		'    dX1Y0.gb = (dX1Y0.gb - step(0.5, dX1Y0.gb)) * 2.0;',
  		'    dX0Y1.gb = (dX0Y1.gb - step(0.5, dX0Y1.gb)) * 2.0;',
  		'    dX1Y1.gb = (dX1Y1.gb - step(0.5, dX1Y1.gb)) * 2.0;',

  		'    vec4 source = mix(mix(dX0Y0, dX1Y0, frac.x), mix(dX0Y1, dX1Y1, frac.x), frac.y);',

  		'    source.gb = source.gb * 0.5 + step(0.0, -source.gb);',

  		'    gl_FragColor = source;',

  		'}'

  	].join( "\n" )
  };
  Fire.ProjectionShader1 = {

  	uniforms: {
  		'oneOverWidth': {
  			type: 'f',
  			value: null
  		},
  		'oneOverHeight': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform float oneOverWidth;',
  		'uniform float oneOverHeight;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    float dL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',
  		'    float dR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',
  		'    float dU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) ).b;',
  		'    float dD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) ).b;',

  		'    dL = (dL - step(0.5, dL)) * 2.0;',
  		'    dR = (dR - step(0.5, dR)) * 2.0;',
  		'    dU = (dU - step(0.5, dU)) * 2.0;',
  		'    dD = (dD - step(0.5, dD)) * 2.0;',

  		'    float h = (oneOverWidth + oneOverHeight) * 0.5;',
  		'    float div = -0.5 * h * (dR - dL + dD - dU);',

  		'    gl_FragColor = vec4( 0.0, 0.0, div * 0.5 + step(0.0, -div), 0.0);',

  		'}'

  	].join( "\n" )
  };
  Fire.ProjectionShader2 = {

  	uniforms: {
  		'oneOverWidth': {
  			type: 'f',
  			value: null
  		},
  		'oneOverHeight': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform float oneOverWidth;',
  		'uniform float oneOverHeight;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    float div = texture2D( densityMap, vUv ).b;',
  		'    float pL = texture2D( densityMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',
  		'    float pR = texture2D( densityMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',
  		'    float pU = texture2D( densityMap, vec2(vUv.x, vUv.y - oneOverHeight) ).g;',
  		'    float pD = texture2D( densityMap, vec2(vUv.x, vUv.y + oneOverHeight) ).g;',

  		'    float divNorm = (div - step(0.5, div)) * 2.0;',
  		'    pL = (pL - step(0.5, pL)) * 2.0;',
  		'    pR = (pR - step(0.5, pR)) * 2.0;',
  		'    pU = (pU - step(0.5, pU)) * 2.0;',
  		'    pD = (pD - step(0.5, pD)) * 2.0;',

  		'    float p = (divNorm + pR + pL + pD + pU) * 0.25;',

  		'    gl_FragColor = vec4( 0.0, p * 0.5 + step(0.0, -p), div, 0.0);',

  		'}'

  	].join( "\n" )
  };
  Fire.ProjectionShader3 = {

  	uniforms: {
  		'oneOverWidth': {
  			type: 'f',
  			value: null
  		},
  		'oneOverHeight': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		},
  		'projMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform float oneOverWidth;',
  		'uniform float oneOverHeight;',
  		'uniform sampler2D densityMap;',
  		'uniform sampler2D projMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    vec4 orig = texture2D(densityMap, vUv);',

  		'    float pL = texture2D( projMap, vec2(vUv.x - oneOverWidth, vUv.y) ).g;',
  		'    float pR = texture2D( projMap, vec2(vUv.x + oneOverWidth, vUv.y) ).g;',
  		'    float pU = texture2D( projMap, vec2(vUv.x, vUv.y - oneOverHeight) ).g;',
  		'    float pD = texture2D( projMap, vec2(vUv.x, vUv.y + oneOverHeight) ).g;',

  		'    float uNorm = (orig.g - step(0.5, orig.g)) * 2.0;',
  		'    float vNorm = (orig.b - step(0.5, orig.b)) * 2.0;',

  		'    pL = (pL - step(0.5, pL)) * 2.0;',
  		'    pR = (pR - step(0.5, pR)) * 2.0;',
  		'    pU = (pU - step(0.5, pU)) * 2.0;',
  		'    pD = (pD - step(0.5, pD)) * 2.0;',

  		'    float h = (oneOverWidth + oneOverHeight) * 0.5;',
  		'    float u = uNorm - (0.5 * (pR - pL) / h);',
  		'    float v = vNorm - (0.5 * (pD - pU) / h);',

  		'    gl_FragColor = vec4( orig.r, u * 0.5 + step(0.0, -u), v * 0.5 + step(0.0, -v), orig.a);',

  		'}'

  	].join( "\n" )
  };

  Fire.ColorShader = {

  	uniforms: {
  		'color1': {
  			type: 'c',
  			value: null
  		},
  		'color2': {
  			type: 'c',
  			value: null
  		},
  		'color3': {
  			type: 'c',
  			value: null
  		},
  		'colorBias': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform vec3 color1;',
  		'uniform vec3 color2;',
  		'uniform vec3 color3;',
  		'uniform float colorBias;',
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    float density = texture2D( densityMap, vUv ).a;',
  		'    float temperature = texture2D( densityMap, vUv ).r;',

  		'    float bias = clamp(colorBias, 0.0001, 0.9999);',

  		'    vec3 blend1 = mix(color3, color2, temperature / bias) * (1.0 - step(bias, temperature));',
  		'    vec3 blend2 = mix(color2, color1, (temperature - bias) / (1.0 - bias) ) * step(bias, temperature);',

  		'    gl_FragColor = vec4(blend1 + blend2, density);',
  		'}'

  	].join( "\n" )
  };
  Fire.DebugShader = {

  	uniforms: {
  		'color1': {
  			type: 'c',
  			value: null
  		},
  		'color2': {
  			type: 'c',
  			value: null
  		},
  		'color3': {
  			type: 'c',
  			value: null
  		},
  		'colorBias': {
  			type: 'f',
  			value: null
  		},
  		'densityMap': {
  			type: 't',
  			value: null
  		}
  	},

  	vertexShader: [
  		'varying vec2 vUv;',

  		'void main() {',

  		' 	  vUv = uv;',

  		'     vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
  		'     gl_Position = projectionMatrix * mvPosition;',

  		'}'

  	].join( "\n" ),

  	fragmentShader: [
  		'uniform sampler2D densityMap;',

  		'varying vec2 vUv;',

  		'void main() {',
  		'    float density;',
  		'    density = texture2D( densityMap, vUv ).a;',

  		'    vec2 vel = texture2D( densityMap, vUv ).gb;',

  		'    vel = (vel - step(0.5, vel)) * 2.0;',

  		'    float r = density;',
  		'    float g = max(abs(vel.x), density * 0.5);',
  		'    float b = max(abs(vel.y), density * 0.5);',
  		'    float a = max(density * 0.5, max(abs(vel.x), abs(vel.y)));',

  		'    gl_FragColor = vec4(r, g, b, a);',

  		'}'

  	].join( "\n" )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Box2( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

  }

  Object.assign( Box2.prototype, {

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this$1.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector2();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = + Infinity;
  		this.max.x = this.max.y = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  	},

  	getCenter: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box2: .getCenter() target is now required' );
  			target = new Vector2();

  		}

  		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box2: .getSize() target is now required' );
  			target = new Vector2();

  		}

  		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y;

  	},

  	getParameter: function ( point, target ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		if ( target === undefined ) {

  			console.warn( 'Box2: .getParameter() target is now required' );
  			target = new Vector2();

  		}

  		return target.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 4 splitting planes to rule out intersections

  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

  	},

  	clampPoint: function ( point, target ) {

  		if ( target === undefined ) {

  			console.warn( 'Box2: .clampPoint() target is now required' );
  			target = new Vector2();

  		}

  		return target.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector2();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Lensflare = function () {

  	Mesh.call( this, Lensflare.Geometry, new MeshBasicMaterial( { opacity: 0, transparent: true } ) );

  	this.type = 'Lensflare';
  	this.frustumCulled = false;
  	this.renderOrder = Infinity;

  	//

  	var positionScreen = new Vector3();
  	var positionView = new Vector3();

  	// textures

  	var tempMap = new DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, RGBFormat );
  	tempMap.minFilter = NearestFilter;
  	tempMap.magFilter = NearestFilter;
  	tempMap.wrapS = ClampToEdgeWrapping;
  	tempMap.wrapT = ClampToEdgeWrapping;
  	tempMap.needsUpdate = true;

  	var occlusionMap = new DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, RGBFormat );
  	occlusionMap.minFilter = NearestFilter;
  	occlusionMap.magFilter = NearestFilter;
  	occlusionMap.wrapS = ClampToEdgeWrapping;
  	occlusionMap.wrapT = ClampToEdgeWrapping;
  	occlusionMap.needsUpdate = true;

  	// material

  	var geometry = Lensflare.Geometry;

  	var material1a = new RawShaderMaterial( {
  		uniforms: {
  			'scale': { value: null },
  			'screenPosition': { value: null }
  		},
  		vertexShader: [

  			'precision highp float;',

  			'uniform vec3 screenPosition;',
  			'uniform vec2 scale;',

  			'attribute vec3 position;',

  			'void main() {',

  			'	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',

  			'}'

  		].join( '\n' ),
  		fragmentShader: [

  			'precision highp float;',

  			'void main() {',

  			'	gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',

  			'}'

  		].join( '\n' ),
  		depthTest: true,
  		depthWrite: false,
  		transparent: false
  	} );

  	var material1b = new RawShaderMaterial( {
  		uniforms: {
  			'map': { value: tempMap },
  			'scale': { value: null },
  			'screenPosition': { value: null }
  		},
  		vertexShader: [

  			'precision highp float;',

  			'uniform vec3 screenPosition;',
  			'uniform vec2 scale;',

  			'attribute vec3 position;',
  			'attribute vec2 uv;',

  			'varying vec2 vUV;',

  			'void main() {',

  			'	vUV = uv;',

  			'	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',

  			'}'

  		].join( '\n' ),
  		fragmentShader: [

  			'precision highp float;',

  			'uniform sampler2D map;',

  			'varying vec2 vUV;',

  			'void main() {',

  			'	gl_FragColor = texture2D( map, vUV );',

  			'}'

  		].join( '\n' ),
  		depthTest: false,
  		depthWrite: false,
  		transparent: false
  	} );

  	// the following object is used for occlusionMap generation

  	var mesh1 = new Mesh( geometry, material1a );

  	//

  	var elements = [];

  	var shader = LensflareElement.Shader;

  	var material2 = new RawShaderMaterial( {
  		uniforms: {
  			'map': { value: null },
  			'occlusionMap': { value: occlusionMap },
  			'color': { value: new Color( 0xffffff ) },
  			'scale': { value: new Vector2() },
  			'screenPosition': { value: new Vector3() }
  		},
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		blending: AdditiveBlending,
  		transparent: true,
  		depthWrite: false
  	} );

  	var mesh2 = new Mesh( geometry, material2 );

  	this.addElement = function ( element ) {

  		elements.push( element );

  	};

  	//

  	var scale = new Vector2();
  	var screenPositionPixels = new Vector2();
  	var validArea = new Box2();
  	var viewport = new Vector4();

  	this.onBeforeRender = function ( renderer, scene, camera ) {

  		renderer.getCurrentViewport( viewport );

  		var invAspect = viewport.w / viewport.z;
  		var halfViewportWidth = viewport.z / 2.0;
  		var halfViewportHeight = viewport.w / 2.0;

  		var size = 16 / viewport.w;
  		scale.set( size * invAspect, size );

  		validArea.min.set( viewport.x, viewport.y );
  		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

  		// calculate position in screen space

  		positionView.setFromMatrixPosition( this.matrixWorld );
  		positionView.applyMatrix4( camera.matrixWorldInverse );

  		if ( positionView.z > 0 ) { return; } // lensflare is behind the camera

  		positionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );

  		// horizontal and vertical coordinate of the lower left corner of the pixels to copy

  		screenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;
  		screenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;

  		// screen cull

  		if ( validArea.containsPoint( screenPositionPixels ) ) {

  			// save current RGB to temp texture

  			renderer.copyFramebufferToTexture( screenPositionPixels, tempMap );

  			// render pink quad

  			var uniforms = material1a.uniforms;
  			uniforms[ "scale" ].value = scale;
  			uniforms[ "screenPosition" ].value = positionScreen;

  			renderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );

  			// copy result to occlusionMap

  			renderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );

  			// restore graphics

  			var uniforms = material1b.uniforms;
  			uniforms[ "scale" ].value = scale;
  			uniforms[ "screenPosition" ].value = positionScreen;

  			renderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );

  			// render elements

  			var vecX = - positionScreen.x * 2;
  			var vecY = - positionScreen.y * 2;

  			for ( var i = 0, l = elements.length; i < l; i ++ ) {

  				var element = elements[ i ];

  				var uniforms = material2.uniforms;

  				uniforms[ "color" ].value.copy( element.color );
  				uniforms[ "map" ].value = element.texture;
  				uniforms[ "screenPosition" ].value.x = positionScreen.x + vecX * element.distance;
  				uniforms[ "screenPosition" ].value.y = positionScreen.y + vecY * element.distance;

  				var size = element.size / viewport.w;
  				var invAspect = viewport.w / viewport.z;

  				uniforms[ "scale" ].value.set( size * invAspect, size );

  				material2.uniformsNeedUpdate = true;

  				renderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );

  			}

  		}

  	};

  	this.dispose = function () {

  		material1a.dispose();
  		material1b.dispose();
  		material2.dispose();

  		tempMap.dispose();
  		occlusionMap.dispose();

  		for ( var i = 0, l = elements.length; i < l; i ++ ) {

  			elements[ i ].texture.dispose();

  		}

  	};

  };

  Lensflare.prototype = Object.create( Mesh.prototype );
  Lensflare.prototype.constructor = Lensflare;
  Lensflare.prototype.isLensflare = true;

  //

  var LensflareElement = function ( texture, size, distance, color ) {

  	this.texture = texture;
  	this.size = size || 1;
  	this.distance = distance || 0;
  	this.color = color || new Color( 0xffffff );

  };

  LensflareElement.Shader = {

  	uniforms: {

  		'map': { value: null },
  		'occlusionMap': { value: null },
  		'color': { value: null },
  		'scale': { value: null },
  		'screenPosition': { value: null }

  	},

  	vertexShader: [

  		'precision highp float;',

  		'uniform vec3 screenPosition;',
  		'uniform vec2 scale;',

  		'uniform sampler2D occlusionMap;',

  		'attribute vec3 position;',
  		'attribute vec2 uv;',

  		'varying vec2 vUV;',
  		'varying float vVisibility;',

  		'void main() {',

  		'	vUV = uv;',

  		'	vec2 pos = position.xy;',

  		'	vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
  		'	visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',

  		'	vVisibility =        visibility.r / 9.0;',
  		'	vVisibility *= 1.0 - visibility.g / 9.0;',
  		'	vVisibility *=       visibility.b / 9.0;',

  		'	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',

  		'}'

  	].join( '\n' ),

  	fragmentShader: [

  		'precision highp float;',

  		'uniform sampler2D map;',
  		'uniform vec3 color;',

  		'varying vec2 vUV;',
  		'varying float vVisibility;',

  		'void main() {',

  		'	vec4 texture = texture2D( map, vUV );',
  		'	texture.a *= vVisibility;',
  		'	gl_FragColor = texture;',
  		'	gl_FragColor.rgb *= color;',

  		'}'

  	].join( '\n' )

  };

  Lensflare.Geometry = ( function () {

  	var geometry = new BufferGeometry();

  	var float32Array = new Float32Array( [
  		- 1, - 1, 0, 0, 0,
  		1, - 1, 0, 1, 0,
  		1, 1, 0, 1, 1,
  		- 1, 1, 0, 0, 1
  	] );

  	var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

  	geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
  	geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
  	geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

  	return geometry;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LightningStorm = function ( stormParams ) {
  	var this$1 = this;


  	Object3D.call( this );
  	
  	// Parameters

  	stormParams = stormParams || {};
  	this.stormParams = stormParams;

  	stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;
  	stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;
  	stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;
  	stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;

  	stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;

  	stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;
  	stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;

  	stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;
  	stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;

  	this.lightningParameters = LightningStrike.copyParameters( stormParams.lightningParameters, stormParams.lightningParameters );

  	this.lightningParameters.isEternal = false;
  	
  	this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new MeshBasicMaterial( { color: 0xB0FFFF } );

  	if ( stormParams.onRayPosition !== undefined ) {

  		this.onRayPosition = stormParams.onRayPosition;

  	}
  	else {

  		this.onRayPosition = function( source, dest ) {

  			dest.set( ( Math.random() - 0.5 ) * stormParams.size, 0, ( Math.random() - 0.5 ) * stormParams.size );
  			
  			var height = _Math.lerp( stormParams.minHeight, stormParams.maxHeight, Math.random() );

  			source.set( stormParams.maxSlope * ( 2 * Math.random() - 1 ), 1, stormParams.maxSlope * ( 2 * Math.random() - 1 ) ).multiplyScalar( height ).add( dest );

  		};

  	}

  	this.onLightningDown = stormParams.onLightningDown;

  	// Internal state

  	this.inited = false;
  	this.nextLightningTime = 0;
  	this.lightningsMeshes = [];
  	this.deadLightningsMeshes = [];

  	for ( var i = 0; i < this.stormParams.maxLightnings; i++ ) {

  		var lightning = new LightningStrike( LightningStrike.copyParameters( {}, this$1.lightningParameters ) );
  		var mesh = new Mesh( lightning, this$1.lightningMaterial );
  		this$1.deadLightningsMeshes.push( mesh );

  	}

  };

  LightningStorm.prototype = Object.create( Object3D.prototype );

  LightningStorm.prototype.constructor = LightningStorm;

  LightningStorm.prototype.isLightningStorm = true;

  LightningStorm.prototype.update = function ( time ) {
  	var this$1 = this;


  	if ( ! this.inited ) {

  		this.nextLightningTime = this.getNextLightningTime( time ) * Math.random();
  		this.inited = true;

  	}

  	if ( time >= this.nextLightningTime ) {

  		// Lightning creation

  		var lightningMesh = this.deadLightningsMeshes.pop();

  		if ( lightningMesh ) {

  			var lightningParams1 = LightningStrike.copyParameters( lightningMesh.geometry.rayParameters, this.lightningParameters );

  			lightningParams1.birthTime = time;
  			lightningParams1.deathTime = time + _Math.lerp( this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random() );

  			this.onRayPosition( lightningParams1.sourceOffset, lightningParams1.destOffset );

  			lightningParams1.noiseSeed = Math.random();

  			this.add( lightningMesh );

  			this.lightningsMeshes.push( lightningMesh );

  		}

  		// Schedule next lightning
  		this.nextLightningTime = this.getNextLightningTime( time );

  	}

  	var i = 0; il = this.lightningsMeshes.length;

  	while ( i < il ){

  		var mesh = this$1.lightningsMeshes[ i ];

  		var lightning = mesh.geometry;

  		var prevState = lightning.state;

  		lightning.update( time );

  		if ( prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState ) {

  			if ( this$1.onLightningDown ) {

  				this$1.onLightningDown( lightning );

  			}

  		}

  		if ( lightning.state === LightningStrike.RAY_EXTINGUISHED ) {

  			// Lightning is to be destroyed

  			this$1.lightningsMeshes.splice( this$1.lightningsMeshes.indexOf( mesh ), 1 ); 

  			this$1.deadLightningsMeshes.push( mesh );

  			this$1.remove( mesh );

  			il--;

  		}
  		else {

  			i++;

  		}

  	}

  };

  LightningStorm.prototype.getNextLightningTime = function ( currentTime ) {

  	return currentTime + _Math.lerp( this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random() ) / ( this.stormParams.maxLightnings + 1 );

  };

  LightningStorm.prototype.copy = function ( source ) {
  	
  	Object3D.prototype.copy.call( this, source );

  	this.stormParams.size = source.stormParams.size;
  	this.stormParams.minHeight = source.stormParams.minHeight;
  	this.stormParams.maxHeight = source.stormParams.maxHeight;
  	this.stormParams.maxSlope = source.stormParams.maxSlope;

  	this.stormParams.maxLightnings = source.stormParams.maxLightnings;

  	this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;
  	this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;

  	this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;
  	this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;

  	this.lightningParameters = LightningStrike.copyParameters( {}, source.lightningParameters );

  	this.lightningMaterial = source.stormParams.lightningMaterial;

  	this.onLightningDown = source.onLightningDown;

  	return this;

  };

  LightningStrike.prototype.clone = function () {

  	return new this.constructor( this.stormParams ).copy( this );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Reflector = function ( geometry, options ) {

  	Mesh.call( this, geometry );

  	this.type = 'Reflector';

  	var scope = this;

  	options = options || {};

  	var color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );
  	var textureWidth = options.textureWidth || 512;
  	var textureHeight = options.textureHeight || 512;
  	var clipBias = options.clipBias || 0;
  	var shader = options.shader || Reflector.ReflectorShader;
  	var recursion = options.recursion !== undefined ? options.recursion : 0;

  	//

  	var reflectorPlane = new Plane();
  	var normal = new Vector3();
  	var reflectorWorldPosition = new Vector3();
  	var cameraWorldPosition = new Vector3();
  	var rotationMatrix = new Matrix4();
  	var lookAtPosition = new Vector3( 0, 0, - 1 );
  	var clipPlane = new Vector4();
  	var viewport = new Vector4();

  	var view = new Vector3();
  	var target = new Vector3();
  	var q = new Vector4();
  	var size = new Vector2();

  	var textureMatrix = new Matrix4();
  	var virtualCamera = new PerspectiveCamera();

  	var parameters = {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBFormat,
  		stencilBuffer: false
  	};

  	var renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	if ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {

  		renderTarget.texture.generateMipmaps = false;

  	}

  	var material = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( shader.uniforms ),
  		fragmentShader: shader.fragmentShader,
  		vertexShader: shader.vertexShader
  	} );

  	material.uniforms[ "tDiffuse" ].value = renderTarget.texture;
  	material.uniforms[ "color" ].value = color;
  	material.uniforms[ "textureMatrix" ].value = textureMatrix;

  	this.material = material;

  	this.onBeforeRender = function ( renderer, scene, camera ) {

  		if ( 'recursion' in camera.userData ) {

  			if ( camera.userData.recursion === recursion ) { return; }

  			camera.userData.recursion ++;

  		}

  		reflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
  		cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

  		rotationMatrix.extractRotation( scope.matrixWorld );

  		normal.set( 0, 0, 1 );
  		normal.applyMatrix4( rotationMatrix );

  		view.subVectors( reflectorWorldPosition, cameraWorldPosition );

  		// Avoid rendering when reflector is facing away

  		if ( view.dot( normal ) > 0 ) { return; }

  		view.reflect( normal ).negate();
  		view.add( reflectorWorldPosition );

  		rotationMatrix.extractRotation( camera.matrixWorld );

  		lookAtPosition.set( 0, 0, - 1 );
  		lookAtPosition.applyMatrix4( rotationMatrix );
  		lookAtPosition.add( cameraWorldPosition );

  		target.subVectors( reflectorWorldPosition, lookAtPosition );
  		target.reflect( normal ).negate();
  		target.add( reflectorWorldPosition );

  		virtualCamera.position.copy( view );
  		virtualCamera.up.set( 0, 1, 0 );
  		virtualCamera.up.applyMatrix4( rotationMatrix );
  		virtualCamera.up.reflect( normal );
  		virtualCamera.lookAt( target );

  		virtualCamera.far = camera.far; // Used in WebGLBackground

  		virtualCamera.updateMatrixWorld();
  		virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

  		virtualCamera.userData.recursion = 0;

  		// Update the texture matrix
  		textureMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);
  		textureMatrix.multiply( virtualCamera.projectionMatrix );
  		textureMatrix.multiply( virtualCamera.matrixWorldInverse );
  		textureMatrix.multiply( scope.matrixWorld );

  		// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
  		// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
  		reflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );
  		reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

  		clipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );

  		var projectionMatrix = virtualCamera.projectionMatrix;

  		q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
  		q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
  		q.z = - 1.0;
  		q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

  		// Calculate the scaled plane vector
  		clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );

  		// Replacing the third row of the projection matrix
  		projectionMatrix.elements[ 2 ] = clipPlane.x;
  		projectionMatrix.elements[ 6 ] = clipPlane.y;
  		projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;
  		projectionMatrix.elements[ 14 ] = clipPlane.w;

  		// Render

  		scope.visible = false;

  		var currentRenderTarget = renderer.getRenderTarget();

  		var currentVrEnabled = renderer.vr.enabled;
  		var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;

  		renderer.vr.enabled = false; // Avoid camera modification and recursion
  		renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

  		renderer.setRenderTarget( renderTarget );
  		renderer.clear();
  		renderer.render( scene, virtualCamera );

  		renderer.vr.enabled = currentVrEnabled;
  		renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;

  		renderer.setRenderTarget( currentRenderTarget );

  		// Restore viewport

  		var bounds = camera.bounds;

  		if ( bounds !== undefined ) {

  			renderer.getSize( size );
  			var pixelRatio = renderer.getPixelRatio();

  			viewport.x = bounds.x * size.width * pixelRatio;
  			viewport.y = bounds.y * size.height * pixelRatio;
  			viewport.z = bounds.z * size.width * pixelRatio;
  			viewport.w = bounds.w * size.height * pixelRatio;

  			renderer.state.viewport( viewport );

  		}

  		scope.visible = true;

  	};

  	this.getRenderTarget = function () {

  		return renderTarget;

  	};

  };

  Reflector.prototype = Object.create( Mesh.prototype );
  Reflector.prototype.constructor = Reflector;

  Reflector.ReflectorShader = {

  	uniforms: {

  		'color': {
  			type: 'c',
  			value: null
  		},

  		'tDiffuse': {
  			type: 't',
  			value: null
  		},

  		'textureMatrix': {
  			type: 'm4',
  			value: null
  		}

  	},

  	vertexShader: [
  		'uniform mat4 textureMatrix;',
  		'varying vec4 vUv;',

  		'void main() {',

  		'	vUv = textureMatrix * vec4( position, 1.0 );',

  		'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

  		'}'
  	].join( '\n' ),

  	fragmentShader: [
  		'uniform vec3 color;',
  		'uniform sampler2D tDiffuse;',
  		'varying vec4 vUv;',

  		'float blendOverlay( float base, float blend ) {',

  		'	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',

  		'}',

  		'vec3 blendOverlay( vec3 base, vec3 blend ) {',

  		'	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',

  		'}',

  		'void main() {',

  		'	vec4 base = texture2DProj( tDiffuse, vUv );',
  		'	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',

  		'}'
  	].join( '\n' )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var ReflectorRTT = function ( geometry, options ) {

  	Reflector.call( this, geometry, options );

  	this.geometry.setDrawRange( 0, 0 ); // avoid rendering geometry

  };

  ReflectorRTT.prototype = Object.create( Reflector.prototype );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Refractor = function ( geometry, options ) {

  	Mesh.call( this, geometry );

  	this.type = 'Refractor';

  	var scope = this;

  	options = options || {};

  	var color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );
  	var textureWidth = options.textureWidth || 512;
  	var textureHeight = options.textureHeight || 512;
  	var clipBias = options.clipBias || 0;
  	var shader = options.shader || Refractor.RefractorShader;

  	//

  	var virtualCamera = new PerspectiveCamera();
  	virtualCamera.matrixAutoUpdate = false;
  	virtualCamera.userData.refractor = true;

  	//

  	var refractorPlane = new Plane();
  	var textureMatrix = new Matrix4();

  	// render target

  	var parameters = {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBFormat,
  		stencilBuffer: false
  	};

  	var renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	if ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {

  		renderTarget.texture.generateMipmaps = false;

  	}

  	// material

  	this.material = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( shader.uniforms ),
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: true // ensures, refractors are drawn from farthest to closest
  	} );

  	this.material.uniforms[ "color" ].value = color;
  	this.material.uniforms[ "tDiffuse" ].value = renderTarget.texture;
  	this.material.uniforms[ "textureMatrix" ].value = textureMatrix;

  	// functions

  	var visible = ( function () {

  		var refractorWorldPosition = new Vector3();
  		var cameraWorldPosition = new Vector3();
  		var rotationMatrix = new Matrix4();

  		var view = new Vector3();
  		var normal = new Vector3();

  		return function visible( camera ) {

  			refractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
  			cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

  			view.subVectors( refractorWorldPosition, cameraWorldPosition );

  			rotationMatrix.extractRotation( scope.matrixWorld );

  			normal.set( 0, 0, 1 );
  			normal.applyMatrix4( rotationMatrix );

  			return view.dot( normal ) < 0;

  		};

  	} )();

  	var updateRefractorPlane = ( function () {

  		var normal = new Vector3();
  		var position = new Vector3();
  		var quaternion = new Quaternion();
  		var scale = new Vector3();

  		return function updateRefractorPlane() {

  			scope.matrixWorld.decompose( position, quaternion, scale );
  			normal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();

  			// flip the normal because we want to cull everything above the plane

  			normal.negate();

  			refractorPlane.setFromNormalAndCoplanarPoint( normal, position );

  		};

  	} )();

  	var updateVirtualCamera = ( function () {

  		var clipPlane = new Plane();
  		var clipVector = new Vector4();
  		var q = new Vector4();

  		return function updateVirtualCamera( camera ) {

  			virtualCamera.matrixWorld.copy( camera.matrixWorld );
  			virtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );
  			virtualCamera.projectionMatrix.copy( camera.projectionMatrix );
  			virtualCamera.far = camera.far; // used in WebGLBackground

  			// The following code creates an oblique view frustum for clipping.
  			// see: Lengyel, Eric. Oblique View Frustum Depth Projection and Clipping.
  			// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 516

  			clipPlane.copy( refractorPlane );
  			clipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

  			clipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );

  			// calculate the clip-space corner point opposite the clipping plane and
  			// transform it into camera space by multiplying it by the inverse of the projection matrix

  			var projectionMatrix = virtualCamera.projectionMatrix;

  			q.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
  			q.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
  			q.z = - 1.0;
  			q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

  			// calculate the scaled plane vector

  			clipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );

  			// replacing the third row of the projection matrix

  			projectionMatrix.elements[ 2 ] = clipVector.x;
  			projectionMatrix.elements[ 6 ] = clipVector.y;
  			projectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;
  			projectionMatrix.elements[ 14 ] = clipVector.w;

  		};

  	} )();

  	// This will update the texture matrix that is used for projective texture mapping in the shader.
  	// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf

  	function updateTextureMatrix( camera ) {

  		// this matrix does range mapping to [ 0, 1 ]

  		textureMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		// we use "Object Linear Texgen", so we need to multiply the texture matrix T
  		// (matrix above) with the projection and view matrix of the virtual camera
  		// and the model matrix of the refractor

  		textureMatrix.multiply( camera.projectionMatrix );
  		textureMatrix.multiply( camera.matrixWorldInverse );
  		textureMatrix.multiply( scope.matrixWorld );

  	}

  	//

  	var render = ( function () {

  		var viewport = new Vector4();
  		var size = new Vector2();

  		return function render( renderer, scene, camera ) {

  			scope.visible = false;

  			var currentRenderTarget = renderer.getRenderTarget();
  			var currentVrEnabled = renderer.vr.enabled;
  			var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;

  			renderer.vr.enabled = false; // avoid camera modification
  			renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows

  			renderer.setRenderTarget( renderTarget );
  			renderer.clear();
  			renderer.render( scene, virtualCamera );

  			renderer.vr.enabled = currentVrEnabled;
  			renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
  			renderer.setRenderTarget( currentRenderTarget );

  			// restore viewport

  			var bounds = camera.bounds;

  			if ( bounds !== undefined ) {

  				renderer.getSize( size );
  				var pixelRatio = renderer.getPixelRatio();

  				viewport.x = bounds.x * size.width * pixelRatio;
  				viewport.y = bounds.y * size.height * pixelRatio;
  				viewport.z = bounds.z * size.width * pixelRatio;
  				viewport.w = bounds.w * size.height * pixelRatio;

  				renderer.state.viewport( viewport );

  			}

  			scope.visible = true;

  		};

  	} )();

  	//

  	this.onBeforeRender = function ( renderer, scene, camera ) {

  		// ensure refractors are rendered only once per frame

  		if ( camera.userData.refractor === true ) { return; }

  		// avoid rendering when the refractor is viewed from behind

  		if ( ! visible( camera ) === true ) { return; }

  		// update

  		updateRefractorPlane();

  		updateTextureMatrix( camera );

  		updateVirtualCamera( camera );

  		render( renderer, scene, camera );

  	};

  	this.getRenderTarget = function () {

  		return renderTarget;

  	};

  };

  Refractor.prototype = Object.create( Mesh.prototype );
  Refractor.prototype.constructor = Refractor;

  Refractor.RefractorShader = {

  	uniforms: {

  		'color': {
  			type: 'c',
  			value: null
  		},

  		'tDiffuse': {
  			type: 't',
  			value: null
  		},

  		'textureMatrix': {
  			type: 'm4',
  			value: null
  		}

  	},

  	vertexShader: [

  		'uniform mat4 textureMatrix;',

  		'varying vec4 vUv;',

  		'void main() {',

  		'	vUv = textureMatrix * vec4( position, 1.0 );',

  		'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

  		'}'

  	].join( '\n' ),

  	fragmentShader: [

  		'uniform vec3 color;',
  		'uniform sampler2D tDiffuse;',

  		'varying vec4 vUv;',

  		'float blendOverlay( float base, float blend ) {',

  		'	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',

  		'}',

  		'vec3 blendOverlay( vec3 base, vec3 blend ) {',

  		'	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',

  		'}',

  		'void main() {',

  		'	vec4 base = texture2DProj( tDiffuse, vUv );',

  		'	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',

  		'}'

  	].join( '\n' )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShadowMesh = function ( mesh ) {

  	var shadowMaterial = new MeshBasicMaterial( {

  		color: 0x000000,
  		transparent: true,
  		opacity: 0.6,
  		depthWrite: false

  	} );

  	Mesh.call( this, mesh.geometry, shadowMaterial );

  	this.meshMatrix = mesh.matrixWorld;

  	this.frustumCulled = false;
  	this.matrixAutoUpdate = false;

  };

  ShadowMesh.prototype = Object.create( Mesh.prototype );
  ShadowMesh.prototype.constructor = ShadowMesh;

  ShadowMesh.prototype.update = function () {

  	var shadowMatrix = new Matrix4();

  	return function ( plane, lightPosition4D ) {

  		// based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm

  		var dot = plane.normal.x * lightPosition4D.x +
  			  plane.normal.y * lightPosition4D.y +
  			  plane.normal.z * lightPosition4D.z +
  			  - plane.constant * lightPosition4D.w;

  		var sme = shadowMatrix.elements;

  		sme[ 0 ]  = dot - lightPosition4D.x * plane.normal.x;
  		sme[ 4 ]  = - lightPosition4D.x * plane.normal.y;
  		sme[ 8 ]  = - lightPosition4D.x * plane.normal.z;
  		sme[ 12 ] = - lightPosition4D.x * - plane.constant;

  		sme[ 1 ]  = - lightPosition4D.y * plane.normal.x;
  		sme[ 5 ]  = dot - lightPosition4D.y * plane.normal.y;
  		sme[ 9 ]  = - lightPosition4D.y * plane.normal.z;
  		sme[ 13 ] = - lightPosition4D.y * - plane.constant;

  		sme[ 2 ]  = - lightPosition4D.z * plane.normal.x;
  		sme[ 6 ]  = - lightPosition4D.z * plane.normal.y;
  		sme[ 10 ] = dot - lightPosition4D.z * plane.normal.z;
  		sme[ 14 ] = - lightPosition4D.z * - plane.constant;

  		sme[ 3 ]  = - lightPosition4D.w * plane.normal.x;
  		sme[ 7 ]  = - lightPosition4D.w * plane.normal.y;
  		sme[ 11 ] = - lightPosition4D.w * plane.normal.z;
  		sme[ 15 ] = dot - lightPosition4D.w * - plane.constant;

  		this.matrix.multiplyMatrices( shadowMatrix, this.meshMatrix );

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Sky = function () {

  	var shader = Sky.SkyShader;

  	var material = new ShaderMaterial( {
  		fragmentShader: shader.fragmentShader,
  		vertexShader: shader.vertexShader,
  		uniforms: UniformsUtils.clone( shader.uniforms ),
  		side: BackSide
  	} );

  	Mesh.call( this, new BoxBufferGeometry( 1, 1, 1 ), material );

  };

  Sky.prototype = Object.create( Mesh.prototype );

  Sky.SkyShader = {

  	uniforms: {
  		"luminance": { value: 1 },
  		"turbidity": { value: 2 },
  		"rayleigh": { value: 1 },
  		"mieCoefficient": { value: 0.005 },
  		"mieDirectionalG": { value: 0.8 },
  		"sunPosition": { value: new Vector3() }
  	},

  	vertexShader: [
  		'uniform vec3 sunPosition;',
  		'uniform float rayleigh;',
  		'uniform float turbidity;',
  		'uniform float mieCoefficient;',

  		'varying vec3 vWorldPosition;',
  		'varying vec3 vSunDirection;',
  		'varying float vSunfade;',
  		'varying vec3 vBetaR;',
  		'varying vec3 vBetaM;',
  		'varying float vSunE;',

  		'const vec3 up = vec3( 0.0, 1.0, 0.0 );',

  		// constants for atmospheric scattering
  		'const float e = 2.71828182845904523536028747135266249775724709369995957;',
  		'const float pi = 3.141592653589793238462643383279502884197169;',

  		// wavelength of used primaries, according to preetham
  		'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',
  		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
  		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
  		'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',

  		// mie stuff
  		// K coefficient for the primaries
  		'const float v = 4.0;',
  		'const vec3 K = vec3( 0.686, 0.678, 0.666 );',
  		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
  		'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',

  		// earth shadow hack
  		// cutoffAngle = pi / 1.95;
  		'const float cutoffAngle = 1.6110731556870734;',
  		'const float steepness = 1.5;',
  		'const float EE = 1000.0;',

  		'float sunIntensity( float zenithAngleCos ) {',
  		'	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );',
  		'	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );',
  		'}',

  		'vec3 totalMie( float T ) {',
  		'	float c = ( 0.2 * T ) * 10E-18;',
  		'	return 0.434 * c * MieConst;',
  		'}',

  		'void main() {',

  		'	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
  		'	vWorldPosition = worldPosition.xyz;',

  		'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
  		'	gl_Position.z = gl_Position.w;', // set z to camera.far

  		'	vSunDirection = normalize( sunPosition );',

  		'	vSunE = sunIntensity( dot( vSunDirection, up ) );',

  		'	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );',

  		'	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',

  		// extinction (absorbtion + out scattering)
  		// rayleigh coefficients
  		'	vBetaR = totalRayleigh * rayleighCoefficient;',

  		// mie coefficients
  		'	vBetaM = totalMie( turbidity ) * mieCoefficient;',

  		'}'
  	].join( '\n' ),

  	fragmentShader: [
  		'varying vec3 vWorldPosition;',
  		'varying vec3 vSunDirection;',
  		'varying float vSunfade;',
  		'varying vec3 vBetaR;',
  		'varying vec3 vBetaM;',
  		'varying float vSunE;',

  		'uniform float luminance;',
  		'uniform float mieDirectionalG;',

  		'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',

  		// constants for atmospheric scattering
  		'const float pi = 3.141592653589793238462643383279502884197169;',

  		'const float n = 1.0003;', // refractive index of air
  		'const float N = 2.545E25;', // number of molecules per unit volume for air at
  									// 288.15K and 1013mb (sea level -45 celsius)

  		// optical length at zenith for molecules
  		'const float rayleighZenithLength = 8.4E3;',
  		'const float mieZenithLength = 1.25E3;',
  		'const vec3 up = vec3( 0.0, 1.0, 0.0 );',
  		// 66 arc seconds -> degrees, and the cosine of that
  		'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',

  		// 3.0 / ( 16.0 * pi )
  		'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',
  		// 1.0 / ( 4.0 * pi )
  		'const float ONE_OVER_FOURPI = 0.07957747154594767;',

  		'float rayleighPhase( float cosTheta ) {',
  		'	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );',
  		'}',

  		'float hgPhase( float cosTheta, float g ) {',
  		'	float g2 = pow( g, 2.0 );',
  		'	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );',
  		'	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );',
  		'}',

  		// Filmic ToneMapping http://filmicgames.com/archives/75
  		'const float A = 0.15;',
  		'const float B = 0.50;',
  		'const float C = 0.10;',
  		'const float D = 0.20;',
  		'const float E = 0.02;',
  		'const float F = 0.30;',

  		'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)

  		'vec3 Uncharted2Tonemap( vec3 x ) {',
  		'	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;',
  		'}',
  		'void main() {',
  		// optical length
  		// cutoff angle at 90 to avoid singularity in next formula.
  		'	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );',
  		'	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );',
  		'	float sR = rayleighZenithLength * inverse;',
  		'	float sM = mieZenithLength * inverse;',

  		// combined extinction factor
  		'	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',

  		// in scattering
  		'	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );',

  		'	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );',
  		'	vec3 betaRTheta = vBetaR * rPhase;',

  		'	float mPhase = hgPhase( cosTheta, mieDirectionalG );',
  		'	vec3 betaMTheta = vBetaM * mPhase;',

  		'	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );',
  		'	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );',

  		// nightsky
  		'	vec3 direction = normalize( vWorldPosition - cameraPos );',
  		'	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]',
  		'	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]',
  		'	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );',
  		'	vec3 L0 = vec3( 0.1 ) * Fex;',

  		// composition + solar disc
  		'	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',
  		'	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;',

  		'	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',

  		'	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );',
  		'	vec3 color = curr * whiteScale;',

  		'	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );',

  		'	gl_FragColor = vec4( retColor, 1.0 );',

  		'}'
  	].join( '\n' )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Water = function ( geometry, options ) {

  	Mesh.call( this, geometry );

  	var scope = this;

  	options = options || {};

  	var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;
  	var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;

  	var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;
  	var alpha = options.alpha !== undefined ? options.alpha : 1.0;
  	var time = options.time !== undefined ? options.time : 0.0;
  	var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;
  	var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );
  	var sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );
  	var waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );
  	var eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );
  	var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;
  	var side = options.side !== undefined ? options.side : FrontSide;
  	var fog = options.fog !== undefined ? options.fog : false;

  	//

  	var mirrorPlane = new Plane();
  	var normal = new Vector3();
  	var mirrorWorldPosition = new Vector3();
  	var cameraWorldPosition = new Vector3();
  	var rotationMatrix = new Matrix4();
  	var lookAtPosition = new Vector3( 0, 0, - 1 );
  	var clipPlane = new Vector4();

  	var view = new Vector3();
  	var target = new Vector3();
  	var q = new Vector4();

  	var textureMatrix = new Matrix4();

  	var mirrorCamera = new PerspectiveCamera();

  	var parameters = {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBFormat,
  		stencilBuffer: false
  	};

  	var renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );

  	if ( ! _Math.isPowerOfTwo( textureWidth ) || ! _Math.isPowerOfTwo( textureHeight ) ) {

  		renderTarget.texture.generateMipmaps = false;

  	}

  	var mirrorShader = {

  		uniforms: UniformsUtils.merge( [
  			UniformsLib[ 'fog' ],
  			UniformsLib[ 'lights' ],
  			{
  				"normalSampler": { value: null },
  				"mirrorSampler": { value: null },
  				"alpha": { value: 1.0 },
  				"time": { value: 0.0 },
  				"size": { value: 1.0 },
  				"distortionScale": { value: 20.0 },
  				"textureMatrix": { value: new Matrix4() },
  				"sunColor": { value: new Color( 0x7F7F7F ) },
  				"sunDirection": { value: new Vector3( 0.70707, 0.70707, 0 ) },
  				"eye": { value: new Vector3() },
  				"waterColor": { value: new Color( 0x555555 ) }
  			}
  		] ),

  		vertexShader: [
  			'uniform mat4 textureMatrix;',
  			'uniform float time;',

  			'varying vec4 mirrorCoord;',
  			'varying vec4 worldPosition;',

  			ShaderChunk[ 'fog_pars_vertex' ],
  			ShaderChunk[ 'shadowmap_pars_vertex' ],

  			'void main() {',
  			'	mirrorCoord = modelMatrix * vec4( position, 1.0 );',
  			'	worldPosition = mirrorCoord.xyzw;',
  			'	mirrorCoord = textureMatrix * mirrorCoord;',
  			'	vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );',
  			'	gl_Position = projectionMatrix * mvPosition;',

  			ShaderChunk[ 'fog_vertex' ],
  			ShaderChunk[ 'shadowmap_vertex' ],

  			'}'
  		].join( '\n' ),

  		fragmentShader: [
  			'uniform sampler2D mirrorSampler;',
  			'uniform float alpha;',
  			'uniform float time;',
  			'uniform float size;',
  			'uniform float distortionScale;',
  			'uniform sampler2D normalSampler;',
  			'uniform vec3 sunColor;',
  			'uniform vec3 sunDirection;',
  			'uniform vec3 eye;',
  			'uniform vec3 waterColor;',

  			'varying vec4 mirrorCoord;',
  			'varying vec4 worldPosition;',

  			'vec4 getNoise( vec2 uv ) {',
  			'	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',
  			'	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',
  			'	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',
  			'	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',
  			'	vec4 noise = texture2D( normalSampler, uv0 ) +',
  			'		texture2D( normalSampler, uv1 ) +',
  			'		texture2D( normalSampler, uv2 ) +',
  			'		texture2D( normalSampler, uv3 );',
  			'	return noise * 0.5 - 1.0;',
  			'}',

  			'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {',
  			'	vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',
  			'	float direction = max( 0.0, dot( eyeDirection, reflection ) );',
  			'	specularColor += pow( direction, shiny ) * sunColor * spec;',
  			'	diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',
  			'}',

  			ShaderChunk[ 'common' ],
  			ShaderChunk[ 'packing' ],
  			ShaderChunk[ 'bsdfs' ],
  			ShaderChunk[ 'fog_pars_fragment' ],
  			ShaderChunk[ 'lights_pars_begin' ],
  			ShaderChunk[ 'shadowmap_pars_fragment' ],
  			ShaderChunk[ 'shadowmask_pars_fragment' ],

  			'void main() {',
  			'	vec4 noise = getNoise( worldPosition.xz * size );',
  			'	vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',

  			'	vec3 diffuseLight = vec3(0.0);',
  			'	vec3 specularLight = vec3(0.0);',

  			'	vec3 worldToEye = eye-worldPosition.xyz;',
  			'	vec3 eyeDirection = normalize( worldToEye );',
  			'	sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',

  			'	float distance = length(worldToEye);',

  			'	vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',
  			'	vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );',

  			'	float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',
  			'	float rf0 = 0.3;',
  			'	float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',
  			'	vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',
  			'	vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);',
  			'	vec3 outgoingLight = albedo;',
  			'	gl_FragColor = vec4( outgoingLight, alpha );',

  			ShaderChunk[ 'tonemapping_fragment' ],
  			ShaderChunk[ 'fog_fragment' ],

  			'}'
  		].join( '\n' )

  	};

  	var material = new ShaderMaterial( {
  		fragmentShader: mirrorShader.fragmentShader,
  		vertexShader: mirrorShader.vertexShader,
  		uniforms: UniformsUtils.clone( mirrorShader.uniforms ),
  		transparent: true,
  		lights: true,
  		side: side,
  		fog: fog
  	} );

  	material.uniforms[ "mirrorSampler" ].value = renderTarget.texture;
  	material.uniforms[ "textureMatrix" ].value = textureMatrix;
  	material.uniforms[ "alpha" ].value = alpha;
  	material.uniforms[ "time" ].value = time;
  	material.uniforms[ "normalSampler" ].value = normalSampler;
  	material.uniforms[ "sunColor" ].value = sunColor;
  	material.uniforms[ "waterColor" ].value = waterColor;
  	material.uniforms[ "sunDirection" ].value = sunDirection;
  	material.uniforms[ "distortionScale" ].value = distortionScale;

  	material.uniforms[ "eye" ].value = eye;

  	scope.material = material;

  	scope.onBeforeRender = function ( renderer, scene, camera ) {

  		mirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );
  		cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

  		rotationMatrix.extractRotation( scope.matrixWorld );

  		normal.set( 0, 0, 1 );
  		normal.applyMatrix4( rotationMatrix );

  		view.subVectors( mirrorWorldPosition, cameraWorldPosition );

  		// Avoid rendering when mirror is facing away

  		if ( view.dot( normal ) > 0 ) { return; }

  		view.reflect( normal ).negate();
  		view.add( mirrorWorldPosition );

  		rotationMatrix.extractRotation( camera.matrixWorld );

  		lookAtPosition.set( 0, 0, - 1 );
  		lookAtPosition.applyMatrix4( rotationMatrix );
  		lookAtPosition.add( cameraWorldPosition );

  		target.subVectors( mirrorWorldPosition, lookAtPosition );
  		target.reflect( normal ).negate();
  		target.add( mirrorWorldPosition );

  		mirrorCamera.position.copy( view );
  		mirrorCamera.up.set( 0, 1, 0 );
  		mirrorCamera.up.applyMatrix4( rotationMatrix );
  		mirrorCamera.up.reflect( normal );
  		mirrorCamera.lookAt( target );

  		mirrorCamera.far = camera.far; // Used in WebGLBackground

  		mirrorCamera.updateMatrixWorld();
  		mirrorCamera.projectionMatrix.copy( camera.projectionMatrix );

  		// Update the texture matrix
  		textureMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);
  		textureMatrix.multiply( mirrorCamera.projectionMatrix );
  		textureMatrix.multiply( mirrorCamera.matrixWorldInverse );

  		// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
  		// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
  		mirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );
  		mirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );

  		clipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );

  		var projectionMatrix = mirrorCamera.projectionMatrix;

  		q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
  		q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
  		q.z = - 1.0;
  		q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

  		// Calculate the scaled plane vector
  		clipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );

  		// Replacing the third row of the projection matrix
  		projectionMatrix.elements[ 2 ] = clipPlane.x;
  		projectionMatrix.elements[ 6 ] = clipPlane.y;
  		projectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;
  		projectionMatrix.elements[ 14 ] = clipPlane.w;

  		eye.setFromMatrixPosition( camera.matrixWorld );

  		//

  		var currentRenderTarget = renderer.getRenderTarget();

  		var currentVrEnabled = renderer.vr.enabled;
  		var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;

  		scope.visible = false;

  		renderer.vr.enabled = false; // Avoid camera modification and recursion
  		renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

  		renderer.setRenderTarget( renderTarget );
  		renderer.clear();
  		renderer.render( scene, mirrorCamera );

  		scope.visible = true;

  		renderer.vr.enabled = currentVrEnabled;
  		renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;

  		renderer.setRenderTarget( currentRenderTarget );

  	};

  };

  Water.prototype = Object.create( Mesh.prototype );
  Water.prototype.constructor = Water;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Water2( geometry, options ) {

  	Mesh.call( this, geometry );

  	this.type = 'Water2';

  	var scope = this;

  	options = options || {};

  	var color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );
  	var textureWidth = options.textureWidth || 512;
  	var textureHeight = options.textureHeight || 512;
  	var clipBias = options.clipBias || 0;
  	var flowDirection = options.flowDirection || new Vector2( 1, 0 );
  	var flowSpeed = options.flowSpeed || 0.03;
  	var reflectivity = options.reflectivity || 0.02;
  	var scale = options.scale || 1;
  	var shader = options.shader || Water2.Water2Shader;

  	var textureLoader = new TextureLoader();

  	var flowMap = options.flowMap || undefined;
  	var normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water2_1_M_Normal.jpg' );
  	var normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water2_2_M_Normal.jpg' );

  	var cycle = 0.15; // a cycle of a flow map phase
  	var halfCycle = cycle * 0.5;
  	var textureMatrix = new Matrix4();
  	var clock = new Clock();

  	// internal components

  	if ( Reflector === undefined ) {

  		console.error( 'Water2: Required component Reflector not found.' );
  		return;

  	}

  	if ( Refractor === undefined ) {

  		console.error( 'Water2: Required component Refractor not found.' );
  		return;

  	}

  	var reflector = new Reflector( geometry, {
  		textureWidth: textureWidth,
  		textureHeight: textureHeight,
  		clipBias: clipBias
  	} );

  	var refractor = new Refractor( geometry, {
  		textureWidth: textureWidth,
  		textureHeight: textureHeight,
  		clipBias: clipBias
  	} );

  	reflector.matrixAutoUpdate = false;
  	refractor.matrixAutoUpdate = false;

  	// material

  	this.material = new ShaderMaterial( {
  		uniforms: UniformsUtils.merge( [
  			UniformsLib[ 'fog' ],
  			shader.uniforms
  		] ),
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		transparent: true,
  		fog: true
  	} );

  	if ( flowMap !== undefined ) {

  		this.material.defines.USE_FLOWMAP = '';
  		this.material.uniforms[ "tFlowMap" ] = {
  			type: 't',
  			value: flowMap
  		};

  	} else {

  		this.material.uniforms[ "flowDirection" ] = {
  			type: 'v2',
  			value: flowDirection
  		};

  	}

  	// maps

  	normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
  	normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;

  	this.material.uniforms[ "tReflectionMap" ].value = reflector.getRenderTarget().texture;
  	this.material.uniforms[ "tRefractionMap" ].value = refractor.getRenderTarget().texture;
  	this.material.uniforms[ "tNormalMap0" ].value = normalMap0;
  	this.material.uniforms[ "tNormalMap1" ].value = normalMap1;

  	// water

  	this.material.uniforms[ "color" ].value = color;
  	this.material.uniforms[ "reflectivity" ].value = reflectivity;
  	this.material.uniforms[ "textureMatrix" ].value = textureMatrix;

  	// inital values

  	this.material.uniforms[ "config" ].value.x = 0; // flowMapOffset0
  	this.material.uniforms[ "config" ].value.y = halfCycle; // flowMapOffset1
  	this.material.uniforms[ "config" ].value.z = halfCycle; // halfCycle
  	this.material.uniforms[ "config" ].value.w = scale; // scale

  	// functions

  	function updateTextureMatrix( camera ) {

  		textureMatrix.set(
  			0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0
  		);

  		textureMatrix.multiply( camera.projectionMatrix );
  		textureMatrix.multiply( camera.matrixWorldInverse );
  		textureMatrix.multiply( scope.matrixWorld );

  	}

  	function updateFlow() {

  		var delta = clock.getDelta();
  		var config = scope.material.uniforms[ "config" ];

  		config.value.x += flowSpeed * delta; // flowMapOffset0
  		config.value.y = config.value.x + halfCycle; // flowMapOffset1

  		// Important: The distance between offsets should be always the value of "halfCycle".
  		// Moreover, both offsets should be in the range of [ 0, cycle ].
  		// This approach ensures a smooth water flow and avoids "reset" effects.

  		if ( config.value.x >= cycle ) {

  			config.value.x = 0;
  			config.value.y = halfCycle;

  		} else if ( config.value.y >= cycle ) {

  			config.value.y = config.value.y - cycle;

  		}

  	}

  	//

  	this.onBeforeRender = function ( renderer, scene, camera ) {

  		updateTextureMatrix( camera );
  		updateFlow();

  		scope.visible = false;

  		reflector.matrixWorld.copy( scope.matrixWorld );
  		refractor.matrixWorld.copy( scope.matrixWorld );

  		reflector.onBeforeRender( renderer, scene, camera );
  		refractor.onBeforeRender( renderer, scene, camera );

  		scope.visible = true;

  	};

  }
  Water2.prototype = Object.create( Mesh.prototype );
  Water2.prototype.constructor = Water2;

  Water2.Water2Shader = {

  	uniforms: {

  		'color': {
  			type: 'c',
  			value: null
  		},

  		'reflectivity': {
  			type: 'f',
  			value: 0
  		},

  		'tReflectionMap': {
  			type: 't',
  			value: null
  		},

  		'tRefractionMap': {
  			type: 't',
  			value: null
  		},

  		'tNormalMap0': {
  			type: 't',
  			value: null
  		},

  		'tNormalMap1': {
  			type: 't',
  			value: null
  		},

  		'textureMatrix': {
  			type: 'm4',
  			value: null
  		},

  		'config': {
  			type: 'v4',
  			value: new Vector4()
  		}

  	},

  	vertexShader: [

  		'#include <fog_pars_vertex>',

  		'uniform mat4 textureMatrix;',

  		'varying vec4 vCoord;',
  		'varying vec2 vUv;',
  		'varying vec3 vToEye;',

  		'void main() {',

  		'	vUv = uv;',
  		'	vCoord = textureMatrix * vec4( position, 1.0 );',

  		'	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
  		'	vToEye = cameraPosition - worldPosition.xyz;',

  		'	vec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex
  		'	gl_Position = projectionMatrix * mvPosition;',

  		'	#include <fog_vertex>',

  		'}'

  	].join( '\n' ),

  	fragmentShader: [

  		'#include <common>',
  		'#include <fog_pars_fragment>',

  		'uniform sampler2D tReflectionMap;',
  		'uniform sampler2D tRefractionMap;',
  		'uniform sampler2D tNormalMap0;',
  		'uniform sampler2D tNormalMap1;',

  		'#ifdef USE_FLOWMAP',
  		'	uniform sampler2D tFlowMap;',
  		'#else',
  		'	uniform vec2 flowDirection;',
  		'#endif',

  		'uniform vec3 color;',
  		'uniform float reflectivity;',
  		'uniform vec4 config;',

  		'varying vec4 vCoord;',
  		'varying vec2 vUv;',
  		'varying vec3 vToEye;',

  		'void main() {',

  		'	float flowMapOffset0 = config.x;',
  		'	float flowMapOffset1 = config.y;',
  		'	float halfCycle = config.z;',
  		'	float scale = config.w;',

  		'	vec3 toEye = normalize( vToEye );',

  		// determine flow direction
  		'	vec2 flow;',
  		'	#ifdef USE_FLOWMAP',
  		'		flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',
  		'	#else',
  		'		flow = flowDirection;',
  		'	#endif',
  		'	flow.x *= - 1.0;',

  		// sample normal maps (distort uvs with flowdata)
  		'	vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',
  		'	vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',

  		// linear interpolate to get the final normal color
  		'	float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',
  		'	vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',

  		// calculate normal vector
  		'	vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',

  		// calculate the fresnel term to blend reflection and refraction maps
  		'	float theta = max( dot( toEye, normal ), 0.0 );',
  		'	float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',

  		// calculate final uv coords
  		'	vec3 coord = vCoord.xyz / vCoord.w;',
  		'	vec2 uv = coord.xy + coord.z * normal.xz * 0.05;',

  		'	vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',
  		'	vec4 refractColor = texture2D( tRefractionMap, uv );',

  		// multiply water color with the mix of both textures
  		'	gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',

  		'	#include <tonemapping_fragment>',
  		'	#include <encodings_fragment>',
  		'	#include <fog_fragment>',

  		'}'

  	].join( '\n' )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var Ocean = function ( renderer, camera, scene, options ) {

  	// flag used to trigger parameter changes
  	this.changed = true;
  	this.initial = true;

  	// Assign required parameters as object properties
  	this.oceanCamera = new OrthographicCamera(); //camera.clone();
  	this.oceanCamera.position.z = 1;
  	this.renderer = renderer;
  	this.renderer.clearColor( 0xffffff );

  	this.scene = new Scene();

  	// Assign optional parameters as variables and object properties
  	function optionalParameter( value, defaultValue ) {

  		return value !== undefined ? value : defaultValue;

  	}
  	options = options || {};
  	this.clearColor = optionalParameter( options.CLEAR_COLOR, [ 1.0, 1.0, 1.0, 0.0 ] );
  	this.geometryOrigin = optionalParameter( options.GEOMETRY_ORIGIN, [ - 1000.0, - 1000.0 ] );
  	this.sunDirectionX = optionalParameter( options.SUN_DIRECTION[ 0 ], - 1.0 );
  	this.sunDirectionY = optionalParameter( options.SUN_DIRECTION[ 1 ], 1.0 );
  	this.sunDirectionZ = optionalParameter( options.SUN_DIRECTION[ 2 ], 1.0 );
  	this.oceanColor = optionalParameter( options.OCEAN_COLOR, new Vector3( 0.004, 0.016, 0.047 ) );
  	this.skyColor = optionalParameter( options.SKY_COLOR, new Vector3( 3.2, 9.6, 12.8 ) );
  	this.exposure = optionalParameter( options.EXPOSURE, 0.35 );
  	this.geometryResolution = optionalParameter( options.GEOMETRY_RESOLUTION, 32 );
  	this.geometrySize = optionalParameter( options.GEOMETRY_SIZE, 2000 );
  	this.resolution = optionalParameter( options.RESOLUTION, 64 );
  	this.floatSize = optionalParameter( options.SIZE_OF_FLOAT, 4 );
  	this.windX = optionalParameter( options.INITIAL_WIND[ 0 ], 10.0 );
  	this.windY = optionalParameter( options.INITIAL_WIND[ 1 ], 10.0 );
  	this.size = optionalParameter( options.INITIAL_SIZE, 250.0 );
  	this.choppiness = optionalParameter( options.INITIAL_CHOPPINESS, 1.5 );

  	//
  	this.matrixNeedsUpdate = false;

  	// Setup framebuffer pipeline
  	var renderTargetType = optionalParameter( options.USE_HALF_FLOAT, false ) ? HalfFloatType : FloatType;
  	var LinearClampParams = {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		wrapS: ClampToEdgeWrapping,
  		wrapT: ClampToEdgeWrapping,
  		format: RGBAFormat,
  		stencilBuffer: false,
  		depthBuffer: false,
  		premultiplyAlpha: false,
  		type: renderTargetType
  	};
  	var NearestClampParams = {
  		minFilter: NearestFilter,
  		magFilter: NearestFilter,
  		wrapS: ClampToEdgeWrapping,
  		wrapT: ClampToEdgeWrapping,
  		format: RGBAFormat,
  		stencilBuffer: false,
  		depthBuffer: false,
  		premultiplyAlpha: false,
  		type: renderTargetType
  	};
  	var NearestRepeatParams = {
  		minFilter: NearestFilter,
  		magFilter: NearestFilter,
  		wrapS: RepeatWrapping,
  		wrapT: RepeatWrapping,
  		format: RGBAFormat,
  		stencilBuffer: false,
  		depthBuffer: false,
  		premultiplyAlpha: false,
  		type: renderTargetType
  	};
  	this.initialSpectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestRepeatParams );
  	this.spectrumFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
  	this.pingPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
  	this.pongPhaseFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
  	this.pingTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
  	this.pongTransformFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );
  	this.displacementMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );
  	this.normalMapFramebuffer = new WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );

  	// Define shaders and constant uniforms
  	////////////////////////////////////////

  	// 0 - The vertex shader used in all of the simulation steps
  	var fullscreeenVertexShader = ShaderLib[ "ocean_sim_vertex" ];

  	// 1 - Horizontal wave vertices used for FFT
  	var oceanHorizontalShader = ShaderLib[ "ocean_subtransform" ];
  	var oceanHorizontalUniforms = UniformsUtils.clone( oceanHorizontalShader.uniforms );
  	this.materialOceanHorizontal = new ShaderMaterial( {
  		uniforms: oceanHorizontalUniforms,
  		vertexShader: fullscreeenVertexShader.vertexShader,
  		fragmentShader: "#define HORIZONTAL \n" + oceanHorizontalShader.fragmentShader
  	} );
  	this.materialOceanHorizontal.uniforms.u_transformSize = { value: this.resolution };
  	this.materialOceanHorizontal.uniforms.u_subtransformSize = { value: null };
  	this.materialOceanHorizontal.uniforms.u_input = { value: null };
  	this.materialOceanHorizontal.depthTest = false;

  	// 2 - Vertical wave vertices used for FFT
  	var oceanVerticalShader = ShaderLib[ "ocean_subtransform" ];
  	var oceanVerticalUniforms = UniformsUtils.clone( oceanVerticalShader.uniforms );
  	this.materialOceanVertical = new ShaderMaterial( {
  		uniforms: oceanVerticalUniforms,
  		vertexShader: fullscreeenVertexShader.vertexShader,
  		fragmentShader: oceanVerticalShader.fragmentShader
  	} );
  	this.materialOceanVertical.uniforms.u_transformSize = { value: this.resolution };
  	this.materialOceanVertical.uniforms.u_subtransformSize = { value: null };
  	this.materialOceanVertical.uniforms.u_input = { value: null };
  	this.materialOceanVertical.depthTest = false;

  	// 3 - Initial spectrum used to generate height map
  	var initialSpectrumShader = ShaderLib[ "ocean_initial_spectrum" ];
  	var initialSpectrumUniforms = UniformsUtils.clone( initialSpectrumShader.uniforms );
  	this.materialInitialSpectrum = new ShaderMaterial( {
  		uniforms: initialSpectrumUniforms,
  		vertexShader: initialSpectrumShader.vertexShader,
  		fragmentShader: initialSpectrumShader.fragmentShader
  	} );
  	this.materialInitialSpectrum.uniforms.u_wind = { value: new Vector2() };
  	this.materialInitialSpectrum.uniforms.u_resolution = { value: this.resolution };
  	this.materialInitialSpectrum.depthTest = false;

  	// 4 - Phases used to animate heightmap
  	var phaseShader = ShaderLib[ "ocean_phase" ];
  	var phaseUniforms = UniformsUtils.clone( phaseShader.uniforms );
  	this.materialPhase = new ShaderMaterial( {
  		uniforms: phaseUniforms,
  		vertexShader: fullscreeenVertexShader.vertexShader,
  		fragmentShader: phaseShader.fragmentShader
  	} );
  	this.materialPhase.uniforms.u_resolution = { value: this.resolution };
  	this.materialPhase.depthTest = false;

  	// 5 - Shader used to update spectrum
  	var spectrumShader = ShaderLib[ "ocean_spectrum" ];
  	var spectrumUniforms = UniformsUtils.clone( spectrumShader.uniforms );
  	this.materialSpectrum = new ShaderMaterial( {
  		uniforms: spectrumUniforms,
  		vertexShader: fullscreeenVertexShader.vertexShader,
  		fragmentShader: spectrumShader.fragmentShader
  	} );
  	this.materialSpectrum.uniforms.u_initialSpectrum = { value: null };
  	this.materialSpectrum.uniforms.u_resolution = { value: this.resolution };
  	this.materialSpectrum.depthTest = false;

  	// 6 - Shader used to update spectrum normals
  	var normalShader = ShaderLib[ "ocean_normals" ];
  	var normalUniforms = UniformsUtils.clone( normalShader.uniforms );
  	this.materialNormal = new ShaderMaterial( {
  		uniforms: normalUniforms,
  		vertexShader: fullscreeenVertexShader.vertexShader,
  		fragmentShader: normalShader.fragmentShader
  	} );
  	this.materialNormal.uniforms.u_displacementMap = { value: null };
  	this.materialNormal.uniforms.u_resolution = { value: this.resolution };
  	this.materialNormal.depthTest = false;

  	// 7 - Shader used to update normals
  	var oceanShader = ShaderLib[ "ocean_main" ];
  	var oceanUniforms = UniformsUtils.clone( oceanShader.uniforms );
  	this.materialOcean = new ShaderMaterial( {
  		uniforms: oceanUniforms,
  		vertexShader: oceanShader.vertexShader,
  		fragmentShader: oceanShader.fragmentShader
  	} );
  	// this.materialOcean.wireframe = true;
  	this.materialOcean.uniforms.u_geometrySize = { value: this.resolution };
  	this.materialOcean.uniforms.u_displacementMap = { value: this.displacementMapFramebuffer.texture };
  	this.materialOcean.uniforms.u_normalMap = { value: this.normalMapFramebuffer.texture };
  	this.materialOcean.uniforms.u_oceanColor = { value: this.oceanColor };
  	this.materialOcean.uniforms.u_skyColor = { value: this.skyColor };
  	this.materialOcean.uniforms.u_sunDirection = { value: new Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };
  	this.materialOcean.uniforms.u_exposure = { value: this.exposure };

  	// Disable blending to prevent default premultiplied alpha values
  	this.materialOceanHorizontal.blending = 0;
  	this.materialOceanVertical.blending = 0;
  	this.materialInitialSpectrum.blending = 0;
  	this.materialPhase.blending = 0;
  	this.materialSpectrum.blending = 0;
  	this.materialNormal.blending = 0;
  	this.materialOcean.blending = 0;

  	// Create the simulation plane
  	this.screenQuad = new Mesh( new PlaneBufferGeometry( 2, 2 ) );
  	this.scene.add( this.screenQuad );

  	// Initialise spectrum data
  	this.generateSeedPhaseTexture();

  	// Generate the ocean mesh
  	this.generateMesh();

  };

  Ocean.prototype.generateMesh = function () {

  	var geometry = new PlaneBufferGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );

  	geometry.rotateX( - Math.PI / 2 );

  	this.oceanMesh = new Mesh( geometry, this.materialOcean );

  };

  Ocean.prototype.render = function () {

  	var currentRenderTarget = this.renderer.getRenderTarget();

  	this.scene.overrideMaterial = null;

  	if ( this.changed )
  		{ this.renderInitialSpectrum(); }

  	this.renderWavePhase();
  	this.renderSpectrum();
  	this.renderSpectrumFFT();
  	this.renderNormalMap();
  	this.scene.overrideMaterial = null;

  	this.renderer.setRenderTarget( currentRenderTarget );

  };

  Ocean.prototype.generateSeedPhaseTexture = function () {
  	var this$1 = this;


  	// Setup the seed texture
  	this.pingPhase = true;
  	var phaseArray = new window.Float32Array( this.resolution * this.resolution * 4 );
  	for ( var i = 0; i < this.resolution; i ++ ) {

  		for ( var j = 0; j < this.resolution; j ++ ) {

  			phaseArray[ i * this$1.resolution * 4 + j * 4 ] = Math.random() * 2.0 * Math.PI;
  			phaseArray[ i * this$1.resolution * 4 + j * 4 + 1 ] = 0.0;
  			phaseArray[ i * this$1.resolution * 4 + j * 4 + 2 ] = 0.0;
  			phaseArray[ i * this$1.resolution * 4 + j * 4 + 3 ] = 0.0;

  		}

  	}

  	this.pingPhaseTexture = new DataTexture( phaseArray, this.resolution, this.resolution, RGBAFormat );
  	this.pingPhaseTexture.wrapS = ClampToEdgeWrapping;
  	this.pingPhaseTexture.wrapT = ClampToEdgeWrapping;
  	this.pingPhaseTexture.type = FloatType;
  	this.pingPhaseTexture.needsUpdate = true;

  };

  Ocean.prototype.renderInitialSpectrum = function () {

  	this.scene.overrideMaterial = this.materialInitialSpectrum;
  	this.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );
  	this.materialInitialSpectrum.uniforms.u_size.value = this.size;

  	this.renderer.setRenderTarget( this.initialSpectrumFramebuffer );
  	this.renderer.clear();
  	this.renderer.render( this.scene, this.oceanCamera );

  };

  Ocean.prototype.renderWavePhase = function () {

  	this.scene.overrideMaterial = this.materialPhase;
  	this.screenQuad.material = this.materialPhase;
  	if ( this.initial ) {

  		this.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;
  		this.initial = false;

  	} else {

  		this.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;

  	}
  	this.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;
  	this.materialPhase.uniforms.u_size.value = this.size;
  	this.renderer.setRenderTarget( this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer );
  	this.renderer.render( this.scene, this.oceanCamera );
  	this.pingPhase = ! this.pingPhase;

  };

  Ocean.prototype.renderSpectrum = function () {

  	this.scene.overrideMaterial = this.materialSpectrum;
  	this.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer.texture;
  	this.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;
  	this.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;
  	this.materialSpectrum.uniforms.u_size.value = this.size;

  	this.renderer.setRenderTarget( this.spectrumFramebuffer );
  	this.renderer.render( this.scene, this.oceanCamera );

  };

  Ocean.prototype.renderSpectrumFFT = function () {
  	var this$1 = this;


  	// GPU FFT using Stockham formulation
  	var iterations = Math.log( this.resolution ) / Math.log( 2 ); // log2

  	this.scene.overrideMaterial = this.materialOceanHorizontal;

  	for ( var i = 0; i < iterations; i ++ ) {

  		if ( i === 0 ) {

  			this$1.materialOceanHorizontal.uniforms.u_input.value = this$1.spectrumFramebuffer.texture;
  			this$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.pingTransformFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		} else if ( i % 2 === 1 ) {

  			this$1.materialOceanHorizontal.uniforms.u_input.value = this$1.pingTransformFramebuffer.texture;
  			this$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.pongTransformFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		} else {

  			this$1.materialOceanHorizontal.uniforms.u_input.value = this$1.pongTransformFramebuffer.texture;
  			this$1.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.pingTransformFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		}

  	}
  	this.scene.overrideMaterial = this.materialOceanVertical;
  	for ( var i = iterations; i < iterations * 2; i ++ ) {

  		if ( i === iterations * 2 - 1 ) {

  			this$1.materialOceanVertical.uniforms.u_input.value = ( iterations % 2 === 0 ) ? this$1.pingTransformFramebuffer.texture : this$1.pongTransformFramebuffer.texture;
  			this$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.displacementMapFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		} else if ( i % 2 === 1 ) {

  			this$1.materialOceanVertical.uniforms.u_input.value = this$1.pingTransformFramebuffer.texture;
  			this$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.pongTransformFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		} else {

  			this$1.materialOceanVertical.uniforms.u_input.value = this$1.pongTransformFramebuffer.texture;
  			this$1.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

  			this$1.renderer.setRenderTarget( this$1.pingTransformFramebuffer );
  			this$1.renderer.render( this$1.scene, this$1.oceanCamera );

  		}

  	}

  };

  Ocean.prototype.renderNormalMap = function () {

  	this.scene.overrideMaterial = this.materialNormal;
  	if ( this.changed ) { this.materialNormal.uniforms.u_size.value = this.size; }
  	this.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer.texture;

  	this.renderer.setRenderTarget( this.normalMapFramebuffer );
  	this.renderer.clear();
  	this.renderer.render( this.scene, this.oceanCamera );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PMREMCubeUVPacker = ( function () {

  	var camera = new OrthographicCamera();
  	var scene = new Scene();
  	var shader = getShader();

  	var PMREMCubeUVPacker = function ( cubeTextureLods ) {
  		var this$1 = this;


  		this.cubeLods = cubeTextureLods;
  		var size = cubeTextureLods[ 0 ].width * 4;

  		var sourceTexture = cubeTextureLods[ 0 ].texture;
  		var params = {
  			format: sourceTexture.format,
  			magFilter: sourceTexture.magFilter,
  			minFilter: sourceTexture.minFilter,
  			type: sourceTexture.type,
  			generateMipmaps: sourceTexture.generateMipmaps,
  			anisotropy: sourceTexture.anisotropy,
  			encoding: ( sourceTexture.encoding === RGBEEncoding ) ? RGBM16Encoding : sourceTexture.encoding
  		};

  		if ( params.encoding === RGBM16Encoding ) {

  			params.magFilter = LinearFilter;
  			params.minFilter = LinearFilter;

  		}

  		this.CubeUVRenderTarget = new WebGLRenderTarget( size, size, params );
  		this.CubeUVRenderTarget.texture.name = "PMREMCubeUVPacker.cubeUv";
  		this.CubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;

  		this.objects = [];

  		var geometry = new PlaneBufferGeometry( 1, 1 );

  		var faceOffsets = [];
  		faceOffsets.push( new Vector2( 0, 0 ) );
  		faceOffsets.push( new Vector2( 1, 0 ) );
  		faceOffsets.push( new Vector2( 2, 0 ) );
  		faceOffsets.push( new Vector2( 0, 1 ) );
  		faceOffsets.push( new Vector2( 1, 1 ) );
  		faceOffsets.push( new Vector2( 2, 1 ) );

  		var textureResolution = size;
  		size = cubeTextureLods[ 0 ].width;

  		var offset2 = 0;
  		var c = 4.0;
  		this.numLods = Math.log( cubeTextureLods[ 0 ].width ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2
  		for ( var i = 0; i < this.numLods; i ++ ) {

  			var offset1 = ( textureResolution - textureResolution / c ) * 0.5;
  			if ( size > 16 ) { c *= 2; }
  			var nMips = size > 16 ? 6 : 1;
  			var mipOffsetX = 0;
  			var mipOffsetY = 0;
  			var mipSize = size;

  			for ( var j = 0; j < nMips; j ++ ) {

  				// Mip Maps
  				for ( var k = 0; k < 6; k ++ ) {

  					// 6 Cube Faces
  					var material = shader.clone();
  					material.uniforms[ 'envMap' ].value = this$1.cubeLods[ i ].texture;
  					material.envMap = this$1.cubeLods[ i ].texture;
  					material.uniforms[ 'faceIndex' ].value = k;
  					material.uniforms[ 'mapSize' ].value = mipSize;

  					var planeMesh = new Mesh( geometry, material );
  					planeMesh.position.x = faceOffsets[ k ].x * mipSize - offset1 + mipOffsetX;
  					planeMesh.position.y = faceOffsets[ k ].y * mipSize - offset1 + offset2 + mipOffsetY;
  					planeMesh.material.side = BackSide;
  					planeMesh.scale.setScalar( mipSize );
  					this$1.objects.push( planeMesh );

  				}
  				mipOffsetY += 1.75 * mipSize;
  				mipOffsetX += 1.25 * mipSize;
  				mipSize /= 2;

  			}
  			offset2 += 2 * size;
  			if ( size > 16 ) { size /= 2; }

  		}

  	};

  	PMREMCubeUVPacker.prototype = {

  		constructor: PMREMCubeUVPacker,

  		update: function ( renderer ) {
  			var this$1 = this;


  			var size = this.cubeLods[ 0 ].width * 4;
  			// top and bottom are swapped for some reason?
  			camera.left = - size * 0.5;
  			camera.right = size * 0.5;
  			camera.top = - size * 0.5;
  			camera.bottom = size * 0.5;
  			camera.near = 0;
  			camera.far = 1;
  			camera.updateProjectionMatrix();

  			for ( var i = 0; i < this.objects.length; i ++ ) {

  				scene.add( this$1.objects[ i ] );

  			}

  			var gammaInput = renderer.gammaInput;
  			var gammaOutput = renderer.gammaOutput;
  			var toneMapping = renderer.toneMapping;
  			var toneMappingExposure = renderer.toneMappingExposure;
  			var currentRenderTarget = renderer.getRenderTarget();

  			renderer.gammaInput = false;
  			renderer.gammaOutput = false;
  			renderer.toneMapping = LinearToneMapping;
  			renderer.toneMappingExposure = 1.0;
  			renderer.setRenderTarget( this.CubeUVRenderTarget );
  			renderer.render( scene, camera );

  			renderer.setRenderTarget( currentRenderTarget );
  			renderer.toneMapping = toneMapping;
  			renderer.toneMappingExposure = toneMappingExposure;
  			renderer.gammaInput = gammaInput;
  			renderer.gammaOutput = gammaOutput;

  			for ( var i = 0; i < this.objects.length; i ++ ) {

  				scene.remove( this$1.objects[ i ] );

  			}

  		},

  		dispose: function () {
  			var this$1 = this;


  			for ( var i = 0, l = this.objects.length; i < l; i ++ ) {

  				this$1.objects[ i ].material.dispose();

  			}

  			this.objects[ 0 ].geometry.dispose();

  		}

  	};

  	function getShader() {

  		var shaderMaterial = new ShaderMaterial( {

  			uniforms: {
  				"faceIndex": { value: 0 },
  				"mapSize": { value: 0 },
  				"envMap": { value: null },
  				"testColor": { value: new Vector3( 1, 1, 1 ) }
  			},

  			vertexShader:
          "precision highp float;\
        varying vec2 vUv;\
        void main() {\
          vUv = uv;\
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\
        }",

  			fragmentShader:
          "precision highp float;\
        varying vec2 vUv;\
        uniform samplerCube envMap;\
        uniform float mapSize;\
        uniform vec3 testColor;\
        uniform int faceIndex;\
        \
        void main() {\
          vec3 sampleDirection;\
          vec2 uv = vUv;\
          uv = uv * 2.0 - 1.0;\
          uv.y *= -1.0;\
          if(faceIndex == 0) {\
            sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\
          } else if(faceIndex == 1) {\
            sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\
          } else if(faceIndex == 2) {\
            sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\
          } else if(faceIndex == 3) {\
            sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\
          } else if(faceIndex == 4) {\
            sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\
          } else {\
            sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\
          }\
          vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\
          gl_FragColor = linearToOutputTexel( color );\
        }",

  			blending: NoBlending

  		} );

  		shaderMaterial.type = 'PMREMCubeUVPacker';

  		return shaderMaterial;

  	}
  	return PMREMCubeUVPacker;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PMREMGenerator = ( function () {

  	var shader = getShader();
  	var camera = new OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );
  	var scene = new Scene();
  	var planeMesh = new Mesh( new PlaneBufferGeometry( 2, 2, 0 ), shader );
  	planeMesh.material.side = DoubleSide;
  	scene.add( planeMesh );
  	scene.add( camera );

  	var PMREMGenerator = function ( sourceTexture, samplesPerLevel, resolution ) {
  		var this$1 = this;


  		this.sourceTexture = sourceTexture;
  		this.resolution = ( resolution !== undefined ) ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons
  		this.samplesPerLevel = ( samplesPerLevel !== undefined ) ? samplesPerLevel : 32;

  		var monotonicEncoding = ( this.sourceTexture.encoding === LinearEncoding ) ||
  			( this.sourceTexture.encoding === GammaEncoding ) || ( this.sourceTexture.encoding === sRGBEncoding );

  		this.sourceTexture.minFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;
  		this.sourceTexture.magFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;
  		this.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;

  		this.cubeLods = [];

  		var size = this.resolution;
  		var params = {
  			format: this.sourceTexture.format,
  			magFilter: this.sourceTexture.magFilter,
  			minFilter: this.sourceTexture.minFilter,
  			type: this.sourceTexture.type,
  			generateMipmaps: this.sourceTexture.generateMipmaps,
  			anisotropy: this.sourceTexture.anisotropy,
  			encoding: this.sourceTexture.encoding
  		};

  		// how many LODs fit in the given CubeUV Texture.
  		this.numLods = Math.log( size ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2

  		for ( var i = 0; i < this.numLods; i ++ ) {

  			var renderTarget = new WebGLRenderTargetCube( size, size, params );
  			renderTarget.texture.name = "PMREMGenerator.cube" + i;
  			this$1.cubeLods.push( renderTarget );
  			size = Math.max( 16, size / 2 );

  		}

  	};

  	PMREMGenerator.prototype = {

  		constructor: PMREMGenerator,
  		update: function ( renderer ) {
  			var this$1 = this;


  			// Texture should only be flipped for CubeTexture, not for
  			// a Texture created via WebGLRenderTargetCube.
  			var tFlip = ( this.sourceTexture.isCubeTexture ) ? - 1 : 1;

  			shader.defines[ 'SAMPLES_PER_LEVEL' ] = this.samplesPerLevel;
  			shader.uniforms[ 'faceIndex' ].value = 0;
  			shader.uniforms[ 'envMap' ].value = this.sourceTexture;
  			shader.envMap = this.sourceTexture;
  			shader.needsUpdate = true;

  			var gammaInput = renderer.gammaInput;
  			var gammaOutput = renderer.gammaOutput;
  			var toneMapping = renderer.toneMapping;
  			var toneMappingExposure = renderer.toneMappingExposure;
  			var currentRenderTarget = renderer.getRenderTarget();

  			renderer.toneMapping = LinearToneMapping;
  			renderer.toneMappingExposure = 1.0;
  			renderer.gammaInput = false;
  			renderer.gammaOutput = false;

  			for ( var i = 0; i < this.numLods; i ++ ) {

  				var r = i / ( this$1.numLods - 1 );
  				shader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice
  				// Only apply the tFlip for the first LOD
  				shader.uniforms[ 'tFlip' ].value = ( i == 0 ) ? tFlip : 1;
  				var size = this$1.cubeLods[ i ].width;
  				shader.uniforms[ 'mapSize' ].value = size;
  				this$1.renderToCubeMapTarget( renderer, this$1.cubeLods[ i ] );

  				if ( i < 5 ) { shader.uniforms[ 'envMap' ].value = this$1.cubeLods[ i ].texture; }

  			}

  			renderer.setRenderTarget( currentRenderTarget );
  			renderer.toneMapping = toneMapping;
  			renderer.toneMappingExposure = toneMappingExposure;
  			renderer.gammaInput = gammaInput;
  			renderer.gammaOutput = gammaOutput;

  		},

  		renderToCubeMapTarget: function ( renderer, renderTarget ) {
  			var this$1 = this;


  			for ( var i = 0; i < 6; i ++ ) {

  				this$1.renderToCubeMapTargetFace( renderer, renderTarget, i );

  			}

  		},

  		renderToCubeMapTargetFace: function ( renderer, renderTarget, faceIndex ) {

  			shader.uniforms[ 'faceIndex' ].value = faceIndex;
  			renderer.setRenderTarget( renderTarget, faceIndex );
  			renderer.clear();
  			renderer.render( scene, camera );

  		},

  		dispose: function () {
  			var this$1 = this;


  			for ( var i = 0, l = this.cubeLods.length; i < l; i ++ ) {

  				this$1.cubeLods[ i ].dispose();

  			}

  		},

  	};

  	function getShader() {

  		var shaderMaterial = new ShaderMaterial( {

  			defines: {
  				"SAMPLES_PER_LEVEL": 20,
  			},

  			uniforms: {
  				"faceIndex": { value: 0 },
  				"roughness": { value: 0.5 },
  				"mapSize": { value: 0.5 },
  				"envMap": { value: null },
  				"tFlip": { value: - 1 },
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"#include <common>\n\
				varying vec2 vUv;\n\
				uniform int faceIndex;\n\
				uniform float roughness;\n\
				uniform samplerCube envMap;\n\
				uniform float mapSize;\n\
				uniform float tFlip;\n\
				\n\
				float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\
					float a = ggxRoughness + 0.0001;\n\
					a *= a;\n\
					return ( 2.0 / a - 2.0 );\n\
				}\n\
				vec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\n\
					float phi = uv.y * 2.0 * PI;\n\
					float cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\
					float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\
					vec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\
					return vecSpace * sampleDir;\n\
				}\n\
				vec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n\
				{\n\
					float a = Roughness * Roughness;\n\
					float Phi = 2.0 * PI * uv.x;\n\
					float CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n\
					float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\
					return vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n\
				}\n\
				mat3 matrixFromVector(vec3 n) {\n\
					float a = 1.0 / (1.0 + n.z);\n\
					float b = -n.x * n.y * a;\n\
					vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\
					vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\
					return mat3(b1, b2, n);\n\
				}\n\
				\n\
				vec4 testColorMap(float Roughness) {\n\
					vec4 color;\n\
					if(faceIndex == 0)\n\
						color = vec4(1.0,0.0,0.0,1.0);\n\
					else if(faceIndex == 1)\n\
						color = vec4(0.0,1.0,0.0,1.0);\n\
					else if(faceIndex == 2)\n\
						color = vec4(0.0,0.0,1.0,1.0);\n\
					else if(faceIndex == 3)\n\
						color = vec4(1.0,1.0,0.0,1.0);\n\
					else if(faceIndex == 4)\n\
						color = vec4(0.0,1.0,1.0,1.0);\n\
					else\n\
						color = vec4(1.0,0.0,1.0,1.0);\n\
					color *= ( 1.0 - Roughness );\n\
					return color;\n\
				}\n\
				void main() {\n\
					vec3 sampleDirection;\n\
					vec2 uv = vUv*2.0 - 1.0;\n\
					float offset = -1.0/mapSize;\n\
					const float a = -1.0;\n\
					const float b = 1.0;\n\
					float c = -1.0 + offset;\n\
					float d = 1.0 - offset;\n\
					float bminusa = b - a;\n\
					uv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\
					uv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\
					if (faceIndex==0) {\n\
						sampleDirection = vec3(1.0, -uv.y, -uv.x);\n\
					} else if (faceIndex==1) {\n\
						sampleDirection = vec3(-1.0, -uv.y, uv.x);\n\
					} else if (faceIndex==2) {\n\
						sampleDirection = vec3(uv.x, 1.0, uv.y);\n\
					} else if (faceIndex==3) {\n\
						sampleDirection = vec3(uv.x, -1.0, -uv.y);\n\
					} else if (faceIndex==4) {\n\
						sampleDirection = vec3(uv.x, -uv.y, 1.0);\n\
					} else {\n\
						sampleDirection = vec3(-uv.x, -uv.y, -1.0);\n\
					}\n\
					vec3 correctedDirection = vec3( tFlip * sampleDirection.x, sampleDirection.yz );\n\
					mat3 vecSpace = matrixFromVector( normalize( correctedDirection ) );\n\
					vec3 rgbColor = vec3(0.0);\n\
					const int NumSamples = SAMPLES_PER_LEVEL;\n\
					vec3 vect;\n\
					float weight = 0.0;\n\
					for( int i = 0; i < NumSamples; i ++ ) {\n\
						float sini = sin(float(i));\n\
						float cosi = cos(float(i));\n\
						float r = rand(vec2(sini, cosi));\n\
						vect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\n\
						float dotProd = dot(vect, normalize(sampleDirection));\n\
						weight += dotProd;\n\
						vec3 color = envMapTexelToLinear(textureCube(envMap, vect)).rgb;\n\
						rgbColor.rgb += color;\n\
					}\n\
					rgbColor /= float(NumSamples);\n\
					//rgbColor = testColorMap( roughness ).rgb;\n\
					gl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\
				}",

  			blending: NoBlending

  		} );

  		shaderMaterial.type = 'PMREMGenerator';

  		return shaderMaterial;

  	}

  	return PMREMGenerator;

  } )();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CopyShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"opacity":  { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float opacity;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 texel = texture2D( tDiffuse, vUv );",
  			"gl_FragColor = opacity * texel;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LuminosityShader = {

  	uniforms: {

  		"tDiffuse": { value: null }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#include <common>",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 texel = texture2D( tDiffuse, vUv );",

  			"float l = linearToRelativeLuminance( texel.rgb );",

  			"gl_FragColor = vec4( l, l, l, texel.w );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ToneMapShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"averageLuminance":  { value: 1.0 },
  		"luminanceMap":  { value: null },
  		"maxLuminance":  { value: 16.0 },
  		"minLuminance":  { value: 0.01 },
  		"middleGrey":  { value: 0.6 }
  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#include <common>",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"uniform float middleGrey;",
  		"uniform float minLuminance;",
  		"uniform float maxLuminance;",
  		"#ifdef ADAPTED_LUMINANCE",
  			"uniform sampler2D luminanceMap;",
  		"#else",
  			"uniform float averageLuminance;",
  		"#endif",

  		"vec3 ToneMap( vec3 vColor ) {",
  			"#ifdef ADAPTED_LUMINANCE",
  				// Get the calculated average luminance
  				"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
  			"#else",
  				"float fLumAvg = averageLuminance;",
  			"#endif",

  			// Calculate the luminance of the current pixel
  			"float fLumPixel = linearToRelativeLuminance( vColor );",

  			// Apply the modified operator (Eq. 4)
  			"float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );",

  			"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
  			"return fLumCompressed * vColor;",
  		"}",

  		"void main() {",

  			"vec4 texel = texture2D( tDiffuse, vUv );",

  			"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AdaptiveToneMappingPass = function ( adaptive, resolution ) {

  	Pass.call( this );

  	this.resolution = ( resolution !== undefined ) ? resolution : 256;
  	this.needsInit = true;
  	this.adaptive = adaptive !== undefined ? !! adaptive : true;

  	this.luminanceRT = null;
  	this.previousLuminanceRT = null;
  	this.currentLuminanceRT = null;

  	if ( CopyShader === undefined )
  		{ console.error( "AdaptiveToneMappingPass relies on CopyShader" ); }

  	var copyShader = CopyShader;

  	this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );

  	this.materialCopy = new ShaderMaterial( {

  		uniforms: this.copyUniforms,
  		vertexShader: copyShader.vertexShader,
  		fragmentShader: copyShader.fragmentShader,
  		blending: NoBlending,
  		depthTest: false

  	} );

  	if ( LuminosityShader === undefined )
  		{ console.error( "AdaptiveToneMappingPass relies on LuminosityShader" ); }

  	this.materialLuminance = new ShaderMaterial( {

  		uniforms: UniformsUtils.clone( LuminosityShader.uniforms ),
  		vertexShader: LuminosityShader.vertexShader,
  		fragmentShader: LuminosityShader.fragmentShader,
  		blending: NoBlending
  	} );

  	this.adaptLuminanceShader = {
  		defines: {
  			"MIP_LEVEL_1X1": ( Math.log( this.resolution ) / Math.log( 2.0 ) ).toFixed( 1 )
  		},
  		uniforms: {
  			"lastLum": { value: null },
  			"currentLum": { value: null },
  			"minLuminance": { value: 0.01 },
  			"delta": { value: 0.016 },
  			"tau": { value: 1.0 }
  		},
  		vertexShader: [
  			"varying vec2 vUv;",

  			"void main() {",

  			"	vUv = uv;",
  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"
  		].join( '\n' ),
  		fragmentShader: [
  			"varying vec2 vUv;",

  			"uniform sampler2D lastLum;",
  			"uniform sampler2D currentLum;",
  			"uniform float minLuminance;",
  			"uniform float delta;",
  			"uniform float tau;",

  			"void main() {",

  			"	vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
  			"	vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",

  			"	float fLastLum = max( minLuminance, lastLum.r );",
  			"	float fCurrentLum = max( minLuminance, currentLum.r );",

  			//The adaption seems to work better in extreme lighting differences
  			//if the input luminance is squared.
  			"	fCurrentLum *= fCurrentLum;",

  			// Adapt the luminance using Pattanaik's technique
  			"	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
  			// "fAdaptedLum = sqrt(fAdaptedLum);",
  			"	gl_FragColor.r = fAdaptedLum;",
  			"}"
  		].join( '\n' )
  	};

  	this.materialAdaptiveLum = new ShaderMaterial( {

  		uniforms: UniformsUtils.clone( this.adaptLuminanceShader.uniforms ),
  		vertexShader: this.adaptLuminanceShader.vertexShader,
  		fragmentShader: this.adaptLuminanceShader.fragmentShader,
  		defines: Object.assign( {}, this.adaptLuminanceShader.defines ),
  		blending: NoBlending
  	} );

  	if ( ToneMapShader === undefined )
  		{ console.error( "AdaptiveToneMappingPass relies on ToneMapShader" ); }

  	this.materialToneMap = new ShaderMaterial( {

  		uniforms: UniformsUtils.clone( ToneMapShader.uniforms ),
  		vertexShader: ToneMapShader.vertexShader,
  		fragmentShader: ToneMapShader.fragmentShader,
  		blending: NoBlending
  	} );

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  AdaptiveToneMappingPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: AdaptiveToneMappingPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		if ( this.needsInit ) {

  			this.reset( renderer );

  			this.luminanceRT.texture.type = readBuffer.texture.type;
  			this.previousLuminanceRT.texture.type = readBuffer.texture.type;
  			this.currentLuminanceRT.texture.type = readBuffer.texture.type;
  			this.needsInit = false;

  		}

  		if ( this.adaptive ) {

  			//Render the luminance of the current scene into a render target with mipmapping enabled
  			this.quad.material = this.materialLuminance;
  			this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
  			renderer.setRenderTarget( this.currentLuminanceRT );
  			renderer.render( this.scene, this.camera );

  			//Use the new luminance values, the previous luminance and the frame delta to
  			//adapt the luminance over time.
  			this.quad.material = this.materialAdaptiveLum;
  			this.materialAdaptiveLum.uniforms.delta.value = deltaTime;
  			this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
  			this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
  			renderer.setRenderTarget( this.luminanceRT );
  			renderer.render( this.scene, this.camera );

  			//Copy the new adapted luminance value so that it can be used by the next frame.
  			this.quad.material = this.materialCopy;
  			this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
  			renderer.setRenderTarget( this.previousLuminanceRT );
  			renderer.render( this.scene, this.camera );

  		}

  		this.quad.material = this.materialToneMap;
  		this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );

  			if ( this.clear ) { renderer.clear(); }

  			renderer.render( this.scene, this.camera );

  		}

  	},

  	reset: function ( renderer ) {

  		// render targets
  		if ( this.luminanceRT ) {

  			this.luminanceRT.dispose();

  		}
  		if ( this.currentLuminanceRT ) {

  			this.currentLuminanceRT.dispose();

  		}
  		if ( this.previousLuminanceRT ) {

  			this.previousLuminanceRT.dispose();

  		}

  		var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450

  		this.luminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );
  		this.luminanceRT.texture.name = "AdaptiveToneMappingPass.l";
  		this.luminanceRT.texture.generateMipmaps = false;

  		this.previousLuminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );
  		this.previousLuminanceRT.texture.name = "AdaptiveToneMappingPass.pl";
  		this.previousLuminanceRT.texture.generateMipmaps = false;

  		// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader
  		pars.minFilter = LinearMipMapLinearFilter;
  		pars.generateMipmaps = true;
  		this.currentLuminanceRT = new WebGLRenderTarget( this.resolution, this.resolution, pars );
  		this.currentLuminanceRT.texture.name = "AdaptiveToneMappingPass.cl";

  		if ( this.adaptive ) {

  			this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ] = "";
  			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;

  		}
  		//Put something in the adaptive luminance texture so that the scene can render initially
  		this.quad.material = new MeshBasicMaterial( { color: 0x777777 } );
  		this.materialLuminance.needsUpdate = true;
  		this.materialAdaptiveLum.needsUpdate = true;
  		this.materialToneMap.needsUpdate = true;
  		// renderer.render( this.scene, this.camera, this.luminanceRT );
  		// renderer.render( this.scene, this.camera, this.previousLuminanceRT );
  		// renderer.render( this.scene, this.camera, this.currentLuminanceRT );

  	},

  	setAdaptive: function ( adaptive ) {

  		if ( adaptive ) {

  			this.adaptive = true;
  			this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ] = "";
  			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;

  		} else {

  			this.adaptive = false;
  			delete this.materialToneMap.defines[ "ADAPTED_LUMINANCE" ];
  			this.materialToneMap.uniforms.luminanceMap.value = null;

  		}
  		this.materialToneMap.needsUpdate = true;

  	},

  	setAdaptionRate: function ( rate ) {

  		if ( rate ) {

  			this.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );

  		}

  	},

  	setMinLuminance: function ( minLum ) {

  		if ( minLum ) {

  			this.materialToneMap.uniforms.minLuminance.value = minLum;
  			this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;

  		}

  	},

  	setMaxLuminance: function ( maxLum ) {

  		if ( maxLum ) {

  			this.materialToneMap.uniforms.maxLuminance.value = maxLum;

  		}

  	},

  	setAverageLuminance: function ( avgLum ) {

  		if ( avgLum ) {

  			this.materialToneMap.uniforms.averageLuminance.value = avgLum;

  		}

  	},

  	setMiddleGrey: function ( middleGrey ) {

  		if ( middleGrey ) {

  			this.materialToneMap.uniforms.middleGrey.value = middleGrey;

  		}

  	},

  	dispose: function () {

  		if ( this.luminanceRT ) {

  			this.luminanceRT.dispose();

  		}
  		if ( this.previousLuminanceRT ) {

  			this.previousLuminanceRT.dispose();

  		}
  		if ( this.currentLuminanceRT ) {

  			this.currentLuminanceRT.dispose();

  		}
  		if ( this.materialLuminance ) {

  			this.materialLuminance.dispose();

  		}
  		if ( this.materialAdaptiveLum ) {

  			this.materialAdaptiveLum.dispose();

  		}
  		if ( this.materialCopy ) {

  			this.materialCopy.dispose();

  		}
  		if ( this.materialToneMap ) {

  			this.materialToneMap.dispose();

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AfterimageShader = {

  	uniforms: {

  		"damp": { value: 0.96 },
  		"tOld": { value: null },
  		"tNew": { value: null }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float damp;",

  		"uniform sampler2D tOld;",
  		"uniform sampler2D tNew;",

  		"varying vec2 vUv;",
  		
  		"vec4 when_gt( vec4 x, float y ) {",

  			"return max( sign( x - y ), 0.0 );",

  		"}",

  		"void main() {",

  			"vec4 texelOld = texture2D( tOld, vUv );",
  			"vec4 texelNew = texture2D( tNew, vUv );",
  			
  			"texelOld *= damp * when_gt( texelOld, 0.1 );",

  			"gl_FragColor = max(texelNew, texelOld);",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var AfterimagePass = function ( damp ) {

  	Pass.call( this );

  	if ( AfterimageShader === undefined )
  		{ console.error( "AfterimagePass relies on AfterimageShader" ); }

  	this.shader = AfterimageShader;

  	this.uniforms = UniformsUtils.clone( this.shader.uniforms );

  	this.uniforms[ "damp" ].value = damp !== undefined ? damp : 0.96;

  	this.textureComp = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {

  		minFilter: LinearFilter,
  		magFilter: NearestFilter,
  		format: RGBAFormat

  	} );

  	this.textureOld = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {

  		minFilter: LinearFilter,
  		magFilter: NearestFilter,
  		format: RGBAFormat

  	} );

  	this.shaderMaterial = new ShaderMaterial( {

  		uniforms: this.uniforms,
  		vertexShader: this.shader.vertexShader,
  		fragmentShader: this.shader.fragmentShader

  	} );

  	this.sceneComp = new Scene();
  	this.scene = new Scene();

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.camera.position.z = 1;

  	var geometry = new PlaneBufferGeometry( 2, 2 );

  	this.quadComp = new Mesh( geometry, this.shaderMaterial );
  	this.sceneComp.add( this.quadComp );

  	var material = new MeshBasicMaterial( {
  		map: this.textureComp.texture
  	} );

  	var quadScreen = new Mesh( geometry, material );
  	this.scene.add( quadScreen );

  };

  AfterimagePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: AfterimagePass,

  	render: function ( renderer, writeBuffer, readBuffer ) {

  		this.uniforms[ "tOld" ].value = this.textureOld.texture;
  		this.uniforms[ "tNew" ].value = readBuffer.texture;

  		this.quadComp.material = this.shaderMaterial;

  		renderer.setRenderTarget( this.textureComp );
  		renderer.render( this.sceneComp, this.camera );

  		renderer.setRenderTarget( this.textureOld );
  		renderer.render( this.scene, this.camera );

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );

  			if ( this.clear ) { renderer.clear(); }

  			renderer.render( this.scene, this.camera );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ConvolutionShader = {

  	defines: {

  		"KERNEL_SIZE_FLOAT": "25.0",
  		"KERNEL_SIZE_INT": "25"

  	},

  	uniforms: {

  		"tDiffuse":        { value: null },
  		"uImageIncrement": { value: new Vector2( 0.001953125, 0.0 ) },
  		"cKernel":         { value: [] }

  	},

  	vertexShader: [

  		"uniform vec2 uImageIncrement;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float cKernel[ KERNEL_SIZE_INT ];",

  		"uniform sampler2D tDiffuse;",
  		"uniform vec2 uImageIncrement;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec2 imageCoord = vUv;",
  			"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",

  			"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",

  				"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
  				"imageCoord += uImageIncrement;",

  			"}",

  			"gl_FragColor = sum;",

  		"}"
  	].join( "\n" ),

  	buildKernel: function ( sigma ) {

  		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

  		function gauss( x, sigma ) {

  			return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );

  		}

  		var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;

  		if ( kernelSize > kMaxKernelSize ) { kernelSize = kMaxKernelSize; }
  		halfWidth = ( kernelSize - 1 ) * 0.5;

  		values = new Array( kernelSize );
  		sum = 0.0;
  		for ( i = 0; i < kernelSize; ++ i ) {

  			values[ i ] = gauss( i - halfWidth, sigma );
  			sum += values[ i ];

  		}

  		// normalize the kernel

  		for ( i = 0; i < kernelSize; ++ i ) { values[ i ] /= sum; }

  		return values;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BloomPass = function ( strength, kernelSize, sigma, resolution ) {

  	Pass.call( this );

  	strength = ( strength !== undefined ) ? strength : 1;
  	kernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;
  	sigma = ( sigma !== undefined ) ? sigma : 4.0;
  	resolution = ( resolution !== undefined ) ? resolution : 256;

  	// render targets

  	var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

  	this.renderTargetX = new WebGLRenderTarget( resolution, resolution, pars );
  	this.renderTargetX.texture.name = "BloomPass.x";
  	this.renderTargetY = new WebGLRenderTarget( resolution, resolution, pars );
  	this.renderTargetY.texture.name = "BloomPass.y";

  	// copy material

  	if ( CopyShader === undefined )
  		{ console.error( "BloomPass relies on CopyShader" ); }

  	var copyShader = CopyShader;

  	this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );

  	this.copyUniforms[ "opacity" ].value = strength;

  	this.materialCopy = new ShaderMaterial( {

  		uniforms: this.copyUniforms,
  		vertexShader: copyShader.vertexShader,
  		fragmentShader: copyShader.fragmentShader,
  		blending: AdditiveBlending,
  		transparent: true

  	} );

  	// convolution material

  	if ( ConvolutionShader === undefined )
  		{ console.error( "BloomPass relies on ConvolutionShader" ); }

  	var convolutionShader = ConvolutionShader;

  	this.convolutionUniforms = UniformsUtils.clone( convolutionShader.uniforms );

  	this.convolutionUniforms[ "uImageIncrement" ].value = BloomPass.blurX;
  	this.convolutionUniforms[ "cKernel" ].value = ConvolutionShader.buildKernel( sigma );

  	this.materialConvolution = new ShaderMaterial( {

  		uniforms: this.convolutionUniforms,
  		vertexShader: convolutionShader.vertexShader,
  		fragmentShader: convolutionShader.fragmentShader,
  		defines: {
  			"KERNEL_SIZE_FLOAT": kernelSize.toFixed( 1 ),
  			"KERNEL_SIZE_INT": kernelSize.toFixed( 0 )
  		}

  	} );

  	this.needsSwap = false;

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  BloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: BloomPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		if ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }

  		// Render quad with blured scene into texture (convolution pass 1)

  		this.quad.material = this.materialConvolution;

  		this.convolutionUniforms[ "tDiffuse" ].value = readBuffer.texture;
  		this.convolutionUniforms[ "uImageIncrement" ].value = BloomPass.blurX;

  		renderer.setRenderTarget( this.renderTargetX );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );
  		// Render quad with blured scene into texture (convolution pass 2)

  		this.convolutionUniforms[ "tDiffuse" ].value = this.renderTargetX.texture;
  		this.convolutionUniforms[ "uImageIncrement" ].value = BloomPass.blurY;

  		renderer.setRenderTarget( this.renderTargetY );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// Render original scene with superimposed blur to texture

  		this.quad.material = this.materialCopy;

  		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetY.texture;

  		if ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }

  		renderer.setRenderTarget( readBuffer );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  	}

  } );

  BloomPass.blurX = new Vector2( 0.001953125, 0.0 );
  BloomPass.blurY = new Vector2( 0.0, 0.001953125 );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BokehPass = function ( scene, camera, params ) {

  	Pass.call( this );

  	this.scene = scene;
  	this.camera = camera;

  	var focus = ( params.focus !== undefined ) ? params.focus : 1.0;
  	var aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;
  	var aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;
  	var maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;

  	// render targets

  	var width = params.width || window.innerWidth || 1;
  	var height = params.height || window.innerHeight || 1;

  	this.renderTargetColor = new WebGLRenderTarget( width, height, {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBFormat
  	} );
  	this.renderTargetColor.texture.name = "BokehPass.color";

  	this.renderTargetDepth = this.renderTargetColor.clone();
  	this.renderTargetDepth.texture.name = "BokehPass.depth";

  	// depth material

  	this.materialDepth = new MeshDepthMaterial();
  	this.materialDepth.depthPacking = RGBADepthPacking;
  	this.materialDepth.blending = NoBlending;

  	// bokeh material

  	if ( BokehShader === undefined ) {

  		console.error( "BokehPass relies on BokehShader" );

  	}

  	var bokehShader = BokehShader;
  	var bokehUniforms = UniformsUtils.clone( bokehShader.uniforms );

  	bokehUniforms[ "tDepth" ].value = this.renderTargetDepth.texture;

  	bokehUniforms[ "focus" ].value = focus;
  	bokehUniforms[ "aspect" ].value = aspect;
  	bokehUniforms[ "aperture" ].value = aperture;
  	bokehUniforms[ "maxblur" ].value = maxblur;
  	bokehUniforms[ "nearClip" ].value = camera.near;
  	bokehUniforms[ "farClip" ].value = camera.far;

  	this.materialBokeh = new ShaderMaterial( {
  		defines: Object.assign( {}, bokehShader.defines ),
  		uniforms: bokehUniforms,
  		vertexShader: bokehShader.vertexShader,
  		fragmentShader: bokehShader.fragmentShader
  	} );

  	this.uniforms = bokehUniforms;
  	this.needsSwap = false;

  	this.camera2 = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene2 = new Scene();

  	this.quad2 = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad2.frustumCulled = false; // Avoid getting clipped
  	this.scene2.add( this.quad2 );

  	this.oldClearColor = new Color();
  	this.oldClearAlpha = 1;

  };

  BokehPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: BokehPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		this.quad2.material = this.materialBokeh;

  		// Render depth into texture

  		this.scene.overrideMaterial = this.materialDepth;

  		this.oldClearColor.copy( renderer.getClearColor() );
  		this.oldClearAlpha = renderer.getClearAlpha();
  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		renderer.setClearColor( 0xffffff );
  		renderer.setClearAlpha( 1.0 );
  		renderer.setRenderTarget( this.renderTargetDepth );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// Render bokeh composite

  		this.uniforms[ "tColor" ].value = readBuffer.texture;
  		this.uniforms[ "nearClip" ].value = this.camera.near;
  		this.uniforms[ "farClip" ].value = this.camera.far;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene2, this.camera2 );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			renderer.clear();
  			renderer.render( this.scene2, this.camera2 );

  		}

  		this.scene.overrideMaterial = null;
  		renderer.setClearColor( this.oldClearColor );
  		renderer.setClearAlpha( this.oldClearAlpha );
  		renderer.autoClear = this.oldAutoClear;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ClearPass = function ( clearColor, clearAlpha ) {

  	Pass.call( this );

  	this.needsSwap = false;

  	this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
  	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

  };

  ClearPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: ClearPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		var oldClearColor, oldClearAlpha;

  		if ( this.clearColor ) {

  			oldClearColor = renderer.getClearColor().getHex();
  			oldClearAlpha = renderer.getClearAlpha();

  			renderer.setClearColor( this.clearColor, this.clearAlpha );

  		}

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
  		renderer.clear();

  		if ( this.clearColor ) {

  			renderer.setClearColor( oldClearColor, oldClearAlpha );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CubeTexturePass = function ( camera, envMap, opacity ) {

  	Pass.call( this );

  	this.camera = camera;

  	this.needsSwap = false;

  	this.cubeShader = ShaderLib[ 'cube' ];
  	this.cubeMesh = new Mesh(
  		new BoxBufferGeometry( 10, 10, 10 ),
  		new ShaderMaterial( {
  			uniforms: this.cubeShader.uniforms,
  			vertexShader: this.cubeShader.vertexShader,
  			fragmentShader: this.cubeShader.fragmentShader,
  			depthTest: false,
  			depthWrite: false,
  			side: BackSide
  		} )
  	);

  	this.envMap = envMap;
  	this.opacity = ( opacity !== undefined ) ? opacity : 1.0;

  	this.cubeScene = new Scene();
  	this.cubeCamera = new PerspectiveCamera();
  	this.cubeScene.add( this.cubeMesh );

  };

  CubeTexturePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: CubeTexturePass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		this.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );
  		this.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );

  		this.cubeMesh.material.uniforms[ "tCube" ].value = this.envMap;
  		this.cubeMesh.material.uniforms[ "opacity" ].value = this.opacity;
  		this.cubeMesh.material.transparent = ( this.opacity < 1.0 );

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.cubeScene, this.cubeCamera );

  		renderer.autoClear = oldAutoClear;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DotScreenShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"tSize":    { value: new Vector2( 256, 256 ) },
  		"center":   { value: new Vector2( 0.5, 0.5 ) },
  		"angle":    { value: 1.57 },
  		"scale":    { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform vec2 center;",
  		"uniform float angle;",
  		"uniform float scale;",
  		"uniform vec2 tSize;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"float pattern() {",

  			"float s = sin( angle ), c = cos( angle );",

  			"vec2 tex = vUv * tSize - center;",
  			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

  			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

  		"}",

  		"void main() {",

  			"vec4 color = texture2D( tDiffuse, vUv );",

  			"float average = ( color.r + color.g + color.b ) / 3.0;",

  			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DotScreenPass = function ( center, angle, scale ) {

  	Pass.call( this );

  	if ( DotScreenShader === undefined )
  		{ console.error( "DotScreenPass relies on DotScreenShader" ); }

  	var shader = DotScreenShader;

  	this.uniforms = UniformsUtils.clone( shader.uniforms );

  	if ( center !== undefined ) { this.uniforms[ "center" ].value.copy( center ); }
  	if ( angle !== undefined ) { this.uniforms[ "angle" ].value = angle; }
  	if ( scale !== undefined ) { this.uniforms[ "scale" ].value = scale; }

  	this.material = new ShaderMaterial( {

  		uniforms: this.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader

  	} );

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  DotScreenPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: DotScreenPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
  		this.uniforms[ "tSize" ].value.set( readBuffer.width, readBuffer.height );

  		this.quad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			if ( this.clear ) { renderer.clear(); }
  			renderer.render( this.scene, this.camera );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MaskPass = function ( scene, camera ) {

  	Pass.call( this );

  	this.scene = scene;
  	this.camera = camera;

  	this.clear = true;
  	this.needsSwap = false;

  	this.inverse = false;

  };

  MaskPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: MaskPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		var context = renderer.context;
  		var state = renderer.state;

  		// don't update color or depth

  		state.buffers.color.setMask( false );
  		state.buffers.depth.setMask( false );

  		// lock buffers

  		state.buffers.color.setLocked( true );
  		state.buffers.depth.setLocked( true );

  		// set up stencil

  		var writeValue, clearValue;

  		if ( this.inverse ) {

  			writeValue = 0;
  			clearValue = 1;

  		} else {

  			writeValue = 1;
  			clearValue = 0;

  		}

  		state.buffers.stencil.setTest( true );
  		state.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );
  		state.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );
  		state.buffers.stencil.setClear( clearValue );

  		// draw into the stencil buffer

  		renderer.setRenderTarget( readBuffer );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  		renderer.setRenderTarget( writeBuffer );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  		// unlock color and depth buffer for subsequent rendering

  		state.buffers.color.setLocked( false );
  		state.buffers.depth.setLocked( false );

  		// only render where stencil is set to 1

  		state.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1
  		state.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );

  	}

  } );
  var ClearMaskPass = function () {

  	Pass.call( this );

  	this.needsSwap = false;

  };

  ClearMaskPass.prototype = Object.create( Pass.prototype );

  Object.assign( ClearMaskPass.prototype, {

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		renderer.state.buffers.stencil.setTest( false );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var EffectComposer = function ( renderer, renderTarget ) {

  	this.renderer = renderer;

  	if ( renderTarget === undefined ) {

  		var parameters = {
  			minFilter: LinearFilter,
  			magFilter: LinearFilter,
  			format: RGBAFormat,
  			stencilBuffer: false
  		};

  		var size = renderer.getDrawingBufferSize( new Vector2() );
  		renderTarget = new WebGLRenderTarget( size.width, size.height, parameters );
  		renderTarget.texture.name = 'EffectComposer.rt1';

  	}

  	this.renderTarget1 = renderTarget;
  	this.renderTarget2 = renderTarget.clone();
  	this.renderTarget2.texture.name = 'EffectComposer.rt2';

  	this.writeBuffer = this.renderTarget1;
  	this.readBuffer = this.renderTarget2;

  	this.passes = [];

  	// dependencies

  	if ( CopyShader === undefined ) {

  		console.error( 'EffectComposer relies on CopyShader' );

  	}

  	if ( ShaderPass === undefined ) {

  		console.error( 'EffectComposer relies on ShaderPass' );

  	}

  	this.copyPass = new ShaderPass( CopyShader );

  	this._previousFrameTime = Date.now();

  };

  Object.assign( EffectComposer.prototype, {

  	swapBuffers: function () {

  		var tmp = this.readBuffer;
  		this.readBuffer = this.writeBuffer;
  		this.writeBuffer = tmp;

  	},

  	addPass: function ( pass ) {

  		this.passes.push( pass );

  		var size = this.renderer.getDrawingBufferSize( new Vector2() );
  		pass.setSize( size.width, size.height );

  	},

  	insertPass: function ( pass, index ) {

  		this.passes.splice( index, 0, pass );

  	},

  	render: function ( deltaTime ) {
  		var this$1 = this;


  		// deltaTime value is in seconds

  		if ( deltaTime === undefined ) {

  			deltaTime = ( Date.now() - this._previousFrameTime ) * 0.001;

  		}

  		this._previousFrameTime = Date.now();

  		var currentRenderTarget = this.renderer.getRenderTarget();

  		var maskActive = false;

  		var pass, i, il = this.passes.length;

  		for ( i = 0; i < il; i ++ ) {

  			pass = this$1.passes[ i ];

  			if ( pass.enabled === false ) { continue; }

  			pass.render( this$1.renderer, this$1.writeBuffer, this$1.readBuffer, deltaTime, maskActive );

  			if ( pass.needsSwap ) {

  				if ( maskActive ) {

  					var context = this$1.renderer.context;

  					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

  					this$1.copyPass.render( this$1.renderer, this$1.writeBuffer, this$1.readBuffer, deltaTime );

  					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

  				}

  				this$1.swapBuffers();

  			}

  			if ( MaskPass !== undefined ) {

  				if ( pass instanceof MaskPass ) {

  					maskActive = true;

  				} else if ( pass instanceof ClearMaskPass ) {

  					maskActive = false;

  				}

  			}

  		}

  		this.renderer.setRenderTarget( currentRenderTarget );

  	},

  	reset: function ( renderTarget ) {

  		if ( renderTarget === undefined ) {

  			var size = this.renderer.getDrawingBufferSize( new Vector2() );

  			renderTarget = this.renderTarget1.clone();
  			renderTarget.setSize( size.width, size.height );

  		}

  		this.renderTarget1.dispose();
  		this.renderTarget2.dispose();
  		this.renderTarget1 = renderTarget;
  		this.renderTarget2 = renderTarget.clone();

  		this.writeBuffer = this.renderTarget1;
  		this.readBuffer = this.renderTarget2;

  	},

  	setSize: function ( width, height ) {
  		var this$1 = this;


  		this.renderTarget1.setSize( width, height );
  		this.renderTarget2.setSize( width, height );

  		for ( var i = 0; i < this.passes.length; i ++ ) {

  			this$1.passes[ i ].setSize( width, height );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FilmShader = {

  	uniforms: {

  		"tDiffuse":   { value: null },
  		"time":       { value: 0.0 },
  		"nIntensity": { value: 0.5 },
  		"sIntensity": { value: 0.05 },
  		"sCount":     { value: 4096 },
  		"grayscale":  { value: 1 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#include <common>",
  		
  		// control parameter
  		"uniform float time;",

  		"uniform bool grayscale;",

  		// noise effect intensity value (0 = no effect, 1 = full effect)
  		"uniform float nIntensity;",

  		// scanlines effect intensity value (0 = no effect, 1 = full effect)
  		"uniform float sIntensity;",

  		// scanlines effect count value (0 = no effect, 4096 = full effect)
  		"uniform float sCount;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			// sample the source
  			"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

  			// make some noise
  			"float dx = rand( vUv + time );",

  			// add noise
  			"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",

  			// get us a sine and cosine
  			"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

  			// add scanlines
  			"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

  			// interpolate between source and result by intensity
  			"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

  			// convert to grayscale if desired
  			"if( grayscale ) {",

  				"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",

  			"}",

  			"gl_FragColor =  vec4( cResult, cTextureScreen.a );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {

  	Pass.call( this );

  	if ( FilmShader === undefined )
  		{ console.error( "FilmPass relies on FilmShader" ); }

  	var shader = FilmShader;

  	this.uniforms = UniformsUtils.clone( shader.uniforms );

  	this.material = new ShaderMaterial( {

  		uniforms: this.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader

  	} );

  	if ( grayscale !== undefined )	{ this.uniforms.grayscale.value = grayscale; }
  	if ( noiseIntensity !== undefined ) { this.uniforms.nIntensity.value = noiseIntensity; }
  	if ( scanlinesIntensity !== undefined ) { this.uniforms.sIntensity.value = scanlinesIntensity; }
  	if ( scanlinesCount !== undefined ) { this.uniforms.sCount.value = scanlinesCount; }

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  FilmPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: FilmPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
  		this.uniforms[ "time" ].value += deltaTime;

  		this.quad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			if ( this.clear ) { renderer.clear(); }
  			renderer.render( this.scene, this.camera );

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DigitalGlitch = {

  	uniforms: {

  		"tDiffuse":		{ value: null },//diffuse texture
  		"tDisp":		{ value: null },//displacement texture for digital glitch squares
  		"byp":			{ value: 0 },//apply the glitch ?
  		"amount":		{ value: 0.08 },
  		"angle":		{ value: 0.02 },
  		"seed":			{ value: 0.02 },
  		"seed_x":		{ value: 0.02 },//-1,1
  		"seed_y":		{ value: 0.02 },//-1,1
  		"distortion_x":	{ value: 0.5 },
  		"distortion_y":	{ value: 0.6 },
  		"col_s":		{ value: 0.05 }
  	},

  	vertexShader: [

  		"varying vec2 vUv;",
  		"void main() {",
  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  		"}"
  	].join( "\n" ),

  	fragmentShader: [
  		"uniform int byp;",//should we apply the glitch ?
  		
  		"uniform sampler2D tDiffuse;",
  		"uniform sampler2D tDisp;",
  		
  		"uniform float amount;",
  		"uniform float angle;",
  		"uniform float seed;",
  		"uniform float seed_x;",
  		"uniform float seed_y;",
  		"uniform float distortion_x;",
  		"uniform float distortion_y;",
  		"uniform float col_s;",
  			
  		"varying vec2 vUv;",
  		"float rand(vec2 co){",
  			"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
  		"}",
  				
  		"void main() {",
  			"if(byp<1) {",
  				"vec2 p = vUv;",
  				"float xs = floor(gl_FragCoord.x / 0.5);",
  				"float ys = floor(gl_FragCoord.y / 0.5);",
  				//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
  				"vec4 normal = texture2D (tDisp, p*seed*seed);",
  				"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {",
  					"if(seed_x>0.){",
  						"p.y = 1. - (p.y + distortion_y);",
  					"}",
  					"else {",
  						"p.y = distortion_y;",
  					"}",
  				"}",
  				"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {",
  					"if(seed_y>0.){",
  						"p.x=distortion_x;",
  					"}",
  					"else {",
  						"p.x = 1. - (p.x + distortion_x);",
  					"}",
  				"}",
  				"p.x+=normal.x*seed_x*(seed/5.);",
  				"p.y+=normal.y*seed_y*(seed/5.);",
  				//base from RGB shift shader
  				"vec2 offset = amount * vec2( cos(angle), sin(angle));",
  				"vec4 cr = texture2D(tDiffuse, p + offset);",
  				"vec4 cga = texture2D(tDiffuse, p);",
  				"vec4 cb = texture2D(tDiffuse, p - offset);",
  				"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
  				//add noise
  				"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);",
  				"gl_FragColor = gl_FragColor+ snow;",
  			"}",
  			"else {",
  				"gl_FragColor=texture2D (tDiffuse, vUv);",
  			"}",
  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GlitchPass = function ( dt_size ) {

  	Pass.call( this );

  	if ( DigitalGlitch === undefined ) { console.error( "GlitchPass relies on DigitalGlitch" ); }

  	var shader = DigitalGlitch;
  	this.uniforms = UniformsUtils.clone( shader.uniforms );

  	if ( dt_size == undefined ) { dt_size = 64; }
  	this.uniforms[ "tDisp" ].value = this.generateHeightmap( dt_size );
  	this.material = new ShaderMaterial( {
  		uniforms: this.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader
  	} );

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  	this.goWild = false;
  	this.curF = 0;
  	this.generateTrigger();

  };

  GlitchPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: GlitchPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		this.uniforms[ "tDiffuse" ].value = readBuffer.texture;
  		this.uniforms[ 'seed' ].value = Math.random();//default seeding
  		this.uniforms[ 'byp' ].value = 0;

  		if ( this.curF % this.randX == 0 || this.goWild == true ) {

  			this.uniforms[ 'amount' ].value = Math.random() / 30;
  			this.uniforms[ 'angle' ].value = _Math.randFloat( - Math.PI, Math.PI );
  			this.uniforms[ 'seed_x' ].value = _Math.randFloat( - 1, 1 );
  			this.uniforms[ 'seed_y' ].value = _Math.randFloat( - 1, 1 );
  			this.uniforms[ 'distortion_x' ].value = _Math.randFloat( 0, 1 );
  			this.uniforms[ 'distortion_y' ].value = _Math.randFloat( 0, 1 );
  			this.curF = 0;
  			this.generateTrigger();

  		} else if ( this.curF % this.randX < this.randX / 5 ) {

  			this.uniforms[ 'amount' ].value = Math.random() / 90;
  			this.uniforms[ 'angle' ].value = _Math.randFloat( - Math.PI, Math.PI );
  			this.uniforms[ 'distortion_x' ].value = _Math.randFloat( 0, 1 );
  			this.uniforms[ 'distortion_y' ].value = _Math.randFloat( 0, 1 );
  			this.uniforms[ 'seed_x' ].value = _Math.randFloat( - 0.3, 0.3 );
  			this.uniforms[ 'seed_y' ].value = _Math.randFloat( - 0.3, 0.3 );

  		} else if ( this.goWild == false ) {

  			this.uniforms[ 'byp' ].value = 1;

  		}

  		this.curF ++;
  		this.quad.material = this.material;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			if ( this.clear ) { renderer.clear(); }
  			renderer.render( this.scene, this.camera );

  		}

  	},

  	generateTrigger: function () {

  		this.randX = _Math.randInt( 120, 240 );

  	},

  	generateHeightmap: function ( dt_size ) {

  		var data_arr = new Float32Array( dt_size * dt_size * 3 );
  		var length = dt_size * dt_size;

  		for ( var i = 0; i < length; i ++ ) {

  			var val = _Math.randFloat( 0, 1 );
  			data_arr[ i * 3 + 0 ] = val;
  			data_arr[ i * 3 + 1 ] = val;
  			data_arr[ i * 3 + 2 ] = val;

  		}

  		var texture = new DataTexture( data_arr, dt_size, dt_size, RGBFormat, FloatType );
  		texture.needsUpdate = true;
  		return texture;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HalftoneShader = {

  	uniforms: {
  		"tDiffuse": { value: null },
  		"shape": { value: 1 },
  		"radius": { value: 4 },
  		"rotateR": { value: Math.PI / 12 * 1 },
  		"rotateG": { value: Math.PI / 12 * 2 },
  		"rotateB": { value: Math.PI / 12 * 3 },
  		"scatter": { value: 0 },
  		"width": { value: 1 },
  		"height": { value: 1 },
  		"blending": { value: 1 },
  		"blendingMode": { value: 1 },
  		"greyscale": { value: false },
  		"disable": { value: false }
  	},

  	vertexShader: [

      "varying vec2 vUV;",

      "void main() {",

        "vUV = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",

      "}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#define SQRT2_MINUS_ONE 0.41421356",
  		"#define SQRT2_HALF_MINUS_ONE 0.20710678",
  		"#define PI2 6.28318531",
  		"#define SHAPE_DOT 1",
  		"#define SHAPE_ELLIPSE 2",
  		"#define SHAPE_LINE 3",
  		"#define SHAPE_SQUARE 4",
  		"#define BLENDING_LINEAR 1",
  		"#define BLENDING_MULTIPLY 2",
  		"#define BLENDING_ADD 3",
  		"#define BLENDING_LIGHTER 4",
  		"#define BLENDING_DARKER 5",
  		"uniform sampler2D tDiffuse;",
  		"uniform float radius;",
  		"uniform float rotateR;",
  		"uniform float rotateG;",
  		"uniform float rotateB;",
  		"uniform float scatter;",
  		"uniform float width;",
  		"uniform float height;",
  		"uniform int shape;",
  		"uniform bool disable;",
  		"uniform float blending;",
  		"uniform int blendingMode;",
  		"varying vec2 vUV;",
  		"uniform bool greyscale;",
  		"const int samples = 8;",

  		"float blend( float a, float b, float t ) {",

  			// linear blend
  			"return a * ( 1.0 - t ) + b * t;",

  		"}",

  		"float hypot( float x, float y ) {",

  			// vector magnitude
  			"return sqrt( x * x + y * y );",

  		"}",

  		"float rand( vec2 seed ){",

  			// get pseudo-random number
  	    "return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",

  		"}",

  		"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",

  			// apply shape-specific transforms
  			"float dist = hypot( coord.x - p.x, coord.y - p.y );",
  			"float rad = channel;",

  			"if ( shape == SHAPE_DOT ) {",

  				"rad = pow( abs( rad ), 1.125 ) * rad_max;",

  			"} else if ( shape == SHAPE_ELLIPSE ) {",

  				"rad = pow( abs( rad ), 1.125 ) * rad_max;",

  				"if ( dist != 0.0 ) {",
  					"float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );",
  					"dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;",
  				"}",

  			"} else if ( shape == SHAPE_LINE ) {",

  				"rad = pow( abs( rad ), 1.5) * rad_max;",
  				"float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;",
  				"dist = hypot( normal.x * dot_p, normal.y * dot_p );",

  			"} else if ( shape == SHAPE_SQUARE ) {",

  				"float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;",
  				"float sin_t = abs( sin( theta ) );",
  				"float cos_t = abs( cos( theta ) );",
  				"rad = pow( abs( rad ), 1.4 );",
  				"rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );",

  			"}",

  			"return rad - dist;",

  		"}",

  		"struct Cell {",

  			// grid sample positions
  			"vec2 normal;",
  			"vec2 p1;",
  			"vec2 p2;",
  			"vec2 p3;",
  			"vec2 p4;",
  			"float samp2;",
  			"float samp1;",
  			"float samp3;",
  			"float samp4;",

  		"};",

  		"vec4 getSample( vec2 point ) {",

  			// multi-sampled point
  			"vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );",
  			"float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;",
  			"float step = PI2 / float( samples );",
  			"float dist = radius * 0.66;",

  			"for ( int i = 0; i < samples; ++i ) {",

  				"float r = base + step * float( i );",
  				"vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );",
  				"tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );",

  			"}",

  			"tex /= float( samples ) + 1.0;",
  			"return tex;",

  		"}",

  		"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",

  			// get colour for given point
  			"float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;",

  			"if ( channel == 0 ) {",

  				"c.samp1 = getSample( c.p1 ).r;",
  				"c.samp2 = getSample( c.p2 ).r;",
  				"c.samp3 = getSample( c.p3 ).r;",
  				"c.samp4 = getSample( c.p4 ).r;",

  			"} else if (channel == 1) {",

  				"c.samp1 = getSample( c.p1 ).g;",
  				"c.samp2 = getSample( c.p2 ).g;",
  				"c.samp3 = getSample( c.p3 ).g;",
  				"c.samp4 = getSample( c.p4 ).g;",

  			"} else {",

  				"c.samp1 = getSample( c.p1 ).b;",
  				"c.samp3 = getSample( c.p3 ).b;",
  				"c.samp2 = getSample( c.p2 ).b;",
  				"c.samp4 = getSample( c.p4 ).b;",

  			"}",

  			"dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );",
  			"dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );",
  			"dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );",
  			"dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );",
  			"res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;",
  			"res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;",
  			"res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;",
  			"res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;",
  			"res = clamp( res, 0.0, 1.0 );",

  			"return res;",

  		"}",

  		"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",

  			// get containing cell
  			"Cell c;",

  			// calc grid
  			"vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );",
  			"float threshold = step * 0.5;",
  			"float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );",
  			"float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );",
  			"vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );",
  			"float offset_normal = mod( hypot( offset.x, offset.y ), step );",
  			"float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;",
  			"float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;",
  			"float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );",
  			"float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;",
  			"float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",

  			// get closest corner
  			"c.normal = n;",
  			"c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;",
  			"c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",

  			// scatter
  			"if ( scatter != 0.0 ) {",

  				"float off_mag = scatter * threshold * 0.5;",
  				"float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;",
  				"c.p1.x += cos( off_angle ) * off_mag;",
  				"c.p1.y += sin( off_angle ) * off_mag;",

  			"}",

  			// find corners
  			"float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );",
  			"float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );",
  			"c.p2.x = c.p1.x - n.x * normal_step;",
  			"c.p2.y = c.p1.y - n.y * normal_step;",
  			"c.p3.x = c.p1.x + n.y * line_step;",
  			"c.p3.y = c.p1.y - n.x * line_step;",
  			"c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;",
  			"c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;",

  			"return c;",

  		"}",

  		"float blendColour( float a, float b, float t ) {",

  			// blend colours
  			"if ( blendingMode == BLENDING_LINEAR ) {",
  				"return blend( a, b, 1.0 - t );",
  			"} else if ( blendingMode == BLENDING_ADD ) {",
  				"return blend( a, min( 1.0, a + b ), t );",
  			"} else if ( blendingMode == BLENDING_MULTIPLY ) {",
  				"return blend( a, max( 0.0, a * b ), t );",
  			"} else if ( blendingMode == BLENDING_LIGHTER ) {",
  				"return blend( a, max( a, b ), t );",
  			"} else if ( blendingMode == BLENDING_DARKER ) {",
  				"return blend( a, min( a, b ), t );",
  			"} else {",
  				"return blend( a, b, 1.0 - t );",
  			"}",

  		"}",

  		"void main() {",

  			"if ( ! disable ) {",

  				// setup
  				"vec2 p = vec2( vUV.x * width, vUV.y * height );",
  				"vec2 origin = vec2( 0, 0 );",
  				"float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",

  				// get channel samples
  				"Cell cell_r = getReferenceCell( p, origin, rotateR, radius );",
  				"Cell cell_g = getReferenceCell( p, origin, rotateG, radius );",
  				"Cell cell_b = getReferenceCell( p, origin, rotateB, radius );",
  				"float r = getDotColour( cell_r, p, 0, rotateR, aa );",
  				"float g = getDotColour( cell_g, p, 1, rotateG, aa );",
  				"float b = getDotColour( cell_b, p, 2, rotateB, aa );",

  				// blend with original
  				"vec4 colour = texture2D( tDiffuse, vUV );",
  				"r = blendColour( r, colour.r, blending );",
  				"g = blendColour( g, colour.g, blending );",
  				"b = blendColour( b, colour.b, blending );",

  				"if ( greyscale ) {",
  					"r = g = b = (r + b + g) / 3.0;",
  				"}",

  				"gl_FragColor = vec4( r, g, b, 1.0 );",

  			"} else {",

  				"gl_FragColor = texture2D( tDiffuse, vUV );",

  			"}",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HalftonePass = function ( width, height, params ) {
  	var this$1 = this;


  	Pass.call( this );

   	if ( HalftoneShader === undefined ) {

   		console.error( 'HalftonePass requires HalftoneShader' );

   	}

   	this.uniforms = UniformsUtils.clone( HalftoneShader.uniforms );
   	this.material = new ShaderMaterial( {
   		uniforms: this.uniforms,
   		fragmentShader: HalftoneShader.fragmentShader,
   		vertexShader: HalftoneShader.vertexShader
   	} );

  	// set params
  	this.uniforms.width.value = width;
  	this.uniforms.height.value = height;

  	for ( var key in params ) {

  		if ( params.hasOwnProperty( key ) && this$1.uniforms.hasOwnProperty( key ) ) {

  			this$1.uniforms[ key ].value = params[ key ];

  		}

  	}

   	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
   	this.scene = new Scene();
   	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
   	this.quad.frustumCulled = false;
   	this.scene.add( this.quad );

  };

  HalftonePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: HalftonePass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

   		this.material.uniforms[ "tDiffuse" ].value = readBuffer.texture;
   		this.quad.material = this.material;

   		if ( this.renderToScreen ) {

   			renderer.setRenderTarget( null );
   			renderer.render( this.scene, this.camera );

  		} else {

   			renderer.setRenderTarget( writeBuffer );
   			if ( this.clear ) { renderer.clear(); }
  			renderer.render( this.scene, this.camera );

  		}

   	},

   	setSize: function ( width, height ) {

   		this.uniforms.width.value = width;
   		this.uniforms.height.value = height;

   	}
  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var OutlinePass = function ( resolution, scene, camera, selectedObjects ) {

  	this.renderScene = scene;
  	this.renderCamera = camera;
  	this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
  	this.visibleEdgeColor = new Color( 1, 1, 1 );
  	this.hiddenEdgeColor = new Color( 0.1, 0.04, 0.02 );
  	this.edgeGlow = 0.0;
  	this.usePatternTexture = false;
  	this.edgeThickness = 1.0;
  	this.edgeStrength = 3.0;
  	this.downSampleRatio = 2;
  	this.pulsePeriod = 0;

  	Pass.call( this );

  	this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );

  	var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

  	var resx = Math.round( this.resolution.x / this.downSampleRatio );
  	var resy = Math.round( this.resolution.y / this.downSampleRatio );

  	this.maskBufferMaterial = new MeshBasicMaterial( { color: 0xffffff } );
  	this.maskBufferMaterial.side = DoubleSide;
  	this.renderTargetMaskBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
  	this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
  	this.renderTargetMaskBuffer.texture.generateMipmaps = false;

  	this.depthMaterial = new MeshDepthMaterial();
  	this.depthMaterial.side = DoubleSide;
  	this.depthMaterial.depthPacking = RGBADepthPacking;
  	this.depthMaterial.blending = NoBlending;

  	this.prepareMaskMaterial = this.getPrepareMaskMaterial();
  	this.prepareMaskMaterial.side = DoubleSide;
  	this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );

  	this.renderTargetDepthBuffer = new WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );
  	this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
  	this.renderTargetDepthBuffer.texture.generateMipmaps = false;

  	this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget( resx, resy, pars );
  	this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
  	this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

  	this.renderTargetBlurBuffer1 = new WebGLRenderTarget( resx, resy, pars );
  	this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
  	this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
  	this.renderTargetBlurBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
  	this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
  	this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

  	this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
  	this.renderTargetEdgeBuffer1 = new WebGLRenderTarget( resx, resy, pars );
  	this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
  	this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
  	this.renderTargetEdgeBuffer2 = new WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );
  	this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
  	this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

  	var MAX_EDGE_THICKNESS = 4;
  	var MAX_EDGE_GLOW = 4;

  	this.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );
  	this.separableBlurMaterial1.uniforms[ "texSize" ].value = new Vector2( resx, resy );
  	this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = 1;
  	this.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );
  	this.separableBlurMaterial2.uniforms[ "texSize" ].value = new Vector2( Math.round( resx / 2 ), Math.round( resy / 2 ) );
  	this.separableBlurMaterial2.uniforms[ "kernelRadius" ].value = MAX_EDGE_GLOW;

  	// Overlay material
  	this.overlayMaterial = this.getOverlayMaterial();

  	// copy material
  	if ( CopyShader === undefined )
  		{ console.error( "OutlinePass relies on CopyShader" ); }

  	var copyShader = CopyShader;

  	this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );
  	this.copyUniforms[ "opacity" ].value = 1.0;

  	this.materialCopy = new ShaderMaterial( {
  		uniforms: this.copyUniforms,
  		vertexShader: copyShader.vertexShader,
  		fragmentShader: copyShader.fragmentShader,
  		blending: NoBlending,
  		depthTest: false,
  		depthWrite: false,
  		transparent: true
  	} );

  	this.enabled = true;
  	this.needsSwap = false;

  	this.oldClearColor = new Color();
  	this.oldClearAlpha = 1;

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  	this.tempPulseColor1 = new Color();
  	this.tempPulseColor2 = new Color();
  	this.textureMatrix = new Matrix4();

  	function replaceDepthToViewZ( string, camera ) {

  		var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';

  		return string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );

  	}

  };

  OutlinePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: OutlinePass,

  	dispose: function () {

  		this.renderTargetMaskBuffer.dispose();
  		this.renderTargetDepthBuffer.dispose();
  		this.renderTargetMaskDownSampleBuffer.dispose();
  		this.renderTargetBlurBuffer1.dispose();
  		this.renderTargetBlurBuffer2.dispose();
  		this.renderTargetEdgeBuffer1.dispose();
  		this.renderTargetEdgeBuffer2.dispose();

  	},

  	setSize: function ( width, height ) {

  		this.renderTargetMaskBuffer.setSize( width, height );

  		var resx = Math.round( width / this.downSampleRatio );
  		var resy = Math.round( height / this.downSampleRatio );
  		this.renderTargetMaskDownSampleBuffer.setSize( resx, resy );
  		this.renderTargetBlurBuffer1.setSize( resx, resy );
  		this.renderTargetEdgeBuffer1.setSize( resx, resy );
  		this.separableBlurMaterial1.uniforms[ "texSize" ].value = new Vector2( resx, resy );

  		resx = Math.round( resx / 2 );
  		resy = Math.round( resy / 2 );

  		this.renderTargetBlurBuffer2.setSize( resx, resy );
  		this.renderTargetEdgeBuffer2.setSize( resx, resy );

  		this.separableBlurMaterial2.uniforms[ "texSize" ].value = new Vector2( resx, resy );

  	},

  	changeVisibilityOfSelectedObjects: function ( bVisible ) {
  		var this$1 = this;


  		function gatherSelectedMeshesCallBack( object ) {

  			if ( object.isMesh ) {

  				if ( bVisible ) {

  					object.visible = object.userData.oldVisible;
  					delete object.userData.oldVisible;

  				} else {

  					object.userData.oldVisible = object.visible;
  					object.visible = bVisible;

  				}

  			}

  		}

  		for ( var i = 0; i < this.selectedObjects.length; i ++ ) {

  			var selectedObject = this$1.selectedObjects[ i ];
  			selectedObject.traverse( gatherSelectedMeshesCallBack );

  		}

  	},

  	changeVisibilityOfNonSelectedObjects: function ( bVisible ) {
  		var this$1 = this;


  		var selectedMeshes = [];

  		function gatherSelectedMeshesCallBack( object ) {

  			if ( object.isMesh ) { selectedMeshes.push( object ); }

  		}

  		for ( var i = 0; i < this.selectedObjects.length; i ++ ) {

  			var selectedObject = this$1.selectedObjects[ i ];
  			selectedObject.traverse( gatherSelectedMeshesCallBack );

  		}

  		function VisibilityChangeCallBack( object ) {

  			if ( object.isMesh || object.isLine || object.isSprite ) {

  				var bFound = false;

  				for ( var i = 0; i < selectedMeshes.length; i ++ ) {

  					var selectedObjectId = selectedMeshes[ i ].id;

  					if ( selectedObjectId === object.id ) {

  						bFound = true;
  						break;

  					}

  				}

  				if ( ! bFound ) {

  					var visibility = object.visible;

  					if ( ! bVisible || object.bVisible ) { object.visible = bVisible; }

  					object.bVisible = visibility;

  				}

  			}

  		}

  		this.renderScene.traverse( VisibilityChangeCallBack );

  	},

  	updateTextureMatrix: function () {

  		this.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,
  			0.0, 0.5, 0.0, 0.5,
  			0.0, 0.0, 0.5, 0.5,
  			0.0, 0.0, 0.0, 1.0 );
  		this.textureMatrix.multiply( this.renderCamera.projectionMatrix );
  		this.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );

  	},

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		if ( this.selectedObjects.length > 0 ) {

  			this.oldClearColor.copy( renderer.getClearColor() );
  			this.oldClearAlpha = renderer.getClearAlpha();
  			var oldAutoClear = renderer.autoClear;

  			renderer.autoClear = false;

  			if ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }

  			renderer.setClearColor( 0xffffff, 1 );

  			// Make selected objects invisible
  			this.changeVisibilityOfSelectedObjects( false );

  			var currentBackground = this.renderScene.background;
  			this.renderScene.background = null;

  			// 1. Draw Non Selected objects in the depth buffer
  			this.renderScene.overrideMaterial = this.depthMaterial;
  			renderer.setRenderTarget( this.renderTargetDepthBuffer );
  			renderer.clear();
  			renderer.render( this.renderScene, this.renderCamera );

  			// Make selected objects visible
  			this.changeVisibilityOfSelectedObjects( true );

  			// Update Texture Matrix for Depth compare
  			this.updateTextureMatrix();

  			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
  			this.changeVisibilityOfNonSelectedObjects( false );
  			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
  			this.prepareMaskMaterial.uniforms[ "cameraNearFar" ].value = new Vector2( this.renderCamera.near, this.renderCamera.far );
  			this.prepareMaskMaterial.uniforms[ "depthTexture" ].value = this.renderTargetDepthBuffer.texture;
  			this.prepareMaskMaterial.uniforms[ "textureMatrix" ].value = this.textureMatrix;
  			renderer.setRenderTarget( this.renderTargetMaskBuffer );
  			renderer.clear();
  			renderer.render( this.renderScene, this.renderCamera );
  			this.renderScene.overrideMaterial = null;
  			this.changeVisibilityOfNonSelectedObjects( true );

  			this.renderScene.background = currentBackground;

  			// 2. Downsample to Half resolution
  			this.quad.material = this.materialCopy;
  			this.copyUniforms[ "tDiffuse" ].value = this.renderTargetMaskBuffer.texture;
  			renderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );

  			this.tempPulseColor1.copy( this.visibleEdgeColor );
  			this.tempPulseColor2.copy( this.hiddenEdgeColor );

  			if ( this.pulsePeriod > 0 ) {

  				var scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;
  				this.tempPulseColor1.multiplyScalar( scalar );
  				this.tempPulseColor2.multiplyScalar( scalar );

  			}

  			// 3. Apply Edge Detection Pass
  			this.quad.material = this.edgeDetectionMaterial;
  			this.edgeDetectionMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskDownSampleBuffer.texture;
  			this.edgeDetectionMaterial.uniforms[ "texSize" ].value = new Vector2( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );
  			this.edgeDetectionMaterial.uniforms[ "visibleEdgeColor" ].value = this.tempPulseColor1;
  			this.edgeDetectionMaterial.uniforms[ "hiddenEdgeColor" ].value = this.tempPulseColor2;
  			renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );

  			// 4. Apply Blur on Half res
  			this.quad.material = this.separableBlurMaterial1;
  			this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
  			this.separableBlurMaterial1.uniforms[ "direction" ].value = OutlinePass.BlurDirectionX;
  			this.separableBlurMaterial1.uniforms[ "kernelRadius" ].value = this.edgeThickness;
  			renderer.setRenderTarget( this.renderTargetBlurBuffer1 );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );
  			this.separableBlurMaterial1.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer1.texture;
  			this.separableBlurMaterial1.uniforms[ "direction" ].value = OutlinePass.BlurDirectionY;
  			renderer.setRenderTarget( this.renderTargetEdgeBuffer1 );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );

  			// Apply Blur on quarter res
  			this.quad.material = this.separableBlurMaterial2;
  			this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetEdgeBuffer1.texture;
  			this.separableBlurMaterial2.uniforms[ "direction" ].value = OutlinePass.BlurDirectionX;
  			renderer.setRenderTarget( this.renderTargetBlurBuffer2 );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );
  			this.separableBlurMaterial2.uniforms[ "colorTexture" ].value = this.renderTargetBlurBuffer2.texture;
  			this.separableBlurMaterial2.uniforms[ "direction" ].value = OutlinePass.BlurDirectionY;
  			renderer.setRenderTarget( this.renderTargetEdgeBuffer2 );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );

  			// Blend it additively over the input texture
  			this.quad.material = this.overlayMaterial;
  			this.overlayMaterial.uniforms[ "maskTexture" ].value = this.renderTargetMaskBuffer.texture;
  			this.overlayMaterial.uniforms[ "edgeTexture1" ].value = this.renderTargetEdgeBuffer1.texture;
  			this.overlayMaterial.uniforms[ "edgeTexture2" ].value = this.renderTargetEdgeBuffer2.texture;
  			this.overlayMaterial.uniforms[ "patternTexture" ].value = this.patternTexture;
  			this.overlayMaterial.uniforms[ "edgeStrength" ].value = this.edgeStrength;
  			this.overlayMaterial.uniforms[ "edgeGlow" ].value = this.edgeGlow;
  			this.overlayMaterial.uniforms[ "usePatternTexture" ].value = this.usePatternTexture;
  			if ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }

  			renderer.setRenderTarget( readBuffer );
  			renderer.render( this.scene, this.camera );

  			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
  			renderer.autoClear = oldAutoClear;

  		}

  		if ( this.renderToScreen ) {

  			this.quad.material = this.materialCopy;
  			this.copyUniforms[ "tDiffuse" ].value = readBuffer.texture;
  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		}

  	},

  	getPrepareMaskMaterial: function () {

  		return new ShaderMaterial( {

  			uniforms: {
  				"depthTexture": { value: null },
  				"cameraNearFar": { value: new Vector2( 0.5, 0.5 ) },
  				"textureMatrix": { value: new Matrix4() }
  			},

  			vertexShader: [
  				'varying vec4 projTexCoord;',
  				'varying vec4 vPosition;',
  				'uniform mat4 textureMatrix;',

  				'void main() {',

  				'	vPosition = modelViewMatrix * vec4( position, 1.0 );',
  				'	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
  				'	projTexCoord = textureMatrix * worldPosition;',
  				'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

  				'}'
  			].join( '\n' ),

  			fragmentShader: [
  				'#include <packing>',
  				'varying vec4 vPosition;',
  				'varying vec4 projTexCoord;',
  				'uniform sampler2D depthTexture;',
  				'uniform vec2 cameraNearFar;',

  				'void main() {',

  				'	float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',
  				'	float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',
  				'	float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',
  				'	gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',

  				'}'
  			].join( '\n' )

  		} );

  	},

  	getEdgeDetectionMaterial: function () {

  		return new ShaderMaterial( {

  			uniforms: {
  				"maskTexture": { value: null },
  				"texSize": { value: new Vector2( 0.5, 0.5 ) },
  				"visibleEdgeColor": { value: new Vector3( 1.0, 1.0, 1.0 ) },
  				"hiddenEdgeColor": { value: new Vector3( 1.0, 1.0, 1.0 ) },
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform vec2 texSize;\
				uniform vec3 visibleEdgeColor;\
				uniform vec3 hiddenEdgeColor;\
				\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
					float diff1 = (c1.r - c2.r)*0.5;\
					float diff2 = (c3.r - c4.r)*0.5;\
					float d = length( vec2(diff1, diff2) );\
					float a1 = min(c1.g, c2.g);\
					float a2 = min(c3.g, c4.g);\
					float visibilityFactor = min(a1, a2);\
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
				}"
  		} );

  	},

  	getSeperableBlurMaterial: function ( maxRadius ) {

  		return new ShaderMaterial( {

  			defines: {
  				"MAX_RADIUS": maxRadius,
  			},

  			uniforms: {
  				"colorTexture": { value: null },
  				"texSize": { value: new Vector2( 0.5, 0.5 ) },
  				"direction": { value: new Vector2( 0.5, 0.5 ) },
  				"kernelRadius": { value: 1.0 }
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"#include <common>\
				varying vec2 vUv;\
				uniform sampler2D colorTexture;\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				uniform float kernelRadius;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\
					vec2 invSize = 1.0 / texSize;\
					float weightSum = gaussianPdf(0.0, kernelRadius);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
					vec2 uvOffset = delta;\
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
						float w = gaussianPdf(uvOffset.x, kernelRadius);\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += ((sample1 + sample2) * w);\
						weightSum += (2.0 * w);\
						uvOffset += delta;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
				}"
  		} );

  	},

  	getOverlayMaterial: function () {

  		return new ShaderMaterial( {

  			uniforms: {
  				"maskTexture": { value: null },
  				"edgeTexture1": { value: null },
  				"edgeTexture2": { value: null },
  				"patternTexture": { value: null },
  				"edgeStrength": { value: 1.0 },
  				"edgeGlow": { value: 1.0 },
  				"usePatternTexture": { value: 0.0 }
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform sampler2D edgeTexture1;\
				uniform sampler2D edgeTexture2;\
				uniform sampler2D patternTexture;\
				uniform float edgeStrength;\
				uniform float edgeGlow;\
				uniform bool usePatternTexture;\
				\
				void main() {\
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
					vec4 maskColor = texture2D(maskTexture, vUv);\
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
					if(usePatternTexture)\
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
					gl_FragColor = finalColor;\
				}",
  			blending: AdditiveBlending,
  			depthTest: false,
  			depthWrite: false,
  			transparent: true
  		} );

  	}

  } );

  OutlinePass.BlurDirectionX = new Vector2( 1.0, 0.0 );
  OutlinePass.BlurDirectionY = new Vector2( 0.0, 1.0 );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

  	Pass.call( this );

  	this.scene = scene;
  	this.camera = camera;

  	this.overrideMaterial = overrideMaterial;

  	this.clearColor = clearColor;
  	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

  	this.clear = true;
  	this.clearDepth = false;
  	this.needsSwap = false;

  };

  RenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: RenderPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		this.scene.overrideMaterial = this.overrideMaterial;

  		var oldClearColor, oldClearAlpha;

  		if ( this.clearColor ) {

  			oldClearColor = renderer.getClearColor().getHex();
  			oldClearAlpha = renderer.getClearAlpha();

  			renderer.setClearColor( this.clearColor, this.clearAlpha );

  		}

  		if ( this.clearDepth ) {

  			renderer.clearDepth();

  		}

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

  		// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
  		if ( this.clear ) { renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil ); }
  		renderer.render( this.scene, this.camera );

  		if ( this.clearColor ) {

  			renderer.setClearColor( oldClearColor, oldClearAlpha );

  		}

  		this.scene.overrideMaterial = null;
  		renderer.autoClear = oldAutoClear;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

  	format = format !== undefined ? format : DepthFormat;

  	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  		throw new Error( 'DepthTexture format must be either DepthFormat or DepthStencilFormat' );

  	}

  	if ( type === undefined && format === DepthFormat ) { type = UnsignedShortType; }
  	if ( type === undefined && format === DepthStencilFormat ) { type = UnsignedInt248Type; }

  	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.image = { width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  	this.flipY = false;
  	this.generateMipmaps	= false;

  }

  DepthTexture.prototype = Object.create( Texture.prototype );
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var SAOShader = {
  	defines: {
  		'NUM_SAMPLES': 7,
  		'NUM_RINGS': 4,
  		'NORMAL_TEXTURE': 0,
  		'DIFFUSE_TEXTURE': 0,
  		'DEPTH_PACKING': 1,
  		'PERSPECTIVE_CAMERA': 1
  	},
  	uniforms: {

  		'tDepth': { type: 't', value: null },
  		'tDiffuse': { type: 't', value: null },
  		'tNormal': { type: 't', value: null },
  		'size': { type: 'v2', value: new Vector2( 512, 512 ) },

  		'cameraNear': { type: 'f', value: 1 },
  		'cameraFar': { type: 'f', value: 100 },
  		'cameraProjectionMatrix': { type: 'm4', value: new Matrix4() },
  		'cameraInverseProjectionMatrix': { type: 'm4', value: new Matrix4() },

  		'scale': { type: 'f', value: 1.0 },
  		'intensity': { type: 'f', value: 0.1 },
  		'bias': { type: 'f', value: 0.5 },

  		'minResolution': { type: 'f', value: 0.0 },
  		'kernelRadius': { type: 'f', value: 100.0 },
  		'randomSeed': { type: 'f', value: 0.0 }
  	},
  	vertexShader: [
  		"varying vec2 vUv;",

  		"void main() {",
  		"	vUv = uv;",
  		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  		"}"

  	].join( "\n" ),
  	fragmentShader: [
  		"#include <common>",

  		"varying vec2 vUv;",

  		"#if DIFFUSE_TEXTURE == 1",
  		"uniform sampler2D tDiffuse;",
  		"#endif",

  		"uniform sampler2D tDepth;",

  		"#if NORMAL_TEXTURE == 1",
  		"uniform sampler2D tNormal;",
  		"#endif",

  		"uniform float cameraNear;",
  		"uniform float cameraFar;",
  		"uniform mat4 cameraProjectionMatrix;",
  		"uniform mat4 cameraInverseProjectionMatrix;",

  		"uniform float scale;",
  		"uniform float intensity;",
  		"uniform float bias;",
  		"uniform float kernelRadius;",
  		"uniform float minResolution;",
  		"uniform vec2 size;",
  		"uniform float randomSeed;",

  		"// RGBA depth",

  		"#include <packing>",

  		"vec4 getDefaultColor( const in vec2 screenPosition ) {",
  		"	#if DIFFUSE_TEXTURE == 1",
  		"	return texture2D( tDiffuse, vUv );",
  		"	#else",
  		"	return vec4( 1.0 );",
  		"	#endif",
  		"}",

  		"float getDepth( const in vec2 screenPosition ) {",
  		"	#if DEPTH_PACKING == 1",
  		"	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
  		"	#else",
  		"	return texture2D( tDepth, screenPosition ).x;",
  		"	#endif",
  		"}",

  		"float getViewZ( const in float depth ) {",
  		"	#if PERSPECTIVE_CAMERA == 1",
  		"	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
  		"	#else",
  		"	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
  		"	#endif",
  		"}",

  		"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
  		"	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
  		"	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
  		"	clipPosition *= clipW; // unprojection.",

  		"	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
  		"}",

  		"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {",
  		"	#if NORMAL_TEXTURE == 1",
  		"	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
  		"	#else",
  		"	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );",
  		"	#endif",
  		"}",

  		"float scaleDividedByCameraFar;",
  		"float minResolutionMultipliedByCameraFar;",

  		"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {",
  		"	vec3 viewDelta = sampleViewPosition - centerViewPosition;",
  		"	float viewDistance = length( viewDelta );",
  		"	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;",

  		"	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );",
  		"}",

  		"// moving costly divides into consts",
  		"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );",
  		"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );",

  		"float getAmbientOcclusion( const in vec3 centerViewPosition ) {",
  		"	// precompute some variables require in getOcclusion.",
  		"	scaleDividedByCameraFar = scale / cameraFar;",
  		"	minResolutionMultipliedByCameraFar = minResolution * cameraFar;",
  		"	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );",

  		"	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/",
  		"	float angle = rand( vUv + randomSeed ) * PI2;",
  		"	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;",
  		"	vec2 radiusStep = radius;",

  		"	float occlusionSum = 0.0;",
  		"	float weightSum = 0.0;",

  		"	for( int i = 0; i < NUM_SAMPLES; i ++ ) {",
  		"		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;",
  		"		radius += radiusStep;",
  		"		angle += ANGLE_STEP;",

  		"		float sampleDepth = getDepth( sampleUv );",
  		"		if( sampleDepth >= ( 1.0 - EPSILON ) ) {",
  		"			continue;",
  		"		}",

  		"		float sampleViewZ = getViewZ( sampleDepth );",
  		"		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );",
  		"		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );",
  		"		weightSum += 1.0;",
  		"	}",

  		"	if( weightSum == 0.0 ) discard;",

  		"	return occlusionSum * ( intensity / weightSum );",
  		"}",
  		"void main() {",
  		"	float centerDepth = getDepth( vUv );",
  		"	if( centerDepth >= ( 1.0 - EPSILON ) ) {",
  		"		discard;",
  		"	}",

  		"	float centerViewZ = getViewZ( centerDepth );",
  		"	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );",

  		"	float ambientOcclusion = getAmbientOcclusion( viewPosition );",

  		"	gl_FragColor = getDefaultColor( vUv );",
  		"	gl_FragColor.xyz *=  1.0 - ambientOcclusion;",
  		"}"
  	].join( "\n" )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var DepthLimitedBlurShader = {
  	defines: {
  		'KERNEL_RADIUS': 4,
  		'DEPTH_PACKING': 1,
  		'PERSPECTIVE_CAMERA': 1
  	},
  	uniforms: {
  		'tDiffuse': { type: 't', value: null },
  		'size': { type: 'v2', value: new Vector2( 512, 512 ) },
  		'sampleUvOffsets': { type: 'v2v', value: [ new Vector2( 0, 0 ) ] },
  		'sampleWeights': { type: '1fv', value: [ 1.0 ] },
  		'tDepth': { type: 't', value: null },
  		'cameraNear': { type: 'f', value: 10 },
  		'cameraFar': { type: 'f', value: 1000 },
  		'depthCutoff': { type: 'f', value: 10 },
  	},
  	vertexShader: [
  		"#include <common>",

  		"uniform vec2 size;",

  		"varying vec2 vUv;",
  		"varying vec2 vInvSize;",

  		"void main() {",
  		"	vUv = uv;",
  		"	vInvSize = 1.0 / size;",

  		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  		"}"

  	].join( "\n" ),
  	fragmentShader: [
  		"#include <common>",
  		"#include <packing>",

  		"uniform sampler2D tDiffuse;",
  		"uniform sampler2D tDepth;",

  		"uniform float cameraNear;",
  		"uniform float cameraFar;",
  		"uniform float depthCutoff;",

  		"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];",
  		"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];",

  		"varying vec2 vUv;",
  		"varying vec2 vInvSize;",

  		"float getDepth( const in vec2 screenPosition ) {",
  		"	#if DEPTH_PACKING == 1",
  		"	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
  		"	#else",
  		"	return texture2D( tDepth, screenPosition ).x;",
  		"	#endif",
  		"}",

  		"float getViewZ( const in float depth ) {",
  		"	#if PERSPECTIVE_CAMERA == 1",
  		"	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
  		"	#else",
  		"	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
  		"	#endif",
  		"}",

  		"void main() {",
  		"	float depth = getDepth( vUv );",
  		"	if( depth >= ( 1.0 - EPSILON ) ) {",
  		"		discard;",
  		"	}",

  		"	float centerViewZ = -getViewZ( depth );",
  		"	bool rBreak = false, lBreak = false;",

  		"	float weightSum = sampleWeights[0];",
  		"	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;",

  		"	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {",

  		"		float sampleWeight = sampleWeights[i];",
  		"		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;",

  		"		vec2 sampleUv = vUv + sampleUvOffset;",
  		"		float viewZ = -getViewZ( getDepth( sampleUv ) );",

  		"		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;",

  		"		if( ! rBreak ) {",
  		"			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;",
  		"			weightSum += sampleWeight;",
  		"		}",

  		"		sampleUv = vUv - sampleUvOffset;",
  		"		viewZ = -getViewZ( getDepth( sampleUv ) );",

  		"		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;",

  		"		if( ! lBreak ) {",
  		"			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;",
  		"			weightSum += sampleWeight;",
  		"		}",

  		"	}",

  		"	gl_FragColor = diffuseSum / weightSum;",
  		"}"
  	].join( "\n" )
  };

  var BlurShaderUtils = {

  	createSampleWeights: function ( kernelRadius, stdDev ) {

  		var gaussian = function ( x, stdDev ) {

  			return Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );

  		};

  		var weights = [];

  		for ( var i = 0; i <= kernelRadius; i ++ ) {

  			weights.push( gaussian( i, stdDev ) );

  		}

  		return weights;

  	},

  	createSampleOffsets: function ( kernelRadius, uvIncrement ) {

  		var offsets = [];

  		for ( var i = 0; i <= kernelRadius; i ++ ) {

  			offsets.push( uvIncrement.clone().multiplyScalar( i ) );

  		}

  		return offsets;

  	},

  	configure: function ( material, kernelRadius, stdDev, uvIncrement ) {

  		material.defines[ 'KERNEL_RADIUS' ] = kernelRadius;
  		material.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );
  		material.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );
  		material.needsUpdate = true;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var UnpackDepthRGBAShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"opacity":  { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float opacity;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"#include <packing>",

  		"void main() {",

  			"float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );",
  			"gl_FragColor = vec4( vec3( depth ), opacity );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SAOPass = function ( scene, camera, depthTexture, useNormals, resolution ) {

  	Pass.call( this );

  	this.scene = scene;
  	this.camera = camera;

  	this.clear = true;
  	this.needsSwap = false;

  	this.supportsDepthTextureExtension = ( depthTexture !== undefined ) ? depthTexture : false;
  	this.supportsNormalTexture = ( useNormals !== undefined ) ? useNormals : false;

  	this.originalClearColor = new Color();
  	this.oldClearColor = new Color();
  	this.oldClearAlpha = 1;

  	this.params = {
  		output: 0,
  		saoBias: 0.5,
  		saoIntensity: 0.18,
  		saoScale: 1,
  		saoKernelRadius: 100,
  		saoMinResolution: 0,
  		saoBlur: true,
  		saoBlurRadius: 8,
  		saoBlurStdDev: 4,
  		saoBlurDepthCutoff: 0.01
  	};

  	this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );

  	this.saoRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBAFormat
  	} );
  	this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
  	this.beautyRenderTarget = this.saoRenderTarget.clone();

  	this.normalRenderTarget = new WebGLRenderTarget( this.resolution.x, this.resolution.y, {
  		minFilter: NearestFilter,
  		magFilter: NearestFilter,
  		format: RGBAFormat
  	} );
  	this.depthRenderTarget = this.normalRenderTarget.clone();

  	if ( this.supportsDepthTextureExtension ) {

  		var depthTexture = new DepthTexture();
  		depthTexture.type = UnsignedShortType;
  		depthTexture.minFilter = NearestFilter;
  		depthTexture.maxFilter = NearestFilter;

  		this.beautyRenderTarget.depthTexture = depthTexture;
  		this.beautyRenderTarget.depthBuffer = true;

  	}

  	this.depthMaterial = new MeshDepthMaterial();
  	this.depthMaterial.depthPacking = RGBADepthPacking;
  	this.depthMaterial.blending = NoBlending;

  	this.normalMaterial = new MeshNormalMaterial();
  	this.normalMaterial.blending = NoBlending;

  	if ( SAOShader === undefined ) {

  		console.error( 'SAOPass relies on SAOShader' );

  	}

  	this.saoMaterial = new ShaderMaterial( {
  		defines: Object.assign( {}, SAOShader.defines ),
  		fragmentShader: SAOShader.fragmentShader,
  		vertexShader: SAOShader.vertexShader,
  		uniforms: UniformsUtils.clone( SAOShader.uniforms )
  	} );
  	this.saoMaterial.extensions.derivatives = true;
  	this.saoMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
  	this.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.supportsNormalTexture ? 1 : 0;
  	this.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
  	this.saoMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
  	this.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
  	this.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
  	this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );
  	this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
  	this.saoMaterial.blending = NoBlending;

  	if ( DepthLimitedBlurShader === undefined ) {

  		console.error( 'SAOPass relies on DepthLimitedBlurShader' );

  	}

  	this.vBlurMaterial = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),
  		defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
  		vertexShader: DepthLimitedBlurShader.vertexShader,
  		fragmentShader: DepthLimitedBlurShader.fragmentShader
  	} );
  	this.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
  	this.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
  	this.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
  	this.vBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
  	this.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
  	this.vBlurMaterial.blending = NoBlending;

  	this.hBlurMaterial = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( DepthLimitedBlurShader.uniforms ),
  		defines: Object.assign( {}, DepthLimitedBlurShader.defines ),
  		vertexShader: DepthLimitedBlurShader.vertexShader,
  		fragmentShader: DepthLimitedBlurShader.fragmentShader
  	} );
  	this.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;
  	this.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;
  	this.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;
  	this.hBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;
  	this.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );
  	this.hBlurMaterial.blending = NoBlending;

  	if ( CopyShader === undefined ) {

  		console.error( 'SAOPass relies on CopyShader' );

  	}

  	this.materialCopy = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( CopyShader.uniforms ),
  		vertexShader: CopyShader.vertexShader,
  		fragmentShader: CopyShader.fragmentShader,
  		blending: NoBlending
  	} );
  	this.materialCopy.transparent = true;
  	this.materialCopy.depthTest = false;
  	this.materialCopy.depthWrite = false;
  	this.materialCopy.blending = CustomBlending;
  	this.materialCopy.blendSrc = DstColorFactor;
  	this.materialCopy.blendDst = ZeroFactor;
  	this.materialCopy.blendEquation = AddEquation;
  	this.materialCopy.blendSrcAlpha = DstAlphaFactor;
  	this.materialCopy.blendDstAlpha = ZeroFactor;
  	this.materialCopy.blendEquationAlpha = AddEquation;

  	if ( CopyShader === undefined ) {

  		console.error( 'SAOPass relies on UnpackDepthRGBAShader' );

  	}

  	this.depthCopy = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( UnpackDepthRGBAShader.uniforms ),
  		vertexShader: UnpackDepthRGBAShader.vertexShader,
  		fragmentShader: UnpackDepthRGBAShader.fragmentShader,
  		blending: NoBlending
  	} );

  	this.quadCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.quadScene = new Scene();
  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quadScene.add( this.quad );

  };

  SAOPass.OUTPUT = {
  	'Beauty': 1,
  	'Default': 0,
  	'SAO': 2,
  	'Depth': 3,
  	'Normal': 4
  };

  SAOPass.prototype = Object.assign( Object.create( Pass.prototype ), {
  	constructor: SAOPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		// Rendering readBuffer first when rendering to screen
  		if ( this.renderToScreen ) {

  			this.materialCopy.blending = NoBlending;
  			this.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;
  			this.materialCopy.needsUpdate = true;
  			this.renderPass( renderer, this.materialCopy, null );

  		}

  		if ( this.params.output === 1 ) {

  			return;

  		}

  		this.oldClearColor.copy( renderer.getClearColor() );
  		this.oldClearAlpha = renderer.getClearAlpha();
  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		renderer.setRenderTarget( this.depthRenderTarget );
  		renderer.clear();

  		this.saoMaterial.uniforms[ 'bias' ].value = this.params.saoBias;
  		this.saoMaterial.uniforms[ 'intensity' ].value = this.params.saoIntensity;
  		this.saoMaterial.uniforms[ 'scale' ].value = this.params.saoScale;
  		this.saoMaterial.uniforms[ 'kernelRadius' ].value = this.params.saoKernelRadius;
  		this.saoMaterial.uniforms[ 'minResolution' ].value = this.params.saoMinResolution;
  		this.saoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
  		this.saoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
  		// this.saoMaterial.uniforms['randomSeed'].value = Math.random();

  		var depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );
  		this.vBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;
  		this.hBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;

  		this.vBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
  		this.vBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
  		this.hBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
  		this.hBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

  		this.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );
  		if ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {

  			BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 0, 1 ) );
  			BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2( 1, 0 ) );
  			this.prevStdDev = this.params.saoBlurStdDev;
  			this.prevNumSamples = this.params.saoBlurRadius;

  		}

  		// Rendering scene to depth texture
  		renderer.setClearColor( 0x000000 );
  		renderer.setRenderTarget( this.beautyRenderTarget );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// Re-render scene if depth texture extension is not supported
  		if ( ! this.supportsDepthTextureExtension ) {

  			// Clear rule : far clipping plane in both RGBA and Basic encoding
  			this.renderOverride( renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0 );

  		}

  		if ( this.supportsNormalTexture ) {

  			// Clear rule : default normal is facing the camera
  			this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );

  		}

  		// Rendering SAO texture
  		this.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

  		// Blurring SAO texture
  		if ( this.params.saoBlur ) {

  			this.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );
  			this.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );

  		}

  		var outputMaterial = this.materialCopy;
  		// Setting up SAO rendering
  		if ( this.params.output === 3 ) {

  			if ( this.supportsDepthTextureExtension ) {

  				this.materialCopy.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.depthTexture;
  				this.materialCopy.needsUpdate = true;

  			} else {

  				this.depthCopy.uniforms[ 'tDiffuse' ].value = this.depthRenderTarget.texture;
  				this.depthCopy.needsUpdate = true;
  				outputMaterial = this.depthCopy;

  			}

  		} else if ( this.params.output === 4 ) {

  			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
  			this.materialCopy.needsUpdate = true;

  		} else {

  			this.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;
  			this.materialCopy.needsUpdate = true;

  		}

  		// Blending depends on output, only want a CustomBlending when showing SAO
  		if ( this.params.output === 0 ) {

  			outputMaterial.blending = CustomBlending;

  		} else {

  			outputMaterial.blending = NoBlending;

  		}

  		// Rendering SAOPass result on top of previous pass
  		this.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );

  		renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
  		renderer.autoClear = oldAutoClear;

  	},

  	renderPass: function ( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

  		// save original state
  		this.originalClearColor.copy( renderer.getClearColor() );
  		var originalClearAlpha = renderer.getClearAlpha();
  		var originalAutoClear = renderer.autoClear;

  		renderer.setRenderTarget( renderTarget );

  		// setup pass state
  		renderer.autoClear = false;
  		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

  			renderer.setClearColor( clearColor );
  			renderer.setClearAlpha( clearAlpha || 0.0 );
  			renderer.clear();

  		}

  		this.quad.material = passMaterial;
  		renderer.render( this.quadScene, this.quadCamera );

  		// restore original state
  		renderer.autoClear = originalAutoClear;
  		renderer.setClearColor( this.originalClearColor );
  		renderer.setClearAlpha( originalClearAlpha );

  	},

  	renderOverride: function ( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

  		this.originalClearColor.copy( renderer.getClearColor() );
  		var originalClearAlpha = renderer.getClearAlpha();
  		var originalAutoClear = renderer.autoClear;

  		renderer.setRenderTarget( renderTarget );
  		renderer.autoClear = false;

  		clearColor = overrideMaterial.clearColor || clearColor;
  		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
  		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

  			renderer.setClearColor( clearColor );
  			renderer.setClearAlpha( clearAlpha || 0.0 );
  			renderer.clear();

  		}

  		this.scene.overrideMaterial = overrideMaterial;
  		renderer.render( this.scene, this.camera );
  		this.scene.overrideMaterial = null;

  		// restore original state
  		renderer.autoClear = originalAutoClear;
  		renderer.setClearColor( this.originalClearColor );
  		renderer.setClearAlpha( originalClearAlpha );

  	},

  	setSize: function ( width, height ) {

  		this.beautyRenderTarget.setSize( width, height );
  		this.saoRenderTarget.setSize( width, height );
  		this.blurIntermediateRenderTarget.setSize( width, height );
  		this.normalRenderTarget.setSize( width, height );
  		this.depthRenderTarget.setSize( width, height );

  		this.saoMaterial.uniforms[ 'size' ].value.set( width, height );
  		this.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );
  		this.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;
  		this.saoMaterial.needsUpdate = true;

  		this.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );
  		this.vBlurMaterial.needsUpdate = true;

  		this.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );
  		this.hBlurMaterial.needsUpdate = true;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SavePass = function ( renderTarget ) {

  	Pass.call( this );

  	if ( CopyShader === undefined )
  		{ console.error( "SavePass relies on CopyShader" ); }

  	var shader = CopyShader;

  	this.textureID = "tDiffuse";

  	this.uniforms = UniformsUtils.clone( shader.uniforms );

  	this.material = new ShaderMaterial( {

  		uniforms: this.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader

  	} );

  	this.renderTarget = renderTarget;

  	if ( this.renderTarget === undefined ) {

  		this.renderTarget = new WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat, stencilBuffer: false } );
  		this.renderTarget.texture.name = "SavePass.rt";

  	}

  	this.needsSwap = false;

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  SavePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: SavePass,

  	render: function ( renderer, writeBuffer, readBuffer ) {

  		if ( this.uniforms[ this.textureID ] ) {

  			this.uniforms[ this.textureID ].value = readBuffer.texture;

  		}

  		this.quad.material = this.material;

  		renderer.setRenderTarget( this.renderTarget );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SMAAShader = [ {

  	defines: {

  		"SMAA_THRESHOLD": "0.1"

  	},

  	uniforms: {

  		"tDiffuse":		{ value: null },
  		"resolution":	{ value: new Vector2( 1 / 1024, 1 / 512 ) }

  	},

  	vertexShader: [

  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[ 3 ];",

  		"void SMAAEdgeDetectionVS( vec2 texcoord ) {",
  			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", // WebGL port note: Changed sign in W component
  			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
  			"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", // WebGL port note: Changed sign in W component
  		"}",

  		"void main() {",

  			"vUv = uv;",

  			"SMAAEdgeDetectionVS( vUv );",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join("\n"),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[ 3 ];",

  		"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
  			"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",

  			// Calculate color deltas:
  			"vec4 delta;",
  			"vec3 C = texture2D( colorTex, texcoord ).rgb;",

  			"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
  			"vec3 t = abs( C - Cleft );",
  			"delta.x = max( max( t.r, t.g ), t.b );",

  			"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
  			"t = abs( C - Ctop );",
  			"delta.y = max( max( t.r, t.g ), t.b );",

  			// We do the usual threshold:
  			"vec2 edges = step( threshold, delta.xy );",

  			// Then discard if there is no edge:
  			"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
  				"discard;",

  			// Calculate right and bottom deltas:
  			"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
  			"t = abs( C - Cright );",
  			"delta.z = max( max( t.r, t.g ), t.b );",

  			"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
  			"t = abs( C - Cbottom );",
  			"delta.w = max( max( t.r, t.g ), t.b );",

  			// Calculate the maximum delta in the direct neighborhood:
  			"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",

  			// Calculate left-left and top-top deltas:
  			"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
  			"t = abs( C - Cleftleft );",
  			"delta.z = max( max( t.r, t.g ), t.b );",

  			"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
  			"t = abs( C - Ctoptop );",
  			"delta.w = max( max( t.r, t.g ), t.b );",

  			// Calculate the final maximum delta:
  			"maxDelta = max( max( maxDelta, delta.z ), delta.w );",

  			// Local contrast adaptation in action:
  			"edges.xy *= step( 0.5 * maxDelta, delta.xy );",

  			"return vec4( edges, 0.0, 0.0 );",
  		"}",

  		"void main() {",

  			"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",

  		"}"

  	].join("\n")

  }, {

  	defines: {

  		"SMAA_MAX_SEARCH_STEPS":		"8",
  		"SMAA_AREATEX_MAX_DISTANCE":	"16",
  		"SMAA_AREATEX_PIXEL_SIZE":		"( 1.0 / vec2( 160.0, 560.0 ) )",
  		"SMAA_AREATEX_SUBTEX_SIZE":		"( 1.0 / 7.0 )"

  	},

  	uniforms: {

  		"tDiffuse":		{ value: null },
  		"tArea":		{ value: null },
  		"tSearch":		{ value: null },
  		"resolution":	{ value: new Vector2( 1 / 1024, 1 / 512 ) }

  	},

  	vertexShader: [

  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[ 3 ];",
  		"varying vec2 vPixcoord;",

  		"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
  			"vPixcoord = texcoord / resolution;",

  			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
  			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", // WebGL port note: Changed sign in Y and W components
  			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", // WebGL port note: Changed sign in Y and W components

  			// And these for the searches, they indicate the ends of the loops:
  			"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",

  		"}",

  		"void main() {",

  			"vUv = uv;",

  			"SMAABlendingWeightCalculationVS( vUv );",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join("\n"),

  	fragmentShader: [

  		"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",

  		"uniform sampler2D tDiffuse;",
  		"uniform sampler2D tArea;",
  		"uniform sampler2D tSearch;",
  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[3];",
  		"varying vec2 vPixcoord;",

  		"vec2 round( vec2 x ) {",
  			"return sign( x ) * floor( abs( x ) + 0.5 );",
  		"}",

  		"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
  			// Not required if searchTex accesses are set to point:
  			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
  			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
  			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
  			"e.r = bias + e.r * scale;",
  			"return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
  		"}",

  		"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
  			
  			"vec2 e = vec2( 0.0, 1.0 );",

  			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
  				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
  				"texcoord -= vec2( 2.0, 0.0 ) * resolution;",
  				"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
  			"}",

  			// We correct the previous (-0.25, -0.125) offset we applied:
  			"texcoord.x += 0.25 * resolution.x;",

  			// The searches are bias by 1, so adjust the coords accordingly:
  			"texcoord.x += resolution.x;",

  			// Disambiguate the length added by the last step:
  			"texcoord.x += 2.0 * resolution.x;", // Undo last step
  			"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",

  			"return texcoord.x;",
  		"}",

  		"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
  			"vec2 e = vec2( 0.0, 1.0 );",

  			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
  				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
  				"texcoord += vec2( 2.0, 0.0 ) * resolution;",
  				"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
  			"}",

  			"texcoord.x -= 0.25 * resolution.x;",
  			"texcoord.x -= resolution.x;",
  			"texcoord.x -= 2.0 * resolution.x;",
  			"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",

  			"return texcoord.x;",
  		"}",

  		"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
  			"vec2 e = vec2( 1.0, 0.0 );",

  			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
  				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
  				"texcoord += vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
  				"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
  			"}",

  			"texcoord.y -= 0.25 * resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y -= resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y -= 2.0 * resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", // WebGL port note: Changed sign

  			"return texcoord.y;",
  		"}",

  		"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
  			"vec2 e = vec2( 1.0, 0.0 );",

  			"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
  				"e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
  				"texcoord -= vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
  				"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
  			"}",

  			"texcoord.y += 0.25 * resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y += resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y += 2.0 * resolution.y;", // WebGL port note: Changed sign
  			"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", // WebGL port note: Changed sign

  			"return texcoord.y;",
  		"}",

  		"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
  			// Rounding prevents precision errors of bilinear filtering:
  			"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",

  			// We do a scale and bias for mapping to texel space:
  			"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",

  			// Move to proper place, according to the subpixel offset:
  			"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",

  			"return texture2D( areaTex, texcoord, 0.0 ).rg;",
  		"}",

  		"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
  			"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",

  			"vec2 e = texture2D( edgesTex, texcoord ).rg;",

  			"if ( e.g > 0.0 ) {", // Edge at north
  				"vec2 d;",

  				// Find the distance to the left:
  				"vec2 coords;",
  				"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
  				"coords.y = offset[ 1 ].y;", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
  				"d.x = coords.x;",

  				// Now fetch the left crossing edges, two at a time using bilinear
  				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
  				// discern what value each edge has:
  				"float e1 = texture2D( edgesTex, coords, 0.0 ).r;",

  				// Find the distance to the right:
  				"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
  				"d.y = coords.x;",

  				// We want the distances to be in pixel units (doing this here allow to
  				// better interleave arithmetic and memory accesses):
  				"d = d / resolution.x - pixcoord.x;",

  				// SMAAArea below needs a sqrt, as the areas texture is compressed
  				// quadratically:
  				"vec2 sqrt_d = sqrt( abs( d ) );",

  				// Fetch the right crossing edges:
  				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
  				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",

  				// Ok, we know how this pattern looks like, now it is time for getting
  				// the actual area:
  				"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
  			"}",

  			"if ( e.r > 0.0 ) {", // Edge at west
  				"vec2 d;",

  				// Find the distance to the top:
  				"vec2 coords;",

  				"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
  				"coords.x = offset[ 0 ].x;", // offset[1].x = texcoord.x - 0.25 * resolution.x;
  				"d.x = coords.y;",

  				// Fetch the top crossing edges:
  				"float e1 = texture2D( edgesTex, coords, 0.0 ).g;",

  				// Find the distance to the bottom:
  				"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
  				"d.y = coords.y;",

  				// We want the distances to be in pixel units:
  				"d = d / resolution.y - pixcoord.y;",

  				// SMAAArea below needs a sqrt, as the areas texture is compressed
  				// quadratically:
  				"vec2 sqrt_d = sqrt( abs( d ) );",

  				// Fetch the bottom crossing edges:
  				"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
  				"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",

  				// Get the area for this direction:
  				"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
  			"}",

  			"return weights;",
  		"}",

  		"void main() {",

  			"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",

  		"}"

  	].join("\n")

  }, {

  	uniforms: {

  		"tDiffuse":		{ value: null },
  		"tColor":		{ value: null },
  		"resolution":	{ value: new Vector2( 1 / 1024, 1 / 512 ) }

  	},

  	vertexShader: [

  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[ 2 ];",

  		"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
  			"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", // WebGL port note: Changed sign in W component
  			"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
  		"}",

  		"void main() {",

  			"vUv = uv;",

  			"SMAANeighborhoodBlendingVS( vUv );",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join("\n"),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform sampler2D tColor;",
  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",
  		"varying vec4 vOffset[ 2 ];",

  		"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
  			// Fetch the blending weights for current pixel:
  			"vec4 a;",
  			"a.xz = texture2D( blendTex, texcoord ).xz;",
  			"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
  			"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",

  			// Is there any blending weight with a value greater than 0.0?
  			"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
  				"return texture2D( colorTex, texcoord, 0.0 );",
  			"} else {",
  				// Up to 4 lines can be crossing a pixel (one through each edge). We
  				// favor blending by choosing the line with the maximum weight for each
  				// direction:
  				"vec2 offset;",
  				"offset.x = a.a > a.b ? a.a : -a.b;", // left vs. right
  				"offset.y = a.g > a.r ? -a.g : a.r;", // top vs. bottom // WebGL port note: Changed signs

  				// Then we go in the direction that has the maximum weight:
  				"if ( abs( offset.x ) > abs( offset.y )) {", // horizontal vs. vertical
  					"offset.y = 0.0;",
  				"} else {",
  					"offset.x = 0.0;",
  				"}",

  				// Fetch the opposite color and lerp by hand:
  				"vec4 C = texture2D( colorTex, texcoord, 0.0 );",
  				"texcoord += sign( offset ) * resolution;",
  				"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
  				"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",

  				// WebGL port note: Added gamma correction
  				"C.xyz = pow(C.xyz, vec3(2.2));",
  				"Cop.xyz = pow(Cop.xyz, vec3(2.2));",
  				"vec4 mixed = mix(C, Cop, s);",
  				"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",

  				"return mixed;",
  			"}",
  		"}",

  		"void main() {",

  			"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",

  		"}"

  	].join("\n")

  } ];

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SMAAPass = function ( width, height ) {

  	Pass.call( this );

  	// render targets

  	this.edgesRT = new WebGLRenderTarget( width, height, {
  		depthBuffer: false,
  		stencilBuffer: false,
  		generateMipmaps: false,
  		minFilter: LinearFilter,
  		format: RGBFormat
  	} );
  	this.edgesRT.texture.name = "SMAAPass.edges";

  	this.weightsRT = new WebGLRenderTarget( width, height, {
  		depthBuffer: false,
  		stencilBuffer: false,
  		generateMipmaps: false,
  		minFilter: LinearFilter,
  		format: RGBAFormat
  	} );
  	this.weightsRT.texture.name = "SMAAPass.weights";

  	// textures
  	var scope = this;

  	var areaTextureImage = new Image();
  	areaTextureImage.src = this.getAreaTexture();
  	areaTextureImage.onload = function () {

  		// assigning data to HTMLImageElement.src is asynchronous (see #15162)
  		scope.areaTexture.needsUpdate = true;

  	};

  	this.areaTexture = new Texture();
  	this.areaTexture.name = "SMAAPass.area";
  	this.areaTexture.image = areaTextureImage;
  	this.areaTexture.format = RGBFormat;
  	this.areaTexture.minFilter = LinearFilter;
  	this.areaTexture.generateMipmaps = false;
  	this.areaTexture.flipY = false;

  	var searchTextureImage = new Image();
  	searchTextureImage.src = this.getSearchTexture();
  	searchTextureImage.onload = function() {
  		// assigning data to HTMLImageElement.src is asynchronous (see #15162)
  		scope.searchTexture.needsUpdate = true;
  	};

  	this.searchTexture = new Texture();
  	this.searchTexture.name = "SMAAPass.search";
  	this.searchTexture.image = searchTextureImage;
  	this.searchTexture.magFilter = NearestFilter;
  	this.searchTexture.minFilter = NearestFilter;
  	this.searchTexture.generateMipmaps = false;
  	this.searchTexture.flipY = false;

  	// materials - pass 1

  	if ( SMAAShader === undefined ) {
  		console.error( "SMAAPass relies on SMAAShader" );
  	}

  	this.uniformsEdges = UniformsUtils.clone( SMAAShader[0].uniforms );

  	this.uniformsEdges[ "resolution" ].value.set( 1 / width, 1 / height );

  	this.materialEdges = new ShaderMaterial( {
  		defines: Object.assign( {}, SMAAShader[ 0 ].defines ),
  		uniforms: this.uniformsEdges,
  		vertexShader: SMAAShader[0].vertexShader,
  		fragmentShader: SMAAShader[0].fragmentShader
  	} );

  	// materials - pass 2

  	this.uniformsWeights = UniformsUtils.clone( SMAAShader[1].uniforms );

  	this.uniformsWeights[ "resolution" ].value.set( 1 / width, 1 / height );
  	this.uniformsWeights[ "tDiffuse" ].value = this.edgesRT.texture;
  	this.uniformsWeights[ "tArea" ].value = this.areaTexture;
  	this.uniformsWeights[ "tSearch" ].value = this.searchTexture;

  	this.materialWeights = new ShaderMaterial( {
  		defines: Object.assign( {}, SMAAShader[ 1 ].defines ),
  		uniforms: this.uniformsWeights,
  		vertexShader: SMAAShader[1].vertexShader,
  		fragmentShader: SMAAShader[1].fragmentShader
  	} );

  	// materials - pass 3

  	this.uniformsBlend = UniformsUtils.clone( SMAAShader[2].uniforms );

  	this.uniformsBlend[ "resolution" ].value.set( 1 / width, 1 / height );
  	this.uniformsBlend[ "tDiffuse" ].value = this.weightsRT.texture;

  	this.materialBlend = new ShaderMaterial( {
  		uniforms: this.uniformsBlend,
  		vertexShader: SMAAShader[2].vertexShader,
  		fragmentShader: SMAAShader[2].fragmentShader
  	} );

  	this.needsSwap = false;

  	this.camera = new OrthographicCamera( -1, 1, 1, -1, 0, 1 );
  	this.scene  = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  SMAAPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: SMAAPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		// pass 1

  		this.uniformsEdges[ "tDiffuse" ].value = readBuffer.texture;

  		this.quad.material = this.materialEdges;

  		renderer.setRenderTarget( this.edgesRT );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  		// pass 2

  		this.quad.material = this.materialWeights;

  		renderer.setRenderTarget( this.weightsRT );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  		// pass 3

  		this.uniformsBlend[ "tColor" ].value = readBuffer.texture;

  		this.quad.material = this.materialBlend;

  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( writeBuffer );
  			if ( this.clear ) { renderer.clear(); }
  			renderer.render( this.scene, this.camera );

  		}

  	},

  	setSize: function ( width, height ) {

  		this.edgesRT.setSize( width, height );
  		this.weightsRT.setSize( width, height );

  		this.materialEdges.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
  		this.materialWeights.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );
  		this.materialBlend.uniforms[ 'resolution' ].value.set( 1 / width, 1 / height );

  	},

  	getAreaTexture: function () {
  		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';
  	},

  	getSearchTexture: function () {
  		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';
  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {

  	Pass.call( this );

  	this.scene = scene;
  	this.camera = camera;

  	this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
  	this.unbiased = true;

  	// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
  	this.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;
  	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

  	if ( CopyShader === undefined ) { console.error( "SSAARenderPass relies on CopyShader" ); }

  	var copyShader = CopyShader;
  	this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );

  	this.copyMaterial = new ShaderMaterial(	{
  		uniforms: this.copyUniforms,
  		vertexShader: copyShader.vertexShader,
  		fragmentShader: copyShader.fragmentShader,
  		premultipliedAlpha: true,
  		transparent: true,
  		blending: AdditiveBlending,
  		depthTest: false,
  		depthWrite: false
  	} );

  	this.camera2 = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene2	= new Scene();
  	this.quad2 = new Mesh( new PlaneBufferGeometry( 2, 2 ), this.copyMaterial );
  	this.quad2.frustumCulled = false; // Avoid getting clipped
  	this.scene2.add( this.quad2 );

  };

  SSAARenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: SSAARenderPass,

  	dispose: function () {

  		if ( this.sampleRenderTarget ) {

  			this.sampleRenderTarget.dispose();
  			this.sampleRenderTarget = null;

  		}

  	},

  	setSize: function ( width, height ) {

  		if ( this.sampleRenderTarget )	{ this.sampleRenderTarget.setSize( width, height ); }

  	},

  	render: function ( renderer, writeBuffer, readBuffer ) {
  		var this$1 = this;


  		if ( ! this.sampleRenderTarget ) {

  			this.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat } );
  			this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";

  		}

  		var jitterOffsets = SSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];

  		var autoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		var oldClearColor = renderer.getClearColor().getHex();
  		var oldClearAlpha = renderer.getClearAlpha();

  		var baseSampleWeight = 1.0 / jitterOffsets.length;
  		var roundingRange = 1 / 32;
  		this.copyUniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;

  		var width = readBuffer.width, height = readBuffer.height;

  		// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
  		for ( var i = 0; i < jitterOffsets.length; i ++ ) {

  			var jitterOffset = jitterOffsets[ i ];

  			if ( this$1.camera.setViewOffset ) {

  				this$1.camera.setViewOffset( width, height,
  					jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16
  					width, height );

  			}

  			var sampleWeight = baseSampleWeight;

  			if ( this$1.unbiased ) {

  				// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
  				// The following equation varies the sampleWeight per sample so that it is uniformly distributed
  				// across a range of values whose rounding errors cancel each other out.

  				var uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );
  				sampleWeight += roundingRange * uniformCenteredDistribution;

  			}

  			this$1.copyUniforms[ "opacity" ].value = sampleWeight;
  			renderer.setClearColor( this$1.clearColor, this$1.clearAlpha );
  			renderer.setRenderTarget( this$1.sampleRenderTarget );
  			renderer.clear();
  			renderer.render( this$1.scene, this$1.camera );

  			renderer.setRenderTarget( this$1.renderToScreen ? null : writeBuffer );

  			if ( i === 0 ) {

  				renderer.setClearColor( 0x000000, 0.0 );
  				renderer.clear();

  			}

  			renderer.render( this$1.scene2, this$1.camera2 );

  		}

  		if ( this.camera.clearViewOffset ) { this.camera.clearViewOffset(); }

  		renderer.autoClear = autoClear;
  		renderer.setClearColor( oldClearColor, oldClearAlpha );

  	}

  } );
  // These jitter vectors are specified in integers because it is easier.
  // I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
  // before being used, thus these integers need to be scaled by 1/16.
  //
  // Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
  SSAARenderPass.JitterVectors = [
  	[
  		[ 0, 0 ]
  	],
  	[
  		[ 4, 4 ], [ - 4, - 4 ]
  	],
  	[
  		[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]
  	],
  	[
  		[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],
  		[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]
  	],
  	[
  		[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],
  		[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],
  		[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],
  		[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]
  	],
  	[
  		[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],
  		[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],
  		[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],
  		[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],
  		[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],
  		[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],
  		[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],
  		[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]
  	]
  ];

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SSAOShader = {

  	defines: {
  		"PERSPECTIVE_CAMERA": 1,
  		"KERNEL_SIZE": 32
  	},

  	uniforms: {

  		"tDiffuse": { value: null },
  		"tNormal": { value: null },
  		"tDepth": { value: null },
  		"tNoise": { value: null },
  		"kernel": { value: null },
  		"cameraNear": { value: null },
  		"cameraFar": { value: null },
  		"resolution": { value: new Vector2() },
  		"cameraProjectionMatrix": { value: new Matrix4() },
  		"cameraInverseProjectionMatrix": { value: new Matrix4() },
  		"kernelRadius": { value: 8 },
  		"minDistance": { value: 0.005 },
  		"maxDistance": { value: 0.05 },

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  		"	vUv = uv;",

  		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform sampler2D tNormal;",
  		"uniform sampler2D tDepth;",
  		"uniform sampler2D tNoise;",

  		"uniform vec3 kernel[ KERNEL_SIZE ];",

  		"uniform vec2 resolution;",

  		"uniform float cameraNear;",
  		"uniform float cameraFar;",
  		"uniform mat4 cameraProjectionMatrix;",
  		"uniform mat4 cameraInverseProjectionMatrix;",

  		"uniform float kernelRadius;",
  		"uniform float minDistance;", // avoid artifacts caused by neighbour fragments with minimal depth difference
  		"uniform float maxDistance;", // avoid the influence of fragments which are too far away

  		"varying vec2 vUv;",

  		"#include <packing>",

  		"float getDepth( const in vec2 screenPosition ) {",

  		"	return texture2D( tDepth, screenPosition ).x;",

  		"}",

  		"float getLinearDepth( const in vec2 screenPosition ) {",

  		"	#if PERSPECTIVE_CAMERA == 1",

  		"		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
  		"		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
  		"		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",

  		"	#else",

  		"		return texture2D( depthSampler, coord ).x;",

  		"	#endif",

  		"}",

  		"float getViewZ( const in float depth ) {",

  		"	#if PERSPECTIVE_CAMERA == 1",

  		"		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",

  		"	#else",

  		"		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",

  		"	#endif",

  		"}",

  		"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",

  		"	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",

  		"	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",

  		"	clipPosition *= clipW; // unprojection.",

  		"	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",

  		"}",

  		"vec3 getViewNormal( const in vec2 screenPosition ) {",

  		"	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",

  		"}",

  		"void main() {",

  		"	float depth = getDepth( vUv );",
  		"	float viewZ = getViewZ( depth );",

  		"	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );",
  		"	vec3 viewNormal = getViewNormal( vUv );",

  		" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );",
  		"	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;",

  		// compute matrix used to reorient a kernel vector

  		"	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );",
  		"	vec3 bitangent = cross( viewNormal, tangent );",
  		"	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );",

  		" float occlusion = 0.0;",

  		" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {",

  		"		vec3 sampleVector = kernelMatrix * kernel[ i ];", // reorient sample vector in view space
  		"		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );", // calculate sample point

  		"		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );", // project point and calculate NDC
  		"		samplePointNDC /= samplePointNDC.w;",

  		"		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;", // compute uv coordinates

  		"		float realDepth = getLinearDepth( samplePointUv );", // get linear depth from depth texture
  		"		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );", // compute linear depth of the sample view Z value
  		"		float delta = sampleDepth - realDepth;",

  		"		if ( delta > minDistance && delta < maxDistance ) {", // if fragment is before sample point, increase occlusion

  		"			occlusion += 1.0;",

  		"		}",

  		"	}",

  		"	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );",

  		"	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );",

  		"}"

  	].join( "\n" )

  };

  var SSAODepthShader = {

  	defines: {
  		"PERSPECTIVE_CAMERA": 1
  	},

  	uniforms: {

  		"tDepth": { value: null },
  		"cameraNear": { value: null },
  		"cameraFar": { value: null },

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  		"	vUv = uv;",
  		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDepth;",

  		"uniform float cameraNear;",
  		"uniform float cameraFar;",

  		"varying vec2 vUv;",

  		"#include <packing>",

  		"float getLinearDepth( const in vec2 screenPosition ) {",

  		"	#if PERSPECTIVE_CAMERA == 1",

  		"		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
  		"		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
  		"		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",

  		"	#else",

  		"		return texture2D( depthSampler, coord ).x;",

  		"	#endif",

  		"}",

  		"void main() {",

  		"	float depth = getLinearDepth( vUv );",
  		"	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );",

  		"}"

  	].join( "\n" )

  };

  var SSAOBlurShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"resolution": { value: new Vector2() }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  		"	vUv = uv;",
  		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",

  		"uniform vec2 resolution;",

  		"varying vec2 vUv;",

  		"void main() {",

  		"	vec2 texelSize = ( 1.0 / resolution );",
  		"	float result = 0.0;",

  		"	for ( int i = - 2; i <= 2; i ++ ) {",

  		"		for ( int j = - 2; j <= 2; j ++ ) {",

  		"			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;",
  		"			result += texture2D( tDiffuse, vUv + offset ).r;",

  		"		}",

  		"	}",

  		"	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SSAOPass = function ( scene, camera, width, height ) {

  	Pass.call( this );

  	this.width = ( width !== undefined ) ? width : 512;
  	this.height = ( height !== undefined ) ? height : 512;

  	this.clear = true;

  	this.camera = camera;
  	this.scene = scene;

  	this.kernelRadius = 8;
  	this.kernelSize = 32;
  	this.kernel = [];
  	this.noiseTexture = null;
  	this.output = 0;

  	this.minDistance = 0.005;
  	this.maxDistance = 0.1;

  	//

  	this.generateSampleKernel();
  	this.generateRandomKernelRotations();

  	// beauty render target with depth buffer

  	var depthTexture = new DepthTexture();
  	depthTexture.type = UnsignedShortType;
  	depthTexture.minFilter = NearestFilter;
  	depthTexture.maxFilter = NearestFilter;

  	this.beautyRenderTarget = new WebGLRenderTarget( this.width, this.height, {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBAFormat,
  		depthTexture: depthTexture,
  		depthBuffer: true
  	} );

  	// normal render target

  	this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {
  		minFilter: NearestFilter,
  		magFilter: NearestFilter,
  		format: RGBAFormat
  	} );

  	// ssao render target

  	this.ssaoRenderTarget = new WebGLRenderTarget( this.width, this.height, {
  		minFilter: LinearFilter,
  		magFilter: LinearFilter,
  		format: RGBAFormat
  	} );

  	this.blurRenderTarget = this.ssaoRenderTarget.clone();

  	// ssao material

  	if ( SSAOShader === undefined ) {

  		console.error( 'SSAOPass: The pass relies on SSAOShader.' );

  	}

  	this.ssaoMaterial = new ShaderMaterial( {
  		defines: Object.assign( {}, SSAOShader.defines ),
  		uniforms: UniformsUtils.clone( SSAOShader.uniforms ),
  		vertexShader: SSAOShader.vertexShader,
  		fragmentShader: SSAOShader.fragmentShader,
  		blending: NoBlending
  	} );

  	this.ssaoMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
  	this.ssaoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;
  	this.ssaoMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;
  	this.ssaoMaterial.uniforms[ 'tNoise' ].value = this.noiseTexture;
  	this.ssaoMaterial.uniforms[ 'kernel' ].value = this.kernel;
  	this.ssaoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
  	this.ssaoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;
  	this.ssaoMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );
  	this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
  	this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );

  	// normal material

  	this.normalMaterial = new MeshNormalMaterial();
  	this.normalMaterial.blending = NoBlending;

  	// blur material

  	this.blurMaterial = new ShaderMaterial( {
  		defines: Object.assign( {}, SSAOBlurShader.defines ),
  		uniforms: UniformsUtils.clone( SSAOBlurShader.uniforms ),
  		vertexShader: SSAOBlurShader.vertexShader,
  		fragmentShader: SSAOBlurShader.fragmentShader
  	} );
  	this.blurMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
  	this.blurMaterial.uniforms[ 'resolution' ].value.set( this.width, this.height );

  	// material for rendering the depth

  	this.depthRenderMaterial = new ShaderMaterial( {
  		defines: Object.assign( {}, SSAODepthShader.defines ),
  		uniforms: UniformsUtils.clone( SSAODepthShader.uniforms ),
  		vertexShader: SSAODepthShader.vertexShader,
  		fragmentShader: SSAODepthShader.fragmentShader,
  		blending: NoBlending
  	} );
  	this.depthRenderMaterial.uniforms[ 'tDepth' ].value = this.beautyRenderTarget.depthTexture;
  	this.depthRenderMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;
  	this.depthRenderMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;

  	// material for rendering the content of a render target

  	this.copyMaterial = new ShaderMaterial( {
  		uniforms: UniformsUtils.clone( CopyShader.uniforms ),
  		vertexShader: CopyShader.vertexShader,
  		fragmentShader: CopyShader.fragmentShader,
  		transparent: true,
  		depthTest: false,
  		depthWrite: false,
  		blendSrc: DstColorFactor,
  		blendDst: ZeroFactor,
  		blendEquation: AddEquation,
  		blendSrcAlpha: DstAlphaFactor,
  		blendDstAlpha: ZeroFactor,
  		blendEquationAlpha: AddEquation
  	} );

  	//

  	this.quadCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.quadScene = new Scene();
  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quadScene.add( this.quad );

  	//

  	this.originalClearColor = new Color();

  };

  SSAOPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: SSAOPass,

  	dispose: function () {

  		// dispose render targets

  		this.beautyRenderTarget.dispose();
  		this.normalRenderTarget.dispose();
  		this.ssaoRenderTarget.dispose();
  		this.blurRenderTarget.dispose();

  		// dispose geometry

  		this.quad.geometry.dispose();

  		// dispose materials

  		this.normalMaterial.dispose();
  		this.blurMaterial.dispose();
  		this.copyMaterial.dispose();
  		this.depthRenderMaterial.dispose();

  	},

  	render: function ( renderer, writeBuffer  ) {

  		// render beauty and depth

  		renderer.setRenderTarget( this.beautyRenderTarget );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// render normals

  		this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );

  		// render SSAO

  		this.ssaoMaterial.uniforms[ 'kernelRadius' ].value = this.kernelRadius;
  		this.ssaoMaterial.uniforms[ 'minDistance' ].value = this.minDistance;
  		this.ssaoMaterial.uniforms[ 'maxDistance' ].value = this.maxDistance;
  		this.renderPass( renderer, this.ssaoMaterial, this.ssaoRenderTarget );

  		// render blur

  		this.renderPass( renderer, this.blurMaterial, this.blurRenderTarget );

  		// output result to screen

  		switch ( this.output ) {

  			case SSAOPass.OUTPUT.SSAO:

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.ssaoRenderTarget.texture;
  				this.copyMaterial.blending = NoBlending;
  				this.renderPass( renderer, this.copyMaterial, null );

  				break;

  			case SSAOPass.OUTPUT.Blur:

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
  				this.copyMaterial.blending = NoBlending;
  				this.renderPass( renderer, this.copyMaterial, null );

  				break;

  			case SSAOPass.OUTPUT.Beauty:

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
  				this.copyMaterial.blending = NoBlending;
  				this.renderPass( renderer, this.copyMaterial, null );

  				break;

  			case SSAOPass.OUTPUT.Depth:

  				this.renderPass( renderer, this.depthRenderMaterial, null );

  				break;

  			case SSAOPass.OUTPUT.Normal:

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;
  				this.copyMaterial.blending = NoBlending;
  				this.renderPass( renderer, this.copyMaterial, null );

  				break;

  			case SSAOPass.OUTPUT.Default:

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.texture;
  				this.copyMaterial.blending = NoBlending;
  				this.renderPass( renderer, this.copyMaterial, null );

  				this.copyMaterial.uniforms[ 'tDiffuse' ].value = this.blurRenderTarget.texture;
  				this.copyMaterial.blending = CustomBlending;
  				this.renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );

  				break;

  			default:
  				console.warn( 'SSAOPass: Unknown output type.' );

  		}

  	},

  	renderPass: function ( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {

  		// save original state
  		this.originalClearColor.copy( renderer.getClearColor() );
  		var originalClearAlpha = renderer.getClearAlpha();
  		var originalAutoClear = renderer.autoClear;

  		renderer.setRenderTarget( renderTarget );

  		// setup pass state
  		renderer.autoClear = false;
  		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

  			renderer.setClearColor( clearColor );
  			renderer.setClearAlpha( clearAlpha || 0.0 );
  			renderer.clear();

  		}

  		this.quad.material = passMaterial;
  		renderer.render( this.quadScene, this.quadCamera );

  		// restore original state
  		renderer.autoClear = originalAutoClear;
  		renderer.setClearColor( this.originalClearColor );
  		renderer.setClearAlpha( originalClearAlpha );

  	},

  	renderOverride: function ( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {

  		this.originalClearColor.copy( renderer.getClearColor() );
  		var originalClearAlpha = renderer.getClearAlpha();
  		var originalAutoClear = renderer.autoClear;

  		renderer.setRenderTarget( renderTarget );
  		renderer.autoClear = false;

  		clearColor = overrideMaterial.clearColor || clearColor;
  		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;

  		if ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {

  			renderer.setClearColor( clearColor );
  			renderer.setClearAlpha( clearAlpha || 0.0 );
  			renderer.clear();

  		}

  		this.scene.overrideMaterial = overrideMaterial;
  		renderer.render( this.scene, this.camera );
  		this.scene.overrideMaterial = null;

  		// restore original state

  		renderer.autoClear = originalAutoClear;
  		renderer.setClearColor( this.originalClearColor );
  		renderer.setClearAlpha( originalClearAlpha );

  	},

  	setSize: function ( width, height ) {

  		this.width = width;
  		this.height = height;

  		this.beautyRenderTarget.setSize( width, height );
  		this.ssaoRenderTarget.setSize( width, height );
  		this.normalRenderTarget.setSize( width, height );
  		this.blurRenderTarget.setSize( width, height );

  		this.ssaoMaterial.uniforms[ 'resolution' ].value.set( width, height );
  		this.ssaoMaterial.uniforms[ 'cameraProjectionMatrix' ].value.copy( this.camera.projectionMatrix );
  		this.ssaoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );

  		this.blurMaterial.uniforms[ 'resolution' ].value.set( width, height );

  	},

  	generateSampleKernel: function () {

  		var kernelSize = this.kernelSize;
  		var kernel = this.kernel;

  		for ( var i = 0; i < kernelSize; i ++ ) {

  			var sample = new Vector3();
  			sample.x = ( Math.random() * 2 ) - 1;
  			sample.y = ( Math.random() * 2 ) - 1;
  			sample.z = Math.random();

  			sample.normalize();

  			var scale = i / kernelSize;
  			scale = _Math.lerp( 0.1, 1, scale * scale );
  			sample.multiplyScalar( scale );

  			kernel.push( sample );

  		}

  	},

  	generateRandomKernelRotations: function () {

  		var width = 4, height = 4;

  		if ( SimplexNoise === undefined ) {

  			console.error( 'SSAOPass: The pass relies on SimplexNoise.' );

  		}

  		var simplex = new SimplexNoise();

  		var size = width * height;
  		var data = new Float32Array( size * 4 );

  		for ( var i = 0; i < size; i ++ ) {

  			var stride = i * 4;

  			var x = ( Math.random() * 2 ) - 1;
  			var y = ( Math.random() * 2 ) - 1;
  			var z = 0;

  			var noise = simplex.noise3d( x, y, z );

  			data[ stride ] = noise;
  			data[ stride + 1 ] = noise;
  			data[ stride + 2 ] = noise;
  			data[ stride + 3 ] = 1;

  		}

  		this.noiseTexture = new DataTexture( data, width, height, RGBAFormat, FloatType );
  		this.noiseTexture.wrapS = RepeatWrapping;
  		this.noiseTexture.wrapT = RepeatWrapping;
  		this.noiseTexture.needsUpdate = true;

  	}

  } );

  SSAOPass.OUTPUT = {
  	'Default': 0,
  	'SSAO': 1,
  	'Blur': 2,
  	'Beauty': 3,
  	'Depth': 4,
  	'Normal': 5
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TAARenderPass = function ( scene, camera, params ) {

  	if ( SSAARenderPass === undefined ) {

  		console.error( "TAARenderPass relies on SSAARenderPass" );

  	}

  	SSAARenderPass.call( this, scene, camera, params );

  	this.sampleLevel = 0;
  	this.accumulate = false;

  };

  TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;

  TAARenderPass.prototype = Object.assign( Object.create( SSAARenderPass.prototype ), {

  	constructor: TAARenderPass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime ) {
  		var this$1 = this;


  		if ( ! this.accumulate ) {

  			SSAARenderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, deltaTime );

  			this.accumulateIndex = - 1;
  			return;

  		}

  		var jitterOffsets = TAARenderPass.JitterVectors[ 5 ];

  		if ( ! this.sampleRenderTarget ) {

  			this.sampleRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );
  			this.sampleRenderTarget.texture.name = "TAARenderPass.sample";

  		}

  		if ( ! this.holdRenderTarget ) {

  			this.holdRenderTarget = new WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );
  			this.holdRenderTarget.texture.name = "TAARenderPass.hold";

  		}

  		if ( this.accumulate && this.accumulateIndex === - 1 ) {

  			SSAARenderPass.prototype.render.call( this, renderer, this.holdRenderTarget, readBuffer, deltaTime );

  			this.accumulateIndex = 0;

  		}

  		var autoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		var sampleWeight = 1.0 / ( jitterOffsets.length );

  		if ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {

  			this.copyUniforms[ "opacity" ].value = sampleWeight;
  			this.copyUniforms[ "tDiffuse" ].value = writeBuffer.texture;

  			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
  			var numSamplesPerFrame = Math.pow( 2, this.sampleLevel );
  			for ( var i = 0; i < numSamplesPerFrame; i ++ ) {

  				var j = this$1.accumulateIndex;
  				var jitterOffset = jitterOffsets[ j ];

  				if ( this$1.camera.setViewOffset ) {

  					this$1.camera.setViewOffset( readBuffer.width, readBuffer.height,
  						jitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16
  						readBuffer.width, readBuffer.height );

  				}

  				renderer.setRenderTarget( writeBuffer );
  				renderer.clear();
  				renderer.render( this$1.scene, this$1.camera );

  				renderer.setRenderTarget( this$1.sampleRenderTarget );
  				if ( this$1.accumulateIndex === 0 ) { renderer.clear(); }
  				renderer.render( this$1.scene2, this$1.camera2 );

  				this$1.accumulateIndex ++;

  				if ( this$1.accumulateIndex >= jitterOffsets.length ) { break; }

  			}

  			if ( this.camera.clearViewOffset ) { this.camera.clearViewOffset(); }

  		}

  		var accumulationWeight = this.accumulateIndex * sampleWeight;

  		if ( accumulationWeight > 0 ) {

  			this.copyUniforms[ "opacity" ].value = 1.0;
  			this.copyUniforms[ "tDiffuse" ].value = this.sampleRenderTarget.texture;
  			renderer.setRenderTarget( writeBuffer );
  			renderer.clear();
  			renderer.render( this.scene2, this.camera2 );

  		}

  		if ( accumulationWeight < 1.0 ) {

  			this.copyUniforms[ "opacity" ].value = 1.0 - accumulationWeight;
  			this.copyUniforms[ "tDiffuse" ].value = this.holdRenderTarget.texture;
  			renderer.setRenderTarget( writeBuffer );
  			if ( accumulationWeight === 0 ) { renderer.clear(); }
  			renderer.render( this.scene2, this.camera2 );

  		}

  		renderer.autoClear = autoClear;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TexturePass = function ( map, opacity ) {

  	Pass.call( this );

  	if ( CopyShader === undefined )
  		{ console.error( "TexturePass relies on CopyShader" ); }

  	var shader = CopyShader;

  	this.map = map;
  	this.opacity = ( opacity !== undefined ) ? opacity : 1.0;

  	this.uniforms = UniformsUtils.clone( shader.uniforms );

  	this.material = new ShaderMaterial( {

  		uniforms: this.uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader,
  		depthTest: false,
  		depthWrite: false

  	} );

  	this.needsSwap = false;

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  TexturePass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: TexturePass,

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {

  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		this.quad.material = this.material;

  		this.uniforms[ "opacity" ].value = this.opacity;
  		this.uniforms[ "tDiffuse" ].value = this.map;
  		this.material.transparent = ( this.opacity < 1.0 );

  		renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );
  		if ( this.clear ) { renderer.clear(); }
  		renderer.render( this.scene, this.camera );

  		renderer.autoClear = oldAutoClear;
  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var LuminosityHighPassShader = {

    shaderID: "luminosityHighPass",

  	uniforms: {

  		"tDiffuse": { type: "t", value: null },
  		"luminosityThreshold": { type: "f", value: 1.0 },
  		"smoothWidth": { type: "f", value: 1.0 },
  		"defaultColor": { type: "c", value: new Color( 0x000000 ) },
  		"defaultOpacity":  { type: "f", value: 0.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join("\n"),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform vec3 defaultColor;",
  		"uniform float defaultOpacity;",
  		"uniform float luminosityThreshold;",
  		"uniform float smoothWidth;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 texel = texture2D( tDiffuse, vUv );",

  			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

  			"float v = dot( texel.xyz, luma );",

  			"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",

  			"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",

  			"gl_FragColor = mix( outputColor, texel, alpha );",

  		"}"

  	].join("\n")

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var UnrealBloomPass = function ( resolution, strength, radius, threshold ) {
  	var this$1 = this;


  	Pass.call( this );

  	this.strength = ( strength !== undefined ) ? strength : 1;
  	this.radius = radius;
  	this.threshold = threshold;
  	this.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );

  	// create color only once here, reuse it later inside the render function
  	this.clearColor = new Color( 0, 0, 0 );

  	// render targets
  	var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
  	this.renderTargetsHorizontal = [];
  	this.renderTargetsVertical = [];
  	this.nMips = 5;
  	var resx = Math.round( this.resolution.x / 2 );
  	var resy = Math.round( this.resolution.y / 2 );

  	this.renderTargetBright = new WebGLRenderTarget( resx, resy, pars );
  	this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
  	this.renderTargetBright.texture.generateMipmaps = false;

  	for ( var i = 0; i < this.nMips; i ++ ) {

  		var renderTargetHorizonal = new WebGLRenderTarget( resx, resy, pars );

  		renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
  		renderTargetHorizonal.texture.generateMipmaps = false;

  		this$1.renderTargetsHorizontal.push( renderTargetHorizonal );

  		var renderTargetVertical = new WebGLRenderTarget( resx, resy, pars );

  		renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
  		renderTargetVertical.texture.generateMipmaps = false;

  		this$1.renderTargetsVertical.push( renderTargetVertical );

  		resx = Math.round( resx / 2 );

  		resy = Math.round( resy / 2 );

  	}

  	// luminosity high pass material

  	if ( LuminosityHighPassShader === undefined )
  		{ console.error( "UnrealBloomPass relies on LuminosityHighPassShader" ); }

  	var highPassShader = LuminosityHighPassShader;
  	this.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );

  	this.highPassUniforms[ "luminosityThreshold" ].value = threshold;
  	this.highPassUniforms[ "smoothWidth" ].value = 0.01;

  	this.materialHighPassFilter = new ShaderMaterial( {
  		uniforms: this.highPassUniforms,
  		vertexShader: highPassShader.vertexShader,
  		fragmentShader: highPassShader.fragmentShader,
  		defines: {}
  	} );

  	// Gaussian Blur Materials
  	this.separableBlurMaterials = [];
  	var kernelSizeArray = [ 3, 5, 7, 9, 11 ];
  	var resx = Math.round( this.resolution.x / 2 );
  	var resy = Math.round( this.resolution.y / 2 );

  	for ( var i = 0; i < this.nMips; i ++ ) {

  		this$1.separableBlurMaterials.push( this$1.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );

  		this$1.separableBlurMaterials[ i ].uniforms[ "texSize" ].value = new Vector2( resx, resy );

  		resx = Math.round( resx / 2 );

  		resy = Math.round( resy / 2 );

  	}

  	// Composite material
  	this.compositeMaterial = this.getCompositeMaterial( this.nMips );
  	this.compositeMaterial.uniforms[ "blurTexture1" ].value = this.renderTargetsVertical[ 0 ].texture;
  	this.compositeMaterial.uniforms[ "blurTexture2" ].value = this.renderTargetsVertical[ 1 ].texture;
  	this.compositeMaterial.uniforms[ "blurTexture3" ].value = this.renderTargetsVertical[ 2 ].texture;
  	this.compositeMaterial.uniforms[ "blurTexture4" ].value = this.renderTargetsVertical[ 3 ].texture;
  	this.compositeMaterial.uniforms[ "blurTexture5" ].value = this.renderTargetsVertical[ 4 ].texture;
  	this.compositeMaterial.uniforms[ "bloomStrength" ].value = strength;
  	this.compositeMaterial.uniforms[ "bloomRadius" ].value = 0.1;
  	this.compositeMaterial.needsUpdate = true;

  	var bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];
  	this.compositeMaterial.uniforms[ "bloomFactors" ].value = bloomFactors;
  	this.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ),
  							 new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];
  	this.compositeMaterial.uniforms[ "bloomTintColors" ].value = this.bloomTintColors;

  	// copy material
  	if ( CopyShader === undefined ) {

  		console.error( "BloomPass relies on CopyShader" );

  	}

  	var copyShader = CopyShader;

  	this.copyUniforms = UniformsUtils.clone( copyShader.uniforms );
  	this.copyUniforms[ "opacity" ].value = 1.0;

  	this.materialCopy = new ShaderMaterial( {
  		uniforms: this.copyUniforms,
  		vertexShader: copyShader.vertexShader,
  		fragmentShader: copyShader.fragmentShader,
  		blending: AdditiveBlending,
  		depthTest: false,
  		depthWrite: false,
  		transparent: true
  	} );

  	this.enabled = true;
  	this.needsSwap = false;

  	this.oldClearColor = new Color();
  	this.oldClearAlpha = 1;

  	this.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
  	this.scene = new Scene();

  	this.basic = new MeshBasicMaterial();

  	this.quad = new Mesh( new PlaneBufferGeometry( 2, 2 ), null );
  	this.quad.frustumCulled = false; // Avoid getting clipped
  	this.scene.add( this.quad );

  };

  UnrealBloomPass.prototype = Object.assign( Object.create( Pass.prototype ), {

  	constructor: UnrealBloomPass,

  	dispose: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {

  			this$1.renderTargetsHorizontal[ i ].dispose();

  		}

  		for ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {

  			this$1.renderTargetsVertical[ i ].dispose();

  		}

  		this.renderTargetBright.dispose();

  	},

  	setSize: function ( width, height ) {
  		var this$1 = this;


  		var resx = Math.round( width / 2 );
  		var resy = Math.round( height / 2 );

  		this.renderTargetBright.setSize( resx, resy );

  		for ( var i = 0; i < this.nMips; i ++ ) {

  			this$1.renderTargetsHorizontal[ i ].setSize( resx, resy );
  			this$1.renderTargetsVertical[ i ].setSize( resx, resy );

  			this$1.separableBlurMaterials[ i ].uniforms[ "texSize" ].value = new Vector2( resx, resy );

  			resx = Math.round( resx / 2 );
  			resy = Math.round( resy / 2 );

  		}

  	},

  	render: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {
  		var this$1 = this;


  		this.oldClearColor.copy( renderer.getClearColor() );
  		this.oldClearAlpha = renderer.getClearAlpha();
  		var oldAutoClear = renderer.autoClear;
  		renderer.autoClear = false;

  		renderer.setClearColor( this.clearColor, 0 );

  		if ( maskActive ) { renderer.context.disable( renderer.context.STENCIL_TEST ); }

  		// Render input to screen

  		if ( this.renderToScreen ) {

  			this.quad.material = this.basic;
  			this.basic.map = readBuffer.texture;

  			renderer.setRenderTarget( null );
  			renderer.clear();
  			renderer.render( this.scene, this.camera );

  		}

  		// 1. Extract Bright Areas

  		this.highPassUniforms[ "tDiffuse" ].value = readBuffer.texture;
  		this.highPassUniforms[ "luminosityThreshold" ].value = this.threshold;
  		this.quad.material = this.materialHighPassFilter;

  		renderer.setRenderTarget( this.renderTargetBright );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// 2. Blur All the mips progressively

  		var inputRenderTarget = this.renderTargetBright;

  		for ( var i = 0; i < this.nMips; i ++ ) {

  			this$1.quad.material = this$1.separableBlurMaterials[ i ];

  			this$1.separableBlurMaterials[ i ].uniforms[ "colorTexture" ].value = inputRenderTarget.texture;
  			this$1.separableBlurMaterials[ i ].uniforms[ "direction" ].value = UnrealBloomPass.BlurDirectionX;
  			renderer.setRenderTarget( this$1.renderTargetsHorizontal[ i ] );
  			renderer.clear();
  			renderer.render( this$1.scene, this$1.camera );

  			this$1.separableBlurMaterials[ i ].uniforms[ "colorTexture" ].value = this$1.renderTargetsHorizontal[ i ].texture;
  			this$1.separableBlurMaterials[ i ].uniforms[ "direction" ].value = UnrealBloomPass.BlurDirectionY;
  			renderer.setRenderTarget( this$1.renderTargetsVertical[ i ] );
  			renderer.clear();
  			renderer.render( this$1.scene, this$1.camera );

  			inputRenderTarget = this$1.renderTargetsVertical[ i ];

  		}

  		// Composite All the mips

  		this.quad.material = this.compositeMaterial;
  		this.compositeMaterial.uniforms[ "bloomStrength" ].value = this.strength;
  		this.compositeMaterial.uniforms[ "bloomRadius" ].value = this.radius;
  		this.compositeMaterial.uniforms[ "bloomTintColors" ].value = this.bloomTintColors;

  		renderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );
  		renderer.clear();
  		renderer.render( this.scene, this.camera );

  		// Blend it additively over the input texture

  		this.quad.material = this.materialCopy;
  		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetsHorizontal[ 0 ].texture;

  		if ( maskActive ) { renderer.context.enable( renderer.context.STENCIL_TEST ); }
  		if ( this.renderToScreen ) {

  			renderer.setRenderTarget( null );
  			renderer.render( this.scene, this.camera );

  		} else {

  			renderer.setRenderTarget( readBuffer );
  			renderer.render( this.scene, this.camera );

  		}

  		// Restore renderer settings

  		renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
  		renderer.autoClear = oldAutoClear;

  	},

  	getSeperableBlurMaterial: function ( kernelRadius ) {

  		return new ShaderMaterial( {

  			defines: {
  				"KERNEL_RADIUS": kernelRadius,
  				"SIGMA": kernelRadius
  			},

  			uniforms: {
  				"colorTexture": { value: null },
  				"texSize": { value: new Vector2( 0.5, 0.5 ) },
  				"direction": { value: new Vector2( 0.5, 0.5 ) }
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"#include <common>\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					float fSigma = float(SIGMA);\
					float weightSum = gaussianPdf(0.0, fSigma);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
						float x = float(i);\
						float w = gaussianPdf(x, fSigma);\
						vec2 uvOffset = direction * invSize * x;\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += (sample1 + sample2) * w;\
						weightSum += 2.0 * w;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\
				}"
  		} );

  	},

  	getCompositeMaterial: function ( nMips ) {

  		return new ShaderMaterial( {

  			defines: {
  				"NUM_MIPS": nMips
  			},

  			uniforms: {
  				"blurTexture1": { value: null },
  				"blurTexture2": { value: null },
  				"blurTexture3": { value: null },
  				"blurTexture4": { value: null },
  				"blurTexture5": { value: null },
  				"dirtTexture": { value: null },
  				"bloomStrength": { value: 1.0 },
  				"bloomFactors": { value: null },
  				"bloomTintColors": { value: null },
  				"bloomRadius": { value: 0.0 }
  			},

  			vertexShader:
  				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

  			fragmentShader:
  				"varying vec2 vUv;\
				uniform sampler2D blurTexture1;\
				uniform sampler2D blurTexture2;\
				uniform sampler2D blurTexture3;\
				uniform sampler2D blurTexture4;\
				uniform sampler2D blurTexture5;\
				uniform sampler2D dirtTexture;\
				uniform float bloomStrength;\
				uniform float bloomRadius;\
				uniform float bloomFactors[NUM_MIPS];\
				uniform vec3 bloomTintColors[NUM_MIPS];\
				\
				float lerpBloomFactor(const in float factor) { \
					float mirrorFactor = 1.2 - factor;\
					return mix(factor, mirrorFactor, bloomRadius);\
				}\
				\
				void main() {\
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
													 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
				}"
  		} );

  	}

  } );

  UnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );
  UnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Park-Miller-Carta Pseudo-Random Number Generator
  // https://github.com/pnitsch/BitmapData.js/blob/master/js/BitmapData.js

  var PRNG = function () {

  	this.seed = 1;
  	this.next = function() {

  		return ( this.gen() / 2147483647 );

  	};
  	this.nextRange = function( min, max )	{

  		return min + ( ( max - min ) * this.next() )

  	};
  	this.gen = function() {

  		return this.seed = ( this.seed * 16807 ) % 2147483647;

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CSS2DObject = function ( element ) {

  	Object3D.call( this );

  	this.element = element;
  	this.element.style.position = 'absolute';

  	this.addEventListener( 'removed', function ( event ) {

  		if ( this.element.parentNode !== null ) {

  			this.element.parentNode.removeChild( this.element );

  		}

  	} );

  };

  CSS2DObject.prototype = Object.create( Object3D.prototype );
  CSS2DObject.prototype.constructor = CSS2DObject;

  //

  var CSS2DRenderer = function () {

  	console.log( 'CSS2DRenderer', REVISION );

  	var _width, _height;
  	var _widthHalf, _heightHalf;

  	var vector = new Vector3();
  	var viewMatrix = new Matrix4();
  	var viewProjectionMatrix = new Matrix4();

  	var cache = {
  		objects: new WeakMap()
  	};

  	var domElement = document.createElement( 'div' );
  	domElement.style.overflow = 'hidden';

  	this.domElement = domElement;

  	this.getSize = function () {

  		return {
  			width: _width,
  			height: _height
  		};

  	};

  	this.setSize = function ( width, height ) {

  		_width = width;
  		_height = height;

  		_widthHalf = _width / 2;
  		_heightHalf = _height / 2;

  		domElement.style.width = width + 'px';
  		domElement.style.height = height + 'px';

  	};

  	var renderObject = function ( object, camera ) {

  		if ( object instanceof CSS2DObject ) {

  			vector.setFromMatrixPosition( object.matrixWorld );
  			vector.applyMatrix4( viewProjectionMatrix );

  			var element = object.element;
  			var style = 'translate(-50%,-50%) translate(' + ( vector.x * _widthHalf + _widthHalf ) + 'px,' + ( - vector.y * _heightHalf + _heightHalf ) + 'px)';

  			element.style.WebkitTransform = style;
  			element.style.MozTransform = style;
  			element.style.oTransform = style;
  			element.style.transform = style;

  			var objectData = {
  				distanceToCameraSquared: getDistanceToSquared( camera, object )
  			};

  			cache.objects.set( object, objectData );

  			if ( element.parentNode !== domElement ) {

  				domElement.appendChild( element );

  			}

  		}

  		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

  			renderObject( object.children[ i ], camera );

  		}

  	};

  	var getDistanceToSquared = function () {

  		var a = new Vector3();
  		var b = new Vector3();

  		return function ( object1, object2 ) {

  			a.setFromMatrixPosition( object1.matrixWorld );
  			b.setFromMatrixPosition( object2.matrixWorld );

  			return a.distanceToSquared( b );

  		};

  	}();

  	var filterAndFlatten = function ( scene ) {

  		var result = [];

  		scene.traverse( function ( object ) {

  			if ( object instanceof CSS2DObject ) { result.push( object ); }

  		} );

  		return result;

  	};

  	var zOrder = function ( scene ) {

  		var sorted = filterAndFlatten( scene ).sort( function ( a, b ) {

  			var distanceA = cache.objects.get( a ).distanceToCameraSquared;
  			var distanceB = cache.objects.get( b ).distanceToCameraSquared;

  			return distanceA - distanceB;

  		} );

  		var zMax = sorted.length;

  		for ( var i = 0, l = sorted.length; i < l; i ++ ) {

  			sorted[ i ].element.style.zIndex = zMax - i;

  		}

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		viewMatrix.copy( camera.matrixWorldInverse );
  		viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, viewMatrix );

  		renderObject( scene, camera );
  		zOrder( scene );

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var CSS3DObject = function ( element ) {

  	Object3D.call( this );

  	this.element = element;
  	this.element.style.position = 'absolute';

  	this.addEventListener( 'removed', function () {

  		if ( this.element.parentNode !== null ) {

  			this.element.parentNode.removeChild( this.element );

  		}

  	} );

  };

  CSS3DObject.prototype = Object.create( Object3D.prototype );
  CSS3DObject.prototype.constructor = CSS3DObject;

  var CSS3DSprite = function ( element ) {

  	CSS3DObject.call( this, element );

  };

  CSS3DSprite.prototype = Object.create( CSS3DObject.prototype );
  CSS3DSprite.prototype.constructor = CSS3DSprite;

  //

  var CSS3DRenderer = function () {

  	console.log( 'CSS3DRenderer', REVISION );

  	var _width, _height;
  	var _widthHalf, _heightHalf;

  	var matrix = new Matrix4();

  	var cache = {
  		camera: { fov: 0, style: '' },
  		objects: new WeakMap()
  	};

  	var domElement = document.createElement( 'div' );
  	domElement.style.overflow = 'hidden';

  	this.domElement = domElement;

  	var cameraElement = document.createElement( 'div' );

  	cameraElement.style.WebkitTransformStyle = 'preserve-3d';
  	cameraElement.style.transformStyle = 'preserve-3d';

  	domElement.appendChild( cameraElement );

  	var isIE = /Trident/i.test( navigator.userAgent );

  	this.getSize = function () {

  		return {
  			width: _width,
  			height: _height
  		};

  	};

  	this.setSize = function ( width, height ) {

  		_width = width;
  		_height = height;
  		_widthHalf = _width / 2;
  		_heightHalf = _height / 2;

  		domElement.style.width = width + 'px';
  		domElement.style.height = height + 'px';

  		cameraElement.style.width = width + 'px';
  		cameraElement.style.height = height + 'px';

  	};

  	function epsilon( value ) {

  		return Math.abs( value ) < 1e-10 ? 0 : value;

  	}

  	function getCameraCSSMatrix( matrix ) {

  		var elements = matrix.elements;

  		return 'matrix3d(' +
  			epsilon( elements[ 0 ] ) + ',' +
  			epsilon( - elements[ 1 ] ) + ',' +
  			epsilon( elements[ 2 ] ) + ',' +
  			epsilon( elements[ 3 ] ) + ',' +
  			epsilon( elements[ 4 ] ) + ',' +
  			epsilon( - elements[ 5 ] ) + ',' +
  			epsilon( elements[ 6 ] ) + ',' +
  			epsilon( elements[ 7 ] ) + ',' +
  			epsilon( elements[ 8 ] ) + ',' +
  			epsilon( - elements[ 9 ] ) + ',' +
  			epsilon( elements[ 10 ] ) + ',' +
  			epsilon( elements[ 11 ] ) + ',' +
  			epsilon( elements[ 12 ] ) + ',' +
  			epsilon( - elements[ 13 ] ) + ',' +
  			epsilon( elements[ 14 ] ) + ',' +
  			epsilon( elements[ 15 ] ) +
  		')';

  	}

  	function getObjectCSSMatrix( matrix, cameraCSSMatrix ) {

  		var elements = matrix.elements;
  		var matrix3d = 'matrix3d(' +
  			epsilon( elements[ 0 ] ) + ',' +
  			epsilon( elements[ 1 ] ) + ',' +
  			epsilon( elements[ 2 ] ) + ',' +
  			epsilon( elements[ 3 ] ) + ',' +
  			epsilon( - elements[ 4 ] ) + ',' +
  			epsilon( - elements[ 5 ] ) + ',' +
  			epsilon( - elements[ 6 ] ) + ',' +
  			epsilon( - elements[ 7 ] ) + ',' +
  			epsilon( elements[ 8 ] ) + ',' +
  			epsilon( elements[ 9 ] ) + ',' +
  			epsilon( elements[ 10 ] ) + ',' +
  			epsilon( elements[ 11 ] ) + ',' +
  			epsilon( elements[ 12 ] ) + ',' +
  			epsilon( elements[ 13 ] ) + ',' +
  			epsilon( elements[ 14 ] ) + ',' +
  			epsilon( elements[ 15 ] ) +
  		')';

  		if ( isIE ) {

  			return 'translate(-50%,-50%)' +
  				'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' +
  				cameraCSSMatrix +
  				matrix3d;

  		}

  		return 'translate(-50%,-50%)' + matrix3d;

  	}

  	function renderObject( object, camera, cameraCSSMatrix ) {

  		if ( object instanceof CSS3DObject ) {

  			var style;

  			if ( object instanceof CSS3DSprite ) {

  				// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

  				matrix.copy( camera.matrixWorldInverse );
  				matrix.transpose();
  				matrix.copyPosition( object.matrixWorld );
  				matrix.scale( object.scale );

  				matrix.elements[ 3 ] = 0;
  				matrix.elements[ 7 ] = 0;
  				matrix.elements[ 11 ] = 0;
  				matrix.elements[ 15 ] = 1;

  				style = getObjectCSSMatrix( matrix, cameraCSSMatrix );

  			} else {

  				style = getObjectCSSMatrix( object.matrixWorld, cameraCSSMatrix );

  			}

  			var element = object.element;
  			var cachedObject = cache.objects.get( object );

  			if ( cachedObject === undefined || cachedObject.style !== style ) {

  				element.style.WebkitTransform = style;
  				element.style.transform = style;

  				var objectData = { style: style };

  				if ( isIE ) {

  					objectData.distanceToCameraSquared = getDistanceToSquared( camera, object );

  				}

  				cache.objects.set( object, objectData );

  			}

  			if ( element.parentNode !== cameraElement ) {

  				cameraElement.appendChild( element );

  			}

  		}

  		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

  			renderObject( object.children[ i ], camera, cameraCSSMatrix );

  		}

  	}

  	var getDistanceToSquared = function () {

  		var a = new Vector3();
  		var b = new Vector3();

  		return function ( object1, object2 ) {

  			a.setFromMatrixPosition( object1.matrixWorld );
  			b.setFromMatrixPosition( object2.matrixWorld );

  			return a.distanceToSquared( b );

  		};

  	}();

  	function filterAndFlatten( scene ) {

  		var result = [];

  		scene.traverse( function ( object ) {

  			if ( object instanceof CSS3DObject ) { result.push( object ); }

  		} );

  		return result;

  	}

  	function zOrder( scene ) {

  		var sorted = filterAndFlatten( scene ).sort( function ( a, b ) {

  			var distanceA = cache.objects.get( a ).distanceToCameraSquared;
  			var distanceB = cache.objects.get( b ).distanceToCameraSquared;

  			return distanceA - distanceB;

  		} );

  		var zMax = sorted.length;

  		for ( var i = 0, l = sorted.length; i < l; i ++ ) {

  			sorted[ i ].element.style.zIndex = zMax - i;

  		}

  	}

  	this.render = function ( scene, camera ) {

  		var fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;

  		if ( cache.camera.fov !== fov ) {

  			if ( camera.isPerspectiveCamera ) {

  				domElement.style.WebkitPerspective = fov + 'px';
  				domElement.style.perspective = fov + 'px';

  			}

  			cache.camera.fov = fov;

  		}

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		if ( camera.isOrthographicCamera ) {

  			var tx = - ( camera.right + camera.left ) / 2;
  			var ty = ( camera.top + camera.bottom ) / 2;

  		}

  		var cameraCSSMatrix = camera.isOrthographicCamera ?
  			'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :
  			'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );

  		var style = cameraCSSMatrix +
  			'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

  		if ( cache.camera.style !== style && ! isIE ) {

  			cameraElement.style.WebkitTransform = style;
  			cameraElement.style.transform = style;

  			cache.camera.style = style;

  		}

  		renderObject( scene, camera, cameraCSSMatrix );

  		if ( isIE ) {

  			// IE10 and 11 does not support 'preserve-3d'.
  			// Thus, z-order in 3D will not work.
  			// We have to calc z-order manually and set CSS z-index for IE.
  			// FYI: z-index can't handle object intersection
  			zOrder( scene );

  		}

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var RenderableObject = function () {

  	this.id = 0;

  	this.object = null;
  	this.z = 0;
  	this.renderOrder = 0;

  };

  //

  var RenderableFace = function () {

  	this.id = 0;

  	this.v1 = new RenderableVertex();
  	this.v2 = new RenderableVertex();
  	this.v3 = new RenderableVertex();

  	this.normalModel = new Vector3();

  	this.vertexNormalsModel = [ new Vector3(), new Vector3(), new Vector3() ];
  	this.vertexNormalsLength = 0;

  	this.color = new Color();
  	this.material = null;
  	this.uvs = [ new Vector2(), new Vector2(), new Vector2() ];

  	this.z = 0;
  	this.renderOrder = 0;

  };

  //

  var RenderableVertex = function () {

  	this.position = new Vector3();
  	this.positionWorld = new Vector3();
  	this.positionScreen = new Vector4();

  	this.visible = true;

  };

  RenderableVertex.prototype.copy = function ( vertex ) {

  	this.positionWorld.copy( vertex.positionWorld );
  	this.positionScreen.copy( vertex.positionScreen );

  };

  //

  var RenderableLine = function () {

  	this.id = 0;

  	this.v1 = new RenderableVertex();
  	this.v2 = new RenderableVertex();

  	this.vertexColors = [ new Color(), new Color() ];
  	this.material = null;

  	this.z = 0;
  	this.renderOrder = 0;

  };

  //

  var RenderableSprite = function () {

  	this.id = 0;

  	this.object = null;

  	this.x = 0;
  	this.y = 0;
  	this.z = 0;

  	this.rotation = 0;
  	this.scale = new Vector2();

  	this.material = null;
  	this.renderOrder = 0;

  };

  //

  var Projector = function () {

  	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
  		_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
  		_face, _faceCount, _facePool = [], _facePoolLength = 0,
  		_line, _lineCount, _linePool = [], _linePoolLength = 0,
  		_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

  		_renderData = { objects: [], lights: [], elements: [] },

  		_vector3 = new Vector3(),
  		_vector4 = new Vector4(),

  		_clipBox = new Box3( new Vector3( - 1, - 1, - 1 ), new Vector3( 1, 1, 1 ) ),
  		_boundingBox = new Box3(),
  		_points3 = new Array( 3 ),

  		_viewMatrix = new Matrix4(),
  		_viewProjectionMatrix = new Matrix4(),

  		_modelMatrix,
  		_modelViewProjectionMatrix = new Matrix4(),

  		_normalMatrix = new Matrix3(),

  		_frustum = new Frustum(),

  		_clippedVertex1PositionScreen = new Vector4(),
  		_clippedVertex2PositionScreen = new Vector4();

  	//

  	this.projectVector = function ( vector, camera ) {

  		console.warn( 'Projector: .projectVector() is now vector.project().' );
  		vector.project( camera );

  	};

  	this.unprojectVector = function ( vector, camera ) {

  		console.warn( 'Projector: .unprojectVector() is now vector.unproject().' );
  		vector.unproject( camera );

  	};

  	this.pickingRay = function () {

  		console.error( 'Projector: .pickingRay() is now raycaster.setFromCamera().' );

  	};

  	//

  	var RenderList = function () {

  		var normals = [];
  		var colors = [];
  		var uvs = [];

  		var object = null;
  		var material = null;

  		var normalMatrix = new Matrix3();

  		function setObject( value ) {

  			object = value;
  			material = object.material;

  			normalMatrix.getNormalMatrix( object.matrixWorld );

  			normals.length = 0;
  			colors.length = 0;
  			uvs.length = 0;

  		}

  		function projectVertex( vertex ) {

  			var position = vertex.position;
  			var positionWorld = vertex.positionWorld;
  			var positionScreen = vertex.positionScreen;

  			positionWorld.copy( position ).applyMatrix4( _modelMatrix );
  			positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

  			var invW = 1 / positionScreen.w;

  			positionScreen.x *= invW;
  			positionScreen.y *= invW;
  			positionScreen.z *= invW;

  			vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&
  					 positionScreen.y >= - 1 && positionScreen.y <= 1 &&
  					 positionScreen.z >= - 1 && positionScreen.z <= 1;

  		}

  		function pushVertex( x, y, z ) {

  			_vertex = getNextVertexInPool();
  			_vertex.position.set( x, y, z );

  			projectVertex( _vertex );

  		}

  		function pushNormal( x, y, z ) {

  			normals.push( x, y, z );

  		}

  		function pushColor( r, g, b ) {

  			colors.push( r, g, b );

  		}

  		function pushUv( x, y ) {

  			uvs.push( x, y );

  		}

  		function checkTriangleVisibility( v1, v2, v3 ) {

  			if ( v1.visible === true || v2.visible === true || v3.visible === true ) { return true; }

  			_points3[ 0 ] = v1.positionScreen;
  			_points3[ 1 ] = v2.positionScreen;
  			_points3[ 2 ] = v3.positionScreen;

  			return _clipBox.intersectsBox( _boundingBox.setFromPoints( _points3 ) );

  		}

  		function checkBackfaceCulling( v1, v2, v3 ) {

  			return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
  				    ( v2.positionScreen.y - v1.positionScreen.y ) -
  				    ( v3.positionScreen.y - v1.positionScreen.y ) *
  				    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

  		}

  		function pushLine( a, b ) {

  			var v1 = _vertexPool[ a ];
  			var v2 = _vertexPool[ b ];

  			// Clip

  			v1.positionScreen.copy( v1.position ).applyMatrix4( _modelViewProjectionMatrix );
  			v2.positionScreen.copy( v2.position ).applyMatrix4( _modelViewProjectionMatrix );

  			if ( clipLine( v1.positionScreen, v2.positionScreen ) === true ) {

  				// Perform the perspective divide
  				v1.positionScreen.multiplyScalar( 1 / v1.positionScreen.w );
  				v2.positionScreen.multiplyScalar( 1 / v2.positionScreen.w );

  				_line = getNextLineInPool();
  				_line.id = object.id;
  				_line.v1.copy( v1 );
  				_line.v2.copy( v2 );
  				_line.z = Math.max( v1.positionScreen.z, v2.positionScreen.z );
  				_line.renderOrder = object.renderOrder;

  				_line.material = object.material;

  				if ( object.material.vertexColors === VertexColors ) {

  					_line.vertexColors[ 0 ].fromArray( colors, a * 3 );
  					_line.vertexColors[ 1 ].fromArray( colors, b * 3 );

  				}

  				_renderData.elements.push( _line );

  			}

  		}

  		function pushTriangle( a, b, c, material ) {
  			var arguments$1 = arguments;


  			var v1 = _vertexPool[ a ];
  			var v2 = _vertexPool[ b ];
  			var v3 = _vertexPool[ c ];

  			if ( checkTriangleVisibility( v1, v2, v3 ) === false ) { return; }

  			if ( material.side === DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {

  				_face = getNextFaceInPool();

  				_face.id = object.id;
  				_face.v1.copy( v1 );
  				_face.v2.copy( v2 );
  				_face.v3.copy( v3 );
  				_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;
  				_face.renderOrder = object.renderOrder;

  				// face normal
  				_vector3.subVectors( v3.position, v2.position );
  				_vector4.subVectors( v1.position, v2.position );
  				_vector3.cross( _vector4 );
  				_face.normalModel.copy( _vector3 );
  				_face.normalModel.applyMatrix3( normalMatrix ).normalize();

  				for ( var i = 0; i < 3; i ++ ) {

  					var normal = _face.vertexNormalsModel[ i ];
  					normal.fromArray( normals, arguments$1[ i ] * 3 );
  					normal.applyMatrix3( normalMatrix ).normalize();

  					var uv = _face.uvs[ i ];
  					uv.fromArray( uvs, arguments$1[ i ] * 2 );

  				}

  				_face.vertexNormalsLength = 3;

  				_face.material = material;

  				if ( material.vertexColors === FaceColors ||  material.vertexColors === VertexColors ) {

  					_face.color.fromArray( colors, a * 3 );

  				}

  				_renderData.elements.push( _face );

  			}

  		}

  		return {
  			setObject: setObject,
  			projectVertex: projectVertex,
  			checkTriangleVisibility: checkTriangleVisibility,
  			checkBackfaceCulling: checkBackfaceCulling,
  			pushVertex: pushVertex,
  			pushNormal: pushNormal,
  			pushColor: pushColor,
  			pushUv: pushUv,
  			pushLine: pushLine,
  			pushTriangle: pushTriangle
  		};

  	};

  	var renderList = new RenderList();

  	function projectObject( object ) {

  		if ( object.visible === false ) { return; }

  		if ( object instanceof Light ) {

  			_renderData.lights.push( object );

  		} else if ( object instanceof Mesh || object instanceof Line || object instanceof Points ) {

  			if ( object.material.visible === false ) { return; }
  			if ( object.frustumCulled === true && _frustum.intersectsObject( object ) === false ) { return; }

  			addObject( object );

  		} else if ( object instanceof Sprite ) {

  			if ( object.material.visible === false ) { return; }
  			if ( object.frustumCulled === true && _frustum.intersectsSprite( object ) === false ) { return; }

  			addObject( object );

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			projectObject( children[ i ] );

  		}

  	}

  	function addObject( object ) {

  		_object = getNextObjectInPool();
  		_object.id = object.id;
  		_object.object = object;

  		_vector3.setFromMatrixPosition( object.matrixWorld );
  		_vector3.applyMatrix4( _viewProjectionMatrix );
  		_object.z = _vector3.z;
  		_object.renderOrder = object.renderOrder;

  		_renderData.objects.push( _object );

  	}

  	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

  		_faceCount = 0;
  		_lineCount = 0;
  		_spriteCount = 0;

  		_renderData.elements.length = 0;

  		if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }
  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_viewMatrix.copy( camera.matrixWorldInverse );
  		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

  		_frustum.setFromMatrix( _viewProjectionMatrix );

  		//

  		_objectCount = 0;

  		_renderData.objects.length = 0;
  		_renderData.lights.length = 0;

  		projectObject( scene );

  		if ( sortObjects === true ) {

  			_renderData.objects.sort( painterSort );

  		}

  		//

  		var objects = _renderData.objects;

  		for ( var o = 0, ol = objects.length; o < ol; o ++ ) {

  			var object = objects[ o ].object;
  			var geometry = object.geometry;

  			renderList.setObject( object );

  			_modelMatrix = object.matrixWorld;

  			_vertexCount = 0;

  			if ( object instanceof Mesh ) {

  				if ( geometry instanceof BufferGeometry ) {

  					var material = object.material;

  					var isMultiMaterial = Array.isArray( material );

  					var attributes = geometry.attributes;
  					var groups = geometry.groups;

  					if ( attributes.position === undefined ) { continue; }

  					var positions = attributes.position.array;

  					for ( var i = 0, l = positions.length; i < l; i += 3 ) {

  						var x = positions[ i ];
  						var y = positions[ i + 1 ];
  						var z = positions[ i + 2 ];

  						if ( material.morphTargets === true ) {

  							var morphTargets = geometry.morphAttributes.position;
  							var morphInfluences = object.morphTargetInfluences;

  							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  								var influence = morphInfluences[ t ];

  								if ( influence === 0 ) { continue; }

  								var target = morphTargets[ t ];

  								x += ( target.getX( i / 3 ) - positions[ i ] ) * influence;
  								y += ( target.getY( i / 3 ) - positions[ i + 1 ] ) * influence;
  								z += ( target.getZ( i / 3 ) - positions[ i + 2 ] ) * influence;

  							}

  						}

  						renderList.pushVertex( x, y, z );

  					}

  					if ( attributes.normal !== undefined ) {

  						var normals = attributes.normal.array;

  						for ( var i = 0, l = normals.length; i < l; i += 3 ) {

  							renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

  						}

  					}

  					if ( attributes.color !== undefined ) {

  						var colors = attributes.color.array;

  						for ( var i = 0, l = colors.length; i < l; i += 3 ) {

  							renderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );

  						}

  					}

  					if ( attributes.uv !== undefined ) {

  						var uvs = attributes.uv.array;

  						for ( var i = 0, l = uvs.length; i < l; i += 2 ) {

  							renderList.pushUv( uvs[ i ], uvs[ i + 1 ] );

  						}

  					}

  					if ( geometry.index !== null ) {

  						var indices = geometry.index.array;

  						if ( groups.length > 0 ) {

  							for ( var g = 0; g < groups.length; g ++ ) {

  								var group = groups[ g ];

  								material = isMultiMaterial === true
  									 ? object.material[ group.materialIndex ]
  									 : object.material;

  								if ( material === undefined ) { continue; }

  								for ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {

  									renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );

  								}

  							}

  						} else {

  							for ( var i = 0, l = indices.length; i < l; i += 3 ) {

  								renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material );

  							}

  						}

  					} else {

  						if ( groups.length > 0 ) {

  							for ( var g = 0; g < groups.length; g ++ ) {

  								var group = groups[ g ];

  								material = isMultiMaterial === true
  									 ? object.material[ group.materialIndex ]
  									 : object.material;

  								if ( material === undefined ) { continue; }

  								for ( var i = group.start, l = group.start + group.count; i < l; i += 3 ) {

  									renderList.pushTriangle( i, i + 1, i + 2, material );

  								}

  							}

  						} else {

  							for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

  								renderList.pushTriangle( i, i + 1, i + 2, material );

  							}

  						}

  					}

  				} else if ( geometry instanceof Geometry ) {

  					var vertices = geometry.vertices;
  					var faces = geometry.faces;
  					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];

  					_normalMatrix.getNormalMatrix( _modelMatrix );

  					var material = object.material;

  					var isMultiMaterial = Array.isArray( material );

  					for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

  						var vertex = vertices[ v ];

  						_vector3.copy( vertex );

  						if ( material.morphTargets === true ) {

  							var morphTargets = geometry.morphTargets;
  							var morphInfluences = object.morphTargetInfluences;

  							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  								var influence = morphInfluences[ t ];

  								if ( influence === 0 ) { continue; }

  								var target = morphTargets[ t ];
  								var targetVertex = target.vertices[ v ];

  								_vector3.x += ( targetVertex.x - vertex.x ) * influence;
  								_vector3.y += ( targetVertex.y - vertex.y ) * influence;
  								_vector3.z += ( targetVertex.z - vertex.z ) * influence;

  							}

  						}

  						renderList.pushVertex( _vector3.x, _vector3.y, _vector3.z );

  					}

  					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  						var face = faces[ f ];

  						material = isMultiMaterial === true
  							 ? object.material[ face.materialIndex ]
  							 : object.material;

  						if ( material === undefined ) { continue; }

  						var side = material.side;

  						var v1 = _vertexPool[ face.a ];
  						var v2 = _vertexPool[ face.b ];
  						var v3 = _vertexPool[ face.c ];

  						if ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) { continue; }

  						var visible = renderList.checkBackfaceCulling( v1, v2, v3 );

  						if ( side !== DoubleSide ) {

  							if ( side === FrontSide && visible === false ) { continue; }
  							if ( side === BackSide && visible === true ) { continue; }

  						}

  						_face = getNextFaceInPool();

  						_face.id = object.id;
  						_face.v1.copy( v1 );
  						_face.v2.copy( v2 );
  						_face.v3.copy( v3 );

  						_face.normalModel.copy( face.normal );

  						if ( visible === false && ( side === BackSide || side === DoubleSide ) ) {

  							_face.normalModel.negate();

  						}

  						_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

  						var faceVertexNormals = face.vertexNormals;

  						for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

  							var normalModel = _face.vertexNormalsModel[ n ];
  							normalModel.copy( faceVertexNormals[ n ] );

  							if ( visible === false && ( side === BackSide || side === DoubleSide ) ) {

  								normalModel.negate();

  							}

  							normalModel.applyMatrix3( _normalMatrix ).normalize();

  						}

  						_face.vertexNormalsLength = faceVertexNormals.length;

  						var vertexUvs = faceVertexUvs[ f ];

  						if ( vertexUvs !== undefined ) {

  							for ( var u = 0; u < 3; u ++ ) {

  								_face.uvs[ u ].copy( vertexUvs[ u ] );

  							}

  						}

  						_face.color = face.color;
  						_face.material = material;

  						_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;
  						_face.renderOrder = object.renderOrder;

  						_renderData.elements.push( _face );

  					}

  				}

  			} else if ( object instanceof Line ) {

  				_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

  				if ( geometry instanceof BufferGeometry ) {

  					var attributes = geometry.attributes;

  					if ( attributes.position !== undefined ) {

  						var positions = attributes.position.array;

  						for ( var i = 0, l = positions.length; i < l; i += 3 ) {

  							renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

  						}

  						if ( attributes.color !== undefined ) {

  							var colors = attributes.color.array;

  							for ( var i = 0, l = colors.length; i < l; i += 3 ) {

  								renderList.pushColor( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] );

  							}

  						}

  						if ( geometry.index !== null ) {

  							var indices = geometry.index.array;

  							for ( var i = 0, l = indices.length; i < l; i += 2 ) {

  								renderList.pushLine( indices[ i ], indices[ i + 1 ] );

  							}

  						} else {

  							var step = object instanceof LineSegments ? 2 : 1;

  							for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {

  								renderList.pushLine( i, i + 1 );

  							}

  						}

  					}

  				} else if ( geometry instanceof Geometry ) {

  					var vertices = object.geometry.vertices;

  					if ( vertices.length === 0 ) { continue; }

  					v1 = getNextVertexInPool();
  					v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

  					var step = object instanceof LineSegments ? 2 : 1;

  					for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

  						v1 = getNextVertexInPool();
  						v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

  						if ( ( v + 1 ) % step > 0 ) { continue; }

  						v2 = _vertexPool[ _vertexCount - 2 ];

  						_clippedVertex1PositionScreen.copy( v1.positionScreen );
  						_clippedVertex2PositionScreen.copy( v2.positionScreen );

  						if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

  							// Perform the perspective divide
  							_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
  							_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

  							_line = getNextLineInPool();

  							_line.id = object.id;
  							_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
  							_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

  							_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );
  							_line.renderOrder = object.renderOrder;

  							_line.material = object.material;

  							if ( object.material.vertexColors === VertexColors ) {

  								_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
  								_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

  							}

  							_renderData.elements.push( _line );

  						}

  					}

  				}

  			} else if ( object instanceof Points ) {

  				_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

  				if ( geometry instanceof Geometry ) {

  					var vertices = object.geometry.vertices;

  					for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

  						var vertex = vertices[ v ];

  						_vector4.set( vertex.x, vertex.y, vertex.z, 1 );
  						_vector4.applyMatrix4( _modelViewProjectionMatrix );

  						pushPoint( _vector4, object, camera );

  					}

  				} else if ( geometry instanceof BufferGeometry ) {

  					var attributes = geometry.attributes;

  					if ( attributes.position !== undefined ) {

  						var positions = attributes.position.array;

  						for ( var i = 0, l = positions.length; i < l; i += 3 ) {

  							_vector4.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ], 1 );
  							_vector4.applyMatrix4( _modelViewProjectionMatrix );

  							pushPoint( _vector4, object, camera );

  						}

  					}

  				}

  			} else if ( object instanceof Sprite ) {

  				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  				_vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );
  				_vector4.applyMatrix4( _viewProjectionMatrix );

  				pushPoint( _vector4, object, camera );

  			}

  		}

  		if ( sortElements === true ) {

  			_renderData.elements.sort( painterSort );

  		}

  		return _renderData;

  	};

  	function pushPoint( _vector4, object, camera ) {

  		var invW = 1 / _vector4.w;

  		_vector4.z *= invW;

  		if ( _vector4.z >= - 1 && _vector4.z <= 1 ) {

  			_sprite = getNextSpriteInPool();
  			_sprite.id = object.id;
  			_sprite.x = _vector4.x * invW;
  			_sprite.y = _vector4.y * invW;
  			_sprite.z = _vector4.z;
  			_sprite.renderOrder = object.renderOrder;
  			_sprite.object = object;

  			_sprite.rotation = object.rotation;

  			_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );
  			_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );

  			_sprite.material = object.material;

  			_renderData.elements.push( _sprite );

  		}

  	}

  	// Pools

  	function getNextObjectInPool() {

  		if ( _objectCount === _objectPoolLength ) {

  			var object = new RenderableObject();
  			_objectPool.push( object );
  			_objectPoolLength ++;
  			_objectCount ++;
  			return object;

  		}

  		return _objectPool[ _objectCount ++ ];

  	}

  	function getNextVertexInPool() {

  		if ( _vertexCount === _vertexPoolLength ) {

  			var vertex = new RenderableVertex();
  			_vertexPool.push( vertex );
  			_vertexPoolLength ++;
  			_vertexCount ++;
  			return vertex;

  		}

  		return _vertexPool[ _vertexCount ++ ];

  	}

  	function getNextFaceInPool() {

  		if ( _faceCount === _facePoolLength ) {

  			var face = new RenderableFace();
  			_facePool.push( face );
  			_facePoolLength ++;
  			_faceCount ++;
  			return face;

  		}

  		return _facePool[ _faceCount ++ ];
  	}

  	function getNextLineInPool() {

  		if ( _lineCount === _linePoolLength ) {

  			var line = new RenderableLine();
  			_linePool.push( line );
  			_linePoolLength ++;
  			_lineCount ++;
  			return line;

  		}

  		return _linePool[ _lineCount ++ ];

  	}

  	function getNextSpriteInPool() {

  		if ( _spriteCount === _spritePoolLength ) {

  			var sprite = new RenderableSprite();
  			_spritePool.push( sprite );
  			_spritePoolLength ++;
  			_spriteCount ++;
  			return sprite;

  		}

  		return _spritePool[ _spriteCount ++ ];

  	}

  	//

  	function painterSort( a, b ) {

  		if ( a.renderOrder !== b.renderOrder ) {

  			return a.renderOrder - b.renderOrder;

  		} else if ( a.z !== b.z ) {

  			return b.z - a.z;

  		} else if ( a.id !== b.id ) {

  			return a.id - b.id;

  		} else {

  			return 0;

  		}

  	}

  	function clipLine( s1, s2 ) {

  		var alpha1 = 0, alpha2 = 1,

  		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
  		// Z = -1 and Z = +1, respectively.

  			bc1near = s1.z + s1.w,
  			bc2near = s2.z + s2.w,
  			bc1far = - s1.z + s1.w,
  			bc2far = - s2.z + s2.w;

  		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

  			// Both vertices lie entirely within all clip planes.
  			return true;

  		} else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {

  			// Both vertices lie entirely outside one of the clip planes.
  			return false;

  		} else {

  			// The line segment spans at least one clip plane.

  			if ( bc1near < 0 ) {

  				// v1 lies outside the near plane, v2 inside
  				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

  			} else if ( bc2near < 0 ) {

  				// v2 lies outside the near plane, v1 inside
  				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

  			}

  			if ( bc1far < 0 ) {

  				// v1 lies outside the far plane, v2 inside
  				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

  			} else if ( bc2far < 0 ) {

  				// v2 lies outside the far plane, v2 inside
  				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

  			}

  			if ( alpha2 < alpha1 ) {

  				// The line segment spans two boundaries, but is outside both of them.
  				// (This can't happen when we're only clipping against just near/far but good
  				//  to leave the check here for future usage if other clip planes are added.)
  				return false;

  			} else {

  				// Update the s1 and s2 vertices to match the clipped line segment.
  				s1.lerp( s2, alpha1 );
  				s2.lerp( s1, 1 - alpha2 );

  				return true;

  			}

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var RaytracingRenderer = function ( parameters ) {

  	console.log( 'RaytracingRenderer', REVISION );

  	parameters = parameters || {};

  	var scope = this;
  	var pool = [];
  	var renderering = false;

  	var canvas = document.createElement( 'canvas' );
  	var context = canvas.getContext( '2d', {
  		alpha: parameters.alpha === true
  	} );

  	var canvasWidth, canvasHeight;

  	var clearColor = new Color( 0x000000 );

  	this.domElement = canvas;

  	this.autoClear = true;

  	var workers = parameters.workers;
  	var blockSize = parameters.blockSize || 64;
  	this.randomize = parameters.randomize;

  	var toRender = [], workerId = 0, sceneId = 0;

  	console.log( '%cSpinning off ' + workers + ' Workers ', 'font-size: 20px; background: black; color: white; font-family: monospace;' );

  	this.setWorkers = function ( w ) {

  		workers = w || navigator.hardwareConcurrency || 4;

  		while ( pool.length < workers ) {

  			var worker = new Worker( parameters.workerPath );
  			worker.id = workerId ++;

  			worker.onmessage = function ( e ) {

  				var data = e.data;

  				if ( ! data ) { return; }

  				if ( data.blockSize && sceneId == data.sceneId ) { // we match sceneId here to be sure

  					var imagedata = new ImageData( new Uint8ClampedArray( data.data ), data.blockSize, data.blockSize );
  					context.putImageData( imagedata, data.blockX, data.blockY );

  					// completed

  					console.log( 'Worker ' + this.id, data.time / 1000, ( Date.now() - reallyThen ) / 1000 + ' s' );

  					if ( pool.length > workers ) {

  						pool.splice( pool.indexOf( this ), 1 );
  						return this.terminate();

  					}

  					renderNext( this );

  				}

  			};

  			worker.color = new Color().setHSL( Math.random(), 0.8, 0.8 ).getHexString();
  			pool.push( worker );

  			updateSettings( worker );

  			if ( renderering ) {

  				worker.postMessage( {
  					scene: sceneJSON,
  					camera: cameraJSON,
  					annex: materials,
  					sceneId: sceneId
  				} );

  				renderNext( worker );

  			}

  		}

  		if ( ! renderering ) {

  			while ( pool.length > workers ) {

  				pool.pop().terminate();

  			}

  		}

  	};

  	this.setWorkers( workers );

  	this.setClearColor = function ( color  ) {

  		clearColor.set( color );

  	};

  	this.setPixelRatio = function () {};

  	this.setSize = function ( width, height ) {

  		canvas.width = width;
  		canvas.height = height;

  		canvasWidth = canvas.width;
  		canvasHeight = canvas.height;

  		context.fillStyle = 'white';

  		pool.forEach( updateSettings );

  	};

  	this.setSize( canvas.width, canvas.height );

  	this.clear = function () {

  	};

  	//

  	var totalBlocks, xblocks, yblocks;

  	function updateSettings( worker ) {

  		worker.postMessage( {

  			init: [ canvasWidth, canvasHeight ],
  			worker: worker.id,
  			// workers: pool.length,
  			blockSize: blockSize

  		} );

  	}

  	function renderNext( worker ) {

  		if ( ! toRender.length ) {

  			renderering = false;
  			return scope.dispatchEvent( { type: "complete" } );

  		}

  		var current = toRender.pop();

  		var blockX = ( current % xblocks ) * blockSize;
  		var blockY = ( current / xblocks | 0 ) * blockSize;

  		worker.postMessage( {
  			render: true,
  			x: blockX,
  			y: blockY,
  			sceneId: sceneId
  		} );

  		context.fillStyle = '#' + worker.color;

  		context.fillRect( blockX, blockY, blockSize, blockSize );

  	}

  	var materials = {};

  	var sceneJSON, cameraJSON, reallyThen;

  	// additional properties that were not serialize automatically

  	var _annex = {

  		mirror: 1,
  		reflectivity: 1,
  		refractionRatio: 1,
  		glass: 1

  	};

  	function serializeObject( o ) {

  		var mat = o.material;

  		if ( ! mat || mat.uuid in materials ) { return; }

  		var props = {};
  		for ( var m in _annex ) {

  			if ( mat[ m ] !== undefined ) {

  				props[ m ] = mat[ m ];

  			}

  		}

  		materials[ mat.uuid ] = props;

  	}

  	this.render = function ( scene, camera ) {

  		renderering = true;

  		// update scene graph

  		if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

  		// update camera matrices

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }
  		sceneJSON = scene.toJSON();
  		cameraJSON = camera.toJSON();
  		++ sceneId;

  		scene.traverse( serializeObject );

  		pool.forEach( function ( worker ) {

  			worker.postMessage( {
  				scene: sceneJSON,
  				camera: cameraJSON,
  				annex: materials,
  				sceneId: sceneId
  			} );

  		} );

  		context.clearRect( 0, 0, canvasWidth, canvasHeight );
  		reallyThen = Date.now();

  		xblocks = Math.ceil( canvasWidth / blockSize );
  		yblocks = Math.ceil( canvasHeight / blockSize );
  		totalBlocks = xblocks * yblocks;

  		toRender = [];

  		for ( var i = 0; i < totalBlocks; i ++ ) {

  			toRender.push( i );

  		}
  		// Randomize painting :)

  		if ( scope.randomize ) {

  			for ( var i = 0; i < totalBlocks; i ++ ) {

  				var swap = Math.random() * totalBlocks | 0;
  				var tmp = toRender[ swap ];
  				toRender[ swap ] = toRender[ i ];
  				toRender[ i ] = tmp;

  			}

  		}
  		pool.forEach( renderNext );

  	};

  };

  Object.assign( RaytracingRenderer.prototype, EventDispatcher.prototype );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SoftwareRenderer = function ( parameters ) {

  	console.log( 'SoftwareRenderer', REVISION );

  	parameters = parameters || {};

  	var canvas = parameters.canvas !== undefined
  			 ? parameters.canvas
  			 : document.createElement( 'canvas' );

  	var context = canvas.getContext( '2d', {
  		alpha: parameters.alpha === true
  	} );

  	var shaders = {};
  	var textures = {};

  	var canvasWidth, canvasHeight;
  	var canvasWBlocks, canvasHBlocks;
  	var viewportXScale, viewportYScale, viewportZScale;
  	var viewportXOffs, viewportYOffs, viewportZOffs;

  	var clearColor = new Color( 0x000000 );
  	var clearAlpha = parameters.alpha === true ? 0 : 1;

  	var imagedata, data, zbuffer;
  	var numBlocks, blockMaxZ, blockFlags;

  	var BLOCK_ISCLEAR = ( 1 << 0 );
  	var BLOCK_NEEDCLEAR = ( 1 << 1 );

  	var subpixelBits = 4;
  	var subpixelBias = ( 1 << subpixelBits ) - 1;
  	var blockShift = 3;
  	var blockSize = 1 << blockShift;
  	var maxZVal = ( 1 << 24 ); // Note: You want to size this so you don't get overflows.
  	var lineMode = false;
  	var lookVector = new Vector3( 0, 0, 1 );
  	var crossVector = new Vector3();

  	var rectx1 = Infinity, recty1 = Infinity;
  	var rectx2 = 0, recty2 = 0;

  	var prevrectx1 = Infinity, prevrecty1 = Infinity;
  	var prevrectx2 = 0, prevrecty2 = 0;

  	var projector = new Projector();

  	var spriteV1 = new Vector4();
  	var spriteV2 = new Vector4();
  	var spriteV3 = new Vector4();

  	var spriteUV1 = new Vector2();
  	var spriteUV2 = new Vector2();
  	var spriteUV3 = new Vector2();

  	var mpVPool = [];
  	var mpVPoolCount = 0;
  	var mpNPool = [];
  	var mpNPoolCount = 0;
  	var mpUVPool = [];
  	var mpUVPoolCount = 0;

  	var _this = this;

  	this.domElement = canvas;

  	this.autoClear = true;

  	this.setClearColor = function ( color, alpha ) {

  		clearColor.set( color );
  		clearAlpha = alpha;
  		clearColorBuffer( clearColor );

  	};

  	this.setPixelRatio = function () {};

  	this.setSize = function ( width, height ) {

  		canvasWBlocks = Math.floor( width / blockSize );
  		canvasHBlocks = Math.floor( height / blockSize );
  		canvasWidth = canvasWBlocks * blockSize;
  		canvasHeight = canvasHBlocks * blockSize;

  		var fixScale = 1 << subpixelBits;

  		viewportXScale = fixScale * canvasWidth / 2;
  		viewportYScale = - fixScale * canvasHeight / 2;
  		viewportZScale = maxZVal / 2;

  		viewportXOffs = fixScale * canvasWidth / 2 + 0.5;
  		viewportYOffs = fixScale * canvasHeight / 2 + 0.5;
  		viewportZOffs = maxZVal / 2 + 0.5;

  		canvas.width = canvasWidth;
  		canvas.height = canvasHeight;

  		imagedata = context.getImageData( 0, 0, canvasWidth, canvasHeight );
  		data = imagedata.data;

  		zbuffer = new Int32Array( data.length / 4 );

  		numBlocks = canvasWBlocks * canvasHBlocks;
  		blockMaxZ = new Int32Array( numBlocks );
  		blockFlags = new Uint8Array( numBlocks );

  		for ( var i = 0, l = zbuffer.length; i < l; i ++ ) {

  			zbuffer[ i ] = maxZVal;

  		}

  		for ( var i = 0; i < numBlocks; i ++ ) {

  			blockFlags[ i ] = BLOCK_ISCLEAR;

  		}

  		clearColorBuffer( clearColor );

  	};

  	this.clear = function () {

  		rectx1 = Infinity;
  		recty1 = Infinity;
  		rectx2 = 0;
  		recty2 = 0;
  		mpVPoolCount = 0;
  		mpNPoolCount = 0;
  		mpUVPoolCount = 0;

  		for ( var i = 0; i < numBlocks; i ++ ) {

  			blockMaxZ[ i ] = maxZVal;
  			blockFlags[ i ] = ( blockFlags[ i ] & BLOCK_ISCLEAR ) ? BLOCK_ISCLEAR : BLOCK_NEEDCLEAR;

  		}

  	};
  	this.render = function ( scene, camera ) {

  		// TODO: Check why autoClear can't be false.
  		this.clear();

  		var background = scene.background;

  		if ( background && background.isColor ) {

  			clearColorBuffer( background );

  		}

  		var renderData = projector.projectScene( scene, camera, false, false );
  		var elements = renderData.elements;

  		for ( var e = 0, el = elements.length; e < el; e ++ ) {

  			var element = elements[ e ];
  			var material = element.material;
  			var shader = getMaterialShader( material );

  			if ( ! shader ) { continue; }

  			if ( element instanceof RenderableFace ) {

  				if ( ! element.uvs ) {

  					drawTriangle(
  						element.v1.positionScreen,
  						element.v2.positionScreen,
  						element.v3.positionScreen,
  						null, null, null,
  						shader, element, material
  					);

  				} else {

  					drawTriangle(
  						element.v1.positionScreen,
  						element.v2.positionScreen,
  						element.v3.positionScreen,
  						element.uvs[ 0 ], element.uvs[ 1 ], element.uvs[ 2 ],
  						shader, element, material
  					);

  				}
  			} else if ( element instanceof RenderableSprite ) {

  				var scaleX = element.scale.x * 0.5;
  				var scaleY = element.scale.y * 0.5;

  				spriteV1.copy( element );
  				spriteV1.x -= scaleX;
  				spriteV1.y += scaleY;

  				spriteV2.copy( element );
  				spriteV2.x -= scaleX;
  				spriteV2.y -= scaleY;

  				spriteV3.copy( element );
  				spriteV3.x += scaleX;
  				spriteV3.y += scaleY;

  				if ( material.map ) {

  					spriteUV1.set( 0, 1 );
  					spriteUV2.set( 0, 0 );
  					spriteUV3.set( 1, 1 );

  					drawTriangle(
  						spriteV1, spriteV2, spriteV3,
  						spriteUV1, spriteUV2, spriteUV3,
  						shader, element, material
  					);

  				} else {

  					drawTriangle(
  						spriteV1, spriteV2, spriteV3,
  						null, null, null,
  						shader, element, material
  					);

  				}

  				spriteV1.copy( element );
  				spriteV1.x += scaleX;
  				spriteV1.y += scaleY;

  				spriteV2.copy( element );
  				spriteV2.x -= scaleX;
  				spriteV2.y -= scaleY;

  				spriteV3.copy( element );
  				spriteV3.x += scaleX;
  				spriteV3.y -= scaleY;

  				if ( material.map ) {

  					spriteUV1.set( 1, 1 );
  					spriteUV2.set( 0, 0 );
  					spriteUV3.set( 1, 0 );

  					drawTriangle(
  						spriteV1, spriteV2, spriteV3,
  						spriteUV1, spriteUV2, spriteUV3,
  						shader, element, material
  					);

  				} else {

  					drawTriangle(
  						spriteV1, spriteV2, spriteV3,
  						null, null, null,
  						shader, element, material
  					);

  				}

  			} else if ( element instanceof RenderableLine ) {

  				var shader = getMaterialShader( material );

  				drawLine(
  					element.v1.positionScreen,
  					element.v2.positionScreen,
  					element.vertexColors[ 0 ],
  					element.vertexColors[ 1 ],
  					shader,
  					material
  				);

  			}

  		}

  		finishClear();

  		var x = Math.min( rectx1, prevrectx1 );
  		var y = Math.min( recty1, prevrecty1 );
  		var width = Math.max( rectx2, prevrectx2 ) - x;
  		var height = Math.max( recty2, prevrecty2 ) - y;
  		if ( x !== Infinity ) {

  			context.putImageData( imagedata, 0, 0, x, y, width, height );

  		}

  		prevrectx1 = rectx1; prevrecty1 = recty1;
  		prevrectx2 = rectx2; prevrecty2 = recty2;

  	};

  	function getAlpha() {

  		return parameters.alpha === true ? clearAlpha : 1;

  	}

  	function clearColorBuffer( color ) {

  		var size = canvasWidth * canvasHeight * 4;

  		for ( var i = 0; i < size; i += 4 ) {

  			data[ i ] = color.r * 255 | 0;
  			data[ i + 1 ] = color.g * 255 | 0;
  			data[ i + 2 ] = color.b * 255 | 0;
  			data[ i + 3 ] = getAlpha() * 255 | 0;

  		}

  		context.fillStyle = 'rgba(' + ( ( clearColor.r * 255 ) | 0 ) + ',' + ( ( clearColor.g * 255 ) | 0 ) + ',' + ( ( clearColor.b * 255 ) | 0 ) + ',' + getAlpha() + ')';
  		context.fillRect( 0, 0, canvasWidth, canvasHeight );

  	}

  	function getPalette( material, bSimulateSpecular ) {

  		var i = 0, j = 0;
  		var diffuseR = material.color.r * 255;
  		var diffuseG = material.color.g * 255;
  		var diffuseB = material.color.b * 255;
  		var palette = new Uint8Array( 256 * 3 );

  		if ( bSimulateSpecular ) {

  			while ( i < 204 ) {

  				palette[ j ++ ] = Math.min( i * diffuseR / 204, 255 );
  				palette[ j ++ ] = Math.min( i * diffuseG / 204, 255 );
  				palette[ j ++ ] = Math.min( i * diffuseB / 204, 255 );
  				++ i;

  			}

  			while ( i < 256 ) {

  				// plus specular highlight
  				palette[ j ++ ] = Math.min( diffuseR + ( i - 204 ) * ( 255 - diffuseR ) / 82, 255 );
  				palette[ j ++ ] = Math.min( diffuseG + ( i - 204 ) * ( 255 - diffuseG ) / 82, 255 );
  				palette[ j ++ ] = Math.min( diffuseB + ( i - 204 ) * ( 255 - diffuseB ) / 82, 255 );
  				++ i;

  			}

  		} else {

  			while ( i < 256 ) {

  				palette[ j ++ ] = Math.min( i * diffuseR / 255, 255 );
  				palette[ j ++ ] = Math.min( i * diffuseG / 255, 255 );
  				palette[ j ++ ] = Math.min( i * diffuseB / 255, 255 );
  				++ i;

  			}

  		}

  		return palette;

  	}

  	function basicMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {

  		var colorOffset = offset * 4;

  		var texture = textures[ material.map.id ];

  		if ( ! texture.data ) { return; }

  		var tdim = texture.width;
  		var isTransparent = material.transparent;
  		var tbound = tdim - 1;
  		var tdata = texture.data;
  		var tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;

  		if ( ! isTransparent ) {

  			buffer[ colorOffset ] = tdata[ tIndex ];
  			buffer[ colorOffset + 1 ] = tdata[ tIndex + 1 ];
  			buffer[ colorOffset + 2 ] = tdata[ tIndex + 2 ];
  			buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;
  			depthBuf[ offset ] = depth;

  		} else {

  			var srcR = tdata[ tIndex ];
  			var srcG = tdata[ tIndex + 1 ];
  			var srcB = tdata[ tIndex + 2 ];
  			var opaci = tdata[ tIndex + 3 ] * material.opacity / 255;
  			var destR = buffer[ colorOffset ];
  			var destG = buffer[ colorOffset + 1 ];
  			var destB = buffer[ colorOffset + 2 ];

  			buffer[ colorOffset ] = ( srcR * opaci + destR * ( 1 - opaci ) );
  			buffer[ colorOffset + 1 ] = ( srcG * opaci + destG * ( 1 - opaci ) );
  			buffer[ colorOffset + 2 ] = ( srcB * opaci + destB * ( 1 - opaci ) );
  			buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;

  			// Only opaue pixls write to the depth buffer

  			if ( buffer[ colorOffset + 3 ] == 255 )	{ depthBuf[ offset ] = depth; }

  		}

  	}

  	function lightingMaterialShader( buffer, depthBuf, offset, depth, u, v, n, face, material ) {

  		var colorOffset = offset * 4;

  		var texture = textures[ material.map.id ];

  		if ( ! texture.data ) { return; }

  		var tdim = texture.width;
  		var isTransparent = material.transparent;
  		var cIndex = ( n > 0 ? ( ~ ~ n ) : 0 ) * 3;
  		var tbound = tdim - 1;
  		var tdata = texture.data;
  		var tIndex = ( ( ( v * tdim ) & tbound ) * tdim + ( ( u * tdim ) & tbound ) ) * 4;

  		if ( ! isTransparent ) {

  			buffer[ colorOffset ] = ( material.palette[ cIndex ] * tdata[ tIndex ] ) >> 8;
  			buffer[ colorOffset + 1 ] = ( material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ] ) >> 8;
  			buffer[ colorOffset + 2 ] = ( material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ] ) >> 8;
  			buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;
  			depthBuf[ offset ] = depth;

  		} else {

  			var foreColorR = material.palette[ cIndex ] * tdata[ tIndex ];
  			var foreColorG = material.palette[ cIndex + 1 ] * tdata[ tIndex + 1 ];
  			var foreColorB = material.palette[ cIndex + 2 ] * tdata[ tIndex + 2 ];
  			var opaci = tdata[ tIndex + 3 ] * material.opacity / 256;
  			var destR = buffer[ colorOffset ];
  			var destG = buffer[ colorOffset + 1 ];
  			var destB = buffer[ colorOffset + 2 ];

  			buffer[ colorOffset ] = foreColorR * opaci + destR * ( 1 - opaci );
  			buffer[ colorOffset + 1 ] = foreColorG * opaci + destG * ( 1 - opaci );
  			buffer[ colorOffset + 2 ] = foreColorB * opaci + destB * ( 1 - opaci );
  			buffer[ colorOffset + 3 ] = ( material.opacity << 8 ) - 1;

  			// Only opaue pixls write to the depth buffer

  			if ( buffer[ colorOffset + 3 ] == 255 ) { depthBuf[ offset ] = depth; }

  		}

  	}

  	function getMaterialShader( material ) {

  		var id = material.id;
  		var shader = shaders[ id ];

  		if ( shader && material.map && ! textures[ material.map.id ] ) { delete shaders[ id ]; }

  		if ( shaders[ id ] === undefined || material.needsUpdate === true ) {

  			if ( material instanceof MeshBasicMaterial ||
  				material instanceof MeshLambertMaterial ||
  				material instanceof MeshPhongMaterial ||
  				material instanceof SpriteMaterial ) {

  				if ( material instanceof MeshLambertMaterial ) {

  					// Generate color palette
  					if ( ! material.palette ) {

  						material.palette = getPalette( material, false );

  					}

  				} else if ( material instanceof MeshPhongMaterial ) {

  					// Generate color palette
  					if ( ! material.palette ) {

  						material.palette = getPalette( material, true );

  					}

  				}

  				var string;

  				if ( material.map ) {

  					var texture = new SoftwareRenderer.Texture();
  					texture.fromImage( material.map.image );

  					if ( ! texture.data ) { return; }

  					textures[ material.map.id ] = texture;

  					if ( material instanceof MeshBasicMaterial
  						|| material instanceof SpriteMaterial ) {

  						shader = basicMaterialShader;

  					} else {

  						shader = lightingMaterialShader;

  					}
  				} else {

  					if ( material.vertexColors === FaceColors || material.vertexColors === VertexColors ) {

  						string = [
  							'var colorOffset = offset * 4;',
  							'buffer[ colorOffset ] = face.color.r * 255;',
  							'buffer[ colorOffset + 1 ] = face.color.g * 255;',
  							'buffer[ colorOffset + 2 ] = face.color.b * 255;',
  							'buffer[ colorOffset + 3 ] = material.opacity * 255;',
  							'depthBuf[ offset ] = depth;'
  						].join( '\n' );

  					} else {

  						string = [
  							'var colorOffset = offset * 4;',
  							'buffer[ colorOffset ] = material.color.r * 255;',
  							'buffer[ colorOffset + 1 ] = material.color.g * 255;',
  							'buffer[ colorOffset + 2 ] = material.color.b * 255;',
  							'buffer[ colorOffset + 3 ] = material.opacity * 255;',
  							'depthBuf[ offset ] = depth;'
  						].join( '\n' );

  					}

  					shader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );

  				}

  			} else if ( material instanceof LineBasicMaterial ) {

  				var string = [
  					'var colorOffset = offset * 4;',
  					'buffer[ colorOffset ] = material.color.r * (color1.r+color2.r) * 0.5 * 255;',
  					'buffer[ colorOffset + 1 ] = material.color.g * (color1.g+color2.g) * 0.5 * 255;',
  					'buffer[ colorOffset + 2 ] = material.color.b * (color1.b+color2.b) * 0.5 * 255;',
  					'buffer[ colorOffset + 3 ] = 255;',
  					'depthBuf[ offset ] = depth;'
  				].join( '\n' );

  				shader = new Function( 'buffer, depthBuf, offset, depth, color1, color2, material', string );

  			} else {

  				var string = [
  					'var colorOffset = offset * 4;',
  					'buffer[ colorOffset ] = u * 255;',
  					'buffer[ colorOffset + 1 ] = v * 255;',
  					'buffer[ colorOffset + 2 ] = 0;',
  					'buffer[ colorOffset + 3 ] = 255;',
  					'depthBuf[ offset ] = depth;'
  				].join( '\n' );

  				shader = new Function( 'buffer, depthBuf, offset, depth, u, v, n, face, material', string );

  			}

  			shaders[ id ] = shader;

  			material.needsUpdate = false;

  		}

  		return shader;

  	}
  	function drawTriangle( v1, v2, v3, uv1, uv2, uv3, shader, face, material ) {

  		// TODO: Implement per-pixel z-clipping

  		if ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 || v3.z < - 1 || v3.z > 1 ) { return; }

  		// https://gist.github.com/2486101
  		// explanation: http://pouet.net/topic.php?which=8760&page=1

  		var fixscale = ( 1 << subpixelBits );

  		// 28.4 fixed-point coordinates

  		var x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;
  		var x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;
  		var x3 = ( v3.x * viewportXScale + viewportXOffs ) | 0;

  		var y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;
  		var y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;
  		var y3 = ( v3.y * viewportYScale + viewportYOffs ) | 0;

  		var bHasNormal = face.vertexNormalsModel && face.vertexNormalsModel.length;
  		var bHasUV = uv1 && uv2 && uv3;

  		var longestSide = Math.max(
  			Math.sqrt( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ),
  			Math.sqrt( ( x2 - x3 ) * ( x2 - x3 ) + ( y2 - y3 ) * ( y2 - y3 ) ),
  			Math.sqrt( ( x3 - x1 ) * ( x3 - x1 ) + ( y3 - y1 ) * ( y3 - y1 ) )
  		);

  		if ( ! ( face instanceof RenderableSprite ) && ( longestSide > 100 * fixscale ) ) {

  			// 1
  			// |\
  			// |a\
  			// |__\
  			// |\c|\
  			// |b\|d\
  			// |__\__\
  			// 2      3
  			var tempFace = { vertexNormalsModel: [], color: face.color };
  			var mpUV12, mpUV23, mpUV31;

  			if ( bHasUV ) {

  				if ( mpUVPoolCount === mpUVPool.length ) {

  					mpUV12 = new Vector2();
  					mpUVPool.push( mpUV12 );
  					++ mpUVPoolCount;

  					mpUV23 = new Vector2();
  					mpUVPool.push( mpUV23 );
  					++ mpUVPoolCount;

  					mpUV31 = new Vector2();
  					mpUVPool.push( mpUV31 );
  					++ mpUVPoolCount;

  				} else {

  					mpUV12 = mpUVPool[ mpUVPoolCount ];
  					++ mpUVPoolCount;

  					mpUV23 = mpUVPool[ mpUVPoolCount ];
  					++ mpUVPoolCount;

  					mpUV31 = mpUVPool[ mpUVPoolCount ];
  					++ mpUVPoolCount;

  				}

  				var weight;

  				weight = ( 1 + v2.z ) * ( v2.w / v1.w ) / ( 1 + v1.z );
  				mpUV12.copy( uv1 ).multiplyScalar( weight ).add( uv2 ).multiplyScalar( 1 / ( weight + 1 ) );

  				weight = ( 1 + v3.z ) * ( v3.w / v2.w ) / ( 1 + v2.z );
  				mpUV23.copy( uv2 ).multiplyScalar( weight ).add( uv3 ).multiplyScalar( 1 / ( weight + 1 ) );

  				weight = ( 1 + v1.z ) * ( v1.w / v3.w ) / ( 1 + v3.z );
  				mpUV31.copy( uv3 ).multiplyScalar( weight ).add( uv1 ).multiplyScalar( 1 / ( weight + 1 ) );

  			}

  			var mpV12, mpV23, mpV31;

  			if ( mpVPoolCount === mpVPool.length ) {

  				mpV12 = new Vector4();
  				mpVPool.push( mpV12 );
  				++ mpVPoolCount;

  				mpV23 = new Vector4();
  				mpVPool.push( mpV23 );
  				++ mpVPoolCount;

  				mpV31 = new Vector4();
  				mpVPool.push( mpV31 );
  				++ mpVPoolCount;

  			} else {

  				mpV12 = mpVPool[ mpVPoolCount ];
  				++ mpVPoolCount;

  				mpV23 = mpVPool[ mpVPoolCount ];
  				++ mpVPoolCount;

  				mpV31 = mpVPool[ mpVPoolCount ];
  				++ mpVPoolCount;

  			}

  			mpV12.copy( v1 ).add( v2 ).multiplyScalar( 0.5 );
  			mpV23.copy( v2 ).add( v3 ).multiplyScalar( 0.5 );
  			mpV31.copy( v3 ).add( v1 ).multiplyScalar( 0.5 );

  			var mpN12, mpN23, mpN31;

  			if ( bHasNormal ) {

  				if ( mpNPoolCount === mpNPool.length ) {

  					mpN12 = new Vector3();
  					mpNPool.push( mpN12 );
  					++ mpNPoolCount;

  					mpN23 = new Vector3();
  					mpNPool.push( mpN23 );
  					++ mpNPoolCount;

  					mpN31 = new Vector3();
  					mpNPool.push( mpN31 );
  					++ mpNPoolCount;

  				} else {

  					mpN12 = mpNPool[ mpNPoolCount ];
  					++ mpNPoolCount;

  					mpN23 = mpNPool[ mpNPoolCount ];
  					++ mpNPoolCount;

  					mpN31 = mpNPool[ mpNPoolCount ];
  					++ mpNPoolCount;

  				}

  				mpN12.copy( face.vertexNormalsModel[ 0 ] ).add( face.vertexNormalsModel[ 1 ] ).normalize();
  				mpN23.copy( face.vertexNormalsModel[ 1 ] ).add( face.vertexNormalsModel[ 2 ] ).normalize();
  				mpN31.copy( face.vertexNormalsModel[ 2 ] ).add( face.vertexNormalsModel[ 0 ] ).normalize();

  			}

  			// a
  			if ( bHasNormal ) {

  				tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 0 ];
  				tempFace.vertexNormalsModel[ 1 ] = mpN12;
  				tempFace.vertexNormalsModel[ 2 ] = mpN31;

  			}

  			drawTriangle( v1, mpV12, mpV31, uv1, mpUV12, mpUV31, shader, tempFace, material );

  			// b
  			if ( bHasNormal ) {

  				tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 1 ];
  				tempFace.vertexNormalsModel[ 1 ] = mpN23;
  				tempFace.vertexNormalsModel[ 2 ] = mpN12;

  			}

  			drawTriangle( v2, mpV23, mpV12, uv2, mpUV23, mpUV12, shader, tempFace, material );

  			// c
  			if ( bHasNormal ) {

  				tempFace.vertexNormalsModel[ 0 ] = mpN12;
  				tempFace.vertexNormalsModel[ 1 ] = mpN23;
  				tempFace.vertexNormalsModel[ 2 ] = mpN31;

  			}

  			drawTriangle( mpV12, mpV23, mpV31, mpUV12, mpUV23, mpUV31, shader, tempFace, material );

  			// d
  			if ( bHasNormal ) {

  				tempFace.vertexNormalsModel[ 0 ] = face.vertexNormalsModel[ 2 ];
  				tempFace.vertexNormalsModel[ 1 ] = mpN31;
  				tempFace.vertexNormalsModel[ 2 ] = mpN23;

  			}

  			drawTriangle( v3, mpV31, mpV23, uv3, mpUV31, mpUV23, shader, tempFace, material );

  			return;

  		}

  		// Z values (.28 fixed-point)

  		var z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;
  		var z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;
  		var z3 = ( v3.z * viewportZScale + viewportZOffs ) | 0;

  		// UV values
  		var bHasUV = false;
  		var tu1, tv1, tu2, tv2, tu3, tv3;

  		if ( uv1 && uv2 && uv3 ) {

  			bHasUV = true;

  			tu1 = uv1.x;
  			tv1 = 1 - uv1.y;
  			tu2 = uv2.x;
  			tv2 = 1 - uv2.y;
  			tu3 = uv3.x;
  			tv3 = 1 - uv3.y;

  		}

  		// Normal values
  		var n1, n2, n3, nz1, nz2, nz3;

  		if ( bHasNormal ) {

  			n1 = face.vertexNormalsModel[ 0 ];
  			n2 = face.vertexNormalsModel[ 1 ];
  			n3 = face.vertexNormalsModel[ 2 ];
  			nz1 = n1.z * 255;
  			nz2 = n2.z * 255;
  			nz3 = n3.z * 255;

  		}

  		// Deltas

  		var dx12 = x1 - x2, dy12 = y2 - y1;
  		var dx23 = x2 - x3, dy23 = y3 - y2;
  		var dx31 = x3 - x1, dy31 = y1 - y3;

  		// Bounding rectangle

  		var minx = Math.max( ( Math.min( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, 0 );
  		var maxx = Math.min( ( Math.max( x1, x2, x3 ) + subpixelBias ) >> subpixelBits, canvasWidth );
  		var miny = Math.max( ( Math.min( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, 0 );
  		var maxy = Math.min( ( Math.max( y1, y2, y3 ) + subpixelBias ) >> subpixelBits, canvasHeight );

  		rectx1 = Math.min( minx, rectx1 );
  		rectx2 = Math.max( maxx, rectx2 );
  		recty1 = Math.min( miny, recty1 );
  		recty2 = Math.max( maxy, recty2 );

  		// Block size, standard 8x8 (must be power of two)

  		var q = blockSize;

  		// Start in corner of 8x8 block

  		minx &= ~ ( q - 1 );
  		miny &= ~ ( q - 1 );

  		// Constant part of half-edge functions

  		var minXfixscale = ( minx << subpixelBits );
  		var minYfixscale = ( miny << subpixelBits );

  		var c1 = dy12 * ( ( minXfixscale ) - x1 ) + dx12 * ( ( minYfixscale ) - y1 );
  		var c2 = dy23 * ( ( minXfixscale ) - x2 ) + dx23 * ( ( minYfixscale ) - y2 );
  		var c3 = dy31 * ( ( minXfixscale ) - x3 ) + dx31 * ( ( minYfixscale ) - y3 );

  		// Correct for fill convention

  		if ( dy12 > 0 || ( dy12 == 0 && dx12 > 0 ) ) { c1 ++; }
  		if ( dy23 > 0 || ( dy23 == 0 && dx23 > 0 ) ) { c2 ++; }
  		if ( dy31 > 0 || ( dy31 == 0 && dx31 > 0 ) ) { c3 ++; }

  		// Note this doesn't kill subpixel precision, but only because we test for >=0 (not >0).
  		// It's a bit subtle. :)
  		c1 = ( c1 - 1 ) >> subpixelBits;
  		c2 = ( c2 - 1 ) >> subpixelBits;
  		c3 = ( c3 - 1 ) >> subpixelBits;

  		// Z interpolation setup

  		var dz12 = z1 - z2, dz31 = z3 - z1;
  		var invDet = 1.0 / ( dx12 * dy31 - dx31 * dy12 );
  		var dzdx = ( invDet * ( dz12 * dy31 - dz31 * dy12 ) ); // dz per one subpixel step in x
  		var dzdy = ( invDet * ( dz12 * dx31 - dx12 * dz31 ) ); // dz per one subpixel step in y

  		// Z at top/left corner of rast area

  		var cz = ( z1 + ( ( minXfixscale ) - x1 ) * dzdx + ( ( minYfixscale ) - y1 ) * dzdy ) | 0;

  		// Z pixel steps

  		dzdx = ( dzdx * fixscale ) | 0;
  		dzdy = ( dzdy * fixscale ) | 0;

  		var dtvdx, dtvdy, cbtu, cbtv;
  		if ( bHasUV ) {

  			// UV interpolation setup
  			var dtu12 = tu1 - tu2, dtu31 = tu3 - tu1;
  			var dtudx = ( invDet * ( dtu12 * dy31 - dtu31 * dy12 ) ); // dtu per one subpixel step in x
  			var dtudy = ( invDet * ( dtu12 * dx31 - dx12 * dtu31 ) ); // dtu per one subpixel step in y
  			var dtv12 = tv1 - tv2, dtv31 = tv3 - tv1;
  			dtvdx = ( invDet * ( dtv12 * dy31 - dtv31 * dy12 ) ); // dtv per one subpixel step in x
  			dtvdy = ( invDet * ( dtv12 * dx31 - dx12 * dtv31 ) ); // dtv per one subpixel step in y

  			// UV at top/left corner of rast area
  			cbtu = ( tu1 + ( minXfixscale - x1 ) * dtudx + ( minYfixscale - y1 ) * dtudy );
  			cbtv = ( tv1 + ( minXfixscale - x1 ) * dtvdx + ( minYfixscale - y1 ) * dtvdy );

  			// UV pixel steps
  			dtudx = dtudx * fixscale;
  			dtudy = dtudy * fixscale;
  			dtvdx = dtvdx * fixscale;
  			dtvdy = dtvdy * fixscale;

  		}

  		var dnzdy, cbnz;

  		if ( bHasNormal ) {

  			 // Normal interpolation setup
  			var dnz12 = nz1 - nz2, dnz31 = nz3 - nz1;
  			var dnzdx = ( invDet * ( dnz12 * dy31 - dnz31 * dy12 ) ); // dnz per one subpixel step in x
  			var dnzdy = ( invDet * ( dnz12 * dx31 - dx12 * dnz31 ) ); // dnz per one subpixel step in y

  			// Normal at top/left corner of rast area
  			cbnz = ( nz1 + ( minXfixscale - x1 ) * dnzdx + ( minYfixscale - y1 ) * dnzdy );

  			// Normal pixel steps
  			dnzdx = ( dnzdx * fixscale );
  			dnzdy = ( dnzdy * fixscale );

  		}

  		// Set up min/max corners
  		var qm1 = q - 1; // for convenience
  		var nmin1 = 0, nmax1 = 0;
  		var nmin2 = 0, nmax2 = 0;
  		var nmin3 = 0, nmax3 = 0;
  		var nminz = 0, nmaxz = 0;
  		if ( dx12 >= 0 ) { nmax1 -= qm1 * dx12; } else { nmin1 -= qm1 * dx12; }
  		if ( dy12 >= 0 ) { nmax1 -= qm1 * dy12; } else { nmin1 -= qm1 * dy12; }
  		if ( dx23 >= 0 ) { nmax2 -= qm1 * dx23; } else { nmin2 -= qm1 * dx23; }
  		if ( dy23 >= 0 ) { nmax2 -= qm1 * dy23; } else { nmin2 -= qm1 * dy23; }
  		if ( dx31 >= 0 ) { nmax3 -= qm1 * dx31; } else { nmin3 -= qm1 * dx31; }
  		if ( dy31 >= 0 ) { nmax3 -= qm1 * dy31; } else { nmin3 -= qm1 * dy31; }
  		if ( dzdx >= 0 ) { nmaxz += qm1 * dzdx; } else { nminz += qm1 * dzdx; }
  		if ( dzdy >= 0 ) { nmaxz += qm1 * dzdy; } else { nminz += qm1 * dzdy; }

  		// Loop through blocks
  		var linestep = canvasWidth - q;

  		var cb1 = c1;
  		var cb2 = c2;
  		var cb3 = c3;
  		var cbz = cz;
  		var qstep = - q;
  		var e1x = qstep * dy12;
  		var e2x = qstep * dy23;
  		var e3x = qstep * dy31;
  		var ezx = qstep * dzdx;

  		var etux, etvx;
  		if ( bHasUV ) {

  			etux = qstep * dtudx;
  			etvx = qstep * dtvdx;

  		}

  		var enzx;
  		if ( bHasNormal ) {

  			enzx = qstep * dnzdx;

  		}

  		var x0 = minx;

  		for ( var y0 = miny; y0 < maxy; y0 += q ) {

  			// New block line - keep hunting for tri outer edge in old block line dir
  			while ( x0 >= minx && x0 < maxx && cb1 >= nmax1 && cb2 >= nmax2 && cb3 >= nmax3 ) {

  				x0 += qstep;
  				cb1 += e1x;
  				cb2 += e2x;
  				cb3 += e3x;
  				cbz += ezx;

  				if ( bHasUV ) {

  					cbtu += etux;
  					cbtv += etvx;

  				}

  				if ( bHasNormal ) {

  					cbnz += enzx;

  				}

  			}

  			// Okay, we're now in a block we know is outside. Reverse direction and go into main loop.
  			qstep = - qstep;
  			e1x = - e1x;
  			e2x = - e2x;
  			e3x = - e3x;
  			ezx = - ezx;

  			if ( bHasUV ) {

  				etux = - etux;
  				etvx = - etvx;

  			}

  			if ( bHasNormal ) {

  				enzx = - enzx;

  			}

  			while ( 1 ) {

  				// Step everything
  				x0 += qstep;
  				cb1 += e1x;
  				cb2 += e2x;
  				cb3 += e3x;
  				cbz += ezx;

  				if ( bHasUV ) {

  					cbtu += etux;
  					cbtv += etvx;

  				}

  				if ( bHasNormal ) {

  					cbnz += enzx;

  				}

  				// We're done with this block line when at least one edge completely out
  				// If an edge function is too small and decreasing in the current traversal
  				// dir, we're done with this line.
  				if ( x0 < minx || x0 >= maxx ) { break; }
  				if ( cb1 < nmax1 ) { if ( e1x < 0 ) { break; } else { continue; } }
  				if ( cb2 < nmax2 ) { if ( e2x < 0 ) { break; } else { continue; } }
  				if ( cb3 < nmax3 ) { if ( e3x < 0 ) { break; } else { continue; } }

  				// We can skip this block if it's already fully covered
  				var blockX = x0 >> blockShift;
  				var blockY = y0 >> blockShift;
  				var blockId = blockX + blockY * canvasWBlocks;
  				var minz = cbz + nminz;

  				// farthest point in block closer than closest point in our tri?
  				if ( blockMaxZ[ blockId ] < minz ) { continue; }

  				// Need to do a deferred clear?
  				var bflags = blockFlags[ blockId ];
  				if ( bflags & BLOCK_NEEDCLEAR ) { clearBlock( blockX, blockY ); }
  				blockFlags[ blockId ] = bflags & ~ ( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );

  				// Offset at top-left corner
  				var offset = x0 + y0 * canvasWidth;

  				// Accept whole block when fully covered
  				if ( cb1 >= nmin1 && cb2 >= nmin2 && cb3 >= nmin3 ) {

  					var maxz = cbz + nmaxz;
  					blockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );

  					var cy1 = cb1;
  					var cy2 = cb2;
  					var cyz = cbz;

  					var cytu, cytv;
  					if ( bHasUV ) {

  						cytu = cbtu;
  						cytv = cbtv;

  					}

  					var cynz;
  					if ( bHasNormal ) {

  						cynz = cbnz;

  					}
  					for ( var iy = 0; iy < q; iy ++ ) {

  						var cx1 = cy1;
  						var cx2 = cy2;
  						var cxz = cyz;

  						var cxtu;
  						var cxtv;
  						if ( bHasUV ) {

  							cxtu = cytu;
  							cxtv = cytv;

  						}

  						var cxnz;
  						if ( bHasNormal ) {

  							cxnz = cynz;

  						}

  						for ( var ix = 0; ix < q; ix ++ ) {

  							var z = cxz;

  							if ( z < zbuffer[ offset ] ) {

  								shader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );

  							}

  							cx1 += dy12;
  							cx2 += dy23;
  							cxz += dzdx;

  							if ( bHasUV ) {

  								cxtu += dtudx;
  								cxtv += dtvdx;

  							}

  							if ( bHasNormal ) {

  								cxnz += dnzdx;

  							}

  							offset ++;

  						}

  						cy1 += dx12;
  						cy2 += dx23;
  						cyz += dzdy;

  						if ( bHasUV ) {

  							cytu += dtudy;
  							cytv += dtvdy;

  						}

  						if ( bHasNormal ) {

  							cynz += dnzdy;

  						}

  						offset += linestep;

  					}

  				} else {

  					// Partially covered block

  					var cy1 = cb1;
  					var cy2 = cb2;
  					var cy3 = cb3;
  					var cyz = cbz;

  					var cytu, cytv;
  					if ( bHasUV ) {

  						cytu = cbtu;
  						cytv = cbtv;

  					}

  					var cynz;
  					if ( bHasNormal ) {

  						cynz = cbnz;

  					}

  					for ( var iy = 0; iy < q; iy ++ ) {

  						var cx1 = cy1;
  						var cx2 = cy2;
  						var cx3 = cy3;
  						var cxz = cyz;

  						var cxtu;
  						var cxtv;
  						if ( bHasUV ) {

  							cxtu = cytu;
  							cxtv = cytv;

  						}

  						var cxnz;
  						if ( bHasNormal ) {

  							cxnz = cynz;

  						}

  						for ( var ix = 0; ix < q; ix ++ ) {

  							if ( ( cx1 | cx2 | cx3 ) >= 0 ) {

  								var z = cxz;

  								if ( z < zbuffer[ offset ] ) {

  									shader( data, zbuffer, offset, z, cxtu, cxtv, cxnz, face, material );

  								}

  							}

  							cx1 += dy12;
  							cx2 += dy23;
  							cx3 += dy31;
  							cxz += dzdx;

  							if ( bHasUV ) {

  								cxtu += dtudx;
  								cxtv += dtvdx;

  							}

  							if ( bHasNormal ) {

  								cxnz += dnzdx;

  							}

  							offset ++;

  						}

  						cy1 += dx12;
  						cy2 += dx23;
  						cy3 += dx31;
  						cyz += dzdy;

  						if ( bHasUV ) {

  							cytu += dtudy;
  							cytv += dtvdy;

  						}

  						if ( bHasNormal ) {

  							cynz += dnzdy;

  						}

  						offset += linestep;

  					}

  				}

  			}

  			// Advance to next row of blocks
  			cb1 += q * dx12;
  			cb2 += q * dx23;
  			cb3 += q * dx31;
  			cbz += q * dzdy;

  			if ( bHasUV ) {

  				cbtu += q * dtudy;
  				cbtv += q * dtvdy;

  			}

  			if ( bHasNormal ) {

  				cbnz += q * dnzdy;

  			}

  		}

  	}

  	// When drawing line, the blockShiftShift has to be zero. In order to clean pixel
  	// Using color1 and color2 to interpolation pixel color
  	// LineWidth is according to material.linewidth
  	function drawLine( v1, v2, color1, color2, shader, material ) {

  		// While the line mode is enable, blockSize has to be changed to 0.
  		if ( ! lineMode ) {

  			lineMode = true;
  			blockShift = 0;
  			blockSize = 1 << blockShift;

  			_this.setSize( canvas.width, canvas.height );

  		}

  		// TODO: Implement per-pixel z-clipping
  		if ( v1.z < - 1 || v1.z > 1 || v2.z < - 1 || v2.z > 1 ) { return; }

  		var halfLineWidth = Math.floor( ( material.linewidth - 1 ) * 0.5 );

  		// https://gist.github.com/2486101
  		// explanation: http://pouet.net/topic.php?which=8760&page=1

  		// 28.4 fixed-point coordinates
  		var x1 = ( v1.x * viewportXScale + viewportXOffs ) | 0;
  		var x2 = ( v2.x * viewportXScale + viewportXOffs ) | 0;

  		var y1 = ( v1.y * viewportYScale + viewportYOffs ) | 0;
  		var y2 = ( v2.y * viewportYScale + viewportYOffs ) | 0;

  		var z1 = ( v1.z * viewportZScale + viewportZOffs ) | 0;
  		var z2 = ( v2.z * viewportZScale + viewportZOffs ) | 0;

  		// Deltas
  		var dx12 = x1 - x2, dy12 = y1 - y2, dz12 = z1 - z2;

  		// Bounding rectangle
  		var minx = Math.max( ( Math.min( x1, x2 ) + subpixelBias ) >> subpixelBits, 0 );
  		var maxx = Math.min( ( Math.max( x1, x2 ) + subpixelBias ) >> subpixelBits, canvasWidth );
  		var miny = Math.max( ( Math.min( y1, y2 ) + subpixelBias ) >> subpixelBits, 0 );
  		var maxy = Math.min( ( Math.max( y1, y2 ) + subpixelBias ) >> subpixelBits, canvasHeight );
  		var minz = Math.max( ( Math.min( z1, z2 ) + subpixelBias ) >> subpixelBits, 0 );
  		var maxz = ( Math.max( z1, z2 ) + subpixelBias ) >> subpixelBits;

  		rectx1 = Math.min( minx, rectx1 );
  		rectx2 = Math.max( maxx, rectx2 );
  		recty1 = Math.min( miny, recty1 );
  		recty2 = Math.max( maxy, recty2 );

  		// Get the line's unit vector and cross vector
  		var length = Math.sqrt( ( dy12 * dy12 ) + ( dx12 * dx12 ) );
  		var unitX = ( dx12 / length );
  		var unitY = ( dy12 / length );
  		var unitZ = ( dz12 / length );
  		var pixelX, pixelY, pixelZ;
  		var pX, pY, pZ;
  		crossVector.set( unitX, unitY, unitZ );
  		crossVector.cross( lookVector );
  		crossVector.normalize();

  		while ( length > 0 ) {

  			// Get this pixel.
  			pixelX = x2 + length * unitX;
  			pixelY = y2 + length * unitY;
  			pixelZ = z2 + length * unitZ;

  			pixelX = ( pixelX + subpixelBias ) >> subpixelBits;
  			pixelY = ( pixelY + subpixelBias ) >> subpixelBits;
  			pZ = ( pixelZ + subpixelBias ) >> subpixelBits;

  			// Draw line with line width
  			for ( var i = - halfLineWidth; i <= halfLineWidth; ++ i ) {

  				// Compute the line pixels.
  				// Get the pixels on the vector that crosses to the line vector
  				pX = Math.floor( ( pixelX + crossVector.x * i ) );
  				pY = Math.floor( ( pixelY + crossVector.y * i ) );

  				// if pixel is over the rect. Continue
  				if ( rectx1 >= pX || rectx2 <= pX || recty1 >= pY || recty2 <= pY )
  					{ continue; }

  				// Find this pixel at which block
  				var blockX = pX >> blockShift;
  				var blockY = pY >> blockShift;
  				var blockId = blockX + blockY * canvasWBlocks;

  				// Compare the pixel depth width z block.
  				if ( blockMaxZ[ blockId ] < minz ) { continue; }

  				blockMaxZ[ blockId ] = Math.min( blockMaxZ[ blockId ], maxz );

  				var bflags = blockFlags[ blockId ];
  				if ( bflags & BLOCK_NEEDCLEAR ) { clearBlock( blockX, blockY ); }
  				blockFlags[ blockId ] = bflags & ~ ( BLOCK_ISCLEAR | BLOCK_NEEDCLEAR );

  				// draw pixel
  				var offset = pX + pY * canvasWidth;

  				if ( pZ < zbuffer[ offset ] ) {

  					shader( data, zbuffer, offset, pZ, color1, color2, material );

  				}

  			}

  			-- length;

  		}

  	}

  	function clearBlock( blockX, blockY ) {

  		var zoffset = blockX * blockSize + blockY * blockSize * canvasWidth;
  		var poffset = zoffset * 4;

  		var zlinestep = canvasWidth - blockSize;
  		var plinestep = zlinestep * 4;

  		for ( var y = 0; y < blockSize; y ++ ) {

  			for ( var x = 0; x < blockSize; x ++ ) {

  				zbuffer[ zoffset ++ ] = maxZVal;

  				data[ poffset ++ ] = clearColor.r * 255 | 0;
  				data[ poffset ++ ] = clearColor.g * 255 | 0;
  				data[ poffset ++ ] = clearColor.b * 255 | 0;
  				data[ poffset ++ ] = getAlpha() * 255 | 0;

  			}

  			zoffset += zlinestep;
  			poffset += plinestep;

  		}

  	}

  	function finishClear( ) {

  		var block = 0;

  		for ( var y = 0; y < canvasHBlocks; y ++ ) {

  			for ( var x = 0; x < canvasWBlocks; x ++ ) {

  				if ( blockFlags[ block ] & BLOCK_NEEDCLEAR ) {

  					clearBlock( x, y );
  					blockFlags[ block ] = BLOCK_ISCLEAR;

  				}

  				block ++;

  			}

  		}

  	}

  };

  SoftwareRenderer.Texture = function () {

  	var canvas;

  	this.fromImage = function ( image ) {

  		if ( ! image || image.width <= 0 || image.height <= 0 )
  			{ return; }

  		if ( canvas === undefined ) {

  			canvas = document.createElement( 'canvas' );

  		}

  		var size = image.width > image.height ? image.width : image.height;
  		size = _Math.ceilPowerOfTwo( size );

  		if ( canvas.width != size || canvas.height != size ) {

  			canvas.width = size;
  			canvas.height = size;

  		}

  		var ctx = canvas.getContext( '2d' );
  		ctx.clearRect( 0, 0, size, size );
  		ctx.drawImage( image, 0, 0, size, size );

  		var imgData = ctx.getImageData( 0, 0, size, size );

  		this.data = imgData.data;
  		this.width = size;
  		this.height = size;
  		this.srcUrl = image.src;

  	};

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SVGObject = function ( node ) {

  	Object3D.call( this );

  	this.node = node;

  };

  SVGObject.prototype = Object.create( Object3D.prototype );
  SVGObject.prototype.constructor = SVGObject;

  var SVGRenderer = function () {

  	console.log( 'SVGRenderer', REVISION );

  	var _this = this,
  		_renderData, _elements, _lights,
  		_projector = new Projector(),
  		_svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ),
  		_svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf,

  		_v1, _v2, _v3,

  		_clipBox = new Box2(),
  		_elemBox = new Box2(),

  		_color = new Color(),
  		_diffuseColor = new Color(),
  		_ambientLight = new Color(),
  		_directionalLights = new Color(),
  		_pointLights = new Color(),
  		_clearColor = new Color(),
  		_clearAlpha = 1,

  		_vector3 = new Vector3(), // Needed for PointLight
  		_centroid = new Vector3(),
  		_normal = new Vector3(),
  		_normalViewMatrix = new Matrix3(),

  		_viewMatrix = new Matrix4(),
  		_viewProjectionMatrix = new Matrix4(),

  		_svgPathPool = [],
  		_svgNode, _pathCount = 0,

  		_currentPath, _currentStyle,

  		_quality = 1, _precision = null;

  	this.domElement = _svg;

  	this.autoClear = true;
  	this.sortObjects = true;
  	this.sortElements = true;

  	this.info = {

  		render: {

  			vertices: 0,
  			faces: 0

  		}

  	};

  	this.setQuality = function ( quality ) {

  		switch ( quality ) {

  			case "high": _quality = 1; break;
  			case "low": _quality = 0; break;

  		}

  	};

  	this.setClearColor = function ( color, alpha ) {

  		_clearColor.set( color );
  		_clearAlpha = alpha !== undefined ? alpha : 1;

  	};

  	this.setPixelRatio = function () {};

  	this.setSize = function ( width, height ) {

  		_svgWidth = width; _svgHeight = height;
  		_svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;

  		_svg.setAttribute( 'viewBox', ( - _svgWidthHalf ) + ' ' + ( - _svgHeightHalf ) + ' ' + _svgWidth + ' ' + _svgHeight );
  		_svg.setAttribute( 'width', _svgWidth );
  		_svg.setAttribute( 'height', _svgHeight );

  		_clipBox.min.set( - _svgWidthHalf, - _svgHeightHalf );
  		_clipBox.max.set( _svgWidthHalf, _svgHeightHalf );

  	};

  	this.setPrecision = function ( precision ) {

  		_precision = precision;

  	};

  	function removeChildNodes() {

  		_pathCount = 0;

  		while ( _svg.childNodes.length > 0 ) {

  			_svg.removeChild( _svg.childNodes[ 0 ] );

  		}

  	}

  	function getSvgColor( color, opacity ) {

  		var arg = Math.floor( color.r * 255 ) + ',' + Math.floor( color.g * 255 ) + ',' + Math.floor( color.b * 255 );

  		if ( opacity === undefined || opacity === 1 ) { return 'rgb(' + arg + ')'; }

  		return 'rgb(' + arg + '); fill-opacity: ' + opacity;

  	}

  	function convert( c ) {

  		return _precision !== null ? c.toFixed( _precision ) : c;

  	}

  	this.clear = function () {

  		removeChildNodes();
  		_svg.style.backgroundColor = getSvgColor( _clearColor, _clearAlpha );

  	};

  	this.render = function ( scene, camera ) {

  		if ( camera instanceof Camera === false ) {

  			console.error( 'SVGRenderer.render: camera is not an instance of Camera.' );
  			return;

  		}

  		var background = scene.background;

  		if ( background && background.isColor ) {

  			removeChildNodes();
  			_svg.style.backgroundColor = getSvgColor( background );

  		} else if ( this.autoClear === true ) {

  			this.clear();

  		}

  		_this.info.render.vertices = 0;
  		_this.info.render.faces = 0;

  		_viewMatrix.copy( camera.matrixWorldInverse );
  		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

  		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
  		_elements = _renderData.elements;
  		_lights = _renderData.lights;

  		_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );

  		calculateLights( _lights );

  		 // reset accumulated path

  		_currentPath = '';
  		_currentStyle = '';

  		for ( var e = 0, el = _elements.length; e < el; e ++ ) {

  			var element = _elements[ e ];
  			var material = element.material;

  			if ( material === undefined || material.opacity === 0 ) { continue; }

  			_elemBox.makeEmpty();

  			if ( element instanceof RenderableSprite ) {

  				_v1 = element;
  				_v1.x *= _svgWidthHalf; _v1.y *= - _svgHeightHalf;

  				renderSprite( _v1, element, material );

  			} else if ( element instanceof RenderableLine ) {

  				_v1 = element.v1; _v2 = element.v2;

  				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
  				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;

  				_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );

  				if ( _clipBox.intersectsBox( _elemBox ) === true ) {

  					renderLine( _v1, _v2, element, material );

  				}

  			} else if ( element instanceof RenderableFace ) {

  				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

  				if ( _v1.positionScreen.z < - 1 || _v1.positionScreen.z > 1 ) { continue; }
  				if ( _v2.positionScreen.z < - 1 || _v2.positionScreen.z > 1 ) { continue; }
  				if ( _v3.positionScreen.z < - 1 || _v3.positionScreen.z > 1 ) { continue; }

  				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= - _svgHeightHalf;
  				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= - _svgHeightHalf;
  				_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= - _svgHeightHalf;

  				_elemBox.setFromPoints( [
  					_v1.positionScreen,
  					_v2.positionScreen,
  					_v3.positionScreen
  				] );

  				if ( _clipBox.intersectsBox( _elemBox ) === true ) {

  					renderFace3( _v1, _v2, _v3, element, material );

  				}

  			}

  		}

  		flushPath(); // just to flush last svg:path

  		scene.traverseVisible( function ( object ) {

  			 if ( object instanceof SVGObject ) {

  				_vector3.setFromMatrixPosition( object.matrixWorld );
  				_vector3.applyMatrix4( _viewProjectionMatrix );

  				if ( _vector3.z < - 1 || _vector3.z > 1 ) { return; }

  				var x = _vector3.x * _svgWidthHalf;
  				var y = - _vector3.y * _svgHeightHalf;

  				var node = object.node;
  				node.setAttribute( 'transform', 'translate(' + x + ',' + y + ')' );

  				_svg.appendChild( node );

  			}

  		} );

  	};

  	function calculateLights( lights ) {

  		_ambientLight.setRGB( 0, 0, 0 );
  		_directionalLights.setRGB( 0, 0, 0 );
  		_pointLights.setRGB( 0, 0, 0 );

  		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

  			var light = lights[ l ];
  			var lightColor = light.color;

  			if ( light.isAmbientLight ) {

  				_ambientLight.r += lightColor.r;
  				_ambientLight.g += lightColor.g;
  				_ambientLight.b += lightColor.b;

  			} else if ( light.isDirectionalLight ) {

  				_directionalLights.r += lightColor.r;
  				_directionalLights.g += lightColor.g;
  				_directionalLights.b += lightColor.b;

  			} else if ( light.isPointLight ) {

  				_pointLights.r += lightColor.r;
  				_pointLights.g += lightColor.g;
  				_pointLights.b += lightColor.b;

  			}

  		}

  	}

  	function calculateLight( lights, position, normal, color ) {

  		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

  			var light = lights[ l ];
  			var lightColor = light.color;

  			if ( light.isDirectionalLight ) {

  				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

  				var amount = normal.dot( lightPosition );

  				if ( amount <= 0 ) { continue; }

  				amount *= light.intensity;

  				color.r += lightColor.r * amount;
  				color.g += lightColor.g * amount;
  				color.b += lightColor.b * amount;

  			} else if ( light.isPointLight ) {

  				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

  				var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

  				if ( amount <= 0 ) { continue; }

  				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

  				if ( amount == 0 ) { continue; }

  				amount *= light.intensity;

  				color.r += lightColor.r * amount;
  				color.g += lightColor.g * amount;
  				color.b += lightColor.b * amount;

  			}

  		}

  	}

  	function renderSprite( v1, element, material ) {

  		var scaleX = element.scale.x * _svgWidthHalf;
  		var scaleY = element.scale.y * _svgHeightHalf;

  		if ( material.isPointsMaterial ) {

  			scaleX *= material.size;
  			scaleY *= material.size;

  		}

  		var path = 'M' + convert( v1.x - scaleX * 0.5 ) + ',' + convert( v1.y - scaleY * 0.5 ) + 'h' + convert( scaleX ) + 'v' + convert( scaleY ) + 'h' + convert( - scaleX ) + 'z';
  		var style = "";

  		if ( material.isSpriteMaterial || material.isPointsMaterial ) {

  			style = 'fill:' + getSvgColor( material.color, material.opacity );

  		}

  		addPath( style, path );

  	}

  	function renderLine( v1, v2, element, material ) {

  		var path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y );

  		if ( material.isLineBasicMaterial ) {

  			var style = 'fill:none;stroke:' + getSvgColor( material.color, material.opacity ) + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;

  			if ( material.isLineDashedMaterial ) {

  				style = style + ';stroke-dasharray:' + material.dashSize + "," + material.gapSize;

  			}

  			addPath( style, path );

  		}

  	}

  	function renderFace3( v1, v2, v3, element, material ) {

  		_this.info.render.vertices += 3;
  		_this.info.render.faces ++;

  		var path = 'M' + convert( v1.positionScreen.x ) + ',' + convert( v1.positionScreen.y ) + 'L' + convert( v2.positionScreen.x ) + ',' + convert( v2.positionScreen.y ) + 'L' + convert( v3.positionScreen.x ) + ',' + convert( v3.positionScreen.y ) + 'z';
  		var style = '';

  		if ( material.isMeshBasicMaterial ) {

  			_color.copy( material.color );

  			if ( material.vertexColors === FaceColors || material.vertexColors === VertexColors ) {

  				_color.multiply( element.color );

  			}

  		} else if ( material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial ) {

  			_diffuseColor.copy( material.color );

  			if ( material.vertexColors === FaceColors || material.vertexColors === VertexColors ) {

  				_diffuseColor.multiply( element.color );

  			}

  			_color.copy( _ambientLight );

  			_centroid.copy( v1.positionWorld ).add( v2.positionWorld ).add( v3.positionWorld ).divideScalar( 3 );

  			calculateLight( _lights, _centroid, element.normalModel, _color );

  			_color.multiply( _diffuseColor ).add( material.emissive );

  		} else if ( material.isMeshNormalMaterial ) {

  			_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );

  			_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

  		}

  		if ( material.wireframe ) {

  			style = 'fill:none;stroke:' + getSvgColor( _color, material.opacity ) + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;

  		} else {

  			style = 'fill:' + getSvgColor( _color, material.opacity );

  		}

  		addPath( style, path );

  	}

  	function addPath( style, path ) {

  		if ( _currentStyle === style ) {

  			_currentPath += path;

  		} else {

  			flushPath();

  			_currentStyle = style;
  			_currentPath = path;

  		}

  	}

  	function flushPath() {

  		if ( _currentPath ) {

  			_svgNode = getPathNode( _pathCount ++ );
  			_svgNode.setAttribute( 'd', _currentPath );
  			_svgNode.setAttribute( 'style', _currentStyle );
  			_svg.appendChild( _svgNode );

  		}

  		_currentPath = '';
  		_currentStyle = '';

  	}

  	function getPathNode( id ) {

  		if ( _svgPathPool[ id ] == null ) {

  			_svgPathPool[ id ] = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );

  			if ( _quality == 0 ) {

  				_svgPathPool[ id ].setAttribute( 'shape-rendering', 'crispEdges' ); //optimizeSpeed

  			}

  			return _svgPathPool[ id ];

  		}

  		return _svgPathPool[ id ];

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLAnimation() {

  	var context = null;
  	var isAnimating = false;
  	var animationLoop = null;

  	function onAnimationFrame( time, frame ) {

  		if ( isAnimating === false ) { return; }

  		animationLoop( time, frame );

  		context.requestAnimationFrame( onAnimationFrame );

  	}

  	return {

  		start: function () {

  			if ( isAnimating === true ) { return; }
  			if ( animationLoop === null ) { return; }

  			context.requestAnimationFrame( onAnimationFrame );

  			isAnimating = true;

  		},

  		stop: function () {

  			isAnimating = false;

  		},

  		setAnimationLoop: function ( callback ) {

  			animationLoop = callback;

  		},

  		setContext: function ( value ) {

  			context = value;

  		}

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLAttributes( gl ) {

  	var buffers = new WeakMap();

  	function createBuffer( attribute, bufferType ) {

  		var array = attribute.array;
  		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

  		var buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		var type = gl.FLOAT;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( array instanceof Float64Array ) {

  			console.warn( 'WebGLAttributes: Unsupported data buffer format: Float64Array.' );

  		} else if ( array instanceof Uint16Array ) {

  			type = gl.UNSIGNED_SHORT;

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		var array = attribute.array;
  		var updateRange = attribute.updateRange;

  		gl.bindBuffer( bufferType, buffer );

  		if ( attribute.dynamic === false ) {

  			gl.bufferData( bufferType, array, gl.STATIC_DRAW );

  		} else if ( updateRange.count === - 1 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else if ( updateRange.count === 0 ) {

  			console.error( 'WebGLObjects.updateBuffer: dynamic BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

  		} else {

  			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

  			updateRange.count = - 1; // reset range

  		}

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		return buffers.get( attribute );

  	}

  	function remove( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		var data = buffers.get( attribute );

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			buffers.delete( attribute );

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		var data = buffers.get( attribute );

  		if ( data === undefined ) {

  			buffers.set( attribute, createBuffer( attribute, bufferType ) );

  		} else if ( data.version < attribute.version ) {

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

  	var clearColor = new Color( 0x000000 );
  	var clearAlpha = 0;

  	var planeMesh;
  	var boxMesh;
  	// Store the current background texture and its `version`
  	// so we can recompile the material accordingly.
  	var currentBackground = null;
  	var currentBackgroundVersion = 0;

  	function render( renderList, scene, camera, forceClear ) {

  		var background = scene.background;

  		if ( background === null ) {

  			setClear( clearColor, clearAlpha );
  			currentBackground = null;
  			currentBackgroundVersion = 0;

  		} else if ( background && background.isColor ) {

  			setClear( background, 1 );
  			forceClear = true;
  			currentBackground = null;
  			currentBackgroundVersion = 0;

  		}

  		if ( renderer.autoClear || forceClear ) {

  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  		if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {

  			if ( boxMesh === undefined ) {

  				boxMesh = new Mesh(
  					new BoxBufferGeometry( 1, 1, 1 ),
  					new ShaderMaterial( {
  						type: 'BackgroundCubeMaterial',
  						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
  						vertexShader: ShaderLib.cube.vertexShader,
  						fragmentShader: ShaderLib.cube.fragmentShader,
  						side: BackSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				boxMesh.geometry.removeAttribute( 'normal' );
  				boxMesh.geometry.removeAttribute( 'uv' );

  				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					this.matrixWorld.copyPosition( camera.matrixWorld );

  				};

  				// enable code injection for non-built-in material
  				Object.defineProperty( boxMesh.material, 'map', {

  					get: function () {

  						return this.uniforms.tCube.value;

  					}

  				} );

  				objects.update( boxMesh );

  			}

  			var texture = background.isWebGLRenderTargetCube ? background.texture : background;
  			boxMesh.material.uniforms.tCube.value = texture;
  			boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;

  			if ( currentBackground !== background ||
  			     currentBackgroundVersion !== texture.version ) {

  				boxMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = texture.version;

  			}

  			// push to the pre-sorted opaque render list
  			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

  		} else if ( background && background.isTexture ) {

  			if ( planeMesh === undefined ) {

  				planeMesh = new Mesh(
  					new PlaneBufferGeometry( 2, 2 ),
  					new ShaderMaterial( {
  						type: 'BackgroundMaterial',
  						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
  						vertexShader: ShaderLib.background.vertexShader,
  						fragmentShader: ShaderLib.background.fragmentShader,
  						side: FrontSide,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  				planeMesh.geometry.removeAttribute( 'normal' );

  				// enable code injection for non-built-in material
  				Object.defineProperty( planeMesh.material, 'map', {

  					get: function () {

  						return this.uniforms.t2D.value;

  					}

  				} );

  				objects.update( planeMesh );

  			}

  			planeMesh.material.uniforms.t2D.value = background;

  			if ( background.matrixAutoUpdate === true ) {

  				background.updateMatrix();

  			}

  			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

  			if ( currentBackground !== background ||
  				   currentBackgroundVersion !== background.version ) {

  				planeMesh.material.needsUpdate = true;

  				currentBackground = background;
  				currentBackgroundVersion = background.version;

  			}
  			// push to the pre-sorted opaque render list
  			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

  		}

  	}

  	function setClear( color, alpha ) {

  		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

  	}

  	return {

  		getClearColor: function () {

  			return clearColor;

  		},
  		setClearColor: function ( color, alpha ) {

  			clearColor.set( color );
  			clearAlpha = alpha !== undefined ? alpha : 1;
  			setClear( clearColor, clearAlpha );

  		},
  		getClearAlpha: function () {

  			return clearAlpha;

  		},
  		setClearAlpha: function ( alpha ) {

  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		render: render

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		info.update( count, mode );

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension;

  		if ( capabilities.isWebGL2 ) {

  			extension = gl;

  		} else {

  			extension = extensions.get( 'ANGLE_instanced_arrays' );

  			if ( extension === null ) {

  				console.error( 'WebGLBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

  		info.update( count, mode, geometry.maxInstancedCount );

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLCapabilities( gl, extensions, parameters ) {

  	var maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) { return maxAnisotropy; }

  		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension !== null ) {

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

  	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	var maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

  	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  	var vertexTextures = maxVertexTextures > 0;
  	var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
  	var floatVertexTextures = vertexTextures && floatFragmentTextures;

  	var maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

  	return {

  		isWebGL2: isWebGL2,

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,
  		floatFragmentTextures: floatFragmentTextures,
  		floatVertexTextures: floatVertexTextures,

  		maxSamples: maxSamples

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLClipping() {

  	var scope = this,

  		globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false,

  		plane = new Plane(),
  		viewNormalMatrix = new Matrix3(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function ( planes, enableLocalClipping, camera ) {

  		var enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		globalState = projectPlanes( planes, camera, 0 );
  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function () {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function () {

  		renderingShadows = false;
  		resetGlobalState();

  	};

  	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

  		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  			// there's no local clipping

  			if ( renderingShadows ) {

  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();

  			}

  		} else {

  			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4,

  				dstArray = cache.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

  			for ( var i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			cache.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}
  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		var nPlanes = planes !== null ? planes.length : 0,
  			dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				var flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;

  		return dstArray;

  	}

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLExtensions( gl ) {

  	var extensions = {};

  	return {

  		get: function ( name ) {

  			if ( extensions[ name ] !== undefined ) {

  				return extensions[ name ];

  			}

  			var extension;

  			switch ( name ) {

  				case 'WEBGL_depth_texture':
  					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  					break;

  				case 'EXT_texture_filter_anisotropic':
  					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  					break;

  				case 'WEBGL_compressed_texture_s3tc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  					break;

  				case 'WEBGL_compressed_texture_pvrtc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  					break;

  				default:
  					extension = gl.getExtension( name );

  			}

  			if ( extension === null ) {

  				console.warn( 'WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			extensions[ name ] = extension;

  			return extension;

  		}

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLGeometries( gl, attributes, info ) {

  	var geometries = {};
  	var wireframeAttributes = {};

  	function onGeometryDispose( event ) {

  		var geometry = event.target;
  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry.index !== null ) {

  			attributes.remove( buffergeometry.index );

  		}

  		for ( var name in buffergeometry.attributes ) {

  			attributes.remove( buffergeometry.attributes[ name ] );

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		var attribute = wireframeAttributes[ buffergeometry.id ];

  		if ( attribute ) {

  			attributes.remove( attribute );
  			delete wireframeAttributes[ buffergeometry.id ];

  		}

  		//

  		info.memory.geometries --;

  	}

  	function get( object, geometry ) {

  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry ) { return buffergeometry; }

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		if ( geometry.isBufferGeometry ) {

  			buffergeometry = geometry;

  		} else if ( geometry.isGeometry ) {

  			if ( geometry._bufferGeometry === undefined ) {

  				geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

  			}

  			buffergeometry = geometry._bufferGeometry;

  		}

  		geometries[ geometry.id ] = buffergeometry;

  		info.memory.geometries ++;

  		return buffergeometry;

  	}

  	function update( geometry ) {

  		var index = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		if ( index !== null ) {

  			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

  		}

  		for ( var name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

  		}

  		// morph targets

  		var morphAttributes = geometry.morphAttributes;

  		for ( var name in morphAttributes ) {

  			var array = morphAttributes[ name ];

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				attributes.update( array[ i ], gl.ARRAY_BUFFER );

  			}

  		}

  	}

  	function getWireframeAttribute( geometry ) {

  		var attribute = wireframeAttributes[ geometry.id ];

  		if ( attribute ) { return attribute; }

  		var indices = [];

  		var geometryIndex = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		// console.time( 'wireframe' );

  		if ( geometryIndex !== null ) {

  			var array = geometryIndex.array;

  			for ( var i = 0, l = array.length; i < l; i += 3 ) {

  				var a = array[ i + 0 ];
  				var b = array[ i + 1 ];
  				var c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			var array = geometryAttributes.position.array;

  			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				var a = i + 0;
  				var b = i + 1;
  				var c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		}

  		// console.timeEnd( 'wireframe' );

  		attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

  		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

  		wireframeAttributes[ geometry.id ] = attribute;

  		return attribute;

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	var type, bytesPerElement;

  	function setIndex( value ) {

  		type = value.type;
  		bytesPerElement = value.bytesPerElement;

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * bytesPerElement );

  		info.update( count, mode );

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension;

  		if ( capabilities.isWebGL2 ) {

  			extension = gl;

  		} else {

  			var extension = extensions.get( 'ANGLE_instanced_arrays' );

  			if ( extension === null ) {

  				console.error( 'WebGLIndexedBufferRenderer: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

  		info.update( count, mode, geometry.maxInstancedCount );

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLInfo( gl ) {

  	var memory = {
  		geometries: 0,
  		textures: 0
  	};

  	var render = {
  		frame: 0,
  		calls: 0,
  		triangles: 0,
  		points: 0,
  		lines: 0
  	};

  	function update( count, mode, instanceCount ) {

  		instanceCount = instanceCount || 1;

  		render.calls ++;

  		switch ( mode ) {

  			case gl.TRIANGLES:
  				render.triangles += instanceCount * ( count / 3 );
  				break;

  			case gl.TRIANGLE_STRIP:
  			case gl.TRIANGLE_FAN:
  				render.triangles += instanceCount * ( count - 2 );
  				break;

  			case gl.LINES:
  				render.lines += instanceCount * ( count / 2 );
  				break;

  			case gl.LINE_STRIP:
  				render.lines += instanceCount * ( count - 1 );
  				break;

  			case gl.LINE_LOOP:
  				render.lines += instanceCount * count;
  				break;

  			case gl.POINTS:
  				render.points += instanceCount * count;
  				break;

  			default:
  				console.error( 'WebGLInfo: Unknown draw mode:', mode );
  				break;

  		}

  	}

  	function reset() {

  		render.frame ++;
  		render.calls = 0;
  		render.triangles = 0;
  		render.points = 0;
  		render.lines = 0;

  	}

  	return {
  		memory: memory,
  		render: render,
  		programs: null,
  		autoReset: true,
  		reset: reset,
  		update: update
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function absNumericalSort( a, b ) {

  	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

  }

  function WebGLMorphtargets( gl ) {

  	var influencesList = {};
  	var morphInfluences = new Float32Array( 8 );

  	function update( object, geometry, material, program ) {

  		var objectInfluences = object.morphTargetInfluences;

  		var length = objectInfluences.length;

  		var influences = influencesList[ geometry.id ];

  		if ( influences === undefined ) {

  			// initialise list

  			influences = [];

  			for ( var i = 0; i < length; i ++ ) {

  				influences[ i ] = [ i, 0 ];

  			}

  			influencesList[ geometry.id ] = influences;

  		}

  		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
  		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

  		// Remove current morphAttributes

  		for ( var i = 0; i < length; i ++ ) {

  			var influence = influences[ i ];

  			if ( influence[ 1 ] !== 0 ) {

  				if ( morphTargets ) { geometry.removeAttribute( 'morphTarget' + i ); }
  				if ( morphNormals ) { geometry.removeAttribute( 'morphNormal' + i ); }

  			}

  		}

  		// Collect influences

  		for ( var i = 0; i < length; i ++ ) {

  			var influence = influences[ i ];

  			influence[ 0 ] = i;
  			influence[ 1 ] = objectInfluences[ i ];

  		}

  		influences.sort( absNumericalSort );

  		// Add morphAttributes

  		for ( var i = 0; i < 8; i ++ ) {

  			var influence = influences[ i ];

  			if ( influence ) {

  				var index = influence[ 0 ];
  				var value = influence[ 1 ];

  				if ( value ) {

  					if ( morphTargets ) { geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] ); }
  					if ( morphNormals ) { geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] ); }

  					morphInfluences[ i ] = value;
  					continue;

  				}

  			}

  			morphInfluences[ i ] = 0;

  		}

  		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

  	}

  	return {

  		update: update

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLObjects( geometries, info ) {

  	var updateList = {};

  	function update( object ) {

  		var frame = info.render.frame;

  		var geometry = object.geometry;
  		var buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateList[ buffergeometry.id ] !== frame ) {

  			if ( geometry.isGeometry ) {

  				buffergeometry.updateFromObject( object );

  			}

  			geometries.update( buffergeometry );

  			updateList[ buffergeometry.id ] = frame;

  		}

  		return buffergeometry;

  	}

  	function dispose() {

  		updateList = {};

  	}

  	return {

  		update: update,
  		dispose: dispose

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DataTexture3D( data, width, height, depth ) {

  	// We're going to add .setXXX() methods for setting properties later.
  	// Users can still set in DataTexture3D directly.
  	//
  	//	var texture = new DataTexture3D( data, width, height, depth );
  	// 	texture.anisotropy = 16;
  	//
  	// See #14839

  	Texture.call( this, null );

  	this.image = { data: data, width: width, height: height, depth: depth };

  	this.magFilter = NearestFilter;
  	this.minFilter = NearestFilter;

  	this.wrapR = ClampToEdgeWrapping;

  	this.generateMipmaps = false;
  	this.flipY = false;

  }

  DataTexture3D.prototype = Object.create( Texture.prototype );
  DataTexture3D.prototype.constructor = DataTexture3D;
  DataTexture3D.prototype.isDataTexture3D = true;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var emptyTexture = new Texture();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();

  // --- Base for inner nodes (including the root) ---

  function UniformContainer() {

  	this.seq = [];
  	this.map = {};

  }

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  var arrayCacheF32 = [];
  var arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  var mat4array = new Float32Array( 16 );
  var mat3array = new Float32Array( 9 );
  var mat2array = new Float32Array( 4 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

  	var firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) { return array; }
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	var n = nBlocks * blockSize,
  		r = arrayCacheF32[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  function arraysEqual( a, b ) {

  	if ( a.length !== b.length ) { return false; }

  	for ( var i = 0, l = a.length; i < l; i ++ ) {

  		if ( a[ i ] !== b[ i ] ) { return false; }

  	}

  	return true;

  }

  function copyArray( a, b ) {

  	for ( var i = 0, l = b.length; i < l; i ++ ) {

  		a[ i ] = b[ i ];

  	}

  }

  // Texture unit allocation

  function allocTexUnits( renderer, n ) {

  	var r = arrayCacheI32[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32[ n ] = r;

  	}

  	for ( var i = 0; i !== n; ++ i )
  		{ r[ i ] = renderer.allocTextureUnit(); }

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValue1f( gl, v ) {

  	var cache = this.cache;

  	if ( cache[ 0 ] === v ) { return; }

  	gl.uniform1f( this.addr, v );

  	cache[ 0 ] = v;

  }

  function setValue1i( gl, v ) {

  	var cache = this.cache;

  	if ( cache[ 0 ] === v ) { return; }

  	gl.uniform1i( this.addr, v );

  	cache[ 0 ] = v;

  }

  // Single float vector (from flat array or VectorN)

  function setValue2fv( gl, v ) {

  	var cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  			gl.uniform2f( this.addr, v.x, v.y );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniform2fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValue3fv( gl, v ) {

  	var cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  			gl.uniform3f( this.addr, v.x, v.y, v.z );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;

  		}

  	} else if ( v.r !== undefined ) {

  		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

  			gl.uniform3f( this.addr, v.r, v.g, v.b );

  			cache[ 0 ] = v.r;
  			cache[ 1 ] = v.g;
  			cache[ 2 ] = v.b;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniform3fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  function setValue4fv( gl, v ) {

  	var cache = this.cache;

  	if ( v.x !== undefined ) {

  		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  			cache[ 0 ] = v.x;
  			cache[ 1 ] = v.y;
  			cache[ 2 ] = v.z;
  			cache[ 3 ] = v.w;

  		}

  	} else {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniform4fv( this.addr, v );

  		copyArray( cache, v );

  	}

  }

  // Single matrix (from flat array or MatrixN)

  function setValue2fm( gl, v ) {

  	var cache = this.cache;
  	var elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniformMatrix2fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) { return; }

  		mat2array.set( elements );

  		gl.uniformMatrix2fv( this.addr, false, mat2array );

  		copyArray( cache, elements );

  	}

  }

  function setValue3fm( gl, v ) {

  	var cache = this.cache;
  	var elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniformMatrix3fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) { return; }

  		mat3array.set( elements );

  		gl.uniformMatrix3fv( this.addr, false, mat3array );

  		copyArray( cache, elements );

  	}

  }

  function setValue4fm( gl, v ) {

  	var cache = this.cache;
  	var elements = v.elements;

  	if ( elements === undefined ) {

  		if ( arraysEqual( cache, v ) ) { return; }

  		gl.uniformMatrix4fv( this.addr, false, v );

  		copyArray( cache, v );

  	} else {

  		if ( arraysEqual( cache, elements ) ) { return; }

  		mat4array.set( elements );

  		gl.uniformMatrix4fv( this.addr, false, mat4array );

  		copyArray( cache, elements );

  	}

  }

  // Single texture (2D / Cube)

  function setValueT1( gl, v, renderer ) {

  	var cache = this.cache;
  	var unit = renderer.allocTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	renderer.setTexture2D( v || emptyTexture, unit );

  }

  function setValueT3D1( gl, v, renderer ) {

  	var cache = this.cache;
  	var unit = renderer.allocTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	renderer.setTexture3D( v || emptyTexture3d, unit );

  }

  function setValueT6( gl, v, renderer ) {

  	var cache = this.cache;
  	var unit = renderer.allocTextureUnit();

  	if ( cache[ 0 ] !== unit ) {

  		gl.uniform1i( this.addr, unit );
  		cache[ 0 ] = unit;

  	}

  	renderer.setTextureCube( v || emptyCubeTexture, unit );

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)

  function setValue2iv( gl, v ) {

  	var cache = this.cache;

  	if ( arraysEqual( cache, v ) ) { return; }

  	gl.uniform2iv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValue3iv( gl, v ) {

  	var cache = this.cache;

  	if ( arraysEqual( cache, v ) ) { return; }

  	gl.uniform3iv( this.addr, v );

  	copyArray( cache, v );

  }

  function setValue4iv( gl, v ) {

  	var cache = this.cache;

  	if ( arraysEqual( cache, v ) ) { return; }

  	gl.uniform4iv( this.addr, v );

  	copyArray( cache, v );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1f; // FLOAT
  		case 0x8b50: return setValue2fv; // _VEC2
  		case 0x8b51: return setValue3fv; // _VEC3
  		case 0x8b52: return setValue4fv; // _VEC4

  		case 0x8b5a: return setValue2fm; // _MAT2
  		case 0x8b5b: return setValue3fm; // _MAT3
  		case 0x8b5c: return setValue4fm; // _MAT4

  		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
  		case 0x8B5F: return setValueT3D1; // SAMPLER_3D
  		case 0x8b60: return setValueT6; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  	}

  }

  // Array of scalars

  function setValue1fv( gl, v ) {

  	var cache = this.cache;

  	if ( arraysEqual( cache, v ) ) { return; }

  	gl.uniform1fv( this.addr, v );

  	copyArray( cache, v );

  }
  function setValue1iv( gl, v ) {

  	var cache = this.cache;

  	if ( arraysEqual( cache, v ) ) { return; }

  	gl.uniform1iv( this.addr, v );

  	copyArray( cache, v );

  }

  // Array of vectors (flat or from THREE classes)

  function setValueV2a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 2 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniform2fv( this.addr, data );

  	this.updateCache( data );

  }

  function setValueV3a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 3 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniform3fv( this.addr, data );

  	this.updateCache( data );

  }

  function setValueV4a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 4 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniform4fv( this.addr, data );

  	this.updateCache( data );

  }

  // Array of matrices (flat or from THREE clases)

  function setValueM2a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 4 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniformMatrix2fv( this.addr, false, data );

  	this.updateCache( data );

  }

  function setValueM3a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 9 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniformMatrix3fv( this.addr, false, data );

  	this.updateCache( data );

  }

  function setValueM4a( gl, v ) {

  	var cache = this.cache;
  	var data = flatten( v, this.size, 16 );

  	if ( arraysEqual( cache, data ) ) { return; }

  	gl.uniformMatrix4fv( this.addr, false, data );

  	this.updateCache( data );

  }

  // Array of textures (2D / Cube)

  function setValueT1a( gl, v, renderer ) {

  	var cache = this.cache;
  	var n = v.length;

  	var units = allocTexUnits( renderer, n );

  	if ( arraysEqual( cache, units ) === false ) {

  		gl.uniform1iv( this.addr, units );
  		copyArray( cache, units );

  	}

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

  	}

  }

  function setValueT6a( gl, v, renderer ) {

  	var cache = this.cache;
  	var n = v.length;

  	var units = allocTexUnits( renderer, n );

  	if ( arraysEqual( cache, units ) === false ) {

  		gl.uniform1iv( this.addr, units );
  		copyArray( cache, units );

  	}

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  	}

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1fv; // FLOAT
  		case 0x8b50: return setValueV2a; // _VEC2
  		case 0x8b51: return setValueV3a; // _VEC3
  		case 0x8b52: return setValueV4a; // _VEC4

  		case 0x8b5a: return setValueM2a; // _MAT2
  		case 0x8b5b: return setValueM3a; // _MAT3
  		case 0x8b5c: return setValueM4a; // _MAT4

  		case 0x8b5e: return setValueT1a; // SAMPLER_2D
  		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  	}

  }

  // --- Uniform Classes ---

  function SingleUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.cache = [];
  	this.setValue = getSingularSetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.cache = [];
  	this.size = activeInfo.size;
  	this.setValue = getPureArraySetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  PureArrayUniform.prototype.updateCache = function ( data ) {

  	var cache = this.cache;

  	if ( data instanceof Float32Array && cache.length !== data.length ) {

  		this.cache = new Float32Array( data.length );

  	}

  	copyArray( cache, data );

  };

  function StructuredUniform( id ) {

  	this.id = id;

  	UniformContainer.call( this ); // mix-in

  }

  StructuredUniform.prototype.setValue = function ( gl, value, renderer ) {

  	var seq = this.seq;

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		u.setValue( gl, value[ u.id ], renderer );

  	}

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

  	var path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart.lastIndex = 0;

  	while ( true ) {

  		var match = RePathPart.exec( path ),
  			matchEnd = RePathPart.lastIndex,

  			id = match[ 1 ],
  			idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) { id = id | 0; } // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform( container, subscript === undefined ?
  				new SingleUniform( id, activeInfo, addr ) :
  				new PureArrayUniform( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			var map = container.map, next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform( id );
  				addUniform( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  function WebGLUniforms( gl, program, renderer ) {
  	var this$1 = this;


  	UniformContainer.call( this );

  	this.renderer = renderer;

  	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

  	for ( var i = 0; i < n; ++ i ) {

  		var info = gl.getActiveUniform( program, i ),
  			addr = gl.getUniformLocation( program, info.name );

  		parseUniform( info, addr, this$1 );

  	}

  }

  WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

  	var u = this.map[ name ];

  	if ( u !== undefined ) { u.setValue( gl, value, this.renderer ); }

  };

  WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

  	var v = object[ name ];

  	if ( v !== undefined ) { this.setValue( gl, name, v ); }

  };
  // Static interface

  WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ],
  			v = values[ u.id ];

  		if ( v.needsUpdate !== false ) {

  			// note: always updating when .needsUpdate is undefined
  			u.setValue( gl, v.value, renderer );

  		}

  	}

  };

  WebGLUniforms.seqWithValue = function ( seq, values ) {

  	var r = [];

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		if ( u.id in values ) { r.push( u ); }

  	}

  	return r;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function addLineNumbers( string ) {

  	var lines = string.split( '\n' );

  	for ( var i = 0; i < lines.length; i ++ ) {

  		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

  	}

  	return lines.join( '\n' );

  }

  function WebGLShader( gl, type, string ) {

  	var shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

  		console.error( 'WebGLShader: Shader couldn\'t compile.' );

  	}

  	if ( gl.getShaderInfoLog( shader ) !== '' ) {

  		console.warn( 'WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

  	}

  	// --enable-privileged-webgl-extension
  	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  	return shader;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var programIdCount = 0;

  function getEncodingComponents( encoding ) {

  	switch ( encoding ) {

  		case LinearEncoding:
  			return [ 'Linear', '( value )' ];
  		case sRGBEncoding:
  			return [ 'sRGB', '( value )' ];
  		case RGBEEncoding:
  			return [ 'RGBE', '( value )' ];
  		case RGBM7Encoding:
  			return [ 'RGBM', '( value, 7.0 )' ];
  		case RGBM16Encoding:
  			return [ 'RGBM', '( value, 16.0 )' ];
  		case RGBDEncoding:
  			return [ 'RGBD', '( value, 256.0 )' ];
  		case GammaEncoding:
  			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
  		default:
  			throw new Error( 'unsupported encoding: ' + encoding );

  	}

  }

  function getTexelDecodingFunction( functionName, encoding ) {

  	var components = getEncodingComponents( encoding );
  	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

  }

  function getTexelEncodingFunction( functionName, encoding ) {

  	var components = getEncodingComponents( encoding );
  	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

  }

  function getToneMappingFunction( functionName, toneMapping ) {

  	var toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping:
  			toneMappingName = 'Linear';
  			break;

  		case ReinhardToneMapping:
  			toneMappingName = 'Reinhard';
  			break;

  		case Uncharted2ToneMapping:
  			toneMappingName = 'Uncharted2';
  			break;

  		case CineonToneMapping:
  			toneMappingName = 'OptimizedCineon';
  			break;

  		case ACESFilmicToneMapping:
  			toneMappingName = 'ACESFilmic';
  			break;

  		default:
  			throw new Error( 'unsupported toneMapping: ' + toneMapping );

  	}

  	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  }

  function generateExtensions( extensions, parameters, rendererExtensions ) {

  	extensions = extensions || {};

  	var chunks = [
  		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
  		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
  		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
  		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
  	];

  	return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

  	var chunks = [];

  	for ( var name in defines ) {

  		var value = defines[ name ];

  		if ( value === false ) { continue; }

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

  	var attributes = {};

  	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

  	for ( var i = 0; i < n; i ++ ) {

  		var info = gl.getActiveAttrib( program, i );
  		var name = info.name;

  		// console.log( 'WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  		attributes[ name ] = gl.getAttribLocation( program, name );

  	}

  	return attributes;

  }

  function filterEmptyLine( string ) {

  	return string !== '';

  }

  function replaceLightNums( string, parameters ) {

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

  }

  function replaceClippingPlaneNums( string, parameters ) {

  	return string
  		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
  		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

  }

  function parseIncludes( string ) {

  	var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  	function replace( match, include ) {

  		var replace = ShaderChunk[ include ];

  		if ( replace === undefined ) {

  			throw new Error( 'Can not resolve #include <' + include + '>' );

  		}

  		return parseIncludes( replace );

  	}

  	return string.replace( pattern, replace );

  }

  function unrollLoops( string ) {

  	var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  	function replace( match, start, end, snippet ) {

  		var unroll = '';

  		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

  			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

  		}

  		return unroll;

  	}

  	return string.replace( pattern, replace );

  }

  function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {

  	var gl = renderer.context;

  	var defines = material.defines;

  	var vertexShader = shader.vertexShader;
  	var fragmentShader = shader.fragmentShader;

  	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	}

  	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  	if ( parameters.envMap ) {

  		switch ( material.envMap.mapping ) {

  			case CubeReflectionMapping:
  			case CubeRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping:
  			case CubeUVRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  			case EquirectangularReflectionMapping:
  			case EquirectangularRefractionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
  				break;

  			case SphericalReflectionMapping:
  				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
  				break;

  		}

  		switch ( material.envMap.mapping ) {

  			case CubeRefractionMapping:
  			case EquirectangularRefractionMapping:
  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  		switch ( material.combine ) {

  			case MultiplyOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

  	// console.log( 'building new program ' );

  	//

  	var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

  	var customDefines = generateDefines( defines );

  	//

  	var program = gl.createProgram();

  	var prefixVertex, prefixFragment;

  	if ( material.isRawShaderMaterial ) {

  		prefixVertex = [

  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixVertex.length > 0 ) {

  			prefixVertex += '\n';

  		}

  		prefixFragment = [

  			customExtensions,
  			customDefines

  		].filter( filterEmptyLine ).join( '\n' );

  		if ( prefixFragment.length > 0 ) {

  			prefixFragment += '\n';

  		}

  	} else {

  		prefixVertex = [

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + shader.name,

  			customDefines,

  			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			'#define MAX_BONES ' + parameters.maxBones,
  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

  			parameters.vertexTangents ? '#define USE_TANGENT' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',
  			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_TANGENT',

  			'	attribute vec4 tangent;',

  			'#endif',

  			'#ifdef USE_COLOR',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_MORPHTARGETS',

  			'	attribute vec3 morphTarget0;',
  			'	attribute vec3 morphTarget1;',
  			'	attribute vec3 morphTarget2;',
  			'	attribute vec3 morphTarget3;',

  			'	#ifdef USE_MORPHNORMALS',

  			'		attribute vec3 morphNormal0;',
  			'		attribute vec3 morphNormal1;',
  			'		attribute vec3 morphNormal2;',
  			'		attribute vec3 morphNormal3;',

  			'	#else',

  			'		attribute vec3 morphTarget4;',
  			'		attribute vec3 morphTarget5;',
  			'		attribute vec3 morphTarget6;',
  			'		attribute vec3 morphTarget7;',

  			'	#endif',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			customExtensions,

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + shader.name,

  			customDefines,

  			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.matcap ? '#define USE_MATCAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

  			parameters.vertexTangents ? '#define USE_TANGENT' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

  			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',

  			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
  			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',

  			( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
  				ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
  			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
  			parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
  			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
  			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
  			parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

  			parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	}

  	vertexShader = parseIncludes( vertexShader );
  	vertexShader = replaceLightNums( vertexShader, parameters );
  	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

  	fragmentShader = parseIncludes( fragmentShader );
  	fragmentShader = replaceLightNums( fragmentShader, parameters );
  	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

  	vertexShader = unrollLoops( vertexShader );
  	fragmentShader = unrollLoops( fragmentShader );

  	if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

  		var isGLSL3ShaderMaterial = false;

  		var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

  		if ( material.isShaderMaterial &&
  			vertexShader.match( versionRegex ) !== null &&
  			fragmentShader.match( versionRegex ) !== null ) {

  			isGLSL3ShaderMaterial = true;

  			vertexShader = vertexShader.replace( versionRegex, '' );
  			fragmentShader = fragmentShader.replace( versionRegex, '' );

  		}

  		// GLSL 3.0 conversion
  		prefixVertex = [
  			'#version 300 es\n',
  			'#define attribute in',
  			'#define varying out',
  			'#define texture2D texture'
  		].join( '\n' ) + '\n' + prefixVertex;

  		prefixFragment = [
  			'#version 300 es\n',
  			'#define varying in',
  			isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
  			isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
  			'#define gl_FragDepthEXT gl_FragDepth',
  			'#define texture2D texture',
  			'#define textureCube texture',
  			'#define texture2DProj textureProj',
  			'#define texture2DLodEXT textureLod',
  			'#define texture2DProjLodEXT textureProjLod',
  			'#define textureCubeLodEXT textureLod',
  			'#define texture2DGradEXT textureGrad',
  			'#define texture2DProjGradEXT textureProjGrad',
  			'#define textureCubeGradEXT textureGrad'
  		].join( '\n' ) + '\n' + prefixFragment;

  	}

  	var vertexGlsl = prefixVertex + vertexShader;
  	var fragmentGlsl = prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
  	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( material.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, material.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	var programLog = gl.getProgramInfoLog( program ).trim();
  	var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
  	var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

  	var runnable = true;
  	var haveDiagnostics = true;

  	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

  		runnable = false;

  		console.error( 'WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

  	} else if ( programLog !== '' ) {

  		console.warn( 'WebGLProgram: gl.getProgramInfoLog()', programLog );

  	} else if ( vertexLog === '' || fragmentLog === '' ) {

  		haveDiagnostics = false;

  	}

  	if ( haveDiagnostics ) {

  		this.diagnostics = {

  			runnable: runnable,
  			material: material,

  			programLog: programLog,

  			vertexShader: {

  				log: vertexLog,
  				prefix: prefixVertex

  			},

  			fragmentShader: {

  				log: fragmentLog,
  				prefix: prefixFragment

  			}

  		};

  	}

  	// clean up

  	gl.deleteShader( glVertexShader );
  	gl.deleteShader( glFragmentShader );

  	// set up caching for uniform locations

  	var cachedUniforms;

  	this.getUniforms = function () {

  		if ( cachedUniforms === undefined ) {

  			cachedUniforms = new WebGLUniforms( gl, program, renderer );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	var cachedAttributes;

  	this.getAttributes = function () {

  		if ( cachedAttributes === undefined ) {

  			cachedAttributes = fetchAttributeLocations( gl, program );

  		}

  		return cachedAttributes;

  	};

  	// free resource

  	this.destroy = function () {

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	// DEPRECATED

  	Object.defineProperties( this, {

  		uniforms: {
  			get: function () {

  				console.warn( 'WebGLProgram: .uniforms is now .getUniforms().' );
  				return this.getUniforms();

  			}
  		},

  		attributes: {
  			get: function () {

  				console.warn( 'WebGLProgram: .attributes is now .getAttributes().' );
  				return this.getAttributes();

  			}
  		}

  	} );
  	//

  	this.name = shader.name;
  	this.id = programIdCount ++;
  	this.code = code;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLPrograms( renderer, extensions, capabilities ) {

  	var programs = [];

  	var shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshDistanceMaterial: 'distanceRGBA',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'phong',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		MeshMatcapMaterial: 'matcap',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points',
  		ShadowMaterial: 'shadow',
  		SpriteMaterial: 'sprite'
  	};

  	var parameterNames = [
  		"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
  		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
  		"roughnessMap", "metalnessMap", "gradientMap",
  		"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp",
  		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
  		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
  		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
  		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
  		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
  		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
  	];
  	function allocateBones( object ) {

  		var skeleton = object.skeleton;
  		var bones = skeleton.bones;

  		if ( capabilities.floatVertexTextures ) {

  			return 1024;

  		} else {

  			// default for when object is not specified
  			// ( for example when prebuilding shader to be used with multiple objects )
  			//
  			//  - leave some extra space for other uniforms
  			//  - limit here is ANGLE's 254 max uniform vectors
  			//    (up to 54 should be safe)

  			var nVertexUniforms = capabilities.maxVertexUniforms;
  			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

  			var maxBones = Math.min( nVertexMatrices, bones.length );

  			if ( maxBones < bones.length ) {

  				console.warn( 'WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
  				return 0;

  			}

  			return maxBones;

  		}

  	}

  	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

  		var encoding;

  		if ( ! map ) {

  			encoding = LinearEncoding;

  		} else if ( map.isTexture ) {

  			encoding = map.encoding;

  		} else if ( map.isWebGLRenderTarget ) {

  			console.warn( "WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
  			encoding = map.texture.encoding;

  		}

  		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

  			encoding = GammaEncoding;

  		}

  		return encoding;

  	}

  	this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

  		var shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
  		var precision = capabilities.precision;

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		var currentRenderTarget = renderer.getRenderTarget();

  		var parameters = {

  			shaderID: shaderID,

  			precision: precision,
  			supportsVertexTextures: capabilities.vertexTextures,
  			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
  			map: !! material.map,
  			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
  			matcap: !! material.matcap,
  			matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
  			envMap: !! material.envMap,
  			envMapMode: material.envMap && material.envMap.mapping,
  			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
  			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
  			lightMap: !! material.lightMap,
  			aoMap: !! material.aoMap,
  			emissiveMap: !! material.emissiveMap,
  			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
  			bumpMap: !! material.bumpMap,
  			normalMap: !! material.normalMap,
  			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
  			displacementMap: !! material.displacementMap,
  			roughnessMap: !! material.roughnessMap,
  			metalnessMap: !! material.metalnessMap,
  			specularMap: !! material.specularMap,
  			alphaMap: !! material.alphaMap,

  			gradientMap: !! material.gradientMap,

  			combine: material.combine,

  			vertexTangents: ( material.normalMap && material.vertexTangents ),
  			vertexColors: material.vertexColors,

  			fog: !! fog,
  			useFog: material.fog,
  			fogExp: ( fog && fog.isFogExp2 ),

  			flatShading: material.flatShading,

  			sizeAttenuation: material.sizeAttenuation,
  			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

  			skinning: material.skinning && maxBones > 0,
  			maxBones: maxBones,
  			useVertexTexture: capabilities.floatVertexTextures,

  			morphTargets: material.morphTargets,
  			morphNormals: material.morphNormals,
  			maxMorphTargets: renderer.maxMorphTargets,
  			maxMorphNormals: renderer.maxMorphNormals,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numClippingPlanes: nClipPlanes,
  			numClipIntersection: nClipIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: renderer.toneMapping,
  			physicallyCorrectLights: renderer.physicallyCorrectLights,

  			premultipliedAlpha: material.premultipliedAlpha,

  			alphaTest: material.alphaTest,
  			doubleSided: material.side === DoubleSide,
  			flipSided: material.side === BackSide,

  			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

  		};

  		return parameters;

  	};

  	this.getProgramCode = function ( material, parameters ) {

  		var array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( material.fragmentShader );
  			array.push( material.vertexShader );

  		}

  		if ( material.defines !== undefined ) {

  			for ( var name in material.defines ) {

  				array.push( name );
  				array.push( material.defines[ name ] );

  			}

  		}

  		for ( var i = 0; i < parameterNames.length; i ++ ) {

  			array.push( parameters[ parameterNames[ i ] ] );

  		}

  		array.push( material.onBeforeCompile.toString() );

  		array.push( renderer.gammaOutput );

  		array.push( renderer.gammaFactor );

  		return array.join();

  	};

  	this.acquireProgram = function ( material, shader, parameters, code ) {

  		var program;

  		// Check if code has been already compiled
  		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

  			var programInfo = programs[ p ];

  			if ( programInfo.code === code ) {

  				program = programInfo;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );
  			programs.push( program );

  		}

  		return program;

  	};

  	this.releaseProgram = function ( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			var i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	};

  	// Exposed for resource monitoring & error feedback via renderer.info:
  	this.programs = programs;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLProperties() {

  	var properties = new WeakMap();

  	function get( object ) {

  		var map = properties.get( object );

  		if ( map === undefined ) {

  			map = {};
  			properties.set( object, map );

  		}

  		return map;

  	}

  	function remove( object ) {

  		properties.delete( object );

  	}

  	function update( object, key, value ) {

  		properties.get( object )[ key ] = value;

  	}

  	function dispose() {

  		properties = new WeakMap();

  	}

  	return {
  		get: get,
  		remove: remove,
  		update: update,
  		dispose: dispose
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function painterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.program && b.program && a.program !== b.program ) {

  		return a.program.id - b.program.id;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.groupOrder !== b.groupOrder ) {

  		return a.groupOrder - b.groupOrder;

  	} else if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }
  function WebGLRenderList() {

  	var renderItems = [];
  	var renderItemsIndex = 0;

  	var opaque = [];
  	var transparent = [];

  	function init() {

  		renderItemsIndex = 0;

  		opaque.length = 0;
  		transparent.length = 0;

  	}

  	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  		var renderItem = renderItems[ renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				program: material.program,
  				groupOrder: groupOrder,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			renderItems[ renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.program = material.program;
  			renderItem.groupOrder = groupOrder;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		renderItemsIndex ++;

  		return renderItem;

  	}

  	function push( object, geometry, material, groupOrder, z, group ) {

  		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		( material.transparent === true ? transparent : opaque ).push( renderItem );

  	}

  	function unshift( object, geometry, material, groupOrder, z, group ) {

  		var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

  	}

  	function sort() {

  		if ( opaque.length > 1 ) { opaque.sort( painterSortStable ); }
  		if ( transparent.length > 1 ) { transparent.sort( reversePainterSortStable ); }

  	}

  	return {
  		opaque: opaque,
  		transparent: transparent,

  		init: init,
  		push: push,
  		unshift: unshift,

  		sort: sort
  	};

  }

  function WebGLRenderLists() {

  	var lists = {};

  	function onSceneDispose( event ) {

  		var scene = event.target;

  		scene.removeEventListener( 'dispose', onSceneDispose );

  		delete lists[ scene.id ];

  	}

  	function get( scene, camera ) {

  		var cameras = lists[ scene.id ];
  		var list;
  		if ( cameras === undefined ) {

  			list = new WebGLRenderList();
  			lists[ scene.id ] = {};
  			lists[ scene.id ][ camera.id ] = list;

  			scene.addEventListener( 'dispose', onSceneDispose );

  		} else {

  			list = cameras[ camera.id ];
  			if ( list === undefined ) {

  				list = new WebGLRenderList();
  				cameras[ camera.id ] = list;

  			}

  		}

  		return list;

  	}

  	function dispose() {

  		lists = {};

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function UniformsCache() {

  	var lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			var uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3(),
  						color: new Color(),

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3(),
  						direction: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3(),
  						color: new Color(),
  						distance: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2(),
  						shadowCameraNear: 1,
  						shadowCameraFar: 1000
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3(),
  						skyColor: new Color(),
  						groundColor: new Color()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color(),
  						position: new Vector3(),
  						halfWidth: new Vector3(),
  						halfHeight: new Vector3()
  						// TODO (abelnation): set RectAreaLight shadow uniforms
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  var count = 0;

  function WebGLLights() {

  	var cache = new UniformsCache();

  	var state = {

  		id: count ++,

  		hash: {
  			stateID: - 1,
  			directionalLength: - 1,
  			pointLength: - 1,
  			spotLength: - 1,
  			rectAreaLength: - 1,
  			hemiLength: - 1,
  			shadowsLength: - 1
  		},

  		ambient: [ 0, 0, 0 ],
  		directional: [],
  		directionalShadowMap: [],
  		directionalShadowMatrix: [],
  		spot: [],
  		spotShadowMap: [],
  		spotShadowMatrix: [],
  		rectArea: [],
  		point: [],
  		pointShadowMap: [],
  		pointShadowMatrix: [],
  		hemi: []

  	};

  	var vector3 = new Vector3();
  	var matrix4 = new Matrix4();
  	var matrix42 = new Matrix4();

  	function setup( lights, shadows, camera ) {

  		var r = 0, g = 0, b = 0;

  		var directionalLength = 0;
  		var pointLength = 0;
  		var spotLength = 0;
  		var rectAreaLength = 0;
  		var hemiLength = 0;

  		var viewMatrix = camera.matrixWorldInverse;

  		for ( var i = 0, l = lights.length; i < l; i ++ ) {

  			var light = lights[ i ];

  			var color = light.color;
  			var intensity = light.intensity;
  			var distance = light.distance;

  			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isDirectionalLight ) {

  				var uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				state.directionalShadowMap[ directionalLength ] = shadowMap;
  				state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
  				state.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				var uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				state.spotShadowMap[ spotLength ] = shadowMap;
  				state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
  				state.spot[ spotLength ] = uniforms;

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				var uniforms = cache.get( light );

  				// (a) intensity is the total visible light emitted
  				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

  				// (b) intensity is the brightness of the light
  				uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				matrix42.identity();
  				matrix4.copy( light.matrixWorld );
  				matrix4.premultiply( viewMatrix );
  				matrix42.extractRotation( matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( matrix42 );
  				uniforms.halfHeight.applyMatrix4( matrix42 );

  				// TODO (abelnation): RectAreaLight distance?
  				// uniforms.distance = distance;

  				state.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				var uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;
  					uniforms.shadowCameraNear = shadow.camera.near;
  					uniforms.shadowCameraFar = shadow.camera.far;

  				}

  				state.pointShadowMap[ pointLength ] = shadowMap;
  				state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
  				state.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				var uniforms = cache.get( light );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );
  				uniforms.direction.normalize();

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				state.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		state.ambient[ 0 ] = r;
  		state.ambient[ 1 ] = g;
  		state.ambient[ 2 ] = b;

  		state.directional.length = directionalLength;
  		state.spot.length = spotLength;
  		state.rectArea.length = rectAreaLength;
  		state.point.length = pointLength;
  		state.hemi.length = hemiLength;

  		state.hash.stateID = state.id;
  		state.hash.directionalLength = directionalLength;
  		state.hash.pointLength = pointLength;
  		state.hash.spotLength = spotLength;
  		state.hash.rectAreaLength = rectAreaLength;
  		state.hash.hemiLength = hemiLength;
  		state.hash.shadowsLength = shadows.length;

  	}

  	return {
  		setup: setup,
  		state: state
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLRenderState() {

  	var lights = new WebGLLights();

  	var lightsArray = [];
  	var shadowsArray = [];

  	function init() {

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  	}

  	function pushLight( light ) {

  		lightsArray.push( light );

  	}

  	function pushShadow( shadowLight ) {

  		shadowsArray.push( shadowLight );

  	}

  	function setupLights( camera ) {

  		lights.setup( lightsArray, shadowsArray, camera );

  	}

  	var state = {
  		lightsArray: lightsArray,
  		shadowsArray: shadowsArray,

  		lights: lights
  	};

  	return {
  		init: init,
  		state: state,
  		setupLights: setupLights,

  		pushLight: pushLight,
  		pushShadow: pushShadow
  	};

  }

  function WebGLRenderStates() {

  	var renderStates = {};

  	function onSceneDispose( event ) {

  		var scene = event.target;

  		scene.removeEventListener( 'dispose', onSceneDispose );

  		delete renderStates[ scene.id ];

  	}

  	function get( scene, camera ) {

  		var renderState;

  		if ( renderStates[ scene.id ] === undefined ) {

  			renderState = new WebGLRenderState();
  			renderStates[ scene.id ] = {};
  			renderStates[ scene.id ][ camera.id ] = renderState;

  			scene.addEventListener( 'dispose', onSceneDispose );

  		} else {

  			if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

  				renderState = new WebGLRenderState();
  				renderStates[ scene.id ][ camera.id ] = renderState;

  			} else {

  				renderState = renderStates[ scene.id ][ camera.id ];

  			}

  		}

  		return renderState;

  	}

  	function dispose() {

  		renderStates = {};

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

  	var _frustum = new Frustum(),
  		_projScreenMatrix = new Matrix4(),

  		_shadowMapSize = new Vector2(),
  		_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

  		_lookTarget = new Vector3(),
  		_lightPositionWorld = new Vector3(),

  		_MorphingFlag = 1,
  		_SkinningFlag = 2,

  		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

  		_depthMaterials = new Array( _NumberOfMaterialVariants ),
  		_distanceMaterials = new Array( _NumberOfMaterialVariants ),

  		_materialCache = {};

  	var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

  	var cubeDirections = [
  		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
  		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
  	];

  	var cubeUps = [
  		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
  	];

  	var cube2DViewPorts = [
  		new Vector4(), new Vector4(), new Vector4(),
  		new Vector4(), new Vector4(), new Vector4()
  	];

  	// init

  	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

  		var useMorphing = ( i & _MorphingFlag ) !== 0;
  		var useSkinning = ( i & _SkinningFlag ) !== 0;

  		var depthMaterial = new MeshDepthMaterial( {

  			depthPacking: RGBADepthPacking,

  			morphTargets: useMorphing,
  			skinning: useSkinning

  		} );

  		_depthMaterials[ i ] = depthMaterial;

  		//

  		var distanceMaterial = new MeshDistanceMaterial( {

  			morphTargets: useMorphing,
  			skinning: useSkinning

  		} );

  		_distanceMaterials[ i ] = distanceMaterial;

  	}

  	//

  	var scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap;

  	this.render = function ( lights, scene, camera ) {

  		if ( scope.enabled === false ) { return; }
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }

  		if ( lights.length === 0 ) { return; }

  		var currentRenderTarget = _renderer.getRenderTarget();

  		var _state = _renderer.state;

  		// Set GL state for depth map.
  		_state.setBlending( NoBlending );
  		_state.buffers.color.setClear( 1, 1, 1, 1 );
  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// render depth map

  		var faceCount;

  		for ( var i = 0, il = lights.length; i < il; i ++ ) {

  			var light = lights[ i ];
  			var shadow = light.shadow;
  			var isPointLight = light && light.isPointLight;

  			if ( shadow === undefined ) {

  				console.warn( 'WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			var shadowCamera = shadow.camera;

  			_shadowMapSize.copy( shadow.mapSize );
  			_shadowMapSize.min( _maxShadowMapSize );

  			if ( isPointLight ) {

  				var vpWidth = _shadowMapSize.x;
  				var vpHeight = _shadowMapSize.y;

  				// These viewports map a cube-map onto a 2D texture with the
  				// following orientation:
  				//
  				//  xzXZ
  				//   y Y
  				//
  				// X - Positive x direction
  				// x - Negative x direction
  				// Y - Positive y direction
  				// y - Negative y direction
  				// Z - Positive z direction
  				// z - Negative z direction

  				// positive X
  				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
  				// negative X
  				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
  				// positive Z
  				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
  				// negative Z
  				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
  				// positive Y
  				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
  				// negative Y
  				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

  				_shadowMapSize.x *= 4.0;
  				_shadowMapSize.y *= 2.0;

  			}

  			if ( shadow.map === null ) {

  				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + ".shadowMap";

  				shadowCamera.updateProjectionMatrix();

  			}

  			if ( shadow.isSpotLightShadow ) {

  				shadow.update( light );

  			}

  			var shadowMap = shadow.map;
  			var shadowMatrix = shadow.matrix;

  			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  			shadowCamera.position.copy( _lightPositionWorld );

  			if ( isPointLight ) {

  				faceCount = 6;

  				// for point lights we set the shadow matrix to be a translation-only matrix
  				// equal to inverse of the light's position

  				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  			} else {

  				faceCount = 1;

  				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
  				shadowCamera.lookAt( _lookTarget );
  				shadowCamera.updateMatrixWorld();

  				// compute shadow matrix

  				shadowMatrix.set(
  					0.5, 0.0, 0.0, 0.5,
  					0.0, 0.5, 0.0, 0.5,
  					0.0, 0.0, 0.5, 0.5,
  					0.0, 0.0, 0.0, 1.0
  				);

  				shadowMatrix.multiply( shadowCamera.projectionMatrix );
  				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

  			}

  			_renderer.setRenderTarget( shadowMap );
  			_renderer.clear();

  			// render shadow map for each cube face (if omni-directional) or
  			// run a single pass if not

  			for ( var face = 0; face < faceCount; face ++ ) {

  				if ( isPointLight ) {

  					_lookTarget.copy( shadowCamera.position );
  					_lookTarget.add( cubeDirections[ face ] );
  					shadowCamera.up.copy( cubeUps[ face ] );
  					shadowCamera.lookAt( _lookTarget );
  					shadowCamera.updateMatrixWorld();

  					var vpDimensions = cube2DViewPorts[ face ];
  					_state.viewport( vpDimensions );

  				}

  				// update camera matrices and frustum

  				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  				_frustum.setFromMatrix( _projScreenMatrix );

  				// set object matrices & frustum culling

  				renderObject( scene, camera, shadowCamera, isPointLight );

  			}

  		}

  		scope.needsUpdate = false;

  		_renderer.setRenderTarget( currentRenderTarget );

  	};

  	function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

  		var geometry = object.geometry;

  		var result = null;

  		var materialVariants = _depthMaterials;
  		var customMaterial = object.customDepthMaterial;

  		if ( isPointLight ) {

  			materialVariants = _distanceMaterials;
  			customMaterial = object.customDistanceMaterial;

  		}

  		if ( ! customMaterial ) {

  			var useMorphing = false;

  			if ( material.morphTargets ) {

  				if ( geometry && geometry.isBufferGeometry ) {

  					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

  				} else if ( geometry && geometry.isGeometry ) {

  					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

  				}

  			}

  			if ( object.isSkinnedMesh && material.skinning === false ) {

  				console.warn( 'WebGLShadowMap: SkinnedMesh with material.skinning set to false:', object );

  			}

  			var useSkinning = object.isSkinnedMesh && material.skinning;

  			var variantIndex = 0;

  			if ( useMorphing ) { variantIndex |= _MorphingFlag; }
  			if ( useSkinning ) { variantIndex |= _SkinningFlag; }

  			result = materialVariants[ variantIndex ];

  		} else {

  			result = customMaterial;

  		}

  		if ( _renderer.localClippingEnabled &&
  				material.clipShadows === true &&
  				material.clippingPlanes.length !== 0 ) {

  			// in this case we need a unique material instance reflecting the
  			// appropriate state

  			var keyA = result.uuid, keyB = material.uuid;

  			var materialsForVariant = _materialCache[ keyA ];

  			if ( materialsForVariant === undefined ) {

  				materialsForVariant = {};
  				_materialCache[ keyA ] = materialsForVariant;

  			}

  			var cachedMaterial = materialsForVariant[ keyB ];

  			if ( cachedMaterial === undefined ) {

  				cachedMaterial = result.clone();
  				materialsForVariant[ keyB ] = cachedMaterial;

  			}

  			result = cachedMaterial;

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;
  		result.clipIntersection = material.clipIntersection;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( isPointLight && result.isMeshDistanceMaterial ) {

  			result.referencePosition.copy( lightPositionWorld );
  			result.nearDistance = shadowCameraNear;
  			result.farDistance = shadowCameraFar;

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, isPointLight ) {

  		if ( object.visible === false ) { return; }

  		var visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				var geometry = _objects.update( object );
  				var material = object.material;

  				if ( Array.isArray( material ) ) {

  					var groups = geometry.groups;

  					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

  						var group = groups[ k ];
  						var groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  						}

  					}

  				} else if ( material.visible ) {

  					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, isPointLight );

  		}

  	}

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLState( gl, extensions, utils, capabilities ) {

  	function ColorBuffer() {

  		var locked = false;

  		var color = new Vector4();
  		var currentColorMask = null;
  		var currentColorClear = new Vector4( 0, 0, 0, 0 );

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

  			}

  		};

  	}

  	function DepthBuffer() {

  		var locked = false;

  		var currentDepthMask = null;
  		var currentDepthFunc = null;
  		var currentDepthClear = null;

  		return {

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( gl.DEPTH_TEST );

  				} else {

  					disable( gl.DEPTH_TEST );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentDepthFunc !== depthFunc ) {

  					if ( depthFunc ) {

  						switch ( depthFunc ) {

  							case NeverDepth:

  								gl.depthFunc( gl.NEVER );
  								break;

  							case AlwaysDepth:

  								gl.depthFunc( gl.ALWAYS );
  								break;

  							case LessDepth:

  								gl.depthFunc( gl.LESS );
  								break;

  							case LessEqualDepth:

  								gl.depthFunc( gl.LEQUAL );
  								break;

  							case EqualDepth:

  								gl.depthFunc( gl.EQUAL );
  								break;

  							case GreaterEqualDepth:

  								gl.depthFunc( gl.GEQUAL );
  								break;

  							case GreaterDepth:

  								gl.depthFunc( gl.GREATER );
  								break;

  							case NotEqualDepth:

  								gl.depthFunc( gl.NOTEQUAL );
  								break;

  							default:

  								gl.depthFunc( gl.LEQUAL );

  						}

  					} else {

  						gl.depthFunc( gl.LEQUAL );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;

  			}

  		};

  	}

  	function StencilBuffer() {

  		var locked = false;

  		var currentStencilMask = null;
  		var currentStencilFunc = null;
  		var currentStencilRef = null;
  		var currentStencilFuncMask = null;
  		var currentStencilFail = null;
  		var currentStencilZFail = null;
  		var currentStencilZPass = null;
  		var currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( stencilTest ) {

  					enable( gl.STENCIL_TEST );

  				} else {

  					disable( gl.STENCIL_TEST );

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef 	!== stencilRef 	||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail	 !== stencilFail 	||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	var colorBuffer = new ColorBuffer();
  	var depthBuffer = new DepthBuffer();
  	var stencilBuffer = new StencilBuffer();

  	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var newAttributes = new Uint8Array( maxVertexAttributes );
  	var enabledAttributes = new Uint8Array( maxVertexAttributes );
  	var attributeDivisors = new Uint8Array( maxVertexAttributes );

  	var enabledCapabilities = {};

  	var compressedTextureFormats = null;

  	var currentProgram = null;

  	var currentBlendingEnabled = null;
  	var currentBlending = null;
  	var currentBlendEquation = null;
  	var currentBlendSrc = null;
  	var currentBlendDst = null;
  	var currentBlendEquationAlpha = null;
  	var currentBlendSrcAlpha = null;
  	var currentBlendDstAlpha = null;
  	var currentPremultipledAlpha = false;

  	var currentFlipSided = null;
  	var currentCullFace = null;

  	var currentLineWidth = null;

  	var currentPolygonOffsetFactor = null;
  	var currentPolygonOffsetUnits = null;

  	var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

  	var lineWidthAvailable = false;
  	var version = 0;
  	var glVersion = gl.getParameter( gl.VERSION );

  	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

  		version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 1.0 );

  	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

  		version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
  		lineWidthAvailable = ( version >= 2.0 );

  	}

  	var currentTextureSlot = null;
  	var currentBoundTextures = {};

  	var currentScissor = new Vector4();
  	var currentViewport = new Vector4();

  	function createTexture( type, target, count ) {

  		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		var texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  		for ( var i = 0; i < count; i ++ ) {

  			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  		}

  		return texture;

  	}

  	var emptyTextures = {};
  	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
  	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

  	// init

  	colorBuffer.setClear( 0, 0, 0, 1 );
  	depthBuffer.setClear( 1 );
  	stencilBuffer.setClear( 0 );

  	enable( gl.DEPTH_TEST );
  	depthBuffer.setFunc( LessEqualDepth );

  	setFlipSided( false );
  	setCullFace( CullFaceBack );
  	enable( gl.CULL_FACE );

  	setBlending( NoBlending );

  	//

  	function initAttributes() {

  		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		enableAttributeAndDivisor( attribute, 0 );

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

  			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function enable( id ) {

  		if ( enabledCapabilities[ id ] !== true ) {

  			gl.enable( id );
  			enabledCapabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( enabledCapabilities[ id ] !== false ) {

  			gl.disable( id );
  			enabledCapabilities[ id ] = false;

  		}

  	}

  	function getCompressedTextureFormats() {

  		if ( compressedTextureFormats === null ) {

  			compressedTextureFormats = [];

  			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

  				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

  				for ( var i = 0; i < formats.length; i ++ ) {

  					compressedTextureFormats.push( formats[ i ] );

  				}

  			}

  		}

  		return compressedTextureFormats;

  	}

  	function useProgram( program ) {

  		if ( currentProgram !== program ) {

  			gl.useProgram( program );

  			currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		if ( blending === NoBlending ) {

  			if ( currentBlendingEnabled ) {

  				disable( gl.BLEND );
  				currentBlendingEnabled = false;

  			}

  			return;

  		}

  		if ( ! currentBlendingEnabled ) {

  			enable( gl.BLEND );
  			currentBlendingEnabled = true;

  		}

  		if ( blending !== CustomBlending ) {

  			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

  					gl.blendEquation( gl.FUNC_ADD );

  					currentBlendEquation = AddEquation;
  					currentBlendEquationAlpha = AddEquation;

  				}

  				if ( premultipliedAlpha ) {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.ONE, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case MultiplyBlending:
  							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
  							break;

  						default:
  							console.error( 'WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				} else {

  					switch ( blending ) {

  						case NormalBlending:
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
  							break;

  						case AdditiveBlending:
  							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
  							break;

  						case SubtractiveBlending:
  							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
  							break;

  						case MultiplyBlending:
  							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
  							break;

  						default:
  							console.error( 'WebGLState: Invalid blending: ', blending );
  							break;

  					}

  				}

  				currentBlendSrc = null;
  				currentBlendDst = null;
  				currentBlendSrcAlpha = null;
  				currentBlendDstAlpha = null;

  				currentBlending = blending;
  				currentPremultipledAlpha = premultipliedAlpha;

  			}

  			return;

  		}

  		// custom blending

  		blendEquationAlpha = blendEquationAlpha || blendEquation;
  		blendSrcAlpha = blendSrcAlpha || blendSrc;
  		blendDstAlpha = blendDstAlpha || blendDst;

  		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  			gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

  			currentBlendEquation = blendEquation;
  			currentBlendEquationAlpha = blendEquationAlpha;

  		}

  		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  			gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

  			currentBlendSrc = blendSrc;
  			currentBlendDst = blendDst;
  			currentBlendSrcAlpha = blendSrcAlpha;
  			currentBlendDstAlpha = blendDstAlpha;

  		}

  		currentBlending = blending;
  		currentPremultipledAlpha = null;

  	}

  	function setMaterial( material, frontFaceCW ) {

  		material.side === DoubleSide
  			? disable( gl.CULL_FACE )
  			: enable( gl.CULL_FACE );

  		var flipSided = ( material.side === BackSide );
  		if ( frontFaceCW ) { flipSided = ! flipSided; }

  		setFlipSided( flipSided );

  		( material.blending === NormalBlending && material.transparent === false )
  			? setBlending( NoBlending )
  			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone ) {

  			enable( gl.CULL_FACE );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			disable( gl.CULL_FACE );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) { gl.lineWidth( width ); }

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( gl.POLYGON_OFFSET_FILL );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	function setScissorTest( scissorTest ) {

  		if ( scissorTest ) {

  			enable( gl.SCISSOR_TEST );

  		} else {

  			disable( gl.SCISSOR_TEST );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) { webglSlot = gl.TEXTURE0 + maxTextures - 1; }

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture ) {

  		if ( currentTextureSlot === null ) {

  			activeTexture();

  		}

  		var boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ currentTextureSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'WebGLState:', error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'WebGLState:', error );

  		}

  	}

  	function texImage3D() {

  		try {

  			gl.texImage3D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'WebGLState:', error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	//

  	function reset() {

  		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

  			if ( enabledAttributes[ i ] === 1 ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  		enabledCapabilities = {};

  		compressedTextureFormats = null;

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		currentProgram = null;

  		currentBlending = null;

  		currentFlipSided = null;
  		currentCullFace = null;

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		enableAttributeAndDivisor: enableAttributeAndDivisor,
  		disableUnusedAttributes: disableUnusedAttributes,
  		enable: enable,
  		disable: disable,
  		getCompressedTextureFormats: getCompressedTextureFormats,

  		useProgram: useProgram,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		texImage2D: texImage2D,
  		texImage3D: texImage3D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

  	var _videoTextures = {};
  	var _canvas;

  	//

  	var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

  	function createCanvas( width, height ) {

  		// Use OffscreenCanvas when available. Specially needed in web workers

  		return useOffscreenCanvas ?
  			new OffscreenCanvas( width, height ) :
  			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

  	}

  	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

  		var scale = 1;

  		// handle case if texture exceeds max size

  		if ( image.width > maxSize || image.height > maxSize ) {

  			scale = maxSize / Math.max( image.width, image.height );

  		}

  		// only perform resize if necessary

  		if ( scale < 1 || needsPowerOfTwo === true ) {

  			// only perform resize for certain image types

  			if ( image instanceof ImageBitmap || image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

  				var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;

  				var width = floor( scale * image.width );
  				var height = floor( scale * image.height );

  				if ( _canvas === undefined ) { _canvas = createCanvas( width, height ); }

  				// cube textures can't reuse the same canvas

  				var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

  				canvas.width = width;
  				canvas.height = height;

  				var context = canvas.getContext( '2d' );
  				context.drawImage( image, 0, 0, width, height );

  				console.warn( 'WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

  				return useOffscreenCanvas ? canvas.transferToImageBitmap() : canvas;

  			} else {

  				if ( 'data' in image ) {

  					console.warn( 'WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

  				}

  				return image;

  			}

  		}

  		return image;

  	}

  	function isPowerOfTwo( image ) {

  		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

  	}

  	function textureNeedsPowerOfTwo( texture ) {

  		if ( capabilities.isWebGL2 ) { return false; }

  		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
  			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

  	}

  	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

  		return texture.generateMipmaps && supportsMips &&
  			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

  	}

  	function generateMipmap( target, texture, width, height ) {

  		_gl.generateMipmap( target );

  		var textureProperties = properties.get( texture );

  		// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
  		textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

  	}

  	function getInternalFormat( glFormat, glType ) {

  		if ( ! capabilities.isWebGL2 ) { return glFormat; }

  		var internalFormat = glFormat;

  		if ( glFormat === _gl.RED ) {

  			if ( glType === _gl.FLOAT ) { internalFormat = _gl.R32F; }
  			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.R16F; }
  			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.R8; }

  		}

  		if ( glFormat === _gl.RGB ) {

  			if ( glType === _gl.FLOAT ) { internalFormat = _gl.RGB32F; }
  			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.RGB16F; }
  			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.RGB8; }

  		}

  		if ( glFormat === _gl.RGBA ) {

  			if ( glType === _gl.FLOAT ) { internalFormat = _gl.RGBA32F; }
  			if ( glType === _gl.HALF_FLOAT ) { internalFormat = _gl.RGBA16F; }
  			if ( glType === _gl.UNSIGNED_BYTE ) { internalFormat = _gl.RGBA8; }

  		}

  		if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
  			internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

  			extensions.get( 'EXT_color_buffer_float' );

  		} else if ( internalFormat === _gl.RGB16F || internalFormat === _gl.RGB32F ) {

  			console.warn( 'WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

  		}

  		return internalFormat;

  	}

  	// Fallback filters for non-power-of-2 textures

  	function filterFallback( f ) {

  		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

  			return _gl.NEAREST;

  		}

  		return _gl.LINEAR;

  	}

  	//

  	function onTextureDispose( event ) {

  		var texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		if ( texture.isVideoTexture ) {

  			delete _videoTextures[ texture.id ];

  		}

  		info.memory.textures --;

  	}

  	function onRenderTargetDispose( event ) {

  		var renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  		info.memory.textures --;

  	}

  	//

  	function deallocateTexture( texture ) {

  		var textureProperties = properties.get( texture );

  		if ( textureProperties.__webglInit === undefined ) { return; }

  		_gl.deleteTexture( textureProperties.__webglTexture );

  		properties.remove( texture );

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		if ( ! renderTarget ) { return; }

  		if ( textureProperties.__webglTexture !== undefined ) {

  			_gl.deleteTexture( textureProperties.__webglTexture );

  		}

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  		}

  		if ( renderTarget.isWebGLRenderTargetCube ) {

  			for ( var i = 0; i < 6; i ++ ) {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
  				if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }

  			}

  		} else {

  			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
  			if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }

  		}

  		properties.remove( renderTarget.texture );
  		properties.remove( renderTarget );

  	}

  	//
  	function setTexture2D( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.isVideoTexture ) { updateVideoTexture( texture ); }

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			var image = texture.image;

  			if ( image === undefined ) {

  				console.warn( 'WebGLRenderer: Texture marked for update but image is undefined' );

  			} else if ( image.complete === false ) {

  				console.warn( 'WebGLRenderer: Texture marked for update but image is incomplete' );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  	}

  	function setTexture3D( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			uploadTexture( textureProperties, texture, slot );
  			return;

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );

  	}

  	function setTextureCube( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.image.length === 6 ) {

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				initTexture( textureProperties, texture );

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

  				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

  				var isCompressed = ( texture && texture.isCompressedTexture );
  				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  				var cubeImage = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed && ! isDataTexture ) {

  						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );

  					} else {

  						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  					}

  				}

  				var image = cubeImage[ 0 ],
  					supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
  					glFormat = utils.convert( texture.format ),
  					glType = utils.convert( texture.type ),
  					glInternalFormat = getInternalFormat( glFormat, glType );

  				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed ) {

  						if ( isDataTexture ) {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

  						}

  					} else {

  						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

  						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

  							mipmap = mipmaps[ j ];

  							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								} else {

  									console.warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  				if ( ! isCompressed ) {

  					textureProperties.__maxMipLevel = 0;

  				} else {

  					textureProperties.__maxMipLevel = mipmaps.length - 1;

  				}

  				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  					// We assume images for cube map have the same size.
  					generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

  				}

  				textureProperties.__version = texture.version;

  				if ( texture.onUpdate ) { texture.onUpdate( texture ); }

  			} else {

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

  			}

  		}

  	}

  	function setTextureCubeDynamic( texture, slot ) {

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

  	}

  	function setTextureParameters( textureType, texture, supportsMips ) {

  		var extension;

  		if ( supportsMips ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

  			if ( textureType === _gl.TEXTURE_3D ) {

  				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, utils.convert( texture.wrapR ) );

  			}

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

  		} else {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

  			if ( textureType === _gl.TEXTURE_3D ) {

  				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

  			}

  			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

  				console.warn( 'WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to ClampToEdgeWrapping.' );

  			}

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

  			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

  				console.warn( 'WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to NearestFilter or LinearFilter.' );

  			}

  		}

  		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension ) {

  			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) { return; }
  			if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) { return; }

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function initTexture( textureProperties, texture ) {

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  			textureProperties.__webglTexture = _gl.createTexture();

  			info.memory.textures ++;

  		}

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		var textureType = ( texture.isDataTexture3D ) ? _gl.TEXTURE_3D : _gl.TEXTURE_2D;

  		initTexture( textureProperties, texture );

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( textureType, textureProperties.__webglTexture );

  		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

  		var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
  		var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );

  		var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
  			glFormat = utils.convert( texture.format ),
  			glType = utils.convert( texture.type ),
  			glInternalFormat = getInternalFormat( glFormat, glType );

  		setTextureParameters( textureType, texture, supportsMips );

  		var mipmap, mipmaps = texture.mipmaps;

  		if ( texture.isDepthTexture ) {

  			// populate depth texture with dummy data

  			glInternalFormat = _gl.DEPTH_COMPONENT;

  			if ( texture.type === FloatType ) {

  				if ( ! capabilities.isWebGL2 ) { throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); }
  				glInternalFormat = _gl.DEPTH_COMPONENT32F;

  			} else if ( capabilities.isWebGL2 ) {

  				// WebGL 2.0 requires signed internalformat for glTexImage2D
  				glInternalFormat = _gl.DEPTH_COMPONENT16;

  			}

  			if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

  					console.warn( 'WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

  					texture.type = UnsignedShortType;
  					glType = utils.convert( texture.type );

  				}

  			}

  			// Depth stencil textures need the DEPTH_STENCIL internal format
  			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  			if ( texture.format === DepthStencilFormat ) {

  				glInternalFormat = _gl.DEPTH_STENCIL;

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedInt248Type ) {

  					console.warn( 'WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

  					texture.type = UnsignedInt248Type;
  					glType = utils.convert( texture.type );

  				}

  			}

  			state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

  		} else if ( texture.isDataTexture ) {

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && supportsMips ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  				texture.generateMipmaps = false;
  				textureProperties.__maxMipLevel = mipmaps.length - 1;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
  				textureProperties.__maxMipLevel = 0;

  			}

  		} else if ( texture.isCompressedTexture ) {

  			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  				mipmap = mipmaps[ i ];

  				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  					} else {

  						console.warn( 'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  					}

  				} else {

  					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  			}

  			textureProperties.__maxMipLevel = mipmaps.length - 1;

  		} else if ( texture.isDataTexture3D ) {

  			state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
  			textureProperties.__maxMipLevel = 0;

  		} else {

  			// regular Texture (image, video, canvas)

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && supportsMips ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

  				}

  				texture.generateMipmaps = false;
  				textureProperties.__maxMipLevel = mipmaps.length - 1;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
  				textureProperties.__maxMipLevel = 0;

  			}

  		}

  		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  			generateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );

  		}

  		textureProperties.__version = texture.version;

  		if ( texture.onUpdate ) { texture.onUpdate( texture ); }

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

  		var glFormat = utils.convert( renderTarget.texture.format );
  		var glType = utils.convert( renderTarget.texture.type );
  		var glInternalFormat = getInternalFormat( glFormat, glType );
  		state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

  		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

  			if ( isMultisample ) {

  				var samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );

  			}

  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

  			if ( isMultisample ) {

  				var samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

  			}
  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else {

  			var glFormat = utils.convert( renderTarget.texture.format );
  			var glType = utils.convert( renderTarget.texture.type );
  			var glInternalFormat = getInternalFormat( glFormat, glType );

  			if ( isMultisample ) {

  				var samples = getRenderTargetSamples( renderTarget );

  				_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  			} else {

  				_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

  			}

  		}

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
  		if ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error( 'renderTarget.depthTexture must be an instance of DepthTexture' );

  		}

  		// upload an empty depth texture with framebuffer size
  		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {

  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;

  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

  		if ( renderTarget.depthTexture.format === DepthFormat ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else {

  			throw new Error( 'Unknown depthTexture format' );

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

  		if ( renderTarget.depthTexture ) {

  			if ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }

  			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
  					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

  				}

  			} else {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

  			}

  		}

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		textureProperties.__webglTexture = _gl.createTexture();

  		info.memory.textures ++;

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
  		var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
  		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( var i = 0; i < 6; i ++ ) {

  				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  			}

  		} else {

  			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  			if ( isMultisample ) {

  				if ( capabilities.isWebGL2 ) {

  					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
  					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

  					_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
  					var glFormat = utils.convert( renderTarget.texture.format );
  					var glType = utils.convert( renderTarget.texture.type );
  					var glInternalFormat = getInternalFormat( glFormat, glType );
  					var samples = getRenderTargetSamples( renderTarget );
  					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
  					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  					if ( renderTarget.depthBuffer ) {

  						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
  						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

  					}

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
  				} else {

  					console.warn( 'WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  				}

  			}

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips );

  			for ( var i = 0; i < 6; i ++ ) {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

  			}

  			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

  				generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );

  			}

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

  		} else {

  			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, supportsMips );
  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

  			if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

  				generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );

  			}

  			state.bindTexture( _gl.TEXTURE_2D, null );

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		var texture = renderTarget.texture;
  		var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

  		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
  			var webglTexture = properties.get( texture ).__webglTexture;

  			state.bindTexture( target, webglTexture );
  			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
  			state.bindTexture( target, null );

  		}

  	}

  	function updateMultisampleRenderTarget( renderTarget ) {

  		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  			if ( capabilities.isWebGL2 ) {

  				var renderTargetProperties = properties.get( renderTarget );

  				_gl.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
  				_gl.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

  				var width = renderTarget.width;
  				var height = renderTarget.height;
  				var mask = _gl.COLOR_BUFFER_BIT;

  				if ( renderTarget.depthBuffer ) { mask |= _gl.DEPTH_BUFFER_BIT; }
  				if ( renderTarget.stencilBuffer ) { mask |= _gl.STENCIL_BUFFER_BIT; }

  				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

  			} else {

  				console.warn( 'WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  			}

  		}

  	}

  	function getRenderTargetSamples( renderTarget ) {

  		return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
  			Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;

  	}

  	function updateVideoTexture( texture ) {

  		var id = texture.id;
  		var frame = info.render.frame;

  		// Check the last frame we updated the VideoTexture

  		if ( _videoTextures[ id ] !== frame ) {

  			_videoTextures[ id ] = frame;
  			texture.update();

  		}

  	}

  	this.setTexture2D = setTexture2D;
  	this.setTexture3D = setTexture3D;
  	this.setTextureCube = setTextureCube;
  	this.setTextureCubeDynamic = setTextureCubeDynamic;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLUtils( gl, extensions, capabilities ) {

  	function convert( p ) {

  		var extension;

  		if ( p === RepeatWrapping ) { return gl.REPEAT; }
  		if ( p === ClampToEdgeWrapping ) { return gl.CLAMP_TO_EDGE; }
  		if ( p === MirroredRepeatWrapping ) { return gl.MIRRORED_REPEAT; }

  		if ( p === NearestFilter ) { return gl.NEAREST; }
  		if ( p === NearestMipMapNearestFilter ) { return gl.NEAREST_MIPMAP_NEAREST; }
  		if ( p === NearestMipMapLinearFilter ) { return gl.NEAREST_MIPMAP_LINEAR; }

  		if ( p === LinearFilter ) { return gl.LINEAR; }
  		if ( p === LinearMipMapNearestFilter ) { return gl.LINEAR_MIPMAP_NEAREST; }
  		if ( p === LinearMipMapLinearFilter ) { return gl.LINEAR_MIPMAP_LINEAR; }

  		if ( p === UnsignedByteType ) { return gl.UNSIGNED_BYTE; }
  		if ( p === UnsignedShort4444Type ) { return gl.UNSIGNED_SHORT_4_4_4_4; }
  		if ( p === UnsignedShort5551Type ) { return gl.UNSIGNED_SHORT_5_5_5_1; }
  		if ( p === UnsignedShort565Type ) { return gl.UNSIGNED_SHORT_5_6_5; }

  		if ( p === ByteType ) { return gl.BYTE; }
  		if ( p === ShortType ) { return gl.SHORT; }
  		if ( p === UnsignedShortType ) { return gl.UNSIGNED_SHORT; }
  		if ( p === IntType ) { return gl.INT; }
  		if ( p === UnsignedIntType ) { return gl.UNSIGNED_INT; }
  		if ( p === FloatType ) { return gl.FLOAT; }

  		if ( p === HalfFloatType ) {

  			if ( capabilities.isWebGL2 ) { return gl.HALF_FLOAT; }

  			extension = extensions.get( 'OES_texture_half_float' );

  			if ( extension !== null ) { return extension.HALF_FLOAT_OES; }

  		}

  		if ( p === AlphaFormat ) { return gl.ALPHA; }
  		if ( p === RGBFormat ) { return gl.RGB; }
  		if ( p === RGBAFormat ) { return gl.RGBA; }
  		if ( p === LuminanceFormat ) { return gl.LUMINANCE; }
  		if ( p === LuminanceAlphaFormat ) { return gl.LUMINANCE_ALPHA; }
  		if ( p === DepthFormat ) { return gl.DEPTH_COMPONENT; }
  		if ( p === DepthStencilFormat ) { return gl.DEPTH_STENCIL; }
  		if ( p === RedFormat ) { return gl.RED; }

  		if ( p === AddEquation ) { return gl.FUNC_ADD; }
  		if ( p === SubtractEquation ) { return gl.FUNC_SUBTRACT; }
  		if ( p === ReverseSubtractEquation ) { return gl.FUNC_REVERSE_SUBTRACT; }

  		if ( p === ZeroFactor ) { return gl.ZERO; }
  		if ( p === OneFactor ) { return gl.ONE; }
  		if ( p === SrcColorFactor ) { return gl.SRC_COLOR; }
  		if ( p === OneMinusSrcColorFactor ) { return gl.ONE_MINUS_SRC_COLOR; }
  		if ( p === SrcAlphaFactor ) { return gl.SRC_ALPHA; }
  		if ( p === OneMinusSrcAlphaFactor ) { return gl.ONE_MINUS_SRC_ALPHA; }
  		if ( p === DstAlphaFactor ) { return gl.DST_ALPHA; }
  		if ( p === OneMinusDstAlphaFactor ) { return gl.ONE_MINUS_DST_ALPHA; }

  		if ( p === DstColorFactor ) { return gl.DST_COLOR; }
  		if ( p === OneMinusDstColorFactor ) { return gl.ONE_MINUS_DST_COLOR; }
  		if ( p === SrcAlphaSaturateFactor ) { return gl.SRC_ALPHA_SATURATE; }

  		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
  			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  			if ( extension !== null ) {

  				if ( p === RGB_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }
  				if ( p === RGBA_S3TC_DXT1_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }
  				if ( p === RGBA_S3TC_DXT3_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }
  				if ( p === RGBA_S3TC_DXT5_Format ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }

  			}

  		}

  		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
  			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }
  				if ( p === RGB_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }
  				if ( p === RGBA_PVRTC_4BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }
  				if ( p === RGBA_PVRTC_2BPPV1_Format ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }

  			}

  		}

  		if ( p === RGB_ETC1_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

  			if ( extension !== null ) { return extension.COMPRESSED_RGB_ETC1_WEBGL; }

  		}

  		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  			if ( extension !== null ) {

  				return p;

  			}

  		}

  		if ( p === MinEquation || p === MaxEquation ) {

  			if ( capabilities.isWebGL2 ) {

  				if ( p === MinEquation ) { return gl.MIN; }
  				if ( p === MaxEquation ) { return gl.MAX; }

  			}

  			extension = extensions.get( 'EXT_blend_minmax' );

  			if ( extension !== null ) {

  				if ( p === MinEquation ) { return extension.MIN_EXT; }
  				if ( p === MaxEquation ) { return extension.MAX_EXT; }

  			}

  		}

  		if ( p === UnsignedInt248Type ) {

  			if ( capabilities.isWebGL2 ) { return gl.UNSIGNED_INT_24_8; }

  			extension = extensions.get( 'WEBGL_depth_texture' );

  			if ( extension !== null ) { return extension.UNSIGNED_INT_24_8_WEBGL; }

  		}

  		return 0;

  	}

  	return { convert: convert };

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ArrayCamera( array ) {

  	PerspectiveCamera.call( this );

  	this.cameras = array || [];

  }

  ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

  	constructor: ArrayCamera,

  	isArrayCamera: true

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var cameraLPos = new Vector3();
  var cameraRPos = new Vector3();
  function setProjectionFromUnion( camera, cameraL, cameraR ) {

  	cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  	cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  	var ipd = cameraLPos.distanceTo( cameraRPos );

  	var projL = cameraL.projectionMatrix.elements;
  	var projR = cameraR.projectionMatrix.elements;

  	// VR systems will have identical far and near planes, and
  	// most likely identical top and bottom frustum extents.
  	// Use the left camera for these values.
  	var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  	var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  	var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  	var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  	var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  	var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  	var left = near * leftFov;
  	var right = near * rightFov;

  	// Calculate the new camera's position offset from the
  	// left camera. xOffset should be roughly half `ipd`.
  	var zOffset = ipd / ( - leftFov + rightFov );
  	var xOffset = zOffset * - leftFov;

  	// TODO: Better way to apply this offset?
  	cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  	camera.translateX( xOffset );
  	camera.translateZ( zOffset );
  	camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  	camera.matrixWorldInverse.getInverse( camera.matrixWorld );

  	// Find the union of the frustum values of the cameras and scale
  	// the values so that the near plane's position does not change in world space,
  	// although must now be relative to the new union camera.
  	var near2 = near + zOffset;
  	var far2 = far + zOffset;
  	var left2 = left - xOffset;
  	var right2 = right + ( ipd - xOffset );
  	var top2 = topFov * far / far2 * near2;
  	var bottom2 = bottomFov * far / far2 * near2;

  	camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebVRManager( renderer ) {

  	var scope = this;

  	var device = null;
  	var frameData = null;

  	var poseTarget = null;

  	var controllers = [];
  	var standingMatrix = new Matrix4();
  	var standingMatrixInverse = new Matrix4();

  	var framebufferScaleFactor = 1.0;

  	var frameOfReferenceType = 'stage';

  	if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

  		frameData = new window.VRFrameData();
  		window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

  	}

  	var matrixWorldInverse = new Matrix4();
  	var tempQuaternion = new Quaternion();
  	var tempPosition = new Vector3();

  	var cameraL = new PerspectiveCamera();
  	cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
  	cameraL.layers.enable( 1 );

  	var cameraR = new PerspectiveCamera();
  	cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
  	cameraR.layers.enable( 2 );

  	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
  	cameraVR.layers.enable( 1 );
  	cameraVR.layers.enable( 2 );

  	//

  	function isPresenting() {

  		return device !== null && device.isPresenting === true;

  	}

  	var currentSize = new Vector2(), currentPixelRatio;

  	function onVRDisplayPresentChange() {

  		if ( isPresenting() ) {

  			var eyeParameters = device.getEyeParameters( 'left' );
  			var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
  			var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

  			currentPixelRatio = renderer.getPixelRatio();
  			renderer.getSize( currentSize );

  			renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

  			animation.start();

  		} else {

  			if ( scope.enabled ) {

  				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

  			}

  			animation.stop();

  		}

  	}

  	//

  	var triggers = [];

  	function findGamepad( id ) {

  		var gamepads = navigator.getGamepads && navigator.getGamepads();

  		for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

  			var gamepad = gamepads[ i ];

  			if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
  				gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
  				gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
  				gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

  				if ( j === id ) { return gamepad; }

  				j ++;

  			}

  		}

  	}

  	function updateControllers() {

  		for ( var i = 0; i < controllers.length; i ++ ) {

  			var controller = controllers[ i ];

  			var gamepad = findGamepad( i );

  			if ( gamepad !== undefined && gamepad.pose !== undefined ) {

  				if ( gamepad.pose === null ) { return; }

  				//  Pose

  				var pose = gamepad.pose;

  				if ( pose.hasPosition === false ) { controller.position.set( 0.2, - 0.6, - 0.05 ); }

  				if ( pose.position !== null ) { controller.position.fromArray( pose.position ); }
  				if ( pose.orientation !== null ) { controller.quaternion.fromArray( pose.orientation ); }
  				controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
  				controller.matrix.premultiply( standingMatrix );
  				controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
  				controller.matrixWorldNeedsUpdate = true;
  				controller.visible = true;

  				//  Trigger

  				var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

  				if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

  					triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

  					if ( triggers[ i ] === true ) {

  						controller.dispatchEvent( { type: 'selectstart' } );

  					} else {

  						controller.dispatchEvent( { type: 'selectend' } );
  						controller.dispatchEvent( { type: 'select' } );

  					}

  				}

  			} else {

  				controller.visible = false;

  			}

  		}

  	}

  	//

  	this.enabled = false;

  	this.getController = function ( id ) {

  		var controller = controllers[ id ];

  		if ( controller === undefined ) {

  			controller = new Group();
  			controller.matrixAutoUpdate = false;
  			controller.visible = false;

  			controllers[ id ] = controller;

  		}

  		return controller;

  	};

  	this.getDevice = function () {

  		return device;

  	};

  	this.setDevice = function ( value ) {

  		if ( value !== undefined ) { device = value; }

  		animation.setContext( value );

  	};

  	this.setFramebufferScaleFactor = function ( value ) {

  		framebufferScaleFactor = value;

  	};

  	this.setFrameOfReferenceType = function ( value ) {

  		frameOfReferenceType = value;

  	};

  	this.setPoseTarget = function ( object ) {

  		if ( object !== undefined ) { poseTarget = object; }

  	};

  	this.getCamera = function ( camera ) {

  		var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

  		if ( isPresenting() === false ) {

  			camera.position.set( 0, userHeight, 0 );
  			camera.rotation.set( 0, 0, 0 );

  			return camera;

  		}

  		device.depthNear = camera.near;
  		device.depthFar = camera.far;

  		device.getFrameData( frameData );

  		//

  		if ( frameOfReferenceType === 'stage' ) {

  			var stageParameters = device.stageParameters;

  			if ( stageParameters ) {

  				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

  			} else {

  				standingMatrix.makeTranslation( 0, userHeight, 0 );

  			}

  		}
  		var pose = frameData.pose;
  		var poseObject = poseTarget !== null ? poseTarget : camera;

  		// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
  		poseObject.matrix.copy( standingMatrix );
  		poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

  		if ( pose.orientation !== null ) {

  			tempQuaternion.fromArray( pose.orientation );
  			poseObject.quaternion.multiply( tempQuaternion );

  		}

  		if ( pose.position !== null ) {

  			tempQuaternion.setFromRotationMatrix( standingMatrix );
  			tempPosition.fromArray( pose.position );
  			tempPosition.applyQuaternion( tempQuaternion );
  			poseObject.position.add( tempPosition );

  		}

  		poseObject.updateMatrixWorld();

  		//

  		cameraL.near = camera.near;
  		cameraR.near = camera.near;

  		cameraL.far = camera.far;
  		cameraR.far = camera.far;

  		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
  		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

  		// TODO (mrdoob) Double check this code

  		standingMatrixInverse.getInverse( standingMatrix );

  		if ( frameOfReferenceType === 'stage' ) {

  			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
  			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

  		}

  		var parent = poseObject.parent;

  		if ( parent !== null ) {

  			matrixWorldInverse.getInverse( parent.matrixWorld );

  			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
  			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

  		}

  		// envMap and Mirror needs camera.matrixWorld

  		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
  		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

  		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
  		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

  		setProjectionFromUnion( cameraVR, cameraL, cameraR );

  		//

  		var layers = device.getLayers();

  		if ( layers.length ) {

  			var layer = layers[ 0 ];

  			if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

  				cameraL.bounds.fromArray( layer.leftBounds );

  			}

  			if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

  				cameraR.bounds.fromArray( layer.rightBounds );

  			}

  		}

  		updateControllers();

  		return cameraVR;

  	};

  	this.getStandingMatrix = function () {

  		return standingMatrix;

  	};

  	this.isPresenting = isPresenting;

  	// Animation Loop

  	var animation = new WebGLAnimation();

  	this.setAnimationLoop = function ( callback ) {

  		animation.setAnimationLoop( callback );

  	};

  	this.submitFrame = function () {

  		if ( isPresenting() ) { device.submitFrame(); }

  	};

  	this.dispose = function () {

  		if ( typeof window !== 'undefined' ) {

  			window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

  		}

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebXRManager( renderer ) {

  	var gl = renderer.context;

  	var device = null;
  	var session = null;

  	var framebufferScaleFactor = 1.0;

  	var frameOfReference = null;
  	var frameOfReferenceType = 'stage';

  	var pose = null;

  	var controllers = [];
  	var inputSources = [];

  	function isPresenting() {

  		return session !== null && frameOfReference !== null;

  	}

  	//

  	var cameraL = new PerspectiveCamera();
  	cameraL.layers.enable( 1 );
  	cameraL.viewport = new Vector4();

  	var cameraR = new PerspectiveCamera();
  	cameraR.layers.enable( 2 );
  	cameraR.viewport = new Vector4();

  	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
  	cameraVR.layers.enable( 1 );
  	cameraVR.layers.enable( 2 );

  	//

  	this.enabled = false;

  	this.getController = function ( id ) {

  		var controller = controllers[ id ];

  		if ( controller === undefined ) {

  			controller = new Group();
  			controller.matrixAutoUpdate = false;
  			controller.visible = false;

  			controllers[ id ] = controller;

  		}

  		return controller;

  	};

  	this.getDevice = function () {

  		return device;

  	};

  	this.setDevice = function ( value ) {

  		if ( value !== undefined ) { device = value; }
  		if ( value instanceof XRDevice ) { gl.setCompatibleXRDevice( value ); }

  	};

  	//

  	function onSessionEvent( event ) {

  		var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
  		if ( controller ) { controller.dispatchEvent( { type: event.type } ); }

  	}

  	function onSessionEnd() {

  		renderer.setFramebuffer( null );
  		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
  		animation.stop();

  	}

  	this.setFramebufferScaleFactor = function ( value ) {

  		framebufferScaleFactor = value;

  	};

  	this.setFrameOfReferenceType = function ( value ) {

  		frameOfReferenceType = value;

  	};

  	this.setSession = function ( value ) {

  		session = value;

  		if ( session !== null ) {

  			session.addEventListener( 'select', onSessionEvent );
  			session.addEventListener( 'selectstart', onSessionEvent );
  			session.addEventListener( 'selectend', onSessionEvent );
  			session.addEventListener( 'end', onSessionEnd );

  			session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
  			session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {

  				frameOfReference = value;

  				renderer.setFramebuffer( session.baseLayer.framebuffer );

  				animation.setContext( session );
  				animation.start();

  			} );

  			//

  			inputSources = session.getInputSources();

  			session.addEventListener( 'inputsourceschange', function () {

  				inputSources = session.getInputSources();
  				console.log( inputSources );

  				for ( var i = 0; i < controllers.length; i ++ ) {

  					var controller = controllers[ i ];
  					controller.userData.inputSource = inputSources[ i ];

  				}

  			} );

  		}

  	};

  	function updateCamera( camera, parent ) {

  		if ( parent === null ) {

  			camera.matrixWorld.copy( camera.matrix );

  		} else {

  			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  		}

  		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

  	}

  	this.getCamera = function ( camera ) {

  		if ( isPresenting() ) {

  			var parent = camera.parent;
  			var cameras = cameraVR.cameras;

  			updateCamera( cameraVR, parent );

  			for ( var i = 0; i < cameras.length; i ++ ) {

  				updateCamera( cameras[ i ], parent );

  			}

  			// update camera and its children

  			camera.matrixWorld.copy( cameraVR.matrixWorld );

  			var children = camera.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].updateMatrixWorld( true );

  			}

  			setProjectionFromUnion( cameraVR, cameraL, cameraR );

  			return cameraVR;

  		}

  		return camera;

  	};

  	this.isPresenting = isPresenting;

  	// Animation Loop

  	var onAnimationFrameCallback = null;

  	function onAnimationFrame( time, frame ) {

  		pose = frame.getDevicePose( frameOfReference );

  		if ( pose !== null ) {

  			var layer = session.baseLayer;
  			var views = frame.views;

  			for ( var i = 0; i < views.length; i ++ ) {

  				var view = views[ i ];
  				var viewport = layer.getViewport( view );
  				var viewMatrix = pose.getViewMatrix( view );

  				var camera = cameraVR.cameras[ i ];
  				camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
  				camera.projectionMatrix.fromArray( view.projectionMatrix );
  				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  				if ( i === 0 ) {

  					cameraVR.matrix.copy( camera.matrix );

  				}

  			}

  		}

  		//

  		for ( var i = 0; i < controllers.length; i ++ ) {

  			var controller = controllers[ i ];

  			var inputSource = inputSources[ i ];

  			if ( inputSource ) {

  				var inputPose = frame.getInputPose( inputSource, frameOfReference );

  				if ( inputPose !== null ) {

  					if ( 'targetRay' in inputPose ) {

  						controller.matrix.elements = inputPose.targetRay.transformMatrix;

  					} else if ( 'pointerMatrix' in inputPose ) {

  						// DEPRECATED

  						controller.matrix.elements = inputPose.pointerMatrix;

  					}

  					controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
  					controller.visible = true;

  					continue;

  				}

  			}

  			controller.visible = false;

  		}

  		if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

  	}

  	var animation = new WebGLAnimation();
  	animation.setAnimationLoop( onAnimationFrame );

  	this.setAnimationLoop = function ( callback ) {

  		onAnimationFrameCallback = callback;

  	};

  	this.dispose = function () {};

  	// DEPRECATED

  	this.getStandingMatrix = function () {

  		console.warn( 'WebXRManager: getStandingMatrix() is no longer needed.' );
  		return new Matrix4();

  	};

  	this.submitFrame = function () {};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLRenderer( parameters ) {

  	console.log( 'WebGLRenderer', REVISION );

  	parameters = parameters || {};

  	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
  		_context = parameters.context !== undefined ? parameters.context : null,

  		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  		_depth = parameters.depth !== undefined ? parameters.depth : true,
  		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

  	var currentRenderList = null;
  	var currentRenderState = null;

  	// public properties

  	this.domElement = _canvas;
  	this.context = null;

  	// clearing

  	this.autoClear = true;
  	this.autoClearColor = true;
  	this.autoClearDepth = true;
  	this.autoClearStencil = true;

  	// scene graph

  	this.sortObjects = true;

  	// user-defined clipping

  	this.clippingPlanes = [];
  	this.localClippingEnabled = false;

  	// physically based shading

  	this.gammaFactor = 2.0;	// for backwards compatibility
  	this.gammaInput = false;
  	this.gammaOutput = false;

  	// physical lights

  	this.physicallyCorrectLights = false;

  	// tone mapping

  	this.toneMapping = LinearToneMapping;
  	this.toneMappingExposure = 1.0;
  	this.toneMappingWhitePoint = 1.0;

  	// morphs

  	this.maxMorphTargets = 8;
  	this.maxMorphNormals = 4;

  	// internal properties

  	var _this = this,

  		_isContextLost = false,

  		// internal state cache

  		_framebuffer = null,

  		_currentRenderTarget = null,
  		_currentFramebuffer = null,
  		_currentMaterialId = - 1,

  		// geometry and program caching

  		_currentGeometryProgram = {
  			geometry: null,
  			program: null,
  			wireframe: false
  		},

  		_currentCamera = null,
  		_currentArrayCamera = null,

  		_currentViewport = new Vector4(),
  		_currentScissor = new Vector4(),
  		_currentScissorTest = null,

  		//

  		_usedTextureUnits = 0,

  		//

  		_width = _canvas.width,
  		_height = _canvas.height,

  		_pixelRatio = 1,

  		_viewport = new Vector4( 0, 0, _width, _height ),
  		_scissor = new Vector4( 0, 0, _width, _height ),
  		_scissorTest = false,

  		// frustum

  		_frustum = new Frustum(),

  		// clipping

  		_clipping = new WebGLClipping(),
  		_clippingEnabled = false,
  		_localClippingEnabled = false,

  		// camera matrices cache

  		_projScreenMatrix = new Matrix4(),

  		_vector3 = new Vector3();

  	function getTargetPixelRatio() {

  		return _currentRenderTarget === null ? _pixelRatio : 1;

  	}

  	// initialize

  	var _gl;

  	try {

  		var contextAttributes = {
  			alpha: _alpha,
  			depth: _depth,
  			stencil: _stencil,
  			antialias: _antialias,
  			premultipliedAlpha: _premultipliedAlpha,
  			preserveDrawingBuffer: _preserveDrawingBuffer,
  			powerPreference: _powerPreference
  		};

  		// event listeners must be registered before WebGL context is created, see #12753

  		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

  		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

  		if ( _gl === null ) {

  			if ( _canvas.getContext( 'webgl' ) !== null ) {

  				throw new Error( 'Error creating WebGL context with your selected attributes.' );

  			} else {

  				throw new Error( 'Error creating WebGL context.' );

  			}

  		}

  		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

  		if ( _gl.getShaderPrecisionFormat === undefined ) {

  			_gl.getShaderPrecisionFormat = function () {

  				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

  			};

  		}

  	} catch ( error ) {

  		console.error( 'WebGLRenderer: ' + error.message );
  		throw error;

  	}

  	var extensions, capabilities, state, info;
  	var properties, textures, attributes, geometries, objects;
  	var programCache, renderLists, renderStates;

  	var background, morphtargets, bufferRenderer, indexedBufferRenderer;

  	var utils;

  	function initGLContext() {

  		extensions = new WebGLExtensions( _gl );

  		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

  		if ( ! capabilities.isWebGL2 ) {

  			extensions.get( 'WEBGL_depth_texture' );
  			extensions.get( 'OES_texture_float' );
  			extensions.get( 'OES_texture_half_float' );
  			extensions.get( 'OES_texture_half_float_linear' );
  			extensions.get( 'OES_standard_derivatives' );
  			extensions.get( 'OES_element_index_uint' );
  			extensions.get( 'ANGLE_instanced_arrays' );

  		}

  		extensions.get( 'OES_texture_float_linear' );

  		utils = new WebGLUtils( _gl, extensions, capabilities );

  		state = new WebGLState( _gl, extensions, utils, capabilities );
  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  		info = new WebGLInfo( _gl );
  		properties = new WebGLProperties();
  		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
  		attributes = new WebGLAttributes( _gl );
  		geometries = new WebGLGeometries( _gl, attributes, info );
  		objects = new WebGLObjects( geometries, info );
  		morphtargets = new WebGLMorphtargets( _gl );
  		programCache = new WebGLPrograms( _this, extensions, capabilities );
  		renderLists = new WebGLRenderLists();
  		renderStates = new WebGLRenderStates();

  		background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

  		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
  		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

  		info.programs = programCache.programs;

  		_this.context = _gl;
  		_this.capabilities = capabilities;
  		_this.extensions = extensions;
  		_this.properties = properties;
  		_this.renderLists = renderLists;
  		_this.state = state;
  		_this.info = info;

  	}

  	initGLContext();

  	// vr

  	var vr = null;

  	if ( typeof navigator !== 'undefined' ) {

  		vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

  	}

  	this.vr = vr;

  	// shadow map

  	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

  	this.shadowMap = shadowMap;

  	// API

  	this.getContext = function () {

  		return _gl;

  	};

  	this.getContextAttributes = function () {

  		return _gl.getContextAttributes();

  	};

  	this.forceContextLoss = function () {

  		var extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) { extension.loseContext(); }

  	};

  	this.forceContextRestore = function () {

  		var extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) { extension.restoreContext(); }

  	};

  	this.getPixelRatio = function () {

  		return _pixelRatio;

  	};

  	this.setPixelRatio = function ( value ) {

  		if ( value === undefined ) { return; }

  		_pixelRatio = value;

  		this.setSize( _width, _height, false );

  	};

  	this.getSize = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

  			target = new Vector2();

  		}

  		return target.set( _width, _height );

  	};

  	this.setSize = function ( width, height, updateStyle ) {

  		if ( vr.isPresenting() ) {

  			console.warn( 'WebGLRenderer: Can\'t change size while VR device is presenting.' );
  			return;

  		}

  		_width = width;
  		_height = height;

  		_canvas.width = width * _pixelRatio;
  		_canvas.height = height * _pixelRatio;

  		if ( updateStyle !== false ) {

  			_canvas.style.width = width + 'px';
  			_canvas.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  	};

  	this.getDrawingBufferSize = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

  			target = new Vector2();

  		}

  		return target.set( _width * _pixelRatio, _height * _pixelRatio );

  	};

  	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  		_width = width;
  		_height = height;

  		_pixelRatio = pixelRatio;

  		_canvas.width = width * pixelRatio;
  		_canvas.height = height * pixelRatio;

  		this.setViewport( 0, 0, width, height );

  	};

  	this.getCurrentViewport = function ( target ) {

  		if ( target === undefined ) {

  			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

  			target = new Vector4();

  		}

  		return target.copy( _currentViewport );

  	};

  	this.getViewport = function ( target ) {

  		return target.copy( _viewport );

  	};

  	this.setViewport = function ( x, y, width, height ) {

  		if ( x.isVector4 ) {

  			_viewport.set( x.x, x.y, x.z, x.w );

  		} else {

  			_viewport.set( x, y, width, height );

  		}

  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  	};

  	this.getScissor = function ( target ) {

  		return target.copy( _scissor );

  	};

  	this.setScissor = function ( x, y, width, height ) {

  		if ( x.isVector4 ) {

  			_scissor.set( x.x, x.y, x.z, x.w );

  		} else {

  			_scissor.set( x, y, width, height );

  		}

  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

  	};

  	this.getScissorTest = function () {

  		return _scissorTest;

  	};

  	this.setScissorTest = function ( boolean ) {

  		state.setScissorTest( _scissorTest = boolean );

  	};

  	// Clearing

  	this.getClearColor = function () {

  		return background.getClearColor();

  	};

  	this.setClearColor = function () {

  		background.setClearColor.apply( background, arguments );

  	};

  	this.getClearAlpha = function () {

  		return background.getClearAlpha();

  	};

  	this.setClearAlpha = function () {

  		background.setClearAlpha.apply( background, arguments );

  	};

  	this.clear = function ( color, depth, stencil ) {

  		var bits = 0;

  		if ( color === undefined || color ) { bits |= _gl.COLOR_BUFFER_BIT; }
  		if ( depth === undefined || depth ) { bits |= _gl.DEPTH_BUFFER_BIT; }
  		if ( stencil === undefined || stencil ) { bits |= _gl.STENCIL_BUFFER_BIT; }

  		_gl.clear( bits );

  	};

  	this.clearColor = function () {

  		this.clear( true, false, false );

  	};

  	this.clearDepth = function () {

  		this.clear( false, true, false );

  	};

  	this.clearStencil = function () {

  		this.clear( false, false, true );

  	};

  	//

  	this.dispose = function () {

  		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

  		renderLists.dispose();
  		renderStates.dispose();
  		properties.dispose();
  		objects.dispose();

  		vr.dispose();

  		animation.stop();

  	};

  	// Events

  	function onContextLost( event ) {

  		event.preventDefault();

  		console.log( 'WebGLRenderer: Context Lost.' );

  		_isContextLost = true;

  	}

  	function onContextRestore(  ) {

  		console.log( 'WebGLRenderer: Context Restored.' );

  		_isContextLost = false;

  		initGLContext();

  	}

  	function onMaterialDispose( event ) {

  		var material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		deallocateMaterial( material );

  	}

  	// Buffer deallocation

  	function deallocateMaterial( material ) {

  		releaseMaterialProgramReference( material );

  		properties.remove( material );

  	}
  	function releaseMaterialProgramReference( material ) {

  		var programInfo = properties.get( material ).program;

  		material.program = undefined;

  		if ( programInfo !== undefined ) {

  			programCache.releaseProgram( programInfo );

  		}

  	}

  	// Buffer rendering

  	function renderObjectImmediate( object, program ) {

  		object.render( function ( object ) {

  			_this.renderBufferImmediate( object, program );

  		} );

  	}

  	this.renderBufferImmediate = function ( object, program ) {

  		state.initAttributes();

  		var buffers = properties.get( object );

  		if ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }
  		if ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }
  		if ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }
  		if ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }

  		var programAttributes = program.getAttributes();

  		if ( object.hasPositions ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.position );
  			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasNormals ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.normal );
  			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasUvs ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.uv );
  			_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasColors ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.color );
  			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		state.disableUnusedAttributes();

  		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

  		object.count = 0;

  	};

  	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

  		var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  		state.setMaterial( material, frontFaceCW );

  		var program = setProgram( camera, fog, material, object );

  		var updateBuffers = false;

  		if ( _currentGeometryProgram.geometry !== geometry.id ||
  			_currentGeometryProgram.program !== program.id ||
  			_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

  			_currentGeometryProgram.geometry = geometry.id;
  			_currentGeometryProgram.program = program.id;
  			_currentGeometryProgram.wireframe = material.wireframe === true;
  			updateBuffers = true;

  		}

  		if ( object.morphTargetInfluences ) {

  			morphtargets.update( object, geometry, material, program );

  			updateBuffers = true;

  		}

  		//

  		var index = geometry.index;
  		var position = geometry.attributes.position;
  		var rangeFactor = 1;

  		if ( material.wireframe === true ) {

  			index = geometries.getWireframeAttribute( geometry );
  			rangeFactor = 2;

  		}

  		var attribute;
  		var renderer = bufferRenderer;

  		if ( index !== null ) {

  			attribute = attributes.get( index );

  			renderer = indexedBufferRenderer;
  			renderer.setIndex( attribute );

  		}

  		if ( updateBuffers ) {

  			setupVertexAttributes( material, program, geometry );

  			if ( index !== null ) {

  				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

  			}

  		}

  		//

  		var dataCount = Infinity;

  		if ( index !== null ) {

  			dataCount = index.count;

  		} else if ( position !== undefined ) {

  			dataCount = position.count;

  		}

  		var rangeStart = geometry.drawRange.start * rangeFactor;
  		var rangeCount = geometry.drawRange.count * rangeFactor;

  		var groupStart = group !== null ? group.start * rangeFactor : 0;
  		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

  		var drawStart = Math.max( rangeStart, groupStart );
  		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

  		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

  		if ( drawCount === 0 ) { return; }

  		//

  		if ( object.isMesh ) {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  				renderer.setMode( _gl.LINES );

  			} else {

  				switch ( object.drawMode ) {

  					case TrianglesDrawMode:
  						renderer.setMode( _gl.TRIANGLES );
  						break;

  					case TriangleStripDrawMode:
  						renderer.setMode( _gl.TRIANGLE_STRIP );
  						break;

  					case TriangleFanDrawMode:
  						renderer.setMode( _gl.TRIANGLE_FAN );
  						break;

  				}

  			}
  		} else if ( object.isLine ) {

  			var lineWidth = material.linewidth;

  			if ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material

  			state.setLineWidth( lineWidth * getTargetPixelRatio() );

  			if ( object.isLineSegments ) {

  				renderer.setMode( _gl.LINES );

  			} else if ( object.isLineLoop ) {

  				renderer.setMode( _gl.LINE_LOOP );

  			} else {

  				renderer.setMode( _gl.LINE_STRIP );

  			}

  		} else if ( object.isPoints ) {

  			renderer.setMode( _gl.POINTS );

  		} else if ( object.isSprite ) {

  			renderer.setMode( _gl.TRIANGLES );

  		}

  		if ( geometry && geometry.isInstancedBufferGeometry ) {

  			if ( geometry.maxInstancedCount > 0 ) {

  				renderer.renderInstances( geometry, drawStart, drawCount );

  			}

  		} else {

  			renderer.render( drawStart, drawCount );

  		}

  	};

  	function setupVertexAttributes( material, program, geometry ) {

  		if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) {

  			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

  				console.error( 'WebGLRenderer.setupVertexAttributes: using InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		state.initAttributes();

  		var geometryAttributes = geometry.attributes;

  		var programAttributes = program.getAttributes();

  		var materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( var name in programAttributes ) {

  			var programAttribute = programAttributes[ name ];

  			if ( programAttribute >= 0 ) {

  				var geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute !== undefined ) {

  					var normalized = geometryAttribute.normalized;
  					var size = geometryAttribute.itemSize;

  					var attribute = attributes.get( geometryAttribute );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) { continue; }

  					var buffer = attribute.buffer;
  					var type = attribute.type;
  					var bytesPerElement = attribute.bytesPerElement;

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						var data = geometryAttribute.data;
  						var stride = data.stride;
  						var offset = geometryAttribute.offset;

  						if ( data && data.isInstancedInterleavedBuffer ) {

  							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

  					}

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					var value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								_gl.vertexAttrib2fv( programAttribute, value );
  								break;

  							case 3:
  								_gl.vertexAttrib3fv( programAttribute, value );
  								break;

  							case 4:
  								_gl.vertexAttrib4fv( programAttribute, value );
  								break;

  							default:
  								_gl.vertexAttrib1fv( programAttribute, value );

  						}

  					}

  				}

  			}

  		}

  		state.disableUnusedAttributes();

  	}

  	// Compile

  	this.compile = function ( scene, camera ) {

  		currentRenderState = renderStates.get( scene, camera );
  		currentRenderState.init();

  		scene.traverse( function ( object ) {

  			if ( object.isLight ) {

  				currentRenderState.pushLight( object );

  				if ( object.castShadow ) {

  					currentRenderState.pushShadow( object );

  				}

  			}

  		} );

  		currentRenderState.setupLights( camera );

  		scene.traverse( function ( object ) {

  			if ( object.material ) {

  				if ( Array.isArray( object.material ) ) {

  					for ( var i = 0; i < object.material.length; i ++ ) {

  						initMaterial( object.material[ i ], scene.fog, object );

  					}

  				} else {

  					initMaterial( object.material, scene.fog, object );

  				}

  			}

  		} );

  	};

  	// Animation Loop

  	var onAnimationFrameCallback = null;

  	function onAnimationFrame( time ) {

  		if ( vr.isPresenting() ) { return; }
  		if ( onAnimationFrameCallback ) { onAnimationFrameCallback( time ); }

  	}

  	var animation = new WebGLAnimation();
  	animation.setAnimationLoop( onAnimationFrame );

  	if ( typeof window !== 'undefined' ) { animation.setContext( window ); }

  	this.setAnimationLoop = function ( callback ) {

  		onAnimationFrameCallback = callback;
  		vr.setAnimationLoop( callback );

  		animation.start();

  	};

  	// Rendering

  	this.render = function ( scene, camera ) {

  		var renderTarget, forceClear;

  		if ( arguments[ 2 ] !== undefined ) {

  			console.warn( 'WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
  			renderTarget = arguments[ 2 ];

  		}

  		if ( arguments[ 3 ] !== undefined ) {

  			console.warn( 'WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
  			forceClear = arguments[ 3 ];

  		}

  		if ( ! ( camera && camera.isCamera ) ) {

  			console.error( 'WebGLRenderer.render: camera is not an instance of Camera.' );
  			return;

  		}

  		if ( _isContextLost ) { return; }

  		// reset caching for this frame

  		_currentGeometryProgram.geometry = null;
  		_currentGeometryProgram.program = null;
  		_currentGeometryProgram.wireframe = false;
  		_currentMaterialId = - 1;
  		_currentCamera = null;

  		// update scene graph

  		if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

  		// update camera matrices and frustum

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		if ( vr.enabled ) {

  			camera = vr.getCamera( camera );

  		}

  		//

  		currentRenderState = renderStates.get( scene, camera );
  		currentRenderState.init();

  		scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		_frustum.setFromMatrix( _projScreenMatrix );

  		_localClippingEnabled = this.localClippingEnabled;
  		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

  		currentRenderList = renderLists.get( scene, camera );
  		currentRenderList.init();

  		projectObject( scene, camera, 0, _this.sortObjects );

  		if ( _this.sortObjects === true ) {

  			currentRenderList.sort();

  		}

  		//

  		if ( _clippingEnabled ) { _clipping.beginShadows(); }

  		var shadowsArray = currentRenderState.state.shadowsArray;

  		shadowMap.render( shadowsArray, scene, camera );

  		currentRenderState.setupLights( camera );

  		if ( _clippingEnabled ) { _clipping.endShadows(); }

  		//

  		if ( this.info.autoReset ) { this.info.reset(); }

  		if ( renderTarget !== undefined ) {

  			this.setRenderTarget( renderTarget );

  		}

  		//

  		background.render( currentRenderList, scene, camera, forceClear );

  		// render scene

  		var opaqueObjects = currentRenderList.opaque;
  		var transparentObjects = currentRenderList.transparent;

  		if ( scene.overrideMaterial ) {

  			var overrideMaterial = scene.overrideMaterial;

  			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera, overrideMaterial ); }
  			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera, overrideMaterial ); }

  		} else {

  			// opaque pass (front-to-back order)

  			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera ); }

  			// transparent pass (back-to-front order)

  			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera ); }

  		}

  		//

  		if ( _currentRenderTarget !== null ) {

  			// Generate mipmap if we're using any kind of mipmap filtering

  			textures.updateRenderTargetMipmap( _currentRenderTarget );

  			// resolve multisample renderbuffers to a single-sample texture if necessary

  			textures.updateMultisampleRenderTarget( _currentRenderTarget );

  		}

  		// Ensure depth buffer writing is enabled so it can be cleared on next render

  		state.buffers.depth.setTest( true );
  		state.buffers.depth.setMask( true );
  		state.buffers.color.setMask( true );

  		state.setPolygonOffset( false );

  		scene.onAfterRender( _this, scene, camera );

  		if ( vr.enabled ) {

  			vr.submitFrame();

  		}

  		// _gl.finish();

  		currentRenderList = null;
  		currentRenderState = null;

  	};

  	function projectObject( object, camera, groupOrder, sortObjects ) {

  		if ( object.visible === false ) { return; }

  		var visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isGroup ) {

  				groupOrder = object.renderOrder;

  			} else if ( object.isLight ) {

  				currentRenderState.pushLight( object );

  				if ( object.castShadow ) {

  					currentRenderState.pushShadow( object );

  				}

  			} else if ( object.isSprite ) {

  				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					var geometry = objects.update( object );
  					var material = object.material;

  					currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  				}

  			} else if ( object.isImmediateRenderObject ) {

  				if ( sortObjects ) {

  					_vector3.setFromMatrixPosition( object.matrixWorld )
  						.applyMatrix4( _projScreenMatrix );

  				}

  				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				if ( object.isSkinnedMesh ) {

  					object.skeleton.update();

  				}

  				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					var geometry = objects.update( object );
  					var material = object.material;

  					if ( Array.isArray( material ) ) {

  						var groups = geometry.groups;

  						for ( var i = 0, l = groups.length; i < l; i ++ ) {

  							var group = groups[ i ];
  							var groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

  							}

  						}

  					} else if ( material.visible ) {

  						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  					}

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			projectObject( children[ i ], camera, groupOrder, sortObjects );

  		}

  	}

  	function renderObjects( renderList, scene, camera, overrideMaterial ) {

  		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

  			var renderItem = renderList[ i ];

  			var object = renderItem.object;
  			var geometry = renderItem.geometry;
  			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
  			var group = renderItem.group;

  			if ( camera.isArrayCamera ) {

  				_currentArrayCamera = camera;

  				var cameras = camera.cameras;

  				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

  					var camera2 = cameras[ j ];

  					if ( object.layers.test( camera2.layers ) ) {

  						if ( 'viewport' in camera2 ) { // XR

  							state.viewport( _currentViewport.copy( camera2.viewport ) );

  						} else {

  							var bounds = camera2.bounds;

  							var x = bounds.x * _width;
  							var y = bounds.y * _height;
  							var width = bounds.z * _width;
  							var height = bounds.w * _height;

  							state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

  						}

  						currentRenderState.setupLights( camera2 );

  						renderObject( object, scene, camera2, geometry, material, group );

  					}

  				}

  			} else {

  				_currentArrayCamera = null;

  				renderObject( object, scene, camera, geometry, material, group );

  			}

  		}

  	}

  	function renderObject( object, scene, camera, geometry, material, group ) {

  		object.onBeforeRender( _this, scene, camera, geometry, material, group );
  		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

  		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  		if ( object.isImmediateRenderObject ) {

  			state.setMaterial( material );

  			var program = setProgram( camera, scene.fog, material, object );

  			_currentGeometryProgram.geometry = null;
  			_currentGeometryProgram.program = null;
  			_currentGeometryProgram.wireframe = false;

  			renderObjectImmediate( object, program );

  		} else {

  			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

  		}

  		object.onAfterRender( _this, scene, camera, geometry, material, group );
  		currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

  	}

  	function initMaterial( material, fog, object ) {

  		var materialProperties = properties.get( material );

  		var lights = currentRenderState.state.lights;
  		var shadowsArray = currentRenderState.state.shadowsArray;

  		var lightsHash = materialProperties.lightsHash;
  		var lightsStateHash = lights.state.hash;

  		var parameters = programCache.getParameters(
  			material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

  		var code = programCache.getProgramCode( material, parameters );

  		var program = materialProperties.program;
  		var programChange = true;

  		if ( program === undefined ) {

  			// new material
  			material.addEventListener( 'dispose', onMaterialDispose );

  		} else if ( program.code !== code ) {

  			// changed glsl or parameters
  			releaseMaterialProgramReference( material );

  		} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
  			lightsHash.directionalLength !== lightsStateHash.directionalLength ||
  			lightsHash.pointLength !== lightsStateHash.pointLength ||
  			lightsHash.spotLength !== lightsStateHash.spotLength ||
  			lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
  			lightsHash.hemiLength !== lightsStateHash.hemiLength ||
  			lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

  			lightsHash.stateID = lightsStateHash.stateID;
  			lightsHash.directionalLength = lightsStateHash.directionalLength;
  			lightsHash.pointLength = lightsStateHash.pointLength;
  			lightsHash.spotLength = lightsStateHash.spotLength;
  			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
  			lightsHash.hemiLength = lightsStateHash.hemiLength;
  			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

  			programChange = false;

  		} else if ( parameters.shaderID !== undefined ) {

  			// same glsl and uniform list
  			return;

  		} else {

  			// only rebuild uniform list
  			programChange = false;

  		}

  		if ( programChange ) {

  			if ( parameters.shaderID ) {

  				var shader = ShaderLib[ parameters.shaderID ];

  				materialProperties.shader = {
  					name: material.type,
  					uniforms: cloneUniforms( shader.uniforms ),
  					vertexShader: shader.vertexShader,
  					fragmentShader: shader.fragmentShader
  				};

  			} else {

  				materialProperties.shader = {
  					name: material.type,
  					uniforms: material.uniforms,
  					vertexShader: material.vertexShader,
  					fragmentShader: material.fragmentShader
  				};

  			}

  			material.onBeforeCompile( materialProperties.shader, _this );

  			// Computing code again as onBeforeCompile may have changed the shaders
  			code = programCache.getProgramCode( material, parameters );

  			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

  			materialProperties.program = program;
  			material.program = program;

  		}

  		var programAttributes = program.getAttributes();

  		if ( material.morphTargets ) {

  			material.numSupportedMorphTargets = 0;

  			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

  				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

  					material.numSupportedMorphTargets ++;

  				}

  			}

  		}

  		if ( material.morphNormals ) {

  			material.numSupportedMorphNormals = 0;

  			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

  				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

  					material.numSupportedMorphNormals ++;

  				}

  			}

  		}

  		var uniforms = materialProperties.shader.uniforms;

  		if ( ! material.isShaderMaterial &&
  			! material.isRawShaderMaterial ||
  			material.clipping === true ) {

  			materialProperties.numClippingPlanes = _clipping.numPlanes;
  			materialProperties.numIntersection = _clipping.numIntersection;
  			uniforms.clippingPlanes = _clipping.uniform;

  		}

  		materialProperties.fog = fog;

  		// store the light setup it was created for
  		if ( lightsHash === undefined ) {

  			materialProperties.lightsHash = lightsHash = {};

  		}

  		lightsHash.stateID = lightsStateHash.stateID;
  		lightsHash.directionalLength = lightsStateHash.directionalLength;
  		lightsHash.pointLength = lightsStateHash.pointLength;
  		lightsHash.spotLength = lightsStateHash.spotLength;
  		lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
  		lightsHash.hemiLength = lightsStateHash.hemiLength;
  		lightsHash.shadowsLength = lightsStateHash.shadowsLength;

  		if ( material.lights ) {

  			// wire up the material to this renderer's lighting state

  			uniforms.ambientLightColor.value = lights.state.ambient;
  			uniforms.directionalLights.value = lights.state.directional;
  			uniforms.spotLights.value = lights.state.spot;
  			uniforms.rectAreaLights.value = lights.state.rectArea;
  			uniforms.pointLights.value = lights.state.point;
  			uniforms.hemisphereLights.value = lights.state.hemi;

  			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
  			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  			// TODO (abelnation): add area lights shadow info to uniforms

  		}

  		var progUniforms = materialProperties.program.getUniforms(),
  			uniformsList =
  				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

  		materialProperties.uniformsList = uniformsList;

  	}

  	function setProgram( camera, fog, material, object ) {

  		_usedTextureUnits = 0;

  		var materialProperties = properties.get( material );
  		var lights = currentRenderState.state.lights;

  		var lightsHash = materialProperties.lightsHash;
  		var lightsStateHash = lights.state.hash;

  		if ( _clippingEnabled ) {

  			if ( _localClippingEnabled || camera !== _currentCamera ) {

  				var useCache =
  					camera === _currentCamera &&
  					material.id === _currentMaterialId;

  				// we might want to call this function with some ClippingGroup
  				// object instead of the material, once it becomes feasible
  				// (#8465, #8379)
  				_clipping.setState(
  					material.clippingPlanes, material.clipIntersection, material.clipShadows,
  					camera, materialProperties, useCache );

  			}

  		}

  		if ( material.needsUpdate === false ) {

  			if ( materialProperties.program === undefined ) {

  				material.needsUpdate = true;

  			} else if ( material.fog && materialProperties.fog !== fog ) {

  				material.needsUpdate = true;

  			} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
  				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
  				lightsHash.pointLength !== lightsStateHash.pointLength ||
  				lightsHash.spotLength !== lightsStateHash.spotLength ||
  				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
  				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
  				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

  				material.needsUpdate = true;

  			} else if ( materialProperties.numClippingPlanes !== undefined &&
  				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
  				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

  				material.needsUpdate = true;

  			}

  		}

  		if ( material.needsUpdate ) {

  			initMaterial( material, fog, object );
  			material.needsUpdate = false;

  		}

  		var refreshProgram = false;
  		var refreshMaterial = false;
  		var refreshLights = false;

  		var program = materialProperties.program,
  			p_uniforms = program.getUniforms(),
  			m_uniforms = materialProperties.shader.uniforms;

  		if ( state.useProgram( program.program ) ) {

  			refreshProgram = true;
  			refreshMaterial = true;
  			refreshLights = true;

  		}

  		if ( material.id !== _currentMaterialId ) {

  			_currentMaterialId = material.id;

  			refreshMaterial = true;

  		}

  		if ( refreshProgram || _currentCamera !== camera ) {

  			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  			if ( capabilities.logarithmicDepthBuffer ) {

  				p_uniforms.setValue( _gl, 'logDepthBufFC',
  					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  			}

  			if ( _currentCamera !== camera ) {

  				_currentCamera = camera;

  				// lighting uniforms depend on the camera so enforce an update
  				// now, in case this material supports lights - or later, when
  				// the next material that does gets activated:

  				refreshMaterial = true;		// set to true on material change
  				refreshLights = true;		// remains set until update done

  			}

  			// load material specific uniforms
  			// (shader material also gets them for the sake of genericity)

  			if ( material.isShaderMaterial ||
  				material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial ||
  				material.envMap ) {

  				var uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl,
  						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  			}

  			if ( material.isMeshPhongMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshBasicMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isShaderMaterial ||
  				material.skinning ) {

  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  			}

  		}

  		// skinning uniforms must be set even if material didn't change
  		// auto-setting of texture unit for bone texture must go before other textures
  		// not sure why, but otherwise weird things happen

  		if ( material.skinning ) {

  			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  			var skeleton = object.skeleton;

  			if ( skeleton ) {

  				var bones = skeleton.bones;

  				if ( capabilities.floatVertexTextures ) {

  					if ( skeleton.boneTexture === undefined ) {

  						// layout (1 matrix = 4 pixels)
  						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
  						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
  						size = _Math.ceilPowerOfTwo( size );
  						size = Math.max( size, 4 );

  						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  						boneMatrices.set( skeleton.boneMatrices ); // copy current values

  						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
  						boneTexture.needsUpdate = true;

  						skeleton.boneMatrices = boneMatrices;
  						skeleton.boneTexture = boneTexture;
  						skeleton.boneTextureSize = size;

  					}

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
  					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

  				} else {

  					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

  				}

  			}

  		}

  		if ( refreshMaterial ) {

  			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
  			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

  			if ( material.lights ) {

  				// the current material requires lighting info

  				// note: all lighting uniforms are always set correctly
  				// they simply reference the renderer's state for their
  				// values
  				//
  				// use the current material's .needsUpdate flags to set
  				// the GL state when required

  				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  			}

  			// refresh uniforms common to several materials

  			if ( fog && material.fog ) {

  				refreshUniformsFog( m_uniforms, fog );

  			}

  			if ( material.isMeshBasicMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  			} else if ( material.isMeshLambertMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsLambert( m_uniforms, material );

  			} else if ( material.isMeshPhongMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  				if ( material.isMeshToonMaterial ) {

  					refreshUniformsToon( m_uniforms, material );

  				} else {

  					refreshUniformsPhong( m_uniforms, material );

  				}

  			} else if ( material.isMeshStandardMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  				if ( material.isMeshPhysicalMaterial ) {

  					refreshUniformsPhysical( m_uniforms, material );

  				} else {

  					refreshUniformsStandard( m_uniforms, material );

  				}

  			} else if ( material.isMeshMatcapMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  				refreshUniformsMatcap( m_uniforms, material );

  			} else if ( material.isMeshDepthMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsDepth( m_uniforms, material );

  			} else if ( material.isMeshDistanceMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsDistance( m_uniforms, material );

  			} else if ( material.isMeshNormalMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsNormal( m_uniforms, material );

  			} else if ( material.isLineBasicMaterial ) {

  				refreshUniformsLine( m_uniforms, material );

  				if ( material.isLineDashedMaterial ) {

  					refreshUniformsDash( m_uniforms, material );

  				}

  			} else if ( material.isPointsMaterial ) {

  				refreshUniformsPoints( m_uniforms, material );

  			} else if ( material.isSpriteMaterial ) {

  				refreshUniformsSprites( m_uniforms, material );

  			} else if ( material.isShadowMaterial ) {

  				m_uniforms.color.value = material.color;
  				m_uniforms.opacity.value = material.opacity;

  			}

  			// RectAreaLight Texture
  			// TODO (mrdoob): Find a nicer implementation

  			if ( m_uniforms.ltc_1 !== undefined ) { m_uniforms.ltc_1.value = UniformsLib.LTC_1; }
  			if ( m_uniforms.ltc_2 !== undefined ) { m_uniforms.ltc_2.value = UniformsLib.LTC_2; }

  			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );

  		}

  		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

  			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
  			material.uniformsNeedUpdate = false;

  		}

  		if ( material.isSpriteMaterial ) {

  			p_uniforms.setValue( _gl, 'center', object.center );

  		}

  		// common matrices

  		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  		return program;

  	}

  	// Uniforms (refresh uniforms objects)

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		if ( material.color ) {

  			uniforms.diffuse.value = material.color;

  		}

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  		}

  		if ( material.specularMap ) {

  			uniforms.specularMap.value = material.specularMap;

  		}

  		if ( material.envMap ) {

  			uniforms.envMap.value = material.envMap;

  			// don't flip CubeTexture envMaps, flip everything else:
  			//  WebGLRenderTargetCube will be flipped for backwards compatibility
  			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  			uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

  			uniforms.reflectivity.value = material.reflectivity;
  			uniforms.refractionRatio.value = material.refractionRatio;

  			uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

  		}

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. specular map
  		// 3. normal map
  		// 4. bump map
  		// 5. alpha map
  		// 6. emissive map

  		var uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.specularMap ) {

  			uvScaleMap = material.specularMap;

  		} else if ( material.displacementMap ) {

  			uvScaleMap = material.displacementMap;

  		} else if ( material.normalMap ) {

  			uvScaleMap = material.normalMap;

  		} else if ( material.bumpMap ) {

  			uvScaleMap = material.bumpMap;

  		} else if ( material.roughnessMap ) {

  			uvScaleMap = material.roughnessMap;

  		} else if ( material.metalnessMap ) {

  			uvScaleMap = material.metalnessMap;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		} else if ( material.emissiveMap ) {

  			uvScaleMap = material.emissiveMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			// backwards compatibility
  			if ( uvScaleMap.isWebGLRenderTarget ) {

  				uvScaleMap = uvScaleMap.texture;

  			}

  			if ( uvScaleMap.matrixAutoUpdate === true ) {

  				uvScaleMap.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  		}

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * _pixelRatio;
  		uniforms.scale.value = _height * 0.5;

  		uniforms.map.value = material.map;

  		if ( material.map !== null ) {

  			if ( material.map.matrixAutoUpdate === true ) {

  				material.map.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( material.map.matrix );

  		}

  	}

  	function refreshUniformsSprites( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;
  		uniforms.rotation.value = material.rotation;
  		uniforms.map.value = material.map;

  		if ( material.map !== null ) {

  			if ( material.map.matrixAutoUpdate === true ) {

  				material.map.updateMatrix();

  			}

  			uniforms.uvTransform.value.copy( material.map.matrix );

  		}

  	}

  	function refreshUniformsFog( uniforms, fog ) {

  		uniforms.fogColor.value = fog.color;

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshUniformsLambert( uniforms, material ) {

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value = material.specular;
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		refreshUniformsPhong( uniforms, material );

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.roughness.value = material.roughness;
  		uniforms.metalness.value = material.metalness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  		}

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		if ( material.envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common
  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material ) {

  		refreshUniformsStandard( uniforms, material );

  		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

  		uniforms.clearCoat.value = material.clearCoat;
  		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

  	}

  	function refreshUniformsMatcap( uniforms, material ) {

  		if ( material.matcap ) {

  			uniforms.matcap.value = material.matcap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsDepth( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsDistance( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		uniforms.referencePosition.value.copy( material.referencePosition );
  		uniforms.nearDistance.value = material.nearDistance;
  		uniforms.farDistance.value = material.farDistance;

  	}

  	function refreshUniformsNormal( uniforms, material ) {

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;
  			if ( material.side === BackSide ) { uniforms.bumpScale.value *= - 1; }

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );
  			if ( material.side === BackSide ) { uniforms.normalScale.value.negate(); }

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  	function markUniformsLightsNeedsUpdate( uniforms, value ) {

  		uniforms.ambientLightColor.needsUpdate = value;

  		uniforms.directionalLights.needsUpdate = value;
  		uniforms.pointLights.needsUpdate = value;
  		uniforms.spotLights.needsUpdate = value;
  		uniforms.rectAreaLights.needsUpdate = value;
  		uniforms.hemisphereLights.needsUpdate = value;

  	}

  	// Textures

  	function allocTextureUnit() {

  		var textureUnit = _usedTextureUnits;

  		if ( textureUnit >= capabilities.maxTextures ) {

  			console.warn( 'WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  		}

  		_usedTextureUnits += 1;

  		return textureUnit;

  	}

  	this.allocTextureUnit = allocTextureUnit;

  	// this.setTexture2D = setTexture2D;
  	this.setTexture2D = ( function () {

  		var warned = false;

  		// backwards compatibility: peel texture.texture
  		return function setTexture2D( texture, slot ) {

  			if ( texture && texture.isWebGLRenderTarget ) {

  				if ( ! warned ) {

  					console.warn( "WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTexture3D = ( function () {

  		// backwards compatibility: peel texture.texture
  		return function setTexture3D( texture, slot ) {

  			textures.setTexture3D( texture, slot );

  		};

  	}() );

  	this.setTexture = ( function () {

  		var warned = false;

  		return function setTexture( texture, slot ) {

  			if ( ! warned ) {

  				console.warn( "WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
  				warned = true;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTextureCube = ( function () {

  		var warned = false;

  		return function setTextureCube( texture, slot ) {

  			// backwards compatibility: peel texture.texture
  			if ( texture && texture.isWebGLRenderTargetCube ) {

  				if ( ! warned ) {

  					console.warn( "WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
  			// TODO: unify these code paths
  			if ( ( texture && texture.isCubeTexture ) ||
  				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

  				// CompressedTexture can have Array in image :/

  				// this function alone should take care of cube textures
  				textures.setTextureCube( texture, slot );

  			} else {

  				// assumed: texture property of WebGLRenderTargetCube

  				textures.setTextureCubeDynamic( texture, slot );

  			}

  		};

  	}() );

  	//

  	this.setFramebuffer = function ( value ) {

  		_framebuffer = value;

  	};

  	this.getRenderTarget = function () {

  		return _currentRenderTarget;

  	};

  	this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipMapLevel ) {

  		_currentRenderTarget = renderTarget;

  		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

  			textures.setupRenderTarget( renderTarget );

  		}

  		var framebuffer = _framebuffer;
  		var isCube = false;

  		if ( renderTarget ) {

  			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( renderTarget.isWebGLRenderTargetCube ) {

  				framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
  				isCube = true;

  			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

  			} else {

  				framebuffer = __webglFramebuffer;

  			}

  			_currentViewport.copy( renderTarget.viewport );
  			_currentScissor.copy( renderTarget.scissor );
  			_currentScissorTest = renderTarget.scissorTest;

  		} else {

  			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
  			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
  			_currentScissorTest = _scissorTest;

  		}

  		if ( _currentFramebuffer !== framebuffer ) {

  			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  			_currentFramebuffer = framebuffer;

  		}

  		state.viewport( _currentViewport );
  		state.scissor( _currentScissor );
  		state.setScissorTest( _currentScissorTest );

  		if ( isCube ) {

  			var textureProperties = properties.get( renderTarget.texture );
  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace || 0, textureProperties.__webglTexture, activeMipMapLevel || 0 );

  		}

  	};

  	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

  		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  			console.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not WebGLRenderTarget.' );
  			return;

  		}

  		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  		if ( framebuffer ) {

  			var restore = false;

  			if ( framebuffer !== _currentFramebuffer ) {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				restore = true;

  			}

  			try {

  				var texture = renderTarget.texture;
  				var textureFormat = texture.format;
  				var textureType = texture.type;

  				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

  					console.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  					return;

  				}

  				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
  					! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
  					! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

  					console.error( 'WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  					return;

  				}

  				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  					}

  				} else {

  					console.error( 'WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

  				}

  			} finally {

  				if ( restore ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

  				}

  			}

  		}

  	};

  	this.copyFramebufferToTexture = function ( position, texture, level ) {

  		var width = texture.image.width;
  		var height = texture.image.height;
  		var glFormat = utils.convert( texture.format );

  		this.setTexture2D( texture, 0 );

  		_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );

  	};

  	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

  		var width = srcTexture.image.width;
  		var height = srcTexture.image.height;
  		var glFormat = utils.convert( dstTexture.format );
  		var glType = utils.convert( dstTexture.type );

  		this.setTexture2D( dstTexture, 0 );

  		if ( srcTexture.isDataTexture ) {

  			_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

  		} else {

  			_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

  		}

  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Uniform( value ) {

  	if ( typeof value === 'string' ) {

  		console.warn( 'Uniform: Type parameter is no longer needed.' );
  		value = arguments[ 1 ];

  	}

  	this.value = value;

  }

  Uniform.prototype.clone = function () {

  	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FXAAShader = {

  	uniforms: {

  		"tDiffuse":   { value: null },
  		"resolution": { value: new Vector2( 1 / 1024, 1 / 512 ) }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [
          "precision highp float;",
          "",
          "uniform sampler2D tDiffuse;",
          "",
          "uniform vec2 resolution;",
          "",
          "varying vec2 vUv;",
          "",
          "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)",
          "",
          "//----------------------------------------------------------------------------------",
          "// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag",
          "// SDK Version: v3.00",
          "// Email:       gameworks@nvidia.com",
          "// Site:        http://developer.nvidia.com/",
          "//",
          "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.",
          "//",
          "// Redistribution and use in source and binary forms, with or without",
          "// modification, are permitted provided that the following conditions",
          "// are met:",
          "//  * Redistributions of source code must retain the above copyright",
          "//    notice, this list of conditions and the following disclaimer.",
          "//  * Redistributions in binary form must reproduce the above copyright",
          "//    notice, this list of conditions and the following disclaimer in the",
          "//    documentation and/or other materials provided with the distribution.",
          "//  * Neither the name of NVIDIA CORPORATION nor the names of its",
          "//    contributors may be used to endorse or promote products derived",
          "//    from this software without specific prior written permission.",
          "//",
          "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY",
          "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
          "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR",
          "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR",
          "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
          "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
          "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
          "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
          "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
          "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
          "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "//",
          "//----------------------------------------------------------------------------------",
          "",
          "#define FXAA_PC 1",
          "#define FXAA_GLSL_100 1",
          "#define FXAA_QUALITY_PRESET 12",
          "",
          "#define FXAA_GREEN_AS_LUMA 1",
          "",
          "",
          "#ifndef FXAA_PC_CONSOLE",
          "    //",
          "    // The console algorithm for PC is included",
          "    // for developers targeting really low spec machines.",
          "    // Likely better to just run FXAA_PC, and use a really low preset.",
          "    //",
          "    #define FXAA_PC_CONSOLE 0",
          "#endif",
          "",
          "#ifndef FXAA_GLSL_120",
          "    #define FXAA_GLSL_120 0",
          "#endif",
          "",
          "#ifndef FXAA_GLSL_130",
          "    #define FXAA_GLSL_130 0",
          "#endif",
          "",
          "#ifndef FXAA_HLSL_3",
          "    #define FXAA_HLSL_3 0",
          "#endif",
          "",
          "#ifndef FXAA_HLSL_4",
          "    #define FXAA_HLSL_4 0",
          "#endif",
          "",
          "#ifndef FXAA_HLSL_5",
          "    #define FXAA_HLSL_5 0",
          "#endif",
          "",
          "#ifndef FXAA_GREEN_AS_LUMA",
          "    //",
          "    // For those using non-linear color,",
          "    // and either not able to get luma in alpha, or not wanting to,",
          "    // this enables FXAA to run using green as a proxy for luma.",
          "    // So with this enabled, no need to pack luma in alpha.",
          "    //",
          "    // This will turn off AA on anything which lacks some amount of green.",
          "    // Pure red and blue or combination of only R and B, will get no AA.",
          "    //",
          "    // Might want to lower the settings for both,",
          "    //    fxaaConsoleEdgeThresholdMin",
          "    //    fxaaQualityEdgeThresholdMin",
          "    // In order to insure AA does not get turned off on colors",
          "    // which contain a minor amount of green.",
          "    //",
          "    // 1 = On.",
          "    // 0 = Off.",
          "    //",
          "    #define FXAA_GREEN_AS_LUMA 0",
          "#endif",
          "",
          "#ifndef FXAA_EARLY_EXIT",
          "    //",
          "    // Controls algorithm's early exit path.",
          "    // On PS3 turning this ON adds 2 cycles to the shader.",
          "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.",
          "    // Turning this off on console will result in a more blurry image.",
          "    // So this defaults to on.",
          "    //",
          "    // 1 = On.",
          "    // 0 = Off.",
          "    //",
          "    #define FXAA_EARLY_EXIT 1",
          "#endif",
          "",
          "#ifndef FXAA_DISCARD",
          "    //",
          "    // Only valid for PC OpenGL currently.",
          "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.",
          "    //",
          "    // 1 = Use discard on pixels which don't need AA.",
          "    //     For APIs which enable concurrent TEX+ROP from same surface.",
          "    // 0 = Return unchanged color on pixels which don't need AA.",
          "    //",
          "    #define FXAA_DISCARD 0",
          "#endif",
          "",
          "#ifndef FXAA_FAST_PIXEL_OFFSET",
          "    //",
          "    // Used for GLSL 120 only.",
          "    //",
          "    // 1 = GL API supports fast pixel offsets",
          "    // 0 = do not use fast pixel offsets",
          "    //",
          "    #ifdef GL_EXT_gpu_shader4",
          "        #define FXAA_FAST_PIXEL_OFFSET 1",
          "    #endif",
          "    #ifdef GL_NV_gpu_shader5",
          "        #define FXAA_FAST_PIXEL_OFFSET 1",
          "    #endif",
          "    #ifdef GL_ARB_gpu_shader5",
          "        #define FXAA_FAST_PIXEL_OFFSET 1",
          "    #endif",
          "    #ifndef FXAA_FAST_PIXEL_OFFSET",
          "        #define FXAA_FAST_PIXEL_OFFSET 0",
          "    #endif",
          "#endif",
          "",
          "#ifndef FXAA_GATHER4_ALPHA",
          "    //",
          "    // 1 = API supports gather4 on alpha channel.",
          "    // 0 = API does not support gather4 on alpha channel.",
          "    //",
          "    #if (FXAA_HLSL_5 == 1)",
          "        #define FXAA_GATHER4_ALPHA 1",
          "    #endif",
          "    #ifdef GL_ARB_gpu_shader5",
          "        #define FXAA_GATHER4_ALPHA 1",
          "    #endif",
          "    #ifdef GL_NV_gpu_shader5",
          "        #define FXAA_GATHER4_ALPHA 1",
          "    #endif",
          "    #ifndef FXAA_GATHER4_ALPHA",
          "        #define FXAA_GATHER4_ALPHA 0",
          "    #endif",
          "#endif",
          "",
          "",
          "",
          "#ifndef FXAA_QUALITY_PRESET",
          "    //",
          "    // Choose the quality preset.",
          "    // This needs to be compiled into the shader as it effects code.",
          "    // Best option to include multiple presets is to",
          "    // in each shader define the preset, then include this file.",
          "    //",
          "    // OPTIONS",
          "    // -----------------------------------------------------------------------",
          "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)",
          "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)",
          "    // 39       - no dither, very expensive",
          "    //",
          "    // NOTES",
          "    // -----------------------------------------------------------------------",
          "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)",
          "    // 13 = about same speed as FXAA 3.9 and better than 12",
          "    // 23 = closest to FXAA 3.9 visually and performance wise",
          "    //  _ = the lowest digit is directly related to performance",
          "    // _  = the highest digit is directly related to style",
          "    //",
          "    #define FXAA_QUALITY_PRESET 12",
          "#endif",
          "",
          "",
          "",
          "",
          "",
          "#if (FXAA_QUALITY_PRESET == 10)",
          "    #define FXAA_QUALITY_PS 3",
          "    #define FXAA_QUALITY_P0 1.5",
          "    #define FXAA_QUALITY_P1 3.0",
          "    #define FXAA_QUALITY_P2 12.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 11)",
          "    #define FXAA_QUALITY_PS 4",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 3.0",
          "    #define FXAA_QUALITY_P3 12.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 12)",
          "    #define FXAA_QUALITY_PS 5",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 4.0",
          "    #define FXAA_QUALITY_P4 12.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 13)",
          "    #define FXAA_QUALITY_PS 6",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 4.0",
          "    #define FXAA_QUALITY_P5 12.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 14)",
          "    #define FXAA_QUALITY_PS 7",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 4.0",
          "    #define FXAA_QUALITY_P6 12.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 15)",
          "    #define FXAA_QUALITY_PS 8",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 4.0",
          "    #define FXAA_QUALITY_P7 12.0",
          "#endif",
          "",
          "",
          "#if (FXAA_QUALITY_PRESET == 20)",
          "    #define FXAA_QUALITY_PS 3",
          "    #define FXAA_QUALITY_P0 1.5",
          "    #define FXAA_QUALITY_P1 2.0",
          "    #define FXAA_QUALITY_P2 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 21)",
          "    #define FXAA_QUALITY_PS 4",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 22)",
          "    #define FXAA_QUALITY_PS 5",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 23)",
          "    #define FXAA_QUALITY_PS 6",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 24)",
          "    #define FXAA_QUALITY_PS 7",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 3.0",
          "    #define FXAA_QUALITY_P6 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 25)",
          "    #define FXAA_QUALITY_PS 8",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 4.0",
          "    #define FXAA_QUALITY_P7 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 26)",
          "    #define FXAA_QUALITY_PS 9",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 2.0",
          "    #define FXAA_QUALITY_P7 4.0",
          "    #define FXAA_QUALITY_P8 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 27)",
          "    #define FXAA_QUALITY_PS 10",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 2.0",
          "    #define FXAA_QUALITY_P7 2.0",
          "    #define FXAA_QUALITY_P8 4.0",
          "    #define FXAA_QUALITY_P9 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 28)",
          "    #define FXAA_QUALITY_PS 11",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 2.0",
          "    #define FXAA_QUALITY_P7 2.0",
          "    #define FXAA_QUALITY_P8 2.0",
          "    #define FXAA_QUALITY_P9 4.0",
          "    #define FXAA_QUALITY_P10 8.0",
          "#endif",
          "",
          "#if (FXAA_QUALITY_PRESET == 29)",
          "    #define FXAA_QUALITY_PS 12",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.5",
          "    #define FXAA_QUALITY_P2 2.0",
          "    #define FXAA_QUALITY_P3 2.0",
          "    #define FXAA_QUALITY_P4 2.0",
          "    #define FXAA_QUALITY_P5 2.0",
          "    #define FXAA_QUALITY_P6 2.0",
          "    #define FXAA_QUALITY_P7 2.0",
          "    #define FXAA_QUALITY_P8 2.0",
          "    #define FXAA_QUALITY_P9 2.0",
          "    #define FXAA_QUALITY_P10 4.0",
          "    #define FXAA_QUALITY_P11 8.0",
          "#endif",
          "",
          "",
          "#if (FXAA_QUALITY_PRESET == 39)",
          "    #define FXAA_QUALITY_PS 12",
          "    #define FXAA_QUALITY_P0 1.0",
          "    #define FXAA_QUALITY_P1 1.0",
          "    #define FXAA_QUALITY_P2 1.0",
          "    #define FXAA_QUALITY_P3 1.0",
          "    #define FXAA_QUALITY_P4 1.0",
          "    #define FXAA_QUALITY_P5 1.5",
          "    #define FXAA_QUALITY_P6 2.0",
          "    #define FXAA_QUALITY_P7 2.0",
          "    #define FXAA_QUALITY_P8 2.0",
          "    #define FXAA_QUALITY_P9 2.0",
          "    #define FXAA_QUALITY_P10 4.0",
          "    #define FXAA_QUALITY_P11 8.0",
          "#endif",
          "",
          "",
          "",
          "",
          "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)",
          "    #define FxaaBool bool",
          "    #define FxaaDiscard discard",
          "    #define FxaaFloat float",
          "    #define FxaaFloat2 vec2",
          "    #define FxaaFloat3 vec3",
          "    #define FxaaFloat4 vec4",
          "    #define FxaaHalf float",
          "    #define FxaaHalf2 vec2",
          "    #define FxaaHalf3 vec3",
          "    #define FxaaHalf4 vec4",
          "    #define FxaaInt2 ivec2",
          "    #define FxaaSat(x) clamp(x, 0.0, 1.0)",
          "    #define FxaaTex sampler2D",
          "#else",
          "    #define FxaaBool bool",
          "    #define FxaaDiscard clip(-1)",
          "    #define FxaaFloat float",
          "    #define FxaaFloat2 float2",
          "    #define FxaaFloat3 float3",
          "    #define FxaaFloat4 float4",
          "    #define FxaaHalf half",
          "    #define FxaaHalf2 half2",
          "    #define FxaaHalf3 half3",
          "    #define FxaaHalf4 half4",
          "    #define FxaaSat(x) saturate(x)",
          "#endif",
          "",
          "#if (FXAA_GLSL_100 == 1)",
          "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)",
          "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)",
          "#endif",
          "",
          "#if (FXAA_GLSL_120 == 1)",
          "    // Requires,",
          "    //  #version 120",
          "    // And at least,",
          "    //  #extension GL_EXT_gpu_shader4 : enable",
          "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)",
          "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)",
          "    #if (FXAA_FAST_PIXEL_OFFSET == 1)",
          "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)",
          "    #else",
          "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)",
          "    #endif",
          "    #if (FXAA_GATHER4_ALPHA == 1)",
          "        // use #extension GL_ARB_gpu_shader5 : enable",
          "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
          "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
          "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
          "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
          "    #endif",
          "#endif",
          "",
          "#if (FXAA_GLSL_130 == 1)",
          "    // Requires \"#version 130\" or better",
          "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)",
          "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)",
          "    #if (FXAA_GATHER4_ALPHA == 1)",
          "        // use #extension GL_ARB_gpu_shader5 : enable",
          "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
          "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
          "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
          "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
          "    #endif",
          "#endif",
          "",
          "#if (FXAA_HLSL_3 == 1)",
          "    #define FxaaInt2 float2",
          "    #define FxaaTex sampler2D",
          "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))",
          "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))",
          "#endif",
          "",
          "#if (FXAA_HLSL_4 == 1)",
          "    #define FxaaInt2 int2",
          "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
          "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
          "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
          "#endif",
          "",
          "#if (FXAA_HLSL_5 == 1)",
          "    #define FxaaInt2 int2",
          "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
          "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
          "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
          "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)",
          "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)",
          "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)",
          "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)",
          "#endif",
          "",
          "",
          "",
          "#if (FXAA_GREEN_AS_LUMA == 0)",
          "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }",
          "#else",
          "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }",
          "#endif",
          "",
          "",
          "",
          "",
          "",
          "#if (FXAA_PC == 1)",
          "",
          "FxaaFloat4 FxaaPixelShader(",
          "    //",
          "    // Use noperspective interpolation here (turn off perspective interpolation).",
          "    // {xy} = center of pixel",
          "    FxaaFloat2 pos,",
          "    //",
          "    // Used only for FXAA Console, and not used on the 360 version.",
          "    // Use noperspective interpolation here (turn off perspective interpolation).",
          "    // {xy_} = upper left of pixel",
          "    // {_zw} = lower right of pixel",
          "    FxaaFloat4 fxaaConsolePosPos,",
          "    //",
          "    // Input color texture.",
          "    // {rgb_} = color in linear or perceptual color space",
          "    // if (FXAA_GREEN_AS_LUMA == 0)",
          "    //     {__a} = luma in perceptual color space (not linear)",
          "    FxaaTex tex,",
          "    //",
          "    // Only used on the optimized 360 version of FXAA Console.",
          "    // For everything but 360, just use the same input here as for \"tex\".",
          "    // For 360, same texture, just alias with a 2nd sampler.",
          "    // This sampler needs to have an exponent bias of -1.",
          "    FxaaTex fxaaConsole360TexExpBiasNegOne,",
          "    //",
          "    // Only used on the optimized 360 version of FXAA Console.",
          "    // For everything but 360, just use the same input here as for \"tex\".",
          "    // For 360, same texture, just alias with a 3nd sampler.",
          "    // This sampler needs to have an exponent bias of -2.",
          "    FxaaTex fxaaConsole360TexExpBiasNegTwo,",
          "    //",
          "    // Only used on FXAA Quality.",
          "    // This must be from a constant/uniform.",
          "    // {x_} = 1.0/screenWidthInPixels",
          "    // {_y} = 1.0/screenHeightInPixels",
          "    FxaaFloat2 fxaaQualityRcpFrame,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // This must be from a constant/uniform.",
          "    // This effects sub-pixel AA quality and inversely sharpness.",
          "    //   Where N ranges between,",
          "    //     N = 0.50 (default)",
          "    //     N = 0.33 (sharper)",
          "    // {x__} = -N/screenWidthInPixels",
          "    // {_y_} = -N/screenHeightInPixels",
          "    // {_z_} =  N/screenWidthInPixels",
          "    // {__w} =  N/screenHeightInPixels",
          "    FxaaFloat4 fxaaConsoleRcpFrameOpt,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // Not used on 360, but used on PS3 and PC.",
          "    // This must be from a constant/uniform.",
          "    // {x__} = -2.0/screenWidthInPixels",
          "    // {_y_} = -2.0/screenHeightInPixels",
          "    // {_z_} =  2.0/screenWidthInPixels",
          "    // {__w} =  2.0/screenHeightInPixels",
          "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.",
          "    // This must be from a constant/uniform.",
          "    // {x__} =  8.0/screenWidthInPixels",
          "    // {_y_} =  8.0/screenHeightInPixels",
          "    // {_z_} = -4.0/screenWidthInPixels",
          "    // {__w} = -4.0/screenHeightInPixels",
          "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,",
          "    //",
          "    // Only used on FXAA Quality.",
          "    // This used to be the FXAA_QUALITY_SUBPIX define.",
          "    // It is here now to allow easier tuning.",
          "    // Choose the amount of sub-pixel aliasing removal.",
          "    // This can effect sharpness.",
          "    //   1.00 - upper limit (softer)",
          "    //   0.75 - default amount of filtering",
          "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)",
          "    //   0.25 - almost off",
          "    //   0.00 - completely off",
          "    FxaaFloat fxaaQualitySubpix,",
          "    //",
          "    // Only used on FXAA Quality.",
          "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.",
          "    // It is here now to allow easier tuning.",
          "    // The minimum amount of local contrast required to apply algorithm.",
          "    //   0.333 - too little (faster)",
          "    //   0.250 - low quality",
          "    //   0.166 - default",
          "    //   0.125 - high quality",
          "    //   0.063 - overkill (slower)",
          "    FxaaFloat fxaaQualityEdgeThreshold,",
          "    //",
          "    // Only used on FXAA Quality.",
          "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.",
          "    // It is here now to allow easier tuning.",
          "    // Trims the algorithm from processing darks.",
          "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)",
          "    //   0.0625 - high quality (faster)",
          "    //   0.0312 - visible limit (slower)",
          "    // Special notes when using FXAA_GREEN_AS_LUMA,",
          "    //   Likely want to set this to zero.",
          "    //   As colors that are mostly not-green",
          "    //   will appear very dark in the green channel!",
          "    //   Tune by looking at mostly non-green content,",
          "    //   then start at zero and increase until aliasing is a problem.",
          "    FxaaFloat fxaaQualityEdgeThresholdMin,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.",
          "    // It is here now to allow easier tuning.",
          "    // This does not effect PS3, as this needs to be compiled in.",
          "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.",
          "    //   Due to the PS3 being ALU bound,",
          "    //   there are only three safe values here: 2 and 4 and 8.",
          "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
          "    // For all other platforms can be a non-power of two.",
          "    //   8.0 is sharper (default!!!)",
          "    //   4.0 is softer",
          "    //   2.0 is really soft (good only for vector graphics inputs)",
          "    FxaaFloat fxaaConsoleEdgeSharpness,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.",
          "    // It is here now to allow easier tuning.",
          "    // This does not effect PS3, as this needs to be compiled in.",
          "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.",
          "    //   Due to the PS3 being ALU bound,",
          "    //   there are only two safe values here: 1/4 and 1/8.",
          "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
          "    // The console setting has a different mapping than the quality setting.",
          "    // Other platforms can use other values.",
          "    //   0.125 leaves less aliasing, but is softer (default!!!)",
          "    //   0.25 leaves more aliasing, and is sharper",
          "    FxaaFloat fxaaConsoleEdgeThreshold,",
          "    //",
          "    // Only used on FXAA Console.",
          "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.",
          "    // It is here now to allow easier tuning.",
          "    // Trims the algorithm from processing darks.",
          "    // The console setting has a different mapping than the quality setting.",
          "    // This only applies when FXAA_EARLY_EXIT is 1.",
          "    // This does not apply to PS3,",
          "    // PS3 was simplified to avoid more shader instructions.",
          "    //   0.06 - faster but more aliasing in darks",
          "    //   0.05 - default",
          "    //   0.04 - slower and less aliasing in darks",
          "    // Special notes when using FXAA_GREEN_AS_LUMA,",
          "    //   Likely want to set this to zero.",
          "    //   As colors that are mostly not-green",
          "    //   will appear very dark in the green channel!",
          "    //   Tune by looking at mostly non-green content,",
          "    //   then start at zero and increase until aliasing is a problem.",
          "    FxaaFloat fxaaConsoleEdgeThresholdMin,",
          "    //",
          "    // Extra constants for 360 FXAA Console only.",
          "    // Use zeros or anything else for other platforms.",
          "    // These must be in physical constant registers and NOT immediates.",
          "    // Immediates will result in compiler un-optimizing.",
          "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)",
          "    FxaaFloat4 fxaaConsole360ConstDir",
          ") {",
          "",
          "    FxaaFloat2 posM;",
          "    posM.x = pos.x;",
          "    posM.y = pos.y;",
          "    #if (FXAA_GATHER4_ALPHA == 1)",
          "        #if (FXAA_DISCARD == 0)",
          "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
          "            #if (FXAA_GREEN_AS_LUMA == 0)",
          "                #define lumaM rgbyM.w",
          "            #else",
          "                #define lumaM rgbyM.y",
          "            #endif",
          "        #endif",
          "        #if (FXAA_GREEN_AS_LUMA == 0)",
          "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);",
          "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));",
          "        #else",
          "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);",
          "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));",
          "        #endif",
          "        #if (FXAA_DISCARD == 1)",
          "            #define lumaM luma4A.w",
          "        #endif",
          "        #define lumaE luma4A.z",
          "        #define lumaS luma4A.x",
          "        #define lumaSE luma4A.y",
          "        #define lumaNW luma4B.w",
          "        #define lumaN luma4B.z",
          "        #define lumaW luma4B.x",
          "    #else",
          "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
          "        #if (FXAA_GREEN_AS_LUMA == 0)",
          "            #define lumaM rgbyM.w",
          "        #else",
          "            #define lumaM rgbyM.y",
          "        #endif",
          "        #if (FXAA_GLSL_100 == 1)",
          "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));",
          "        #else",
          "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));",
          "        #endif",
          "    #endif",
          "",
          "    FxaaFloat maxSM = max(lumaS, lumaM);",
          "    FxaaFloat minSM = min(lumaS, lumaM);",
          "    FxaaFloat maxESM = max(lumaE, maxSM);",
          "    FxaaFloat minESM = min(lumaE, minSM);",
          "    FxaaFloat maxWN = max(lumaN, lumaW);",
          "    FxaaFloat minWN = min(lumaN, lumaW);",
          "    FxaaFloat rangeMax = max(maxWN, maxESM);",
          "    FxaaFloat rangeMin = min(minWN, minESM);",
          "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;",
          "    FxaaFloat range = rangeMax - rangeMin;",
          "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);",
          "    FxaaBool earlyExit = range < rangeMaxClamped;",
          "",
          "    if(earlyExit)",
          "        #if (FXAA_DISCARD == 1)",
          "            FxaaDiscard;",
          "        #else",
          "            return rgbyM;",
          "        #endif",
          "",
          "    #if (FXAA_GATHER4_ALPHA == 0)",
          "        #if (FXAA_GLSL_100 == 1)",
          "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));",
          "        #else",
          "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));",
          "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
          "        #endif",
          "    #else",
          "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));",
          "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
          "    #endif",
          "",
          "    FxaaFloat lumaNS = lumaN + lumaS;",
          "    FxaaFloat lumaWE = lumaW + lumaE;",
          "    FxaaFloat subpixRcpRange = 1.0/range;",
          "    FxaaFloat subpixNSWE = lumaNS + lumaWE;",
          "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;",
          "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;",
          "",
          "    FxaaFloat lumaNESE = lumaNE + lumaSE;",
          "    FxaaFloat lumaNWNE = lumaNW + lumaNE;",
          "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;",
          "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;",
          "",
          "    FxaaFloat lumaNWSW = lumaNW + lumaSW;",
          "    FxaaFloat lumaSWSE = lumaSW + lumaSE;",
          "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);",
          "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);",
          "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;",
          "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;",
          "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;",
          "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;",
          "",
          "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;",
          "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;",
          "    FxaaBool horzSpan = edgeHorz >= edgeVert;",
          "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;",
          "",
          "    if(!horzSpan) lumaN = lumaW;",
          "    if(!horzSpan) lumaS = lumaE;",
          "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;",
          "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;",
          "",
          "    FxaaFloat gradientN = lumaN - lumaM;",
          "    FxaaFloat gradientS = lumaS - lumaM;",
          "    FxaaFloat lumaNN = lumaN + lumaM;",
          "    FxaaFloat lumaSS = lumaS + lumaM;",
          "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);",
          "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));",
          "    if(pairN) lengthSign = -lengthSign;",
          "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);",
          "",
          "    FxaaFloat2 posB;",
          "    posB.x = posM.x;",
          "    posB.y = posM.y;",
          "    FxaaFloat2 offNP;",
          "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;",
          "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;",
          "    if(!horzSpan) posB.x += lengthSign * 0.5;",
          "    if( horzSpan) posB.y += lengthSign * 0.5;",
          "",
          "    FxaaFloat2 posN;",
          "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;",
          "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;",
          "    FxaaFloat2 posP;",
          "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;",
          "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;",
          "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;",
          "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));",
          "    FxaaFloat subpixE = subpixC * subpixC;",
          "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));",
          "",
          "    if(!pairN) lumaNN = lumaSS;",
          "    FxaaFloat gradientScaled = gradient * 1.0/4.0;",
          "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;",
          "    FxaaFloat subpixF = subpixD * subpixE;",
          "    FxaaBool lumaMLTZero = lumaMM < 0.0;",
          "",
          "    lumaEndN -= lumaNN * 0.5;",
          "    lumaEndP -= lumaNN * 0.5;",
          "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;",
          "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;",
          "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;",
          "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;",
          "    FxaaBool doneNP = (!doneN) || (!doneP);",
          "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;",
          "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;",
          "",
          "    if(doneNP) {",
          "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "        doneN = abs(lumaEndN) >= gradientScaled;",
          "        doneP = abs(lumaEndP) >= gradientScaled;",
          "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;",
          "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;",
          "        doneNP = (!doneN) || (!doneP);",
          "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;",
          "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;",
          "",
          "        #if (FXAA_QUALITY_PS > 3)",
          "        if(doneNP) {",
          "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "            doneN = abs(lumaEndN) >= gradientScaled;",
          "            doneP = abs(lumaEndP) >= gradientScaled;",
          "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;",
          "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;",
          "            doneNP = (!doneN) || (!doneP);",
          "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;",
          "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;",
          "",
          "            #if (FXAA_QUALITY_PS > 4)",
          "            if(doneNP) {",
          "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                doneN = abs(lumaEndN) >= gradientScaled;",
          "                doneP = abs(lumaEndP) >= gradientScaled;",
          "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;",
          "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;",
          "                doneNP = (!doneN) || (!doneP);",
          "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;",
          "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;",
          "",
          "                #if (FXAA_QUALITY_PS > 5)",
          "                if(doneNP) {",
          "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                    doneN = abs(lumaEndN) >= gradientScaled;",
          "                    doneP = abs(lumaEndP) >= gradientScaled;",
          "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;",
          "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;",
          "                    doneNP = (!doneN) || (!doneP);",
          "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;",
          "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;",
          "",
          "                    #if (FXAA_QUALITY_PS > 6)",
          "                    if(doneNP) {",
          "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                        doneN = abs(lumaEndN) >= gradientScaled;",
          "                        doneP = abs(lumaEndP) >= gradientScaled;",
          "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;",
          "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;",
          "                        doneNP = (!doneN) || (!doneP);",
          "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;",
          "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;",
          "",
          "                        #if (FXAA_QUALITY_PS > 7)",
          "                        if(doneNP) {",
          "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                            doneN = abs(lumaEndN) >= gradientScaled;",
          "                            doneP = abs(lumaEndP) >= gradientScaled;",
          "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;",
          "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;",
          "                            doneNP = (!doneN) || (!doneP);",
          "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;",
          "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;",
          "",
          "    #if (FXAA_QUALITY_PS > 8)",
          "    if(doneNP) {",
          "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "        doneN = abs(lumaEndN) >= gradientScaled;",
          "        doneP = abs(lumaEndP) >= gradientScaled;",
          "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;",
          "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;",
          "        doneNP = (!doneN) || (!doneP);",
          "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;",
          "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;",
          "",
          "        #if (FXAA_QUALITY_PS > 9)",
          "        if(doneNP) {",
          "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "            doneN = abs(lumaEndN) >= gradientScaled;",
          "            doneP = abs(lumaEndP) >= gradientScaled;",
          "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;",
          "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;",
          "            doneNP = (!doneN) || (!doneP);",
          "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;",
          "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;",
          "",
          "            #if (FXAA_QUALITY_PS > 10)",
          "            if(doneNP) {",
          "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                doneN = abs(lumaEndN) >= gradientScaled;",
          "                doneP = abs(lumaEndP) >= gradientScaled;",
          "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;",
          "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;",
          "                doneNP = (!doneN) || (!doneP);",
          "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;",
          "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;",
          "",
          "                #if (FXAA_QUALITY_PS > 11)",
          "                if(doneNP) {",
          "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                    doneN = abs(lumaEndN) >= gradientScaled;",
          "                    doneP = abs(lumaEndP) >= gradientScaled;",
          "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;",
          "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;",
          "                    doneNP = (!doneN) || (!doneP);",
          "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;",
          "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;",
          "",
          "                    #if (FXAA_QUALITY_PS > 12)",
          "                    if(doneNP) {",
          "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
          "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
          "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
          "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
          "                        doneN = abs(lumaEndN) >= gradientScaled;",
          "                        doneP = abs(lumaEndP) >= gradientScaled;",
          "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;",
          "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;",
          "                        doneNP = (!doneN) || (!doneP);",
          "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;",
          "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;",
          "",
          "                    }",
          "                    #endif",
          "",
          "                }",
          "                #endif",
          "",
          "            }",
          "            #endif",
          "",
          "        }",
          "        #endif",
          "",
          "    }",
          "    #endif",
          "",
          "                        }",
          "                        #endif",
          "",
          "                    }",
          "                    #endif",
          "",
          "                }",
          "                #endif",
          "",
          "            }",
          "            #endif",
          "",
          "        }",
          "        #endif",
          "",
          "    }",
          "",
          "    FxaaFloat dstN = posM.x - posN.x;",
          "    FxaaFloat dstP = posP.x - posM.x;",
          "    if(!horzSpan) dstN = posM.y - posN.y;",
          "    if(!horzSpan) dstP = posP.y - posM.y;",
          "",
          "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;",
          "    FxaaFloat spanLength = (dstP + dstN);",
          "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;",
          "    FxaaFloat spanLengthRcp = 1.0/spanLength;",
          "",
          "    FxaaBool directionN = dstN < dstP;",
          "    FxaaFloat dst = min(dstN, dstP);",
          "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;",
          "    FxaaFloat subpixG = subpixF * subpixF;",
          "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;",
          "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;",
          "",
          "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;",
          "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);",
          "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;",
          "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;",
          "    #if (FXAA_DISCARD == 1)",
          "        return FxaaTexTop(tex, posM);",
          "    #else",
          "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);",
          "    #endif",
          "}",
          "",
          "#endif",
          "",
          "void main() {",
          "  gl_FragColor = FxaaPixelShader(",
          "    vUv,",
          "    vec4(0.0),",
          "    tDiffuse,",
          "    tDiffuse,",
          "    tDiffuse,",
          "    resolution,",
          "    vec4(0.0),",
          "    vec4(0.0),",
          "    vec4(0.0),",
          "    0.75,",
          "    0.166,",
          "    0.0833,",
          "    0.0,",
          "    0.0,",
          "    0.0,",
          "    vec4(0.0)",
          "  );",
          "",
          "  // TODO avoid querying texture twice for same texel",
          "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;",
          "}"
  	].join("\n")

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var WebGLDeferredRenderer = function ( parameters ) {

  	parameters = parameters || {};

  	// private properties

  	var _this = this;

  	var _context;
  	var _state;

  	var _width, _height;

  	// for Classic Deferred Rendering
  	var _compColor;
  	var _passColor, _passForward, _passCopy;

  	// for Light Pre-Pass
  	var _compReconstruction;
  	var _passReconstruction;

  	// for Common
  	var _compNormalDepth, _compLight, _compFinal;
  	var _passNormalDepth, _passLight, _passLightFullscreen, _passFinal, _passFXAA;

  	var _depthTexture;

  	var _currentCamera;

  	var _lightScene, _lightFullscreenScene;

  	var _antialias = false;
  	var _hasTransparentObject = false;
  	var _lightPrePass = false;
  	var _cacheKeepAlive = false;

  	var _tmpMaterial = new ShaderMaterial( { visible: false } );
  	var _tmpVector3 = new Vector3();

  	// scene/material/light cache for deferred rendering.
  	// save them at the creation and release
  	// if they're unused removeThresholdCount frames
  	// unless _cacheKeepAlive is true.

  	// scene.uuid -> lightScene, lightFullscreenScene
  	var _lightScenesCache = {};
  	var _lightFullscreenScenesCache = {};

  	// object.material.uuid -> deferredMaterial or
  	// object.material[ n ].uuid -> deferredMaterial
  	var _normalDepthMaterialsCache = {};
  	var _normalDepthShininessMaterialsCache = {};
  	var _colorMaterialsCache = {};
  	var _reconstructionMaterialsCache = {};

  	// originalLight.uuid -> deferredLight
  	var _deferredLightsCache = {};

  	// deferredLight.uuid -> deferredLightMaterial
  	var _classicDeferredLightMaterialsCache = {};
  	var _lightPrePassMaterialsCache = {};

  	var _removeThresholdCount = 60;

  	// deferredMaterials.uuid -> object.material or
  	// deferredMaterials.uuid -> object.material[ n ]
  	// save before render and release after render.
  	var _originalMaterialsTable = {};

  	// object.uuid -> originalOnBeforeRender
  	// save before render and release after render.
  	var _originalOnBeforeRendersTable = {};

  	// object.material.uuid -> object.material.visible or
  	// object.material[ i ].uuid -> object.material[ i ].visible or
  	// save before render and release after render.
  	var _originalVisibleTable = {};

  	// external properties

  	this.renderer = undefined;
  	this.domElement = undefined;

  	this.forwardRendering = false; // for debug

  	// private methods

  	function init( parameters ) {

  		_this.renderer = parameters.renderer !== undefined ? parameters.renderer : new WebGLRenderer();
  		_this.domElement = _this.renderer.domElement;

  		_context = _this.renderer.context;
  		_state = _this.renderer.state;

  		_width = parameters.width !== undefined ? parameters.width : _this.renderer.getSize( new Vector2() ).width;
  		_height = parameters.height !== undefined ? parameters.height : _this.renderer.getSize( new Vector2() ).height;

  		var antialias = parameters.antialias !== undefined ? parameters.antialias : false;

  		if ( parameters.cacheKeepAlive !== undefined ) { _cacheKeepAlive = parameters.cacheKeepAlive; }

  		initDepthTexture();

  		initPassNormalDepth();
  		initPassColor();
  		initPassLight();
  		initPassReconstruction();
  		initPassFinal();

  		_this.setSize( _width, _height );
  		_this.setAntialias( antialias );
  		_this.enableLightPrePass( false );

  	}

  	function initDepthTexture() {

  		_depthTexture = new DepthTexture(
  			_width,
  			_height,
  			UnsignedInt248Type,
  			undefined,
  			undefined,
  			undefined,
  			undefined,
  			undefined,
  			undefined,
  			DepthStencilFormat
  		);

  	}

  	function initPassNormalDepth() {

  		_passNormalDepth = new RenderPass();
  		_passNormalDepth.clear = true;

  		var rt = new WebGLRenderTarget( _width, _height, {
  			minFilter: NearestFilter,
  			magFilter: NearestFilter,
  			format: RGBAFormat,
  			type: FloatType,
  			stencilBuffer: true,
  			depthTexture: _depthTexture
  		} );

  		rt.texture.generateMipamps = false;

  		_compNormalDepth = new EffectComposer( _this.renderer, rt );
  		_compNormalDepth.addPass( _passNormalDepth );

  	}

  	function initPassColor() {

  		_passColor = new RenderPass();
  		_passColor.clear = true;

  		var rt = new WebGLRenderTarget( _width, _height, {
  			minFilter: NearestFilter,
  			magFilter: NearestFilter,
  			format: RGBAFormat,
  			type: FloatType,
  			depthTexture: _depthTexture
  		} );

  		rt.texture.generateMipamps = false;

  		_compColor = new EffectComposer( _this.renderer, rt );
  		_compColor.addPass( _passColor );

  	}

  	function initPassLight() {

  		_passLightFullscreen = new RenderPass();
  		_passLightFullscreen.clear = true;
  		_passLightFullscreen.camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  		_passLight = new RenderPass();
  		_passLight.clear = false;

  		var rt = new WebGLRenderTarget( _width, _height, {
  			minFilter: NearestFilter,
  			magFilter: NearestFilter,
  			format: RGBAFormat,
  			type: FloatType,
  			depthTexture: _depthTexture
  		} );

  		rt.texture.generateMipamps = false;

  		_compLight = new EffectComposer( _this.renderer, rt );
  		_compLight.addPass( _passLightFullscreen );
  		_compLight.addPass( _passLight );

  	}

  	function initPassReconstruction() {

  		_passReconstruction = new RenderPass();
  		_passReconstruction.clear = true;

  		var rt = new WebGLRenderTarget( _width, _height, {
  			minFilter: NearestFilter,
  			magFilter: NearestFilter,
  			format: RGBAFormat,
  			type: FloatType,
  			depthTexture: _depthTexture
  		} );

  		rt.texture.generateMipamps = false;

  		_compReconstruction = new EffectComposer( _this.renderer, rt );
  		_compReconstruction.addPass( _passReconstruction );

  	}

  	function initPassFinal() {

  		_passFinal = new ShaderPass( ShaderDeferred[ 'final' ] );
  		_passFinal.clear = true;
  		_passFinal.uniforms.samplerResult.value = _compLight.renderTarget2.texture;
  		_passFinal.material.blending = NoBlending;
  		_passFinal.material.depthWrite = false;
  		_passFinal.material.depthTest = false;

  		_passForward = new RenderPass();
  		_passForward.clear = false;

  		_passCopy = new ShaderPass( CopyShader );

  		_passFXAA = new ShaderPass( FXAAShader );

  		var rt = new WebGLRenderTarget( _width, _height, {
  			minFilter: NearestFilter,
  			magFilter: LinearFilter,
  			format: RGBFormat,
  			type: UnsignedByteType,
  			depthTexture: _depthTexture
  		} );

  		rt.texture.generateMipamps = false;

  		_compFinal = new EffectComposer( _this.renderer, rt );
  		_compFinal.addPass( _passFinal );
  		_compFinal.addPass( _passForward );
  		_compFinal.addPass( _passCopy );
  		_compFinal.addPass( _passFXAA );

  	}

  	function initLightScene( scene ) {

  		var lightSceneData = _lightScenesCache[ scene.uuid ];
  		var lightFullscreenSceneData = _lightFullscreenScenesCache[ scene.uuid ];

  		if ( lightSceneData === undefined ) {

  			var s = new Scene();
  			s.userData.lights = {};

  			lightSceneData = createCacheData();
  			lightSceneData.scene = s;

  			_lightScenesCache[ scene.uuid ] = lightSceneData;

  		}

  		if ( lightFullscreenSceneData === undefined ) {

  			var s = new Scene();
  			s.userData.lights = {};

  			var emissiveLight = createDeferredEmissiveLight();

  			s.userData.emissiveLight = emissiveLight;
  			s.add( emissiveLight );

  			lightFullscreenSceneData = createCacheData();
  			lightFullscreenSceneData.scene = s;

  			_lightFullscreenScenesCache[ scene.uuid ] = lightFullscreenSceneData;

  		}

  		lightSceneData.used = true;
  		lightFullscreenSceneData.used = true;

  		var lightScene = lightSceneData.scene;
  		var lightFullscreenScene = lightFullscreenSceneData.scene;

  		// emissiveLight is only for Classic Deferred Rendering
  		lightFullscreenScene.userData.emissiveLight.visible = ! _lightPrePass;

  		_lightScene = lightScene;
  		_lightFullscreenScene = lightFullscreenScene;

  	}

  	function getMaterialFromCacheOrCreate( originalMaterial, cache, createFunc, updateFunc ) {

  		var data = cache[ originalMaterial.uuid ];

  		if ( data === undefined ) {

  			data = createCacheData();
  			data.material = createFunc( originalMaterial );
  			cache[ originalMaterial.uuid ] = data;

  		}

  		data.used = true;

  		updateFunc( data.material, originalMaterial );

  		_originalMaterialsTable[ data.material.uuid ] = originalMaterial;

  		return data.material;

  	}

  	function overrideMaterialAndOnBeforeRender( object, getMaterialFunc, onBeforeRender ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				object.material[ i ] = getMaterialFunc( object.material[ i ] );

  			}

  		} else {

  			object.material = getMaterialFunc( object.material );

  		}

  		object.onBeforeRender = onBeforeRender;

  	}

  	function restoreOriginalMaterial( object ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				object.material[ i ] = _originalMaterialsTable[ object.material[ i ].uuid ];

  			}

  		} else {

  			object.material = _originalMaterialsTable[ object.material.uuid ];

  		}

  	}

  	function setMaterialNormalDepth( object ) {

  		overrideMaterialAndOnBeforeRender( object, getNormalDepthMaterial, updateDeferredNormalDepthUniforms );

  	}

  	function getNormalDepthMaterial( originalMaterial ) {

  		return getMaterialFromCacheOrCreate(
  			originalMaterial,
  			( _lightPrePass ) ? _normalDepthShininessMaterialsCache : _normalDepthMaterialsCache,
  			createDeferredNormalDepthMaterial,
  			updateDeferredNormalDepthMaterial
  		);

  	}

  	function createDeferredNormalDepthMaterial( originalMaterial ) {

  		var shader = ( _lightPrePass ) ? ShaderDeferred[ 'normalDepthShininess' ] : ShaderDeferred[ 'normalDepth' ];

  		return new ShaderMaterial( {
  			uniforms: Object.assign( {}, shader.uniforms ),
  			fragmentShader: shader.fragmentShader,
  			vertexShader: shader.vertexShader,
  			blending: NoBlending
  		} );

  	}

  	function updateDeferredNormalDepthMaterial( material, originalMaterial ) {

  		if ( originalMaterial.skinning !== undefined ) { material.skinning = originalMaterial.skinning; }
  		if ( originalMaterial.morphTargets !== undefined ) { material.morphTargets = originalMaterial.morphTargets; }

  		if ( originalMaterial.visible === true ) {

  			material.visible = ! originalMaterial.transparent;

  		} else {

  			material.visible = false;

  		}

  	}

  	function updateDeferredNormalDepthUniforms( renderer, scene, camera, geometry, material, group ) {

  		if ( ! _lightPrePass ) { return; }

  		var originalMaterial = _originalMaterialsTable[ material.uuid ];

  		if ( originalMaterial === undefined || originalMaterial.shininess === undefined ) { return; }

  		material.uniforms.shininess.value = originalMaterial.shininess;

  	}

  	function setMaterialColor( object ) {

  		overrideMaterialAndOnBeforeRender( object, getColorMaterial, updateDeferredColorUniforms );

  	}

  	function getColorMaterial( originalMaterial ) {

  		return getMaterialFromCacheOrCreate(
  			originalMaterial,
  			_colorMaterialsCache,
  			createDeferredColorMaterial,
  			updateDeferredColorMaterial
  		);

  	}

  	function createDeferredColorMaterial( originalMaterial ) {

  		var shader = ShaderDeferred[ 'color' ];

  		var material = new ShaderMaterial( {
  			uniforms: Object.assign( {}, shader.uniforms ),
  			fragmentShader: shader.fragmentShader,
  			vertexShader: shader.vertexShader,
  			blending: NoBlending
  		} );

  		if ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }

  		return material;

  	}

  	function updateDeferredColorMaterial( material, originalMaterial ) {

  		if ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }
  		if ( originalMaterial.skinning !== undefined ) { material.skinning = originalMaterial.skinning; }
  		if ( originalMaterial.morphTargets !== undefined ) { material.morphTargets = originalMaterial.morphTargets; }

  		if ( originalMaterial.visible === true ) {

  			material.visible = ! originalMaterial.transparent;

  		} else {

  			material.visible = false;

  		}

  	}

  	function updateDeferredColorUniforms( renderer, scene, camera, geometry, material, group ) {

  		var originalMaterial = _originalMaterialsTable[ material.uuid ];
  		var uniforms = material.uniforms;

  		var diffuse, emissive;

  		if ( originalMaterial.isMeshBasicMaterial === true ) {

  			emissive = originalMaterial.color;

  		} else {

  			diffuse = originalMaterial.color;
  			emissive = originalMaterial.emissive;

  		}

  		var specular = originalMaterial.specular;
  		var shininess = originalMaterial.shininess;
  		var map = originalMaterial.map;

  		if ( diffuse !== undefined ) { uniforms.diffuse.value.copy( diffuse ); }
  		if ( emissive !== undefined ) { uniforms.emissive.value.copy( emissive ); }
  		if ( specular !== undefined ) { uniforms.specular.value.copy( specular ); }
  		if ( shininess !== undefined && uniforms.shininess !== undefined ) { uniforms.shininess.value = shininess; }
  		if ( map !== undefined ) { uniforms.map.value = map; }

  	}

  	function setMaterialReconstruction( object ) {

  		overrideMaterialAndOnBeforeRender( object, getReconstructionMaterial, updateDeferredReconstructionUniforms );

  	}

  	function getReconstructionMaterial( originalMaterial ) {

  		if ( originalMaterial.transparent === true ) {

  			_originalMaterialsTable[ originalMaterial.uuid ] = originalMaterial;
  			return originalMaterial;

  		}

  		return getMaterialFromCacheOrCreate(
  			originalMaterial,
  			_reconstructionMaterialsCache,
  			createDeferredReconstructionMaterial,
  			updateDeferredReconstructionMaterial
  		);

  	}

  	function createDeferredReconstructionMaterial( originalMaterial ) {

  		var shader = ShaderDeferred[ 'reconstruction' ];

  		var material = new ShaderMaterial( {
  			uniforms: Object.assign( {}, shader.uniforms ),
  			fragmentShader: shader.fragmentShader,
  			vertexShader: shader.vertexShader,
  			blending: NoBlending
  		} );

  		if ( originalMaterial.map !== undefined ) { material.map = originalMaterial.map; }

  		return material;

  	}

  	function updateDeferredReconstructionMaterial( material, originalMaterial ) {

  		updateDeferredColorMaterial( material, originalMaterial );

  	}

  	function updateDeferredReconstructionUniforms( renderer, scene, camera, geometry, material, group ) {

  		if ( material.transparent === true ) {

  			// 'this' is object here because this method is set as object.onBefore()
  			var onBeforeRender = _originalOnBeforeRendersTable[ this.uuid ];

  			if ( onBeforeRender ) {

  				onBeforeRender.call( this, renderer, scene, camera, geometry, material, group );

  			}

  			return;

  		}

  		updateDeferredColorUniforms( renderer, scene, camera, geometry, material, group );

  		material.uniforms.samplerLight.value = _compLight.renderTarget2.texture;

  	}

  	function setVisibleForForwardRendering( object ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				if ( _originalVisibleTable[ object.material[ i ].uuid ] === undefined ) {

  					_originalVisibleTable[ object.material[ i ].uuid ] = object.material[ i ].visible;
  					object.material[ i ].visible = object.material[ i ].transparent && object.material[ i ].visible;

  				}

  			}

  		} else {

  			if ( _originalVisibleTable[ object.material.uuid ] === undefined ) {

  				_originalVisibleTable[ object.material.uuid ] = object.material.visible;
  				object.material.visible = object.material.transparent && object.material.visible;

  			}

  		}

  	}

  	function restoreVisible( object ) {

  		if ( object.material === undefined ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				object.material[ i ].visible = _originalVisibleTable[ object.material[ i ].uuid ];

  			}

  		} else {

  			object.material.visible = _originalVisibleTable[ object.material.uuid ];

  		}

  	}

  	function createDeferredEmissiveLight() {

  		var shader = ShaderDeferred[ 'emissiveLight' ];

  		var material = new ShaderMaterial( {
  			uniforms: Object.assign( {}, shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			blending: NoBlending,
  			depthWrite: false
  		} );

  		var geometry = new PlaneBufferGeometry( 2, 2 );
  		var mesh = new Mesh( geometry, material );

  		mesh.onBeforeRender = function ( renderer, scene, camera, geometry, material, group ) {

  			material.uniforms.samplerColor.value = _compColor.renderTarget2.texture;

  		};

  		return mesh;

  	}

  	function createDeferredLight( originalLight ) {

  		if ( originalLight.isPointLight ) {

  			return createDeferredPointLight( originalLight );

  		} else if ( originalLight.isSpotLight ) {

  			return createDeferredSpotLight( originalLight );

  		} else if ( originalLight.isDirectionalLight ) {

  			return createDeferredDirectionalLight( originalLight );

  		}

  		return null;

  	}

  	function createDeferredLightMaterial( originalLight ) {

  		if ( originalLight.isPointLight ) {

  			return createDeferredPointLightMaterial();

  		} else if ( originalLight.isSpotLight ) {

  			return createDeferredSpotLightMaterial();

  		} else if ( originalLight.isDirectionalLight ) {

  			return createDeferredDirectionalLightMaterial();

  		}

  		return null;

  	}

  	function getDeferredLightMaterial( light ) {

  		var cache = ( _lightPrePass ) ? _lightPrePassMaterialsCache : _classicDeferredLightMaterialsCache;

  		var data = cache[ light.uuid ];

  		if ( data === undefined ) {

  			data = createCacheData();
  			data.material = createDeferredLightMaterial( light.userData.originalLight );
  			cache[ light.uuid ] = data;

  		}

  		data.used = true;

  		return data.material;

  	}

  	function updateDeferredLight( light ) {

  		var originalLight = light.userData.originalLight;

  		if ( originalLight.isPointLight ) {

  			updateDeferredPointLight( light );

  		}

  	}

  	function createDeferredLightMesh( light, geometry ) {

  		var mesh = new Mesh( geometry, _tmpMaterial );

  		mesh.userData.originalLight = light;

  		return mesh;

  	}

  	function createDeferredLightShaderMaterial( shader ) {

  		var material = new ShaderMaterial( {
  			uniforms: Object.assign( {}, shader.uniforms ),
  			vertexShader: shader.vertexShader,
  			fragmentShader: shader.fragmentShader,
  			transparent: true,
  			blending: AdditiveBlending,
  			depthWrite: false
  		} );

  		if ( _lightPrePass ) { material.premultipliedAlpha = true; }

  		return material;

  	}

  	function updateDeferredLightCommonUniforms( uniforms ) {

  		if ( _lightPrePass ) {

  			uniforms.samplerNormalDepthShininess.value = _compNormalDepth.renderTarget2.texture;

  		} else {

  			uniforms.samplerNormalDepth.value = _compNormalDepth.renderTarget2.texture;
  			uniforms.samplerColor.value = _compColor.renderTarget2.texture;

  		}

  	}

  	function createDeferredPointLight( light ) {

  		var mesh = createDeferredLightMesh( light, new SphereBufferGeometry( 1, 16, 8 ) );
  		mesh.onBeforeRender = updateDeferredPointLightUniforms;
  		return mesh;

  	}
  	function createDeferredPointLightMaterial() {

  		var shader = ( _lightPrePass ) ? ShaderDeferred[ 'pointLightPre' ] : ShaderDeferred[ 'pointLight' ];

  		var material = createDeferredLightShaderMaterial( shader );

  		material.side = BackSide;
  		material.depthFunc = GreaterEqualDepth;

  		return material;

  	}

  	function updateDeferredPointLight( light ) {

  		var originalLight = light.userData.originalLight;
  		var distance = originalLight.distance;

  		if ( distance > 0 ) {

  			light.scale.set( 1, 1, 1 ).multiplyScalar( distance );
  			light.position.setFromMatrixPosition( originalLight.matrixWorld );

  		}

  	}

  	function updateDeferredPointLightUniforms( renderer, scene, camera, geometry, material, group ) {

  		var light = this;

  		var originalLight = light.userData.originalLight;
  		var distance = originalLight.distance;
  		var uniforms = material.uniforms;

  		uniforms.lightColor.value.copy( originalLight.color );

  		if ( distance > 0 ) {

  			uniforms.lightRadius.value = distance;
  			uniforms.lightIntensity.value = originalLight.intensity;
  			uniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );

  		} else {

  			uniforms.lightRadius.value = Infinity;

  		}

  		updateDeferredLightCommonUniforms( uniforms );

  	}

  	function createDeferredSpotLight( light ) {

  		var mesh = createDeferredLightMesh( light, new PlaneBufferGeometry( 2, 2 ) );
  		mesh.onBeforeRender = updateDeferredSpotLightUniforms;
  		return mesh;

  	}

  	function createDeferredSpotLightMaterial() {

  		var shader = ( _lightPrePass ) ? ShaderDeferred[ 'spotLightPre' ] : ShaderDeferred[ 'spotLight' ];

  		var material = createDeferredLightShaderMaterial( shader );

  		material.depthTest = false;

  		return material;

  	}

  	function updateDeferredSpotLightUniforms( renderer, scene, camera, geometry, material, group ) {

  		var light = this;

  		var originalLight = light.userData.originalLight;
  		var uniforms = light.material.uniforms;

  		uniforms.lightAngle.value = originalLight.angle;
  		uniforms.lightColor.value.copy( originalLight.color );
  		uniforms.lightIntensity.value = originalLight.intensity;
  		uniforms.lightPositionVS.value.setFromMatrixPosition( originalLight.matrixWorld ).applyMatrix4( _currentCamera.matrixWorldInverse );

  		var vec = uniforms.lightDirectionVS.value;
  		var vec2 = _tmpVector3;

  		vec.setFromMatrixPosition( originalLight.matrixWorld );
  		vec2.setFromMatrixPosition( originalLight.target.matrixWorld );
  		vec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );

  		updateDeferredLightCommonUniforms( uniforms );

  	}

  	function createDeferredDirectionalLight( light ) {

  		var mesh = createDeferredLightMesh( light, new PlaneBufferGeometry( 2, 2 ) );
  		mesh.onBeforeRender = updateDeferredDirectionalLightUniforms;
  		return mesh;

  	}

  	function createDeferredDirectionalLightMaterial() {

  		var shader = ( _lightPrePass ) ? ShaderDeferred[ 'directionalLightPre' ] : ShaderDeferred[ 'directionalLight' ];

  		var material = createDeferredLightShaderMaterial( shader );

  		material.depthTest = false;

  		return material;

  	}

  	function updateDeferredDirectionalLightUniforms( renderer, scene, camera, geometry, material, group ) {

  		var light = this;

  		var originalLight = light.userData.originalLight;
  		var uniforms = light.material.uniforms;

  		uniforms.lightColor.value.copy( originalLight.color );
  		uniforms.lightIntensity.value = originalLight.intensity;

  		var vec = uniforms.lightDirectionVS.value;
  		var vec2 = _tmpVector3;

  		vec.setFromMatrixPosition( originalLight.matrixWorld );
  		vec2.setFromMatrixPosition( originalLight.target.matrixWorld );
  		vec.sub( vec2 ).normalize().transformDirection( _currentCamera.matrixWorldInverse );

  		updateDeferredLightCommonUniforms( uniforms );

  	}

  	function saveOriginalOnBeforeRenderAndCheckTransparency( object ) {

  		if ( object.material === undefined ) { return; }

  		_originalOnBeforeRendersTable[ object.uuid ] = object.onBeforeRender;

  		// _hasTransparentObject is used only for Classic Deferred Rendering
  		if ( _hasTransparentObject || _lightPrePass ) { return; }

  		if ( ! object.visible ) { return; }

  		if ( Array.isArray( object.material ) ) {

  			for ( var i = 0, il = object.material.length; i < il; i ++ ) {

  				if ( object.material[ i ].visible === true && object.material[ i ].transparent === true ) {

  					_hasTransparentObject = true;
  					break;

  				}

  			}

  		} else {

  			if ( object.material.visible === true && object.material.transparent === true ) { _hasTransparentObject = true; }

  		}

  	}

  	function restoreOriginalOnBeforeRender( object ) {

  		if ( object.material === undefined ) { return; }

  		object.onBeforeRender = _originalOnBeforeRendersTable[ object.uuid ];

  	}

  	function addDeferredLightsToLightScene( object ) {

  		if ( object.isLight !== true ) { return; }

  		var data = _deferredLightsCache[ object.uuid ];

  		if ( data === undefined ) {

  			data = createCacheData();
  			data.light = createDeferredLight( object );
  			_deferredLightsCache[ object.uuid ] = data;

  		}

  		data.used = true;

  		var light = data.light;

  		if ( light === null ) { return; }

  		var scene = ( object.isPointLight === true ) ? _lightScene : _lightFullscreenScene;

  		var lights = scene.userData.lights;

  		if ( lights[ light.uuid ] === undefined ) {

  			scene.add( light );

  			lights[ light.uuid ] = {
  				light: light,
  				found: true
  			};

  		}

  		lights[ light.uuid ].found = true;

  	}

  	function updateDeferredLightsInLightScene( scene ) {

  		var lights = scene.userData.lights;
  		var keys = Object.keys( lights );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			var key = keys[ i ];

  			if ( lights[ key ].found === false ) {

  				scene.remove( lights[ key ].light );
  				delete lights[ key ];

  			} else {

  				var light = lights[ key ].light;
  				light.material = getDeferredLightMaterial( light );

  				updateDeferredLight( light );
  				lights[ key ].found = false;

  			}

  		}

  	}

  	function updateDeferredCommonUniforms( camera ) {

  		var uniforms = ShaderDeferredCommon[ 'commonUniforms' ];

  		uniforms.viewWidth.value = _width;
  		uniforms.viewHeight.value = _height;

  		uniforms.matProjInverse.value.getInverse( camera.projectionMatrix );

  	}

  	function enableFinalPasses() {

  		if ( _lightPrePass ) {

  			_passForward.renderToScreen = false;
  			_passForward.enabled = false;

  			_passCopy.renderToScreen = false;
  			_passCopy.enabled = false;

  			if ( _antialias ) {

  				_passFinal.renderToScreen = false;

  				_passFXAA.renderToScreen = true;
  				_passFXAA.enabled = true;

  			} else {

  				_passFinal.renderToScreen = true;

  				_passFXAA.renderToScreen = false;
  				_passFXAA.enabled = false;

  			}

  		} else {

  			if ( _hasTransparentObject ) {

  				if ( _antialias ) {

  					_passFinal.renderToScreen = false;

  					_passForward.renderToScreen = false;
  					_passForward.enabled = true;

  					_passCopy.renderToScreen = false;
  					_passCopy.enabled = false;

  					_passFXAA.renderToScreen = true;
  					_passFXAA.enabled = true;

  				} else {

  					_passFinal.renderToScreen = false;

  					_passForward.renderToScreen = false;
  					_passForward.enabled = true;

  					_passCopy.renderToScreen = true;
  					_passCopy.enabled = true;

  					_passFXAA.renderToScreen = false;
  					_passFXAA.enabled = false;

  				}

  			} else {

  				if ( _antialias ) {

  					_passFinal.renderToScreen = false;

  					_passForward.renderToScreen = false;
  					_passForward.enabled = false;

  					_passCopy.renderToScreen = false;
  					_passCopy.enabled = false;

  					_passFXAA.renderToScreen = true;
  					_passFXAA.enabled = true;

  				} else {

  					_passFinal.renderToScreen = true;

  					_passForward.renderToScreen = false;
  					_passForward.enabled = false;

  					_passCopy.renderToScreen = false;
  					_passCopy.enabled = false;

  					_passFXAA.renderToScreen = false;
  					_passFXAA.enabled = false;

  				}

  			}

  		}

  	}

  	function createCacheData() {

  		return {
  			used: true,
  			keepAlive: _cacheKeepAlive,
  			count: 0
  		};

  	}

  	function cleanupCache( cache ) {

  		var keys = Object.keys( cache );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			var key = keys[ i ];

  			if ( cache[ key ].used === false ) {

  				cache[ key ].count ++;

  				if ( cache[ key ].keepAlive === false && cache[ key ].count > _removeThresholdCount ) {

  					delete cache[ key ];

  				}

  			} else {

  				cache[ key ].used = false;
  				cache[ key ].count = 0;

  			}

  		}

  	}

  	function cleanupTable( table ) {

  		var keys = Object.keys( table );

  		for ( var i = 0, il = keys.length; i < il; i ++ ) {

  			var key = keys[ i ];

  			table[ key ] = undefined;

  		}

  	}

  	function cleanupCaches() {

  		cleanupCache( _lightScenesCache );
  		cleanupCache( _lightFullscreenScenesCache );
  		cleanupCache( _normalDepthMaterialsCache );
  		cleanupCache( _normalDepthShininessMaterialsCache );
  		cleanupCache( _colorMaterialsCache );
  		cleanupCache( _reconstructionMaterialsCache );
  		cleanupCache( _classicDeferredLightMaterialsCache );
  		cleanupCache( _lightPrePassMaterialsCache );
  		cleanupCache( _deferredLightsCache );

  		cleanupTable( _originalMaterialsTable );
  		cleanupTable( _originalOnBeforeRendersTable );
  		cleanupTable( _originalVisibleTable );

  	}
  	function renderNormalDepth( scene, camera ) {

  		scene.traverse( setMaterialNormalDepth );

  		_passNormalDepth.scene = scene;
  		_passNormalDepth.camera = camera;

  		_this.renderer.autoClearDepth = true;
  		_this.renderer.autoClearStencil = true;

  		_state.buffers.stencil.setTest( true );
  		_state.buffers.stencil.setFunc( _context.ALWAYS, 1, 0xffffffff );
  		_state.buffers.stencil.setOp( _context.REPLACE, _context.REPLACE, _context.REPLACE );

  		_compNormalDepth.render();

  		scene.traverse( restoreOriginalMaterial );

  	}
  	function renderColor( scene, camera ) {

  		scene.traverse( setMaterialColor );

  		_passColor.scene = scene;
  		_passColor.camera = camera;

  		_this.renderer.autoClearDepth = false;
  		_this.renderer.autoClearStencil = false;

  		_state.buffers.stencil.setFunc( _context.EQUAL, 1, 0xffffffff );
  		_state.buffers.stencil.setOp( _context.KEEP, _context.KEEP, _context.KEEP );

  		_compColor.render();

  		scene.traverse( restoreOriginalMaterial );

  	}
  	function renderLight( scene, camera ) {

  		scene.traverse( addDeferredLightsToLightScene );

  		updateDeferredLightsInLightScene( _lightScene );
  		updateDeferredLightsInLightScene( _lightFullscreenScene );

  		_passLight.scene = _lightScene;
  		_passLight.camera = camera;

  		_passLightFullscreen.scene = _lightFullscreenScene;

  		_this.renderer.autoClearDepth = false;
  		_this.renderer.autoClearStencil = false;

  		_compLight.render();

  		_state.buffers.stencil.setTest( false );

  	}
  	function renderLightPre( scene, camera ) {

  		scene.traverse( addDeferredLightsToLightScene );

  		updateDeferredLightsInLightScene( _lightScene );
  		updateDeferredLightsInLightScene( _lightFullscreenScene );

  		_passLight.scene = _lightScene;
  		_passLight.camera = camera;

  		_passLightFullscreen.scene = _lightFullscreenScene;

  		_this.renderer.autoClearDepth = false;
  		_this.renderer.autoClearStencil = false;

  		_state.buffers.stencil.setFunc( _context.EQUAL, 1, 0xffffffff );
  		_state.buffers.stencil.setOp( _context.KEEP, _context.KEEP, _context.KEEP );

  		_compLight.render();

  	}
  	function renderReconstruction( scene, camera ) {

  		scene.traverse( setMaterialReconstruction );

  		_passReconstruction.scene = scene;
  		_passReconstruction.camera = camera;

  		_this.renderer.autoClearDepth = false;
  		_this.renderer.autoClearStencil = false;

  		_compReconstruction.render();

  		_state.buffers.stencil.setTest( false );

  		scene.traverse( restoreOriginalMaterial );

  	}
  	function renderFinal( scene, camera ) {

  		if ( ! _lightPrePass && _hasTransparentObject ) {

  			scene.traverse( setVisibleForForwardRendering );
  			scene.traverse( restoreOriginalOnBeforeRender );

  			_passForward.scene = scene;
  			_passForward.camera = camera;

  		}

  		enableFinalPasses();

  		_this.renderer.autoClearDepth = false;
  		_this.renderer.autoClearStencil = false;

  		_compFinal.render();

  		if ( ! _lightPrePass && _hasTransparentObject ) {

  			scene.traverse( restoreVisible );

  		}

  	}

  	// external APIs

  	this.setSize = function ( width, height ) {

  		_width = width;
  		_height = height;

  		this.renderer.setSize( _width, _height );

  		_compNormalDepth.setSize( _width, _height );
  		_compColor.setSize( _width, _height );
  		_compLight.setSize( _width, _height );
  		_compReconstruction.setSize( _width, _height );
  		_compFinal.setSize( _width, _height );

  		_depthTexture.image.width = _width;
  		_depthTexture.image.height = _height;
  		_depthTexture.needsUpdate = true;

  		_passFXAA.uniforms.resolution.value.set( 1 / _width, 1 / _height );

  	};

  	this.setAntialias = function ( enabled ) {

  		_antialias = enabled;

  	};

  	this.enableLightPrePass = function ( enabled ) {

  		_lightPrePass = enabled;

  		_passFinal.uniforms.samplerResult.value = ( _lightPrePass ) ? _compReconstruction.renderTarget2.texture : _compLight.renderTarget2.texture;

  	};

  	this.render = function ( scene, camera ) {

  		// for debug to compare with normal forward rendering

  		if ( this.forwardRendering ) {

  			this.renderer.render( scene, camera );
  			return;

  		}

  		var currentSceneAutoUpdate = scene.autoUpdate;
  		var currentAutoClearColor = this.renderer.autoClearColor;
  		var currentAutoClearDepth = this.renderer.autoClearDepth;
  		var currentAutoClearStencil = this.renderer.autoClearStencil;

  		_currentCamera = camera;

  		initLightScene( scene );

  		scene.autoUpdate = false;
  		scene.updateMatrixWorld();

  		_hasTransparentObject = false;

  		scene.traverse( saveOriginalOnBeforeRenderAndCheckTransparency );

  		updateDeferredCommonUniforms( camera );

  		renderNormalDepth( scene, camera );

  		if ( _lightPrePass ) {

  			renderLightPre( scene, camera );
  			renderReconstruction( scene, camera );

  		} else {

  			renderColor( scene, camera );
  			renderLight( scene, camera );

  		}

  		renderFinal( scene, camera );

  		scene.traverse( restoreOriginalOnBeforeRender );

  		cleanupCaches();

  		scene.autoUpdate = currentSceneAutoUpdate;
  		this.renderer.autoClearColor = currentAutoClearColor;
  		this.renderer.autoClearDepth = currentAutoClearDepth;
  		this.renderer.autoClearStencil = currentAutoClearStencil;

  	};

  	// initialize

  	init( parameters );

  };

  var DeferredShaderChunk = {

  	packVector3: [

  		"float vec3_to_float( vec3 data ) {",

  		"	const float unit = 255.0/256.0;",
  		"	highp float compressed = fract( data.x * unit ) + floor( data.y * unit * 255.0 ) + floor( data.z * unit * 255.0 ) * 255.0;",
  		"	return compressed;",

  		"}"

  	].join( "\n" ),

  	unpackFloat: [

  		"vec3 float_to_vec3( float data ) {",

  		"	const float unit = 255.0;",
  		"	vec3 uncompressed;",
  		"	uncompressed.x = fract( data );",
  		"	float zInt = floor( data / unit );",
  		"	uncompressed.z = fract( zInt / unit );",
  		"	uncompressed.y = fract( floor( data - ( zInt * unit ) ) / unit );",
  		"	return uncompressed;",

  		"}"

  	].join( "\n" ),

  	// Refer to http://aras-p.info/texts/CompactNormalStorage.html
  	packNormal: [

  		"vec2 normal_to_vec2( vec3 normal ) {",

  		"	return normal.xy / sqrt( normal.z * 8.0 + 8.0 ) + 0.5;",

  		"}"

  	].join( "\n" ),

  	unpackVector2: [

  		"vec3 vec2_to_normal( vec2 data ) {",

  		"	vec2 fenc = data * 4.0 - 2.0;",
  		"	float f = dot( fenc, fenc );",
  		"	float g = sqrt( 1.0 - f / 4.0 );",
  		"	vec3 normal;",
  		"	normal.xy = fenc * g;",
  		"	normal.z = 1.0 - f / 2.0;",
  		"	return normal;",

  		"}"

  	].join( "\n" ),

  	computeTextureCoord: [

  		"vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );"

  	].join( "\n" ),

  	packNormalDepth: [

  		"vec4 packedNormalDepth;",
  		"packedNormalDepth.xyz = normal * 0.5 + 0.5;",
  		"packedNormalDepth.w = position.z / position.w;"

  	].join( "\n" ),

  	unpackNormalDepth: [

  		"vec4 normalDepthMap = texture2D( samplerNormalDepth, texCoord );",
  		"float depth = normalDepthMap.w;",

  		"if ( depth == 0.0 ) discard;",

  		"vec3 normal = normalDepthMap.xyz * 2.0 - 1.0;"

  	].join( "\n" ),

  	packNormalDepthShininess: [

  		"vec4 packedNormalDepthShininess;",
  		"packedNormalDepthShininess.xy = normal_to_vec2( normal );",
  		"packedNormalDepthShininess.z = shininess;",
  		"packedNormalDepthShininess.w = position.z / position.w;"

  	].join( "\n" ),

  	unpackNormalDepthShininess: [

  		"vec4 normalDepthMap = texture2D( samplerNormalDepthShininess, texCoord );",
  		"float depth = normalDepthMap.w;",

  		"if ( depth == 0.0 ) discard;",

  		"vec3 normal = vec2_to_normal( normalDepthMap.xy );",
  		"float shininess = normalDepthMap.z;"

  	].join( "\n" ),

  	packColor: [

  		"vec4 packedColor;",
  		"packedColor.x = vec3_to_float( diffuseColor.rgb );",
  		"packedColor.y = vec3_to_float( emissiveColor );",
  		"packedColor.z = vec3_to_float( specularColor );",
  		"packedColor.w = shininess;"

  	].join( "\n" ),

  	unpackColor: [

  		"vec4 colorMap = texture2D( samplerColor, texCoord );",
  		"vec3 diffuseColor = float_to_vec3( colorMap.x );",
  		"vec3 emissiveColor = float_to_vec3( colorMap.y );",
  		"vec3 specularColor = float_to_vec3( colorMap.z );",
  		"float shininess = colorMap.w;"

  	].join( "\n" ),

  	packLight: [

  		"vec4 packedLight;",
  		"packedLight.xyz = lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * attenuation;",
  		"packedLight.w = lightIntensity * specular * max( dot( lightVector, normal ), 0.0 ) * attenuation;"

  	].join( "\n" ),

  	computeVertexPositionVS: [

  		"vec2 xy = texCoord * 2.0 - 1.0;",
  		"vec4 vertexPositionProjected = vec4( xy, depth, 1.0 );",
  		"vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;",
  		"vertexPositionVS.xyz /= vertexPositionVS.w;",
  		"vertexPositionVS.w = 1.0;"

  	].join( "\n" ),

  	// TODO: calculate schlick
  	computeSpecular: [

  		"vec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );",
  		"float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );",
  		"float specular = 0.31830988618 * ( shininess * 0.5 + 1.0 ) * pow( dotNormalHalf, shininess );"

  	].join( "\n" ),

  	combine: [

  		"gl_FragColor = vec4( lightIntensity * lightColor * max( dot( lightVector, normal ), 0.0 ) * ( diffuseColor + specular * specularColor ) * attenuation, 1.0 );"

  	].join( "\n" )

  };

  var ShaderDeferredCommon = {

  	commonUniforms: {

  		matProjInverse: new Uniform( new Matrix4() ),

  		viewWidth: new Uniform( 800 ),
  		viewHeight: new Uniform( 600 )

  	}

  };

  var ShaderDeferred = {

  	normalDepth: {

  		uniforms: {},

  		vertexShader: [

  			"varying vec3 vNormal;",
  			"varying vec4 vPosition;",

  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",

  			"void main() {",

  			"#include <begin_vertex>",
  			"#include <beginnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",
  			"#include <morphtarget_vertex>",
  			"#include <skinning_vertex>",
  			"#include <project_vertex>",

  			"	vNormal = normalize( transformedNormal );",
  			"	vPosition = gl_Position;",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec3 vNormal;",
  			"varying vec4 vPosition;",

  			"void main() {",

  			"	vec3 normal = vNormal;",
  			"	vec4 position = vPosition;",

  			DeferredShaderChunk[ "packNormalDepth" ],

  			"	gl_FragColor = packedNormalDepth;",

  			"}"

  		].join( "\n" )

  	},

  	color: {

  		uniforms: {

  			map: new Uniform( null ),
  			offsetRepeat: new Uniform( new Vector4( 0, 0, 1, 1 ) ),

  			diffuse: new Uniform( new Color( 0x000000 ) ),
  			emissive: new Uniform( new Color( 0x000000 ) ),
  			specular: new Uniform( new Color( 0x000000 ) ),
  			shininess: new Uniform( 30.0 )

  		},

  		vertexShader: [

  			"#include <uv_pars_vertex>",
  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",

  			"void main() {",

  			"#include <uv_vertex>",
  			"#include <begin_vertex>",
  			"#include <beginnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",
  			"#include <morphtarget_vertex>",
  			"#include <skinning_vertex>",
  			"#include <project_vertex>",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform vec3 diffuse;",
  			"uniform vec3 emissive;",
  			"uniform vec3 specular;",
  			"uniform float shininess;",

  			"#include <uv_pars_fragment>",
  			"#include <map_pars_fragment>",
  			DeferredShaderChunk[ "packVector3" ],

  			"void main() {",

  			"	vec4 diffuseColor = vec4( diffuse, 1.0 );",
  			"	vec3 emissiveColor = emissive;",
  			"	vec3 specularColor = specular;",

  			"#include <map_fragment>",
  			DeferredShaderChunk[ "packColor" ],

  			"	gl_FragColor = packedColor;",

  			"}"

  		].join( "\n" )

  	},

  	emissiveLight: {

  		uniforms: Object.assign(

  			{

  				samplerColor: new Uniform( null )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() { ",

  			"	gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );",

  			"}"

  		].join( '\n' ),

  		fragmentShader: [

  			"uniform sampler2D samplerColor;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			DeferredShaderChunk[ "unpackFloat" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackColor" ],

  			"	gl_FragColor = vec4( emissiveColor, 1.0 );",

  			"}"

  		].join( '\n' )

  	},

  	pointLight: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepth: new Uniform( null ),
  				samplerColor: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightIntensity: new Uniform( 1.0 ),
  				lightRadius: new Uniform( 1.0 )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() {",

  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepth;",
  			"uniform sampler2D samplerColor;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightPositionVS;",
  			"uniform float lightIntensity;",
  			"uniform float lightRadius;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepth" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],

  			"	vec3 lightVector = lightPositionVS - vertexPositionVS.xyz;",
  			"	float distance = length( lightVector );",

  			"	if ( distance > lightRadius ) discard;",

  			"	lightVector = normalize( lightVector );",

  			DeferredShaderChunk[ "unpackColor" ],
  			DeferredShaderChunk[ "computeSpecular" ],

  			"	//float cutoff = 0.3;",
  			"	//float denom = distance / lightRadius + 1.0;",
  			"	//float attenuation = 1.0 / ( denom * denom );",
  			"	//attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );",
  			"	//attenuation = max( attenuation, 0.0 );",
  			"	//attenuation *= attenuation;",

  			"	//diffuseColor *= saturate( -distance / lightRadius + 1.0 );",
  			"	//float attenuation = 1.0;",

  			"	float attenuation = saturate( -distance / lightRadius + 1.0 );",

  			DeferredShaderChunk[ "combine" ],

  			"}"

  		].join( "\n" )

  	},

  	spotLight: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepth: new Uniform( null ),
  				samplerColor: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightAngle: new Uniform( 1.0 ),
  				lightIntensity: new Uniform( 1.0 )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() { ",

  			"	gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepth;",
  			"uniform sampler2D samplerColor;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightPositionVS;",
  			"uniform vec3 lightDirectionVS;",
  			"uniform float lightAngle;",
  			"uniform float lightIntensity;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepth" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],
  			DeferredShaderChunk[ "unpackColor" ],

  			"	vec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );",

  			"	float rho = dot( lightDirectionVS, lightVector );",
  			"	float rhoMax = cos( lightAngle );",

  			"	if ( rho <= rhoMax ) discard;",

  			"	float theta = rhoMax + 0.0001;",
  			"	float phi = rhoMax + 0.05;",
  			"	float falloff = 4.0;",

  			"	float spot = 0.0;",

  			"	if ( rho >= phi ) {",

  			"		spot = 1.0;",

  			"	} else if ( rho <= theta ) {",

  			"		spot = 0.0;",

  			"	} else { ",

  			"		spot = pow( ( rho - theta ) / ( phi - theta ), falloff );",

  			"	}",

  			"	diffuseColor *= spot;",

  			DeferredShaderChunk[ "computeSpecular" ],

  			"	const float attenuation = 1.0;",

  			DeferredShaderChunk[ "combine" ],

  			"}"

  		].join( "\n" )

  	},

  	directionalLight: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepth: new Uniform( null ),
  				samplerColor: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightIntensity: new Uniform( 1.0 )
  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() { ",

  			"	gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );",

  			"}"

  		].join( '\n' ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepth;",
  			"uniform sampler2D samplerColor;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightDirectionVS;",
  			"uniform float lightIntensity;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepth" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],
  			DeferredShaderChunk[ "unpackColor" ],

  			"	vec3 lightVector = normalize( lightDirectionVS );",

  			DeferredShaderChunk[ "computeSpecular" ],

  			"	const float attenuation = 1.0;",

  			DeferredShaderChunk[ "combine" ],

  			"}"

  		].join( '\n' )

  	},

  	normalDepthShininess: {

  		uniforms: {

  			shininess: new Uniform( 30.0 )

  		},

  		vertexShader: [

  			"varying vec3 vNormal;",
  			"varying vec4 vPosition;",

  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",

  			"void main() {",

  			"#include <begin_vertex>",
  			"#include <beginnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",
  			"#include <morphtarget_vertex>",
  			"#include <skinning_vertex>",
  			"#include <project_vertex>",

  			"	vNormal = normalize( transformedNormal );",
  			"	vPosition = gl_Position;",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec3 vNormal;",
  			"varying vec4 vPosition;",

  			"uniform float shininess;",

  			DeferredShaderChunk[ "packNormal" ],

  			"void main() {",

  			"	vec3 normal = vNormal;",
  			"	vec4 position = vPosition;",

  			DeferredShaderChunk[ "packNormalDepthShininess" ],

  			"	gl_FragColor = packedNormalDepthShininess;",

  			"}"

  		].join( "\n" )

  	},

  	pointLightPre: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepthShininess: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightIntensity: new Uniform( 1.0 ),
  				lightRadius: new Uniform( 1.0 )
  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),
  		vertexShader: [

  			"void main() {",

  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepthShininess;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightPositionVS;",
  			"uniform float lightIntensity;",
  			"uniform float lightRadius;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],
  			DeferredShaderChunk[ "unpackVector2" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepthShininess" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],

  			"	vec3 lightVector = lightPositionVS - vertexPositionVS.xyz;",
  			"	float distance = length( lightVector );",

  			"	if ( distance > lightRadius ) discard;",

  			"	lightVector = normalize( lightVector );",

  			DeferredShaderChunk[ "computeSpecular" ],

  			"	float attenuation = saturate( -distance / lightRadius + 1.0 );",

  			DeferredShaderChunk[ "packLight" ],

  			"	gl_FragColor = packedLight;",

  			"}"

  		].join( "\n" )

  	},

  	spotLightPre: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepthShininess: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightPositionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightAngle: new Uniform( 1.0 ),
  				lightIntensity: new Uniform( 1.0 )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() { ",

  			"	gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepthShininess;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightPositionVS;",
  			"uniform vec3 lightDirectionVS;",
  			"uniform float lightAngle;",
  			"uniform float lightIntensity;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],
  			DeferredShaderChunk[ "unpackVector2" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepthShininess" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],

  			"	vec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );",

  			"	float rho = dot( lightDirectionVS, lightVector );",
  			"	float rhoMax = cos( lightAngle );",

  			"	if ( rho <= rhoMax ) discard;",

  			"	float theta = rhoMax + 0.0001;",
  			"	float phi = rhoMax + 0.05;",
  			"	float falloff = 4.0;",

  			"	float spot = 0.0;",

  			"	if ( rho >= phi ) {",

  			"		spot = 1.0;",

  			"	} else if ( rho <= theta ) {",

  			"		spot = 0.0;",

  			"	} else { ",

  			"		spot = pow( ( rho - theta ) / ( phi - theta ), falloff );",

  			"	}",

  			DeferredShaderChunk[ "computeSpecular" ],

  			"	const float attenuation = 1.0;",

  			DeferredShaderChunk[ "packLight" ],

  			"	gl_FragColor = spot * packedLight;",

  			"}"

  		].join( "\n" )

  	},

  	directionalLightPre: {

  		uniforms: Object.assign(

  			{

  				samplerNormalDepthShininess: new Uniform( null ),

  				lightColor: new Uniform( new Color( 0x000000 ) ),
  				lightDirectionVS: new Uniform( new Vector3( 0, 1, 0 ) ),
  				lightIntensity: new Uniform( 1.0 )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"void main() { ",

  			"	gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );",

  			"}"

  		].join( '\n' ),

  		fragmentShader: [

  			"uniform sampler2D samplerNormalDepthShininess;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"uniform vec3 lightColor;",
  			"uniform vec3 lightDirectionVS;",
  			"uniform float lightIntensity;",

  			"uniform mat4 matProjInverse;",

  			DeferredShaderChunk[ "unpackFloat" ],
  			DeferredShaderChunk[ "unpackVector2" ],

  			"void main() {",

  			DeferredShaderChunk[ "computeTextureCoord" ],
  			DeferredShaderChunk[ "unpackNormalDepthShininess" ],
  			DeferredShaderChunk[ "computeVertexPositionVS" ],

  			"	vec3 lightVector = normalize( lightDirectionVS );",

  			DeferredShaderChunk[ "computeSpecular" ],

  			"	const float attenuation = 1.0;",

  			DeferredShaderChunk[ "packLight" ],

  			"	gl_FragColor = packedLight;",

  			"}"

  		].join( '\n' )

  	},

  	reconstruction: {

  		uniforms: Object.assign(

  			{

  				samplerLight: new Uniform( null ),

  				map: new Uniform( null ),
  				offsetRepeat: new Uniform( new Vector4( 0, 0, 1, 1 ) ),

  				diffuse: new Uniform( new Color( 0x000000 ) ),
  				emissive: new Uniform( new Color( 0x000000 ) ),
  				specular: new Uniform( new Color( 0x000000 ) ),
  				shininess: new Uniform( 30.0 )

  			},

  			ShaderDeferredCommon[ 'commonUniforms' ]

  		),

  		vertexShader: [

  			"#include <uv_pars_vertex>",
  			"#include <morphtarget_pars_vertex>",
  			"#include <skinning_pars_vertex>",

  			"void main() {",

  			"#include <uv_vertex>",
  			"#include <begin_vertex>",
  			"#include <beginnormal_vertex>",
  			"#include <skinbase_vertex>",
  			"#include <skinnormal_vertex>",
  			"#include <defaultnormal_vertex>",
  			"#include <morphtarget_vertex>",
  			"#include <skinning_vertex>",
  			"#include <project_vertex>",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D samplerLight;",

  			"uniform vec3 diffuse;",
  			"uniform vec3 emissive;",
  			"uniform vec3 specular;",
  			"uniform float shininess;",

  			"uniform float viewHeight;",
  			"uniform float viewWidth;",

  			"#include <uv_pars_fragment>",
  			"#include <map_pars_fragment>",

  			DeferredShaderChunk[ "unpackFloat" ],

  			"void main() {",

  			"	vec4 diffuseColor = vec4( diffuse, 1.0 );",
  			"	vec3 emissiveColor = emissive;",
  			"	vec3 specularColor = specular;",

  			DeferredShaderChunk[ "computeTextureCoord" ],

  			"	vec4 light = texture2D( samplerLight, texCoord );",

  			"#include <map_fragment>",

  			"	vec3 diffuseFinal = diffuseColor.rgb * light.rgb;",
  			"	vec3 emissiveFinal = emissiveColor;",
  			"	vec3 specularFinal = specularColor * light.rgb * light.a;",

  			"	gl_FragColor = vec4( diffuseFinal + emissiveFinal + specularFinal, 1.0 );",

  			"}"

  		].join( "\n" )

  	},

  	// TODO: implement tone mapping
  	final: {

  		uniforms: {

  			samplerResult: new Uniform( null )

  		},

  		vertexShader: [

  			"varying vec2 texCoord;",

  			"void main() {",

  			"	vec4 pos = vec4( sign( position.xy ), 0.0, 1.0 );",
  			"	texCoord = pos.xy * vec2( 0.5 ) + 0.5;",
  			"	gl_Position = pos;",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec2 texCoord;",
  			"uniform sampler2D samplerResult;",

  			"void main() {",

  			"	gl_FragColor = texture2D( samplerResult, texCoord );",

  			"}"

  		].join( "\n" )

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RollerCoasterGeometry( curve, divisions ) {

  	BufferGeometry.call( this );

  	var vertices = [];
  	var normals = [];
  	var colors = [];

  	var color1 = [ 1, 1, 1 ];
  	var color2 = [ 1, 1, 0 ];

  	var up = new Vector3( 0, 1, 0 );
  	var forward = new Vector3();
  	var right = new Vector3();

  	var quaternion = new Quaternion();
  	var prevQuaternion = new Quaternion();
  	prevQuaternion.setFromAxisAngle( up, Math.PI / 2 );

  	var point = new Vector3();
  	var prevPoint = new Vector3();
  	prevPoint.copy( curve.getPointAt( 0 ) );

  	// shapes

  	var step = [
  		new Vector3( - 0.225, 0, 0 ),
  		new Vector3( 0, - 0.050, 0 ),
  		new Vector3( 0, - 0.175, 0 ),

  		new Vector3( 0, - 0.050, 0 ),
  		new Vector3( 0.225, 0, 0 ),
  		new Vector3( 0, - 0.175, 0 )
  	];

  	var PI2 = Math.PI * 2;

  	var sides = 5;
  	var tube1 = [];

  	for ( var i = 0; i < sides; i ++ ) {

  		var angle = ( i / sides ) * PI2;
  		tube1.push( new Vector3( Math.sin( angle ) * 0.06, Math.cos( angle ) * 0.06, 0 ) );

  	}

  	var sides = 6;
  	var tube2 = [];

  	for ( var i = 0; i < sides; i ++ ) {

  		var angle = ( i / sides ) * PI2;
  		tube2.push( new Vector3( Math.sin( angle ) * 0.025, Math.cos( angle ) * 0.025, 0 ) );

  	}

  	var vector = new Vector3();
  	var normal = new Vector3();

  	function drawShape( shape, color ) {

  		normal.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  		for ( var j = 0; j < shape.length; j ++ ) {

  			vector.copy( shape[ j ] );
  			vector.applyQuaternion( quaternion );
  			vector.add( point );

  			vertices.push( vector.x, vector.y, vector.z );
  			normals.push( normal.x, normal.y, normal.z );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );

  		}

  		normal.set( 0, 0, 1 ).applyQuaternion( quaternion );

  		for ( var j = shape.length - 1; j >= 0; j -- ) {

  			vector.copy( shape[ j ] );
  			vector.applyQuaternion( quaternion );
  			vector.add( point );

  			vertices.push( vector.x, vector.y, vector.z );
  			normals.push( normal.x, normal.y, normal.z );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );

  		}

  	}

  	var vector1 = new Vector3();
  	var vector2 = new Vector3();
  	var vector3 = new Vector3();
  	var vector4 = new Vector3();

  	var normal1 = new Vector3();
  	var normal2 = new Vector3();
  	var normal3 = new Vector3();
  	var normal4 = new Vector3();

  	function extrudeShape( shape, offset, color ) {

  		for ( var j = 0, jl = shape.length; j < jl; j ++ ) {

  			var point1 = shape[ j ];
  			var point2 = shape[ ( j + 1 ) % jl ];

  			vector1.copy( point1 ).add( offset );
  			vector1.applyQuaternion( quaternion );
  			vector1.add( point );

  			vector2.copy( point2 ).add( offset );
  			vector2.applyQuaternion( quaternion );
  			vector2.add( point );

  			vector3.copy( point2 ).add( offset );
  			vector3.applyQuaternion( prevQuaternion );
  			vector3.add( prevPoint );

  			vector4.copy( point1 ).add( offset );
  			vector4.applyQuaternion( prevQuaternion );
  			vector4.add( prevPoint );

  			vertices.push( vector1.x, vector1.y, vector1.z );
  			vertices.push( vector2.x, vector2.y, vector2.z );
  			vertices.push( vector4.x, vector4.y, vector4.z );

  			vertices.push( vector2.x, vector2.y, vector2.z );
  			vertices.push( vector3.x, vector3.y, vector3.z );
  			vertices.push( vector4.x, vector4.y, vector4.z );

  			//

  			normal1.copy( point1 );
  			normal1.applyQuaternion( quaternion );
  			normal1.normalize();

  			normal2.copy( point2 );
  			normal2.applyQuaternion( quaternion );
  			normal2.normalize();

  			normal3.copy( point2 );
  			normal3.applyQuaternion( prevQuaternion );
  			normal3.normalize();

  			normal4.copy( point1 );
  			normal4.applyQuaternion( prevQuaternion );
  			normal4.normalize();

  			normals.push( normal1.x, normal1.y, normal1.z );
  			normals.push( normal2.x, normal2.y, normal2.z );
  			normals.push( normal4.x, normal4.y, normal4.z );

  			normals.push( normal2.x, normal2.y, normal2.z );
  			normals.push( normal3.x, normal3.y, normal3.z );
  			normals.push( normal4.x, normal4.y, normal4.z );

  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );

  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );
  			colors.push( color[ 0 ], color[ 1 ], color[ 2 ] );

  		}

  	}

  	var offset = new Vector3();

  	for ( var i = 1; i <= divisions; i ++ ) {

  		point.copy( curve.getPointAt( i / divisions ) );

  		up.set( 0, 1, 0 );

  		forward.subVectors( point, prevPoint ).normalize();
  		right.crossVectors( up, forward ).normalize();
  		up.crossVectors( forward, right );

  		var angle = Math.atan2( forward.x, forward.z );

  		quaternion.setFromAxisAngle( up, angle );

  		if ( i % 2 === 0 ) {

  			drawShape( step, color2 );

  		}

  		extrudeShape( tube1, offset.set( 0, - 0.125, 0 ), color2 );
  		extrudeShape( tube2, offset.set( 0.2, 0, 0 ), color1 );
  		extrudeShape( tube2, offset.set( - 0.2, 0, 0 ), color1 );

  		prevPoint.copy( point );
  		prevQuaternion.copy( quaternion );

  	}

  	// console.log( vertices.length );

  	this.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );
  	this.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );
  	this.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );

  }

  RollerCoasterGeometry.prototype = Object.create( BufferGeometry.prototype );

  function RollerCoasterLiftersGeometry( curve, divisions ) {

  	BufferGeometry.call( this );

  	var vertices = [];
  	var normals = [];

  	var quaternion = new Quaternion();

  	var up = new Vector3( 0, 1, 0 );

  	var point = new Vector3();
  	var tangent = new Vector3();

  	// shapes

  	var tube1 = [
  		new Vector3( 0, 0.05, - 0.05 ),
  		new Vector3( 0, 0.05, 0.05 ),
  		new Vector3( 0, - 0.05, 0 )
  	];

  	var tube2 = [
  		new Vector3( - 0.05, 0, 0.05 ),
  		new Vector3( - 0.05, 0, - 0.05 ),
  		new Vector3( 0.05, 0, 0 )
  	];

  	var tube3 = [
  		new Vector3( 0.05, 0, - 0.05 ),
  		new Vector3( 0.05, 0, 0.05 ),
  		new Vector3( - 0.05, 0, 0 )
  	];

  	var vector1 = new Vector3();
  	var vector2 = new Vector3();
  	var vector3 = new Vector3();
  	var vector4 = new Vector3();

  	var normal1 = new Vector3();
  	var normal2 = new Vector3();
  	var normal3 = new Vector3();
  	var normal4 = new Vector3();

  	function extrudeShape( shape, fromPoint, toPoint ) {

  		for ( var j = 0, jl = shape.length; j < jl; j ++ ) {

  			var point1 = shape[ j ];
  			var point2 = shape[ ( j + 1 ) % jl ];

  			vector1.copy( point1 );
  			vector1.applyQuaternion( quaternion );
  			vector1.add( fromPoint );

  			vector2.copy( point2 );
  			vector2.applyQuaternion( quaternion );
  			vector2.add( fromPoint );

  			vector3.copy( point2 );
  			vector3.applyQuaternion( quaternion );
  			vector3.add( toPoint );

  			vector4.copy( point1 );
  			vector4.applyQuaternion( quaternion );
  			vector4.add( toPoint );

  			vertices.push( vector1.x, vector1.y, vector1.z );
  			vertices.push( vector2.x, vector2.y, vector2.z );
  			vertices.push( vector4.x, vector4.y, vector4.z );

  			vertices.push( vector2.x, vector2.y, vector2.z );
  			vertices.push( vector3.x, vector3.y, vector3.z );
  			vertices.push( vector4.x, vector4.y, vector4.z );

  			//

  			normal1.copy( point1 );
  			normal1.applyQuaternion( quaternion );
  			normal1.normalize();

  			normal2.copy( point2 );
  			normal2.applyQuaternion( quaternion );
  			normal2.normalize();

  			normal3.copy( point2 );
  			normal3.applyQuaternion( quaternion );
  			normal3.normalize();

  			normal4.copy( point1 );
  			normal4.applyQuaternion( quaternion );
  			normal4.normalize();

  			normals.push( normal1.x, normal1.y, normal1.z );
  			normals.push( normal2.x, normal2.y, normal2.z );
  			normals.push( normal4.x, normal4.y, normal4.z );

  			normals.push( normal2.x, normal2.y, normal2.z );
  			normals.push( normal3.x, normal3.y, normal3.z );
  			normals.push( normal4.x, normal4.y, normal4.z );

  		}

  	}

  	var fromPoint = new Vector3();
  	var toPoint = new Vector3();

  	for ( var i = 1; i <= divisions; i ++ ) {

  		point.copy( curve.getPointAt( i / divisions ) );
  		tangent.copy( curve.getTangentAt( i / divisions ) );

  		var angle = Math.atan2( tangent.x, tangent.z );

  		quaternion.setFromAxisAngle( up, angle );

  		//

  		if ( point.y > 10 ) {

  			fromPoint.set( - 0.75, - 0.35, 0 );
  			fromPoint.applyQuaternion( quaternion );
  			fromPoint.add( point );

  			toPoint.set( 0.75, - 0.35, 0 );
  			toPoint.applyQuaternion( quaternion );
  			toPoint.add( point );

  			extrudeShape( tube1, fromPoint, toPoint );

  			fromPoint.set( - 0.7, - 0.3, 0 );
  			fromPoint.applyQuaternion( quaternion );
  			fromPoint.add( point );

  			toPoint.set( - 0.7, - point.y, 0 );
  			toPoint.applyQuaternion( quaternion );
  			toPoint.add( point );

  			extrudeShape( tube2, fromPoint, toPoint );

  			fromPoint.set( 0.7, - 0.3, 0 );
  			fromPoint.applyQuaternion( quaternion );
  			fromPoint.add( point );

  			toPoint.set( 0.7, - point.y, 0 );
  			toPoint.applyQuaternion( quaternion );
  			toPoint.add( point );

  			extrudeShape( tube3, fromPoint, toPoint );

  		} else {

  			fromPoint.set( 0, - 0.2, 0 );
  			fromPoint.applyQuaternion( quaternion );
  			fromPoint.add( point );

  			toPoint.set( 0, - point.y, 0 );
  			toPoint.applyQuaternion( quaternion );
  			toPoint.add( point );

  			extrudeShape( tube3, fromPoint, toPoint );

  		}

  	}

  	this.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );
  	this.addAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3 ) );

  }

  RollerCoasterLiftersGeometry.prototype = Object.create( BufferGeometry.prototype );

  function RollerCoasterShadowGeometry( curve, divisions ) {

  	BufferGeometry.call( this );

  	var vertices = [];

  	var up = new Vector3( 0, 1, 0 );
  	var forward = new Vector3();

  	var quaternion = new Quaternion();
  	var prevQuaternion = new Quaternion();
  	prevQuaternion.setFromAxisAngle( up, Math.PI / 2 );

  	var point = new Vector3();

  	var prevPoint = new Vector3();
  	prevPoint.copy( curve.getPointAt( 0 ) );
  	prevPoint.y = 0;

  	var vector1 = new Vector3();
  	var vector2 = new Vector3();
  	var vector3 = new Vector3();
  	var vector4 = new Vector3();

  	for ( var i = 1; i <= divisions; i ++ ) {

  		point.copy( curve.getPointAt( i / divisions ) );
  		point.y = 0;

  		forward.subVectors( point, prevPoint );

  		var angle = Math.atan2( forward.x, forward.z );

  		quaternion.setFromAxisAngle( up, angle );

  		vector1.set( - 0.3, 0, 0 );
  		vector1.applyQuaternion( quaternion );
  		vector1.add( point );

  		vector2.set( 0.3, 0, 0 );
  		vector2.applyQuaternion( quaternion );
  		vector2.add( point );

  		vector3.set( 0.3, 0, 0 );
  		vector3.applyQuaternion( prevQuaternion );
  		vector3.add( prevPoint );

  		vector4.set( - 0.3, 0, 0 );
  		vector4.applyQuaternion( prevQuaternion );
  		vector4.add( prevPoint );

  		vertices.push( vector1.x, vector1.y, vector1.z );
  		vertices.push( vector2.x, vector2.y, vector2.z );
  		vertices.push( vector4.x, vector4.y, vector4.z );

  		vertices.push( vector2.x, vector2.y, vector2.z );
  		vertices.push( vector3.x, vector3.y, vector3.z );
  		vertices.push( vector4.x, vector4.y, vector4.z );

  		prevPoint.copy( point );
  		prevQuaternion.copy( quaternion );

  	}

  	this.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );

  }

  RollerCoasterShadowGeometry.prototype = Object.create( BufferGeometry.prototype );

  function SkyGeometry() {

  	BufferGeometry.call( this );

  	var vertices = [];

  	for ( var i = 0; i < 100; i ++ ) {

  		var x = Math.random() * 800 - 400;
  		var y = Math.random() * 50 + 50;
  		var z = Math.random() * 800 - 400;

  		var size = Math.random() * 40 + 20;

  		vertices.push( x - size, y, z - size );
  		vertices.push( x + size, y, z - size );
  		vertices.push( x - size, y, z + size );

  		vertices.push( x + size, y, z - size );
  		vertices.push( x + size, y, z + size );
  		vertices.push( x - size, y, z + size );

  	}
  	this.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );

  }

  SkyGeometry.prototype = Object.create( BufferGeometry.prototype );

  function TreesGeometry( landscape ) {

  	BufferGeometry.call( this );

  	var vertices = [];
  	var colors = [];

  	var raycaster = new Raycaster();
  	raycaster.ray.direction.set( 0, - 1, 0 );

  	for ( var i = 0; i < 2000; i ++ ) {

  		var x = Math.random() * 500 - 250;
  		var z = Math.random() * 500 - 250;

  		raycaster.ray.origin.set( x, 50, z );

  		var intersections = raycaster.intersectObject( landscape );

  		if ( intersections.length === 0 ) { continue; }

  		var y = intersections[ 0 ].point.y;

  		var height = Math.random() * 5 + 0.5;

  		var angle = Math.random() * Math.PI * 2;

  		vertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );
  		vertices.push( x, y + height, z );
  		vertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );

  		angle += Math.PI / 2;

  		vertices.push( x + Math.sin( angle ), y, z + Math.cos( angle ) );
  		vertices.push( x, y + height, z );
  		vertices.push( x + Math.sin( angle + Math.PI ), y, z + Math.cos( angle + Math.PI ) );

  		var random = Math.random() * 0.1;

  		for ( var j = 0; j < 6; j ++ ) {

  			colors.push( 0.2 + random, 0.4 + random, 0 );

  		}

  	}

  	this.addAttribute( 'position', new BufferAttribute( new Float32Array( vertices ), 3 ) );
  	this.addAttribute( 'color', new BufferAttribute( new Float32Array( colors ), 3 ) );

  }

  TreesGeometry.prototype = Object.create( BufferGeometry.prototype );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderGodRays = {

  	'godrays_depthMask': {

  		uniforms: {

  			tInput: {
  				value: null
  			}

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  			" vUv = uv;",
  			" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec2 vUv;",

  			"uniform sampler2D tInput;",

  			"void main() {",

  			"	gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );",
  			"}"

  		].join( "\n" )

  	},
  	'godrays_generate': {

  		uniforms: {

  			tInput: {
  				value: null
  			},
  			fStepSize: {
  				value: 1.0
  			},
  			vSunPositionScreenSpace: {
  				value: new Vector2( 0.5, 0.5 )
  			}

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  				"vUv = uv;",
  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"#define TAPS_PER_PASS 6.0",

  			"varying vec2 vUv;",

  			"uniform sampler2D tInput;",

  			"uniform vec2 vSunPositionScreenSpace;",
  			"uniform float fStepSize;", // filter step size

  			"void main() {",

  				// delta from current pixel to "sun" position

  				"vec2 delta = vSunPositionScreenSpace - vUv;",
  				"float dist = length( delta );",

  				// Step vector (uv space)

  				"vec2 stepv = fStepSize * delta / dist;",

  				// Number of iterations between pixel and sun

  				"float iters = dist/fStepSize;",

  				"vec2 uv = vUv.xy;",
  				"float col = 0.0;",

  				// This breaks ANGLE in Chrome 22
  				//	- see http://code.google.com/p/chromium/issues/detail?id=153105
  				// Unrolling loop manually makes it work in ANGLE

  				"if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				"if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				"if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				"if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				"if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				"if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;",
  				"uv += stepv;",

  				// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out
  				// objectionable artifacts, in particular near the sun position. The side
  				// effect is that the result is darker than it should be around the sun, as
  				// TAPS_PER_PASS is greater than the number of samples actually accumulated.
  				// When the result is inverted (in the shader 'godrays_combine', this produces
  				// a slight bright spot at the position of the sun, even when it is occluded.

  				"gl_FragColor = vec4( col/TAPS_PER_PASS );",
  				"gl_FragColor.a = 1.0;",

  			"}"

  		].join( "\n" )

  	},
  	'godrays_combine': {

  		uniforms: {

  			tColors: {
  				value: null
  			},

  			tGodRays: {
  				value: null
  			},

  			fGodRayIntensity: {
  				value: 0.69
  			},

  			vSunPositionScreenSpace: {
  				value: new Vector2( 0.5, 0.5 )
  			}

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  				"vUv = uv;",
  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  			].join( "\n" ),

  		fragmentShader: [

  			"varying vec2 vUv;",

  			"uniform sampler2D tColors;",
  			"uniform sampler2D tGodRays;",

  			"uniform vec2 vSunPositionScreenSpace;",
  			"uniform float fGodRayIntensity;",

  			"void main() {",

  				// Since MeshDepthMaterial renders foreground objects white and background
  				// objects black, the god-rays will be white streaks. Therefore value is inverted
  				// before being combined with tColors

  				"gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );",
  				"gl_FragColor.a = 1.0;",

  			"}"

  		].join( "\n" )

  	},
  	'godrays_fake_sun': {

  		uniforms: {

  			vSunPositionScreenSpace: {
  				value: new Vector2( 0.5, 0.5 )
  			},

  			fAspect: {
  				value: 1.0
  			},

  			sunColor: {
  				value: new Color( 0xffee00 )
  			},

  			bgColor: {
  				value: new Color( 0x000000 )
  			}

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  				"vUv = uv;",
  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec2 vUv;",

  			"uniform vec2 vSunPositionScreenSpace;",
  			"uniform float fAspect;",

  			"uniform vec3 sunColor;",
  			"uniform vec3 bgColor;",

  			"void main() {",

  				"vec2 diff = vUv - vSunPositionScreenSpace;",

  				// Correct for aspect ratio

  				"diff.x *= fAspect;",

  				"float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );",
  				"prop = 0.35 * pow( 1.0 - prop, 3.0 );",

  				"gl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );",
  				"gl_FragColor.w = 1.0;",

  			"}"

  		].join( "\n" )

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BasicShader = {

  	uniforms: {},

  	vertexShader: [

  		"void main() {",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"void main() {",

  			"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BleachBypassShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"opacity":  { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float opacity;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 base = texture2D( tDiffuse, vUv );",

  			"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
  			"float lum = dot( lumCoeff, base.rgb );",
  			"vec3 blend = vec3( lum );",

  			"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",

  			"vec3 result1 = 2.0 * base.rgb * blend;",
  			"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",

  			"vec3 newColor = mix( result1, result2, L );",

  			"float A2 = opacity * base.a;",
  			"vec3 mixRGB = A2 * newColor.rgb;",
  			"mixRGB += ( ( 1.0 - A2 ) * base.rgb );",

  			"gl_FragColor = vec4( mixRGB, base.a );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BlendShader = {

  	uniforms: {

  		"tDiffuse1": { value: null },
  		"tDiffuse2": { value: null },
  		"mixRatio":  { value: 0.5 },
  		"opacity":   { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float opacity;",
  		"uniform float mixRatio;",

  		"uniform sampler2D tDiffuse1;",
  		"uniform sampler2D tDiffuse2;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 texel1 = texture2D( tDiffuse1, vUv );",
  			"vec4 texel2 = texture2D( tDiffuse2, vUv );",
  			"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var BrightnessContrastShader = {

  	uniforms: {

  		"tDiffuse":   { value: null },
  		"brightness": { value: 0 },
  		"contrast":   { value: 0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float brightness;",
  		"uniform float contrast;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"gl_FragColor = texture2D( tDiffuse, vUv );",

  			"gl_FragColor.rgb += brightness;",

  			"if (contrast > 0.0) {",
  				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
  			"} else {",
  				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
  			"}",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColorCorrectionShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"powRGB":   { value: new Vector3( 2, 2, 2 ) },
  		"mulRGB":   { value: new Vector3( 1, 1, 1 ) },
  		"addRGB":   { value: new Vector3( 0, 0, 0 ) }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform vec3 powRGB;",
  		"uniform vec3 mulRGB;",
  		"uniform vec3 addRGB;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"gl_FragColor = texture2D( tDiffuse, vUv );",
  			"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ColorifyShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"color":    { value: new Color( 0xffffff ) }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform vec3 color;",
  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 texel = texture2D( tDiffuse, vUv );",

  			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",
  			"float v = dot( texel.xyz, luma );",

  			"gl_FragColor = vec4( v * color, texel.w );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DOFMipMapShader = {

  	uniforms: {

  		"tColor":   { value: null },
  		"tDepth":   { value: null },
  		"focus":    { value: 1.0 },
  		"maxblur":  { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float focus;",
  		"uniform float maxblur;",

  		"uniform sampler2D tColor;",
  		"uniform sampler2D tDepth;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 depth = texture2D( tDepth, vUv );",

  			"float factor = depth.x - focus;",

  			"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );",

  			"gl_FragColor = col;",
  			"gl_FragColor.a = 1.0;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FocusShader = {

  	uniforms : {

  		"tDiffuse":       { value: null },
  		"screenWidth":    { value: 1024 },
  		"screenHeight":   { value: 1024 },
  		"sampleDistance": { value: 0.94 },
  		"waveFactor":     { value: 0.00125 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float screenWidth;",
  		"uniform float screenHeight;",
  		"uniform float sampleDistance;",
  		"uniform float waveFactor;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 color, org, tmp, add;",
  			"float sample_dist, f;",
  			"vec2 vin;",
  			"vec2 uv = vUv;",

  			"add = color = org = texture2D( tDiffuse, uv );",

  			"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
  			"sample_dist = dot( vin, vin ) * 2.0;",

  			"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",

  			"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
  			"if( tmp.b < color.b ) color = tmp;",

  			"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
  			"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",

  			"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",

  		"}"
  	].join( "\n" )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FreiChenShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"aspect":    { value: new Vector2( 512, 512 ) }
  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"varying vec2 vUv;",

  		"uniform vec2 aspect;",

  		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",
  		"mat3 G[9];",

  		// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

  		"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
  		"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
  		"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
  		"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
  		"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
  		"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
  		"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
  		"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
  		"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",

  		"void main(void)",
  		"{",

  			"G[0] = g0,",
  			"G[1] = g1,",
  			"G[2] = g2,",
  			"G[3] = g3,",
  			"G[4] = g4,",
  			"G[5] = g5,",
  			"G[6] = g6,",
  			"G[7] = g7,",
  			"G[8] = g8;",

  			"mat3 I;",
  			"float cnv[9];",
  			"vec3 sample;",
  			"for (float i=0.0; i<3.0; i++) {",
  				"for (float j=0.0; j<3.0; j++) {",
  					"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
  					"I[int(i)][int(j)] = length(sample);",
  				"}",
  			"}",
  			"for (int i=0; i<9; i++) {",
  				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
  				"cnv[i] = dp3 * dp3;",
  			"}",

  			"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
  			"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",

  			"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
  		"}"

  	].join( "\n" )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var FresnelShader = {

  	uniforms: {

  		"mRefractionRatio": { value: 1.02 },
  		"mFresnelBias": { value: 0.1 },
  		"mFresnelPower": { value: 2.0 },
  		"mFresnelScale": { value: 1.0 },
  		"tCube": { value: null }

  	},

  	vertexShader: [

  		"uniform float mRefractionRatio;",
  		"uniform float mFresnelBias;",
  		"uniform float mFresnelScale;",
  		"uniform float mFresnelPower;",

  		"varying vec3 vReflect;",
  		"varying vec3 vRefract[3];",
  		"varying float vReflectionFactor;",

  		"void main() {",

  			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
  			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

  			"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",

  			"vec3 I = worldPosition.xyz - cameraPosition;",

  			"vReflect = reflect( I, worldNormal );",
  			"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );",
  			"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );",
  			"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );",
  			"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );",

  			"gl_Position = projectionMatrix * mvPosition;",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform samplerCube tCube;",

  		"varying vec3 vReflect;",
  		"varying vec3 vRefract[3];",
  		"varying float vReflectionFactor;",

  		"void main() {",

  			"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
  			"vec4 refractedColor = vec4( 1.0 );",

  			"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
  			"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
  			"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",

  			"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GammaCorrectionShader = {

  	uniforms: {

  		"tDiffuse": { value: null }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",

  			"gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HorizontalBlurShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"h":        { value: 1.0 / 512.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float h;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 sum = vec4( 0.0 );",

  			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",

  			"gl_FragColor = sum;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HorizontalTiltShiftShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"h":        { value: 1.0 / 512.0 },
  		"r":        { value: 0.35 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float h;",
  		"uniform float r;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 sum = vec4( 0.0 );",

  			"float hh = h * abs( r - vUv.y );",

  			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;",

  			"gl_FragColor = sum;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var HueSaturationShader = {

  	uniforms: {

  		"tDiffuse":   { value: null },
  		"hue":        { value: 0 },
  		"saturation": { value: 0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float hue;",
  		"uniform float saturation;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"gl_FragColor = texture2D( tDiffuse, vUv );",

  			// hue
  			"float angle = hue * 3.14159265;",
  			"float s = sin(angle), c = cos(angle);",
  			"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
  			"float len = length(gl_FragColor.rgb);",
  			"gl_FragColor.rgb = vec3(",
  				"dot(gl_FragColor.rgb, weights.xyz),",
  				"dot(gl_FragColor.rgb, weights.zxy),",
  				"dot(gl_FragColor.rgb, weights.yzx)",
  			");",

  			// saturation
  			"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
  			"if (saturation > 0.0) {",
  				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
  			"} else {",
  				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
  			"}",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var KaleidoShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"sides":    { value: 6.0 },
  		"angle":    { value: 0.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float sides;",
  		"uniform float angle;",
  		
  		"varying vec2 vUv;",

  		"void main() {",

  			"vec2 p = vUv - 0.5;",
  			"float r = length(p);",
  			"float a = atan(p.y, p.x) + angle;",
  			"float tau = 2. * 3.1416 ;",
  			"a = mod(a, tau/sides);",
  			"a = abs(a - tau/sides/2.) ;",
  			"p = r * vec2(cos(a), sin(a));",
  			"vec4 color = texture2D(tDiffuse, p + 0.5);",
  			"gl_FragColor = color;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MirrorShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"side":     { value: 1 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform int side;",
  		
  		"varying vec2 vUv;",

  		"void main() {",

  			"vec2 p = vUv;",
  			"if (side == 0){",
  				"if (p.x > 0.5) p.x = 1.0 - p.x;",
  			"}else if (side == 1){",
  				"if (p.x < 0.5) p.x = 1.0 - p.x;",
  			"}else if (side == 2){",
  				"if (p.y < 0.5) p.y = 1.0 - p.y;",
  			"}else if (side == 3){",
  				"if (p.y > 0.5) p.y = 1.0 - p.y;",
  			"} ",
  			"vec4 color = texture2D(tDiffuse, p);",
  			"gl_FragColor = color;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var NormalMapShader = {

  	uniforms: {

  		"heightMap":  { value: null },
  		"resolution": { value: new Vector2( 512, 512 ) },
  		"scale":      { value: new Vector2( 1, 1 ) },
  		"height":     { value: 0.05 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float height;",
  		"uniform vec2 resolution;",
  		"uniform sampler2D heightMap;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"float val = texture2D( heightMap, vUv ).x;",

  			"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;",
  			"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;",

  			"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Parallax Occlusion shaders from
  //    http://sunandblackcat.com/tipFullView.php?topicid=28
  // No tangent-space transforms logic based on
  //   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html

  var ParallaxShader = {
  	// Ordered from fastest to best quality.
  	modes: {
  		none:  'NO_PARALLAX',
  		basic: 'USE_BASIC_PARALLAX',
  		steep: 'USE_STEEP_PARALLAX',
  		occlusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM
  		relief: 'USE_RELIEF_PARALLAX'
  	},

  	uniforms: {
  		"bumpMap": { value: null },
  		"map": { value: null },
  		"parallaxScale": { value: null },
  		"parallaxMinLayers": { value: null },
  		"parallaxMaxLayers": { value: null }
  	},

  	vertexShader: [
  		"varying vec2 vUv;",
  		"varying vec3 vViewPosition;",
  		"varying vec3 vNormal;",

  		"void main() {",

  			"vUv = uv;",
  			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
  			"vViewPosition = -mvPosition.xyz;",
  			"vNormal = normalize( normalMatrix * normal );",
  			"gl_Position = projectionMatrix * mvPosition;",

  		"}"

    ].join( "\n" ),

  	fragmentShader: [
  		"uniform sampler2D bumpMap;",
  		"uniform sampler2D map;",

  		"uniform float parallaxScale;",
  		"uniform float parallaxMinLayers;",
  		"uniform float parallaxMaxLayers;",

  		"varying vec2 vUv;",
  		"varying vec3 vViewPosition;",
  		"varying vec3 vNormal;",

  		"#ifdef USE_BASIC_PARALLAX",

  			"vec2 parallaxMap( in vec3 V ) {",

  				"float initialHeight = texture2D( bumpMap, vUv ).r;",

  				// No Offset Limitting: messy, floating output at grazing angles.
  				//"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

  				// Offset Limiting
  				"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
  				"return vUv - texCoordOffset;",

  			"}",

  		"#else",

  			"vec2 parallaxMap( in vec3 V ) {",

  				// Determine number of layers from angle between V and N
  				"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",

  				"float layerHeight = 1.0 / numLayers;",
  				"float currentLayerHeight = 0.0;",
  				// Shift of texture coordinates for each iteration
  				"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",

  				"vec2 currentTextureCoords = vUv;",

  				"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",

  				// while ( heightFromTexture > currentLayerHeight )
  				// Infinite loops are not well supported. Do a "large" finite
  				// loop, but not too large, as it slows down some compilers.
  				"for ( int i = 0; i < 30; i += 1 ) {",
  					"if ( heightFromTexture <= currentLayerHeight ) {",
  						"break;",
  					"}",
  					"currentLayerHeight += layerHeight;",
  					// Shift texture coordinates along vector V
  					"currentTextureCoords -= dtex;",
  					"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
  				"}",

  				"#ifdef USE_STEEP_PARALLAX",

  					"return currentTextureCoords;",

  				"#elif defined( USE_RELIEF_PARALLAX )",

  					"vec2 deltaTexCoord = dtex / 2.0;",
  					"float deltaHeight = layerHeight / 2.0;",

  					// Return to the mid point of previous layer
  					"currentTextureCoords += deltaTexCoord;",
  					"currentLayerHeight -= deltaHeight;",

  					// Binary search to increase precision of Steep Parallax Mapping
  					"const int numSearches = 5;",
  					"for ( int i = 0; i < numSearches; i += 1 ) {",

  						"deltaTexCoord /= 2.0;",
  						"deltaHeight /= 2.0;",
  						"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
  						// Shift along or against vector V
  						"if( heightFromTexture > currentLayerHeight ) {", // Below the surface

  							"currentTextureCoords -= deltaTexCoord;",
  							"currentLayerHeight += deltaHeight;",

  						"} else {", // above the surface

  							"currentTextureCoords += deltaTexCoord;",
  							"currentLayerHeight -= deltaHeight;",

  						"}",

  					"}",
  					"return currentTextureCoords;",

  				"#elif defined( USE_OCLUSION_PARALLAX )",

  					"vec2 prevTCoords = currentTextureCoords + dtex;",

  					// Heights for linear interpolation
  					"float nextH = heightFromTexture - currentLayerHeight;",
  					"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",

  					// Proportions for linear interpolation
  					"float weight = nextH / ( nextH - prevH );",

  					// Interpolation of texture coordinates
  					"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",

  				"#else", // NO_PARALLAX

  					"return vUv;",

  				"#endif",

  			"}",
  		"#endif",

  		"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",

   			"vec2 texDx = dFdx( vUv );",
  			"vec2 texDy = dFdy( vUv );",

  			"vec3 vSigmaX = dFdx( surfPosition );",
  			"vec3 vSigmaY = dFdy( surfPosition );",
  			"vec3 vR1 = cross( vSigmaY, surfNormal );",
  			"vec3 vR2 = cross( surfNormal, vSigmaX );",
  			"float fDet = dot( vSigmaX, vR1 );",

  			"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
  			"vec3 vProjVtex;",
  			"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
  			"vProjVtex.z = dot( surfNormal, viewPosition );",

  			"return parallaxMap( vProjVtex );",
  		"}",

  		"void main() {",

  			"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
  			"gl_FragColor = texture2D( map, mapUv );",

  		"}"

    ].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PixelShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"resolution": { value: null },
  		"pixelSize": { value: 1. },

  	},

  	vertexShader: [

  		"varying highp vec2 vUv;",

  		"void main() {",

  		"vUv = uv;",
  		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float pixelSize;",
  		"uniform vec2 resolution;",

  		"varying highp vec2 vUv;",

  		"void main(){",

  		"vec2 dxy = pixelSize / resolution;",
  		"vec2 coord = dxy * floor( vUv / dxy );",
  		"gl_FragColor = texture2D(tDiffuse, coord);",

  		"}"

  	].join( "\n" )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var RGBShiftShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"amount":   { value: 0.005 },
  		"angle":    { value: 0.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float amount;",
  		"uniform float angle;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
  			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
  			"vec4 cga = texture2D(tDiffuse, vUv);",
  			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
  			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SepiaShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"amount":   { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float amount;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 color = texture2D( tDiffuse, vUv );",
  			"vec3 c = color.rgb;",

  			"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );",
  			"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );",
  			"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );",

  			"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SobelOperatorShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"resolution": { value: new Vector2() }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",

  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform vec2 resolution;",
  		"varying vec2 vUv;",

  		"void main() {",

  			"vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",

  			// kernel definition (in glsl matrices are filled in column-major order)

  			"const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );", // x direction kernel
  			"const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );", // y direction kernel

  			// fetch the 3x3 neighbourhood of a fragment

  			// first column

  			"float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;",
  			"float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;",
  			"float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",

  			// second column

  			"float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;",
  			"float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;",
  			"float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",

  			// third column

  			"float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;",
  			"float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;",
  			"float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",

  			// gradient value in x direction

  			"float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ",
  				"Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ",
  				"Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",

  			// gradient value in y direction

  			"float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ",
  				"Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ",
  				"Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",

  			// magnitute of the total gradient

  			"float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );",

  			"gl_FragColor = vec4( vec3( G ), 1 );",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TechnicolorShader = {

  	uniforms: {

  		"tDiffuse": { value: null }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );",
  			"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);",

  			"gl_FragColor = newTex;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TriangleBlurShader = {

  	uniforms : {

  		"texture": { value: null },
  		"delta":   { value: new Vector2( 1, 1 ) }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"#include <common>",

  		"#define ITERATIONS 10.0",

  		"uniform sampler2D texture;",
  		"uniform vec2 delta;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 color = vec4( 0.0 );",

  			"float total = 0.0;",

  			// randomize the lookup values to hide the fixed number of samples

  			"float offset = rand( vUv );",

  			"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",

  				"float percent = ( t + offset - 0.5 ) / ITERATIONS;",
  				"float weight = 1.0 - abs( percent );",

  				"color += texture2D( texture, vUv + delta * percent ) * weight;",
  				"total += weight;",

  			"}",

  			"gl_FragColor = color / total;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VerticalBlurShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"v":        { value: 1.0 / 512.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float v;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 sum = vec4( 0.0 );",

  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",

  			"gl_FragColor = sum;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VerticalTiltShiftShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"v":        { value: 1.0 / 512.0 },
  		"r":        { value: 0.35 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform sampler2D tDiffuse;",
  		"uniform float v;",
  		"uniform float r;",

  		"varying vec2 vUv;",

  		"void main() {",

  			"vec4 sum = vec4( 0.0 );",

  			"float vv = v * abs( r - vUv.y );",

  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;",
  			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;",

  			"gl_FragColor = sum;",

  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VignetteShader = {

  	uniforms: {

  		"tDiffuse": { value: null },
  		"offset":   { value: 1.0 },
  		"darkness": { value: 1.0 }

  	},

  	vertexShader: [

  		"varying vec2 vUv;",

  		"void main() {",

  			"vUv = uv;",
  			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  		"}"

  	].join( "\n" ),

  	fragmentShader: [

  		"uniform float offset;",
  		"uniform float darkness;",

  		"uniform sampler2D tDiffuse;",

  		"varying vec2 vUv;",

  		"void main() {",

  			// Eskil's vignette

  			"vec4 texel = texture2D( tDiffuse, vUv );",
  			"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
  			"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
  		"}"

  	].join( "\n" )

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VolumeRenderShader1 = {
  	uniforms: {
          "u_size": { value: new Vector3( 1, 1, 1 ) },
          "u_renderstyle": { value: 0 },
          "u_renderthreshold": { value: 0.5 },
          "u_clim": { value: new Vector2( 1, 1 ) },
          "u_data": { value: null },
          "u_cmdata": { value: null }
      },
      vertexShader: [
          'varying vec4 v_nearpos;',
          'varying vec4 v_farpos;',
          'varying vec3 v_position;',

          'mat4 inversemat(mat4 m) {',
              // Taken from https://github.com/stackgl/glsl-inverse/blob/master/index.glsl
              // This function is licenced by the MIT license to Mikola Lysenko
              'float',
              'a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],',
              'a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],',
              'a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],',
              'a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],',

              'b00 = a00 * a11 - a01 * a10,',
              'b01 = a00 * a12 - a02 * a10,',
              'b02 = a00 * a13 - a03 * a10,',
              'b03 = a01 * a12 - a02 * a11,',
              'b04 = a01 * a13 - a03 * a11,',
              'b05 = a02 * a13 - a03 * a12,',
              'b06 = a20 * a31 - a21 * a30,',
              'b07 = a20 * a32 - a22 * a30,',
              'b08 = a20 * a33 - a23 * a30,',
              'b09 = a21 * a32 - a22 * a31,',
              'b10 = a21 * a33 - a23 * a31,',
              'b11 = a22 * a33 - a23 * a32,',

              'det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;',

          'return mat4(',
              'a11 * b11 - a12 * b10 + a13 * b09,',
              'a02 * b10 - a01 * b11 - a03 * b09,',
              'a31 * b05 - a32 * b04 + a33 * b03,',
              'a22 * b04 - a21 * b05 - a23 * b03,',
              'a12 * b08 - a10 * b11 - a13 * b07,',
              'a00 * b11 - a02 * b08 + a03 * b07,',
              'a32 * b02 - a30 * b05 - a33 * b01,',
              'a20 * b05 - a22 * b02 + a23 * b01,',
              'a10 * b10 - a11 * b08 + a13 * b06,',
              'a01 * b08 - a00 * b10 - a03 * b06,',
              'a30 * b04 - a31 * b02 + a33 * b00,',
              'a21 * b02 - a20 * b04 - a23 * b00,',
              'a11 * b07 - a10 * b09 - a12 * b06,',
              'a00 * b09 - a01 * b07 + a02 * b06,',
              'a31 * b01 - a30 * b03 - a32 * b00,',
              'a20 * b03 - a21 * b01 + a22 * b00) / det;',
          '}',
          'void main() {',
              // Prepare transforms to map to "camera view". See also:
              // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
              'mat4 viewtransformf = viewMatrix;',
              'mat4 viewtransformi = inversemat(viewMatrix);',

              // Project local vertex coordinate to camera position. Then do a step
              // backward (in cam coords) to the near clipping plane, and project back. Do
              // the same for the far clipping plane. This gives us all the information we
              // need to calculate the ray and truncate it to the viewing cone.
              'vec4 position4 = vec4(position, 1.0);',
              'vec4 pos_in_cam = viewtransformf * position4;',

              // Intersection of ray and near clipping plane (z = -1 in clip coords)
              'pos_in_cam.z = -pos_in_cam.w;',
              'v_nearpos = viewtransformi * pos_in_cam;',

              // Intersection of ray and far clipping plane (z = +1 in clip coords)
              'pos_in_cam.z = pos_in_cam.w;',
              'v_farpos = viewtransformi * pos_in_cam;',

              // Set varyings and output pos
              'v_position = position;',
              'gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;',
          '}' ].join( '\n' ),
  	fragmentShader: [
          'precision highp float;',
          'precision mediump sampler3D;',

          'uniform vec3 u_size;',
          'uniform int u_renderstyle;',
          'uniform float u_renderthreshold;',
          'uniform vec2 u_clim;',

          'uniform sampler3D u_data;',
          'uniform sampler2D u_cmdata;',

          'varying vec3 v_position;',
          'varying vec4 v_nearpos;',
          'varying vec4 v_farpos;',

          // The maximum distance through our rendering volume is sqrt(3).
          'const int MAX_STEPS = 887;  // 887 for 512^3, 1774 for 1024^3',
          'const int REFINEMENT_STEPS = 4;',
          'const float relative_step_size = 1.0;',
          'const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);',
          'const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);',
          'const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);',
          'const float shininess = 40.0;',

          'void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',
          'void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',

          'float sample1(vec3 texcoords);',
          'vec4 apply_colormap(float val);',
          'vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);',
          'void main() {',
              // Normalize clipping plane info
              'vec3 farpos = v_farpos.xyz / v_farpos.w;',
              'vec3 nearpos = v_nearpos.xyz / v_nearpos.w;',

              // Calculate unit vector pointing in the view direction through this fragment.
              'vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);',

              // Compute the (negative) distance to the front surface or near clipping plane.
              // v_position is the back face of the cuboid, so the initial distance calculated in the dot
              // product below is the distance from near clip plane to the back of the cuboid
              'float distance = dot(nearpos - v_position, view_ray);',
              'distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,',
                                          '(u_size.x - 0.5 - v_position.x) / view_ray.x));',
              'distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,',
                                          '(u_size.y - 0.5 - v_position.y) / view_ray.y));',
              'distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,',
                                          '(u_size.z - 0.5 - v_position.z) / view_ray.z));',

                                          // Now we have the starting position on the front surface
              'vec3 front = v_position + view_ray * distance;',

              // Decide how many steps to take
              'int nsteps = int(-distance / relative_step_size + 0.5);',
              'if ( nsteps < 1 )',
                  'discard;',

              // Get starting location and step vector in texture coordinates
              'vec3 step = ((v_position - front) / u_size) / float(nsteps);',
              'vec3 start_loc = front / u_size;',

              // For testing: show the number of steps. This helps to establish
              // whether the rays are correctly oriented
              //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',
              //'return;',

              'if (u_renderstyle == 0)',
                  'cast_mip(start_loc, step, nsteps, view_ray);',
              'else if (u_renderstyle == 1)',
                  'cast_iso(start_loc, step, nsteps, view_ray);',

              'if (gl_FragColor.a < 0.05)',
                  'discard;',
          '}',
          'float sample1(vec3 texcoords) {',
              '',
              'return texture(u_data, texcoords.xyz).r;',
          '}',
          'vec4 apply_colormap(float val) {',
              'val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);',
              'return texture2D(u_cmdata, vec2(val, 0.5));',
          '}',
          'void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',

              'float max_val = -1e6;',
              'int max_i = 100;',
              'vec3 loc = start_loc;',

              // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
              // non-constant expression. So we use a hard-coded max, and an additional condition
              // inside the loop.
              'for (int iter=0; iter<MAX_STEPS; iter++) {',
                  'if (iter >= nsteps)',
                      'break;',
                  // Sample from the 3D texture
                  'float val = sample1(loc);',
                  // Apply MIP operation
                  'if (val > max_val) {',
                      'max_val = val;',
                      'max_i = iter;',
                  '}',
                  // Advance location deeper into the volume
                  'loc += step;',
              '}',

              // Refine location, gives crispier images
              'vec3 iloc = start_loc + step * (float(max_i) - 0.5);',
              'vec3 istep = step / float(REFINEMENT_STEPS);',
              'for (int i=0; i<REFINEMENT_STEPS; i++) {',
                  'max_val = max(max_val, sample1(iloc));',
                  'iloc += istep;',
              '}',

              // Resolve final color
              'gl_FragColor = apply_colormap(max_val);',
          '}',
          'void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',

              'gl_FragColor = vec4(0.0);  // init transparent',
              'vec4 color3 = vec4(0.0);  // final color',
              'vec3 dstep = 1.5 / u_size;  // step to sample derivative',
              'vec3 loc = start_loc;',

              'float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);',

              // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
              // non-constant expression. So we use a hard-coded max, and an additional condition
              // inside the loop.
              'for (int iter=0; iter<MAX_STEPS; iter++) {',
                  'if (iter >= nsteps)',
                      'break;',

                      // Sample from the 3D texture
                  'float val = sample1(loc);',

                  'if (val > low_threshold) {',
                  // Take the last interval in smaller steps
                      'vec3 iloc = loc - 0.5 * step;',
                      'vec3 istep = step / float(REFINEMENT_STEPS);',
                      'for (int i=0; i<REFINEMENT_STEPS; i++) {',
                          'val = sample1(iloc);',
                          'if (val > u_renderthreshold) {',
                              'gl_FragColor = add_lighting(val, iloc, dstep, view_ray);',
                              'return;',
                          '}',
                          'iloc += istep;',
                      '}',
                  '}',

                  // Advance location deeper into the volume
                  'loc += step;',
              '}',
          '}',
          'vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)',
          '{',
              // Calculate color by incorporating lighting

              // View direction
              'vec3 V = normalize(view_ray);',

              // calculate normal vector from gradient
              'vec3 N;',
              'float val1, val2;',
              'val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));',
              'val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));',
              'N[0] = val1 - val2;',
              'val = max(max(val1, val2), val);',
              'val1 = sample1(loc + vec3(0.0, -step[1], 0.0));',
              'val2 = sample1(loc + vec3(0.0, +step[1], 0.0));',
              'N[1] = val1 - val2;',
              'val = max(max(val1, val2), val);',
              'val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));',
              'val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));',
              'N[2] = val1 - val2;',
              'val = max(max(val1, val2), val);',

              'float gm = length(N); // gradient magnitude',
              'N = normalize(N);',

              // Flip normal so it points towards viewer
              'float Nselect = float(dot(N, V) > 0.0);',
              'N = (2.0 * Nselect - 1.0) * N;  // ==  Nselect * N - (1.0-Nselect)*N;',

              // Init colors
              'vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);',
              'vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);',
              'vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);',

              // note: could allow multiple lights
              'for (int i=0; i<1; i++)',
              '{',
                   // Get light direction (make sure to prevent zero devision)
                  'vec3 L = normalize(view_ray);  //lightDirs[i];',
                  'float lightEnabled = float( length(L) > 0.0 );',
                  'L = normalize(L + (1.0 - lightEnabled));',

                  // Calculate lighting properties
                  'float lambertTerm = clamp(dot(N, L), 0.0, 1.0);',
                  'vec3 H = normalize(L+V); // Halfway vector',
                  'float specularTerm = pow(max(dot(H, N), 0.0), shininess);',

                  // Calculate mask
                  'float mask1 = lightEnabled;',

                  // Calculate colors
                  'ambient_color +=  mask1 * ambient_color;  // * gl_LightSource[i].ambient;',
                  'diffuse_color +=  mask1 * lambertTerm;',
                  'specular_color += mask1 * specularTerm * specular_color;',
              '}',

              // Calculate final color by componing different components
              'vec4 final_color;',
              'vec4 color = apply_colormap(val);',
              'final_color = color * (ambient_color + diffuse_color) + specular_color;',
              'final_color.a = color.a;',
              'return final_color;',
          '}' ].join( '\n' )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var WaterRefractionShader = {

  	uniforms: {

  		'color': {
  			type: 'c',
  			value: null
  		},

  		'time': {
  			type: 'f',
  			value: 0
  		},

  		'tDiffuse': {
  			type: 't',
  			value: null
  		},

  		'tDudv': {
  			type: 't',
  			value: null
  		},

  		'textureMatrix': {
  			type: 'm4',
  			value: null
  		}

  	},

  	vertexShader: [

  		'uniform mat4 textureMatrix;',

  		'varying vec2 vUv;',
  		'varying vec4 vUvRefraction;',

  		'void main() {',

  		'	vUv = uv;',

  		'	vUvRefraction = textureMatrix * vec4( position, 1.0 );',

  		'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

  		'}'

  	].join( '\n' ),

  	fragmentShader: [

  		'uniform vec3 color;',
  		'uniform float time;',
  		'uniform sampler2D tDiffuse;',
  		'uniform sampler2D tDudv;',

  		'varying vec2 vUv;',
  		'varying vec4 vUvRefraction;',

  		'float blendOverlay( float base, float blend ) {',

  		'	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',

  		'}',

  		'vec3 blendOverlay( vec3 base, vec3 blend ) {',

  		'	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );',

  		'}',

  		'void main() {',

  		' float waveStrength = 0.1;',
  		' float waveSpeed = 0.03;',

  		// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)

  		'	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;',
  		'	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );',
  		'	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',

  		// new uv coords

  		' vec4 uv = vec4( vUvRefraction );',
  		' uv.xy += distortion;',

  		'	vec4 base = texture2DProj( tDiffuse, uv );',

  		'	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',

  		'}'

  	].join( '\n' )
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderSkin = {
  	'skinSimple' : {

  		uniforms: UniformsUtils.merge( [

  			UniformsLib[ "fog" ],
  			UniformsLib[ "lights" ],

  			{

  				"enableBump": { value: 0 },
  				"enableSpecular": { value: 0 },

  				"tDiffuse": { value: null },
  				"tBeckmann": { value: null },

  				"diffuse": { value: new Color( 0xeeeeee ) },
  				"specular": { value: new Color( 0x111111 ) },
  				"opacity": { value: 1 },

  				"uRoughness": { value: 0.15 },
  				"uSpecularBrightness": { value: 0.75 },

  				"bumpMap": { value: null },
  				"bumpScale": { value: 1 },

  				"specularMap": { value: null },

  				"offsetRepeat": { value: new Vector4( 0, 0, 1, 1 ) },

  				"uWrapRGB": { value: new Vector3( 0.75, 0.375, 0.1875 ) }

  			}

  		] ),

  		fragmentShader: [

  			"#define USE_BUMPMAP",

  			"uniform bool enableBump;",
  			"uniform bool enableSpecular;",

  			"uniform vec3 diffuse;",
  			"uniform vec3 specular;",
  			"uniform float opacity;",

  			"uniform float uRoughness;",
  			"uniform float uSpecularBrightness;",

  			"uniform vec3 uWrapRGB;",

  			"uniform sampler2D tDiffuse;",
  			"uniform sampler2D tBeckmann;",

  			"uniform sampler2D specularMap;",

  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],
  			ShaderChunk[ "bsdfs" ],
  			ShaderChunk[ "packing" ],
  			ShaderChunk[ "lights_pars_begin" ],
  			ShaderChunk[ "fog_pars_fragment" ],
  			ShaderChunk[ "bumpmap_pars_fragment" ],

  			// Fresnel term

  			"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {",

  				"float base = 1.0 - dot( V, H );",
  				"float exponential = pow( base, 5.0 );",

  				"return exponential + F0 * ( 1.0 - exponential );",

  			"}",

  			// Kelemen/Szirmay-Kalos specular BRDF

  			"float KS_Skin_Specular( vec3 N,", 		// Bumped surface normal
  									"vec3 L,", 		// Points to light
  									"vec3 V,", 		// Points to eye
  									"float m,",  	// Roughness
  									"float rho_s", 	// Specular brightness
  									") {",

  				"float result = 0.0;",
  				"float ndotl = dot( N, L );",

  				"if( ndotl > 0.0 ) {",

  					"vec3 h = L + V;", // Unnormalized half-way vector
  					"vec3 H = normalize( h );",

  					"float ndoth = dot( N, H );",

  					"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );",

  					"float F = fresnelReflectance( H, V, 0.028 );",
  					"float frSpec = max( PH * F / dot( h, h ), 0.0 );",

  					"result = ndotl * rho_s * frSpec;", // BRDF * dot(N,L) * rho_s

  				"}",

  				"return result;",

  			"}",

  			"void main() {",

  				"vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
  				"vec4 diffuseColor = vec4( diffuse, opacity );",

  				"vec4 colDiffuse = texture2D( tDiffuse, vUv );",
  				"colDiffuse.rgb *= colDiffuse.rgb;",

  				"diffuseColor = diffuseColor * colDiffuse;",

  				"vec3 normal = normalize( vNormal );",
  				"vec3 viewerDirection = normalize( vViewPosition );",

  				"float specularStrength;",

  				"if ( enableSpecular ) {",

  					"vec4 texelSpecular = texture2D( specularMap, vUv );",
  					"specularStrength = texelSpecular.r;",

  				"} else {",

  					"specularStrength = 1.0;",

  				"}",

  				"#ifdef USE_BUMPMAP",

  					"if ( enableBump ) normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

  				"#endif",

  				// point lights

  				"vec3 totalSpecularLight = vec3( 0.0 );",
  				"vec3 totalDiffuseLight = vec3( 0.0 );",

  				"#if NUM_POINT_LIGHTS > 0",

  					"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",

  						"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;",

  						"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );",

  						"lVector = normalize( lVector );",

  						"float pointDiffuseWeightFull = max( dot( normal, lVector ), 0.0 );",
  						"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, lVector ) + 0.5, 0.0 );",
  						"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), uWrapRGB );",

  						"float pointSpecularWeight = KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );",

  						"totalDiffuseLight += pointLight[ i ].color * ( pointDiffuseWeight * attenuation );",
  						"totalSpecularLight += pointLight[ i ].color * specular * ( pointSpecularWeight * specularStrength * attenuation );",

  					"}",

  				"#endif",

  				// directional lights

  				"#if NUM_DIR_LIGHTS > 0",

  					"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {",

  						"vec3 dirVector = directionalLights[ i ].direction;",

  						"float dirDiffuseWeightFull = max( dot( normal, dirVector ), 0.0 );",
  						"float dirDiffuseWeightHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",
  						"vec3 dirDiffuseWeight = mix( vec3 ( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), uWrapRGB );",

  						"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );",

  						"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;",
  						"totalSpecularLight += directionalLights[ i ].color * ( dirSpecularWeight * specularStrength );",

  					"}",

  				"#endif",

  				// hemisphere lights

  				"#if NUM_HEMI_LIGHTS > 0",

  					"for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",

  						"vec3 lVector = hemisphereLightDirection[ i ];",

  						"float dotProduct = dot( normal, lVector );",
  						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

  						"totalDiffuseLight += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

  						// specular (sky light)

  						"float hemiSpecularWeight = 0.0;",
  						"hemiSpecularWeight += KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );",

  						// specular (ground light)

  						"vec3 lVectorGround = -lVector;",
  						"hemiSpecularWeight += KS_Skin_Specular( normal, lVectorGround, viewerDirection, uRoughness, uSpecularBrightness );",

  						"vec3 hemiSpecularColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

  						"totalSpecularLight += hemiSpecularColor * specular * ( hemiSpecularWeight * specularStrength );",

  					"}",

  				"#endif",

  				"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor * diffuse ) + totalSpecularLight;",

  				"gl_FragColor = linearToOutputTexel( vec4( outgoingLight, diffuseColor.a ) );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

  				ShaderChunk[ "fog_fragment" ],

  			"}"

  		].join( "\n" ),

  		vertexShader: [

  			"uniform vec4 offsetRepeat;",

  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],
  			ShaderChunk[ "lights_pars_begin" ],
  			ShaderChunk[ "fog_pars_vertex" ],

  			"void main() {",

  				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
  				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

  				"vViewPosition = -mvPosition.xyz;",

  				"vNormal = normalize( normalMatrix * normal );",

  				"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

  				"gl_Position = projectionMatrix * mvPosition;",

  				ShaderChunk[ "fog_vertex" ],

  			"}"

  		].join( "\n" )

  	},
  	'skin' : {

  		uniforms: UniformsUtils.merge( [

  			UniformsLib[ "fog" ],
  			UniformsLib[ "lights" ],

  			{

  				"passID": { value: 0 },

  				"tDiffuse"	: { value: null },
  				"tNormal"	: { value: null },

  				"tBlur1"	: { value: null },
  				"tBlur2"	: { value: null },
  				"tBlur3"	: { value: null },
  				"tBlur4"	: { value: null },

  				"tBeckmann"	: { value: null },

  				"uNormalScale": { value: 1.0 },

  				"diffuse":  { value: new Color( 0xeeeeee ) },
  				"specular": { value: new Color( 0x111111 ) },
  				"opacity": 	  { value: 1 },

  				"uRoughness": 	  		{ value: 0.15 },
  				"uSpecularBrightness": 	{ value: 0.75 }

  			}

  		] ),

  		fragmentShader: [

  			"uniform vec3 diffuse;",
  			"uniform vec3 specular;",
  			"uniform float opacity;",

  			"uniform float uRoughness;",
  			"uniform float uSpecularBrightness;",

  			"uniform int passID;",

  			"uniform sampler2D tDiffuse;",
  			"uniform sampler2D tNormal;",

  			"uniform sampler2D tBlur1;",
  			"uniform sampler2D tBlur2;",
  			"uniform sampler2D tBlur3;",
  			"uniform sampler2D tBlur4;",

  			"uniform sampler2D tBeckmann;",

  			"uniform float uNormalScale;",

  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],
  			ShaderChunk[ "lights_pars_begin" ],
  			ShaderChunk[ "fog_pars_fragment" ],

  			"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {",

  				"float base = 1.0 - dot( V, H );",
  				"float exponential = pow( base, 5.0 );",

  				"return exponential + F0 * ( 1.0 - exponential );",

  			"}",

  			// Kelemen/Szirmay-Kalos specular BRDF

  			"float KS_Skin_Specular( vec3 N,", 		// Bumped surface normal
  									"vec3 L,", 		// Points to light
  									"vec3 V,", 		// Points to eye
  									"float m,",  	// Roughness
  									"float rho_s", 	// Specular brightness
  									") {",

  				"float result = 0.0;",
  				"float ndotl = dot( N, L );",

  				"if( ndotl > 0.0 ) {",

  					"vec3 h = L + V;", // Unnormalized half-way vector
  					"vec3 H = normalize( h );",

  					"float ndoth = dot( N, H );",

  					"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );",
  					"float F = fresnelReflectance( H, V, 0.028 );",
  					"float frSpec = max( PH * F / dot( h, h ), 0.0 );",

  					"result = ndotl * rho_s * frSpec;", // BRDF * dot(N,L) * rho_s

  				"}",

  				"return result;",

  			"}",

  			"void main() {",

  				"vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
  				"vec4 diffuseColor = vec4( diffuse, opacity );",

  				"vec4 mSpecular = vec4( specular, opacity );",

  				"vec4 colDiffuse = texture2D( tDiffuse, vUv );",
  				"colDiffuse *= colDiffuse;",

  				"diffuseColor *= colDiffuse;",

  				// normal mapping

  				"vec4 posAndU = vec4( -vViewPosition, vUv.x );",
  				"vec4 posAndU_dx = dFdx( posAndU ),  posAndU_dy = dFdy( posAndU );",
  				"vec3 tangent = posAndU_dx.w * posAndU_dx.xyz + posAndU_dy.w * posAndU_dy.xyz;",
  				"vec3 normal = normalize( vNormal );",
  				"vec3 binormal = normalize( cross( tangent, normal ) );",
  				"tangent = cross( normal, binormal );",	// no normalization required
  				"mat3 tsb = mat3( tangent, binormal, normal );",

  				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
  				"normalTex.xy *= uNormalScale;",
  				"normalTex = normalize( normalTex );",

  				"vec3 finalNormal = tsb * normalTex;",
  				"normal = normalize( finalNormal );",

  				"vec3 viewerDirection = normalize( vViewPosition );",

  				// point lights

  				"vec3 totalDiffuseLight = vec3( 0.0 );",
  				"vec3 totalSpecularLight = vec3( 0.0 );",

  				"#if NUM_POINT_LIGHTS > 0",

  					"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",

  						"vec3 pointVector = normalize( pointLights[ i ].direction );",
  						"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );",

  						"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

  						"totalDiffuseLight += pointLightColor[ i ] * ( pointDiffuseWeight * attenuation );",

  						"if ( passID == 1 ) {",

  							"float pointSpecularWeight = KS_Skin_Specular( normal, pointVector, viewerDirection, uRoughness, uSpecularBrightness );",

  							"totalSpecularLight += pointLightColor[ i ] * mSpecular.xyz * ( pointSpecularWeight * attenuation );",

  						"}",

  					"}",

  				"#endif",

  				// directional lights

  				"#if NUM_DIR_LIGHTS > 0",

  					"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {",

  						"vec3 dirVector = directionalLights[ i ].direction;",

  						"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",
  						"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;",

  						"if ( passID == 1 ) {",

  							"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );",

  							"totalSpecularLight += directionalLights[ i ].color * mSpecular.xyz * dirSpecularWeight;",

  						"}",

  					"}",

  				"#endif",
  				"outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalSpecularLight );",

  				"if ( passID == 0 ) {",

  					"outgoingLight = sqrt( outgoingLight );",

  				"} else if ( passID == 1 ) {",

  					//"#define VERSION1",

  					"#ifdef VERSION1",

  						"vec3 nonblurColor = sqrt(outgoingLight );",

  					"#else",

  						"vec3 nonblurColor = outgoingLight;",

  					"#endif",

  					"vec3 blur1Color = texture2D( tBlur1, vUv ).xyz;",
  					"vec3 blur2Color = texture2D( tBlur2, vUv ).xyz;",
  					"vec3 blur3Color = texture2D( tBlur3, vUv ).xyz;",
  					"vec3 blur4Color = texture2D( tBlur4, vUv ).xyz;",
  					//"gl_FragColor = vec4( blur1Color, gl_FragColor.w );",

  					//"gl_FragColor = vec4( vec3( 0.22, 0.5, 0.7 ) * nonblurColor + vec3( 0.2, 0.5, 0.3 ) * blur1Color + vec3( 0.58, 0.0, 0.0 ) * blur2Color, gl_FragColor.w );",

  					//"gl_FragColor = vec4( vec3( 0.25, 0.6, 0.8 ) * nonblurColor + vec3( 0.15, 0.25, 0.2 ) * blur1Color + vec3( 0.15, 0.15, 0.0 ) * blur2Color + vec3( 0.45, 0.0, 0.0 ) * blur3Color, gl_FragColor.w );",
  					"outgoingLight = vec3( vec3( 0.22,  0.437, 0.635 ) * nonblurColor + ",
  										 "vec3( 0.101, 0.355, 0.365 ) * blur1Color + ",
  										 "vec3( 0.119, 0.208, 0.0 )   * blur2Color + ",
  										 "vec3( 0.114, 0.0,   0.0 )   * blur3Color + ",
  										 "vec3( 0.444, 0.0,   0.0 )   * blur4Color );",

  					"outgoingLight *= sqrt( colDiffuse.xyz );",

  					"outgoingLight += ambientLightColor * diffuse * colDiffuse.xyz + totalSpecularLight;",

  					"#ifndef VERSION1",

  						"outgoingLight = sqrt( outgoingLight );",

  					"#endif",

  				"}",

  				"gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

  				ShaderChunk[ "fog_fragment" ],

  			"}"

  		].join( "\n" ),

  		vertexShader: [

  			"#ifdef VERTEX_TEXTURES",

  				"uniform sampler2D tDisplacement;",
  				"uniform float uDisplacementScale;",
  				"uniform float uDisplacementBias;",

  			"#endif",

  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],
  			ShaderChunk[ "fog_pars_vertex" ],

  			"void main() {",

  				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

  				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

  				"vViewPosition = -mvPosition.xyz;",

  				"vNormal = normalize( normalMatrix * normal );",

  				"vUv = uv;",

  				// displacement mapping

  				"#ifdef VERTEX_TEXTURES",

  					"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
  					"float df = uDisplacementScale * dv.x + uDisplacementBias;",
  					"vec4 displacedPosition = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;",
  					"gl_Position = projectionMatrix * displacedPosition;",

  				"#else",

  					"gl_Position = projectionMatrix * mvPosition;",

  				"#endif",

  				ShaderChunk[ "fog_vertex" ],

  			"}" ].join( "\n" ),

  		vertexShaderUV: [

  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],

  			"void main() {",

  				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

  				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

  				"vViewPosition = -mvPosition.xyz;",

  				"vNormal = normalize( normalMatrix * normal );",

  				"vUv = uv;",

  				"gl_Position = vec4( uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 0.0, 1.0 );",

  			"}"

  		].join( "\n" )

  	},
  	"beckmann" : {

  		uniforms: {},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  				"vUv = uv;",
  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"varying vec2 vUv;",

  			"float PHBeckmann( float ndoth, float m ) {",

  				"float alpha = acos( ndoth );",
  				"float ta = tan( alpha );",

  				"float val = 1.0 / ( m * m * pow( ndoth, 4.0 ) ) * exp( -( ta * ta ) / ( m * m ) );",
  				"return val;",

  			"}",

  			"float KSTextureCompute( vec2 tex ) {",

  				// Scale the value to fit within [0,1]  invert upon lookup.

  				"return 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );",

  			"}",

  			"void main() {",

  				"float x = KSTextureCompute( vUv );",

  				"gl_FragColor = vec4( x, x, x, 1.0 );",

  			"}"

  		].join( "\n" )

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderTerrain = {
  	'terrain' : {

  		uniforms: UniformsUtils.merge( [

  			UniformsLib[ "fog" ],
  			UniformsLib[ "lights" ],

  			{

  				"enableDiffuse1": { value: 0 },
  				"enableDiffuse2": { value: 0 },
  				"enableSpecular": { value: 0 },
  				"enableReflection": { value: 0 },

  				"tDiffuse1": { value: null },
  				"tDiffuse2": { value: null },
  				"tDetail": { value: null },
  				"tNormal": { value: null },
  				"tSpecular": { value: null },
  				"tDisplacement": { value: null },

  				"uNormalScale": { value: 1.0 },

  				"uDisplacementBias": { value: 0.0 },
  				"uDisplacementScale": { value: 1.0 },

  				"diffuse": { value: new Color( 0xeeeeee ) },
  				"specular": { value: new Color( 0x111111 ) },
  				"shininess": { value: 30 },
  				"opacity": { value: 1 },

  				"uRepeatBase": { value: new Vector2( 1, 1 ) },
  				"uRepeatOverlay": { value: new Vector2( 1, 1 ) },

  				"uOffset": { value: new Vector2( 0, 0 ) }

  			}

  		] ),

  		fragmentShader: [

  			"uniform vec3 diffuse;",
  			"uniform vec3 specular;",
  			"uniform float shininess;",
  			"uniform float opacity;",

  			"uniform bool enableDiffuse1;",
  			"uniform bool enableDiffuse2;",
  			"uniform bool enableSpecular;",

  			"uniform sampler2D tDiffuse1;",
  			"uniform sampler2D tDiffuse2;",
  			"uniform sampler2D tDetail;",
  			"uniform sampler2D tNormal;",
  			"uniform sampler2D tSpecular;",
  			"uniform sampler2D tDisplacement;",

  			"uniform float uNormalScale;",

  			"uniform vec2 uRepeatOverlay;",
  			"uniform vec2 uRepeatBase;",

  			"uniform vec2 uOffset;",

  			"varying vec3 vTangent;",
  			"varying vec3 vBinormal;",
  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "common" ],
  			ShaderChunk[ "bsdfs" ],
  			ShaderChunk[ "lights_pars_begin" ],
  			ShaderChunk[ "shadowmap_pars_fragment" ],
  			ShaderChunk[ "fog_pars_fragment" ],

  			"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {",
   				"if ( decayExponent > 0.0 ) {",
   					"return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );",
   				"}",
   				"return 1.0;",
   			"}",

  			"void main() {",

  				"vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
  				"vec4 diffuseColor = vec4( diffuse, opacity );",

  				"vec3 specularTex = vec3( 1.0 );",

  				"vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;",
  				"vec2 uvBase = uRepeatBase * vUv;",

  				"vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;",
  				"normalTex.xy *= uNormalScale;",
  				"normalTex = normalize( normalTex );",

  				"if( enableDiffuse1 && enableDiffuse2 ) {",

  					"vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );",
  					"vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );",

  					"colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );",
  					"colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );",

  					"diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );",

  				" } else if( enableDiffuse1 ) {",

  					"diffuseColor *= texture2D( tDiffuse1, uvOverlay );",

  				"} else if( enableDiffuse2 ) {",

  					"diffuseColor *= texture2D( tDiffuse2, uvOverlay );",

  				"}",

  				"if( enableSpecular )",
  					"specularTex = texture2D( tSpecular, uvOverlay ).xyz;",

  				"mat3 tsb = mat3( vTangent, vBinormal, vNormal );",
  				"vec3 finalNormal = tsb * normalTex;",

  				"vec3 normal = normalize( finalNormal );",
  				"vec3 viewPosition = normalize( vViewPosition );",

  				"vec3 totalDiffuseLight = vec3( 0.0 );",
  				"vec3 totalSpecularLight = vec3( 0.0 );",

  				// point lights

  				"#if NUM_POINT_LIGHTS > 0",

  					"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",

  						"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;",

  						"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );",

  						"lVector = normalize( lVector );",

  						"vec3 pointHalfVector = normalize( lVector + viewPosition );",

  						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
  						"float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );",

  						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

  						"totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;",
  						"totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;",

  					"}",

  				"#endif",

  				// directional lights

  				"#if NUM_DIR_LIGHTS > 0",

  					"vec3 dirDiffuse = vec3( 0.0 );",
  					"vec3 dirSpecular = vec3( 0.0 );",

  					"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {",

  						"vec3 dirVector = directionalLights[ i ].direction;",
  						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",

  						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
  						"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

  						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

  						"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;",
  						"totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;",

  					"}",

  				"#endif",

  				// hemisphere lights

  				"#if NUM_HEMI_LIGHTS > 0",

  					"vec3 hemiDiffuse  = vec3( 0.0 );",
  					"vec3 hemiSpecular = vec3( 0.0 );",

  					"for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",

  						"vec3 lVector = hemisphereLightDirection[ i ];",

  						// diffuse

  						"float dotProduct = dot( normal, lVector );",
  						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

  						"totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );",

  						// specular (sky light)

  						"float hemiSpecularWeight = 0.0;",

  						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
  						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
  						"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

  						// specular (ground light)

  						"vec3 lVectorGround = -lVector;",

  						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
  						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
  						"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

  						"totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;",

  					"}",

  				"#endif",

  				"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );",

  				"gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

  				ShaderChunk[ "fog_fragment" ],

  			"}"

  		].join( "\n" ),

  		vertexShader: [

  			"attribute vec4 tangent;",

  			"uniform vec2 uRepeatBase;",

  			"uniform sampler2D tNormal;",

  			"#ifdef VERTEX_TEXTURES",

  				"uniform sampler2D tDisplacement;",
  				"uniform float uDisplacementScale;",
  				"uniform float uDisplacementBias;",

  			"#endif",

  			"varying vec3 vTangent;",
  			"varying vec3 vBinormal;",
  			"varying vec3 vNormal;",
  			"varying vec2 vUv;",

  			"varying vec3 vViewPosition;",

  			ShaderChunk[ "shadowmap_pars_vertex" ],
  			ShaderChunk[ "fog_pars_vertex" ],

  			"void main() {",

  				"vNormal = normalize( normalMatrix * normal );",

  				// tangent and binormal vectors

  				"vTangent = normalize( normalMatrix * tangent.xyz );",

  				"vBinormal = cross( vNormal, vTangent ) * tangent.w;",
  				"vBinormal = normalize( vBinormal );",

  				// texture coordinates

  				"vUv = uv;",

  				"vec2 uvBase = uv * uRepeatBase;",

  				// displacement mapping

  				"#ifdef VERTEX_TEXTURES",

  					"vec3 dv = texture2D( tDisplacement, uvBase ).xyz;",
  					"float df = uDisplacementScale * dv.x + uDisplacementBias;",
  					"vec3 displacedPosition = normal * df + position;",

  					"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",
  					"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",

  				"#else",

  					"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
  					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

  				"#endif",

  				"gl_Position = projectionMatrix * mvPosition;",

  				"vViewPosition = -mvPosition.xyz;",

  				"vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;",
  				"vNormal = normalMatrix * normalTex;",

  				ShaderChunk[ "shadowmap_vertex" ],
  				ShaderChunk[ "fog_vertex" ],

  			"}"

  		].join( "\n" )

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShaderToon = {

  	'toon1' : {

  		uniforms: {

  			"uDirLightPos": { value: new Vector3() },
  			"uDirLightColor": { value: new Color( 0xeeeeee ) },

  			"uAmbientLightColor": { value: new Color( 0x050505 ) },

  			"uBaseColor": { value: new Color( 0xffffff ) }

  		},

  		vertexShader: [

  			"varying vec3 vNormal;",
  			"varying vec3 vRefract;",

  			"void main() {",

  				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
  				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
  				"vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",

  				"vNormal = normalize( normalMatrix * normal );",

  				"vec3 I = worldPosition.xyz - cameraPosition;",
  				"vRefract = refract( normalize( I ), worldNormal, 1.02 );",

  				"gl_Position = projectionMatrix * mvPosition;",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform vec3 uBaseColor;",

  			"uniform vec3 uDirLightPos;",
  			"uniform vec3 uDirLightColor;",

  			"uniform vec3 uAmbientLightColor;",

  			"varying vec3 vNormal;",

  			"varying vec3 vRefract;",

  			"void main() {",

  				"float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);",
  				"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",

  				"float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );",
  				"intensity += length(lightWeighting) * 0.2;",

  				"float cameraWeighting = dot( normalize( vNormal ), vRefract );",
  				"intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );",
  				"intensity = intensity * 0.2 + 0.3;",

  				"if ( intensity < 0.50 ) {",

  					"gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );",

  				"} else {",

  					"gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );",

  				"}",

  			"}"

  		].join( "\n" )

  	},

  	'toon2' : {

  		uniforms: {

  			"uDirLightPos": { value: new Vector3() },
  			"uDirLightColor": { value: new Color( 0xeeeeee ) },

  			"uAmbientLightColor": { value: new Color( 0x050505 ) },

  			"uBaseColor": { value: new Color( 0xeeeeee ) },
  			"uLineColor1": { value: new Color( 0x808080 ) },
  			"uLineColor2": { value: new Color( 0x000000 ) },
  			"uLineColor3": { value: new Color( 0x000000 ) },
  			"uLineColor4": { value: new Color( 0x000000 ) }

  		},

  		vertexShader: [

  			"varying vec3 vNormal;",

  			"void main() {",

  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  				"vNormal = normalize( normalMatrix * normal );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform vec3 uBaseColor;",
  			"uniform vec3 uLineColor1;",
  			"uniform vec3 uLineColor2;",
  			"uniform vec3 uLineColor3;",
  			"uniform vec3 uLineColor4;",

  			"uniform vec3 uDirLightPos;",
  			"uniform vec3 uDirLightColor;",

  			"uniform vec3 uAmbientLightColor;",

  			"varying vec3 vNormal;",

  			"void main() {",

  				"float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);",
  				"float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);",

  				"gl_FragColor = vec4( uBaseColor, 1.0 );",

  				"if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {",

  					"gl_FragColor *= vec4( uLineColor1, 1.0 );",

  				"}",

  				"if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {",

  					"gl_FragColor *= vec4( uLineColor2, 1.0 );",

  				"}",

  			"}"

  		].join( "\n" )

  	},

  	'hatching' : {

  		uniforms: {

  			"uDirLightPos":	{ value: new Vector3() },
  			"uDirLightColor": { value: new Color( 0xeeeeee ) },

  			"uAmbientLightColor": { value: new Color( 0x050505 ) },

  			"uBaseColor":  { value: new Color( 0xffffff ) },
  			"uLineColor1": { value: new Color( 0x000000 ) },
  			"uLineColor2": { value: new Color( 0x000000 ) },
  			"uLineColor3": { value: new Color( 0x000000 ) },
  			"uLineColor4": { value: new Color( 0x000000 ) }

  		},

  		vertexShader: [

  			"varying vec3 vNormal;",

  			"void main() {",

  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  				"vNormal = normalize( normalMatrix * normal );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform vec3 uBaseColor;",
  			"uniform vec3 uLineColor1;",
  			"uniform vec3 uLineColor2;",
  			"uniform vec3 uLineColor3;",
  			"uniform vec3 uLineColor4;",

  			"uniform vec3 uDirLightPos;",
  			"uniform vec3 uDirLightColor;",

  			"uniform vec3 uAmbientLightColor;",

  			"varying vec3 vNormal;",

  			"void main() {",

  				"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);",
  				"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",

  				"gl_FragColor = vec4( uBaseColor, 1.0 );",

  				"if ( length(lightWeighting) < 1.00 ) {",

  					"if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {",

  						"gl_FragColor = vec4( uLineColor1, 1.0 );",

  					"}",

  				"}",

  				"if ( length(lightWeighting) < 0.75 ) {",

  					"if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {",

  						"gl_FragColor = vec4( uLineColor2, 1.0 );",

  					"}",
  				"}",

  				"if ( length(lightWeighting) < 0.50 ) {",

  					"if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {",

  						"gl_FragColor = vec4( uLineColor3, 1.0 );",

  					"}",
  				"}",

  				"if ( length(lightWeighting) < 0.3465 ) {",

  					"if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {",

  						"gl_FragColor = vec4( uLineColor4, 1.0 );",

  					"}",
  				"}",

  			"}"

  		].join( "\n" )

  	},

  	'dotted' : {

  		uniforms: {

  			"uDirLightPos":	{ value: new Vector3() },
  			"uDirLightColor": { value: new Color( 0xeeeeee ) },

  			"uAmbientLightColor": { value: new Color( 0x050505 ) },

  			"uBaseColor":  { value: new Color( 0xffffff ) },
  			"uLineColor1": { value: new Color( 0x000000 ) }

  		},

  		vertexShader: [

  			"varying vec3 vNormal;",

  			"void main() {",

  				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
  				"vNormal = normalize( normalMatrix * normal );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform vec3 uBaseColor;",
  			"uniform vec3 uLineColor1;",
  			"uniform vec3 uLineColor2;",
  			"uniform vec3 uLineColor3;",
  			"uniform vec3 uLineColor4;",

  			"uniform vec3 uDirLightPos;",
  			"uniform vec3 uDirLightColor;",

  			"uniform vec3 uAmbientLightColor;",

  			"varying vec3 vNormal;",

  			"void main() {",

  				"float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);",
  				"vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;",

  				"gl_FragColor = vec4( uBaseColor, 1.0 );",

  				"if ( length(lightWeighting) < 1.00 ) {",

  					"if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {",

  						"gl_FragColor = vec4( uLineColor1, 1.0 );",

  					"}",

  				"}",

  				"if ( length(lightWeighting) < 0.50 ) {",

  					"if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {",

  						"gl_FragColor = vec4( uLineColor1, 1.0 );",

  					"}",

  				"}",

  			"}"

  		].join( "\n" )

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TranslucentShader = function TranslucentShader() {
  	this.uniforms = UniformsUtils.merge( [

  		UniformsLib[ "common" ],
  		UniformsLib[ "lights" ],

  		{
  			"color":  { value: new Color( 0xffffff ) },
  			"diffuse":  { value: new Color( 0xffffff ) },
  			"specular": { value: new Color( 0xffffff ) },
  			"emissive": { value: new Color( 0x000000 ) },
  			"opacity": { value: 1 },
  			"shininess": { value: 1 },

  			"thicknessMap": { value: null },
  			"thicknessColor": { value: new Color( 0xffffff ) },
  			"thicknessDistortion": { value: 0.1 },
  			"thicknessAmbient": { value: 0.0 },
  			"thicknessAttenuation": { value: 0.1 },
  			"thicknessPower": { value: 2.0 },
  			"thicknessScale": { value: 10.0 }
  		}

  	] );

  	this.fragmentShader = [
  		"#define USE_MAP",
  		"#define PHONG",
  		"#define TRANSLUCENT",
  		"#include <common>",
  		"#include <bsdfs>",
  		"#include <uv_pars_fragment>",
  		"#include <map_pars_fragment>",
  		"#include <lights_phong_pars_fragment>",

  		"varying vec3 vColor;",

  		"uniform vec3 diffuse;",
  		"uniform vec3 specular;",
  		"uniform vec3 emissive;",
  		"uniform float opacity;",
  		"uniform float shininess;",

  		// Translucency
  		"uniform sampler2D thicknessMap;",
  		"uniform float thicknessPower;",
  		"uniform float thicknessScale;",
  		"uniform float thicknessDistortion;",
  		"uniform float thicknessAmbient;",
  		"uniform float thicknessAttenuation;",
  		"uniform vec3 thicknessColor;",

  		ShaderChunk[ "lights_pars_begin" ],

  		"void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {",
  		"	vec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;",
  		"	vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));",
  		"	float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;",
  		"	vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;",
  		"	reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;",
  		"}",

  		"void main() {",

  		"	vec3 normal = normalize( vNormal );",

  		"	vec3 viewerDirection = normalize( vViewPosition );",

  		"	vec4 diffuseColor = vec4( diffuse, opacity );",
  		"	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",

  			ShaderChunk[ "map_fragment" ],
  			ShaderChunk[ "color_fragment" ],
  			ShaderChunk[ "specularmap_fragment" ],

  		"	vec3 totalEmissiveRadiance = emissive;",

  			ShaderChunk["lights_phong_fragment"],

  		// Doing lights fragment begin.
  		"	GeometricContext geometry;",
  		"	geometry.position = - vViewPosition;",
  		"	geometry.normal = normal;",
  		"	geometry.viewDir = normalize( vViewPosition );",

  		"	IncidentLight directLight;",

  		"	#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )",

  		"		PointLight pointLight;",

  		"		#pragma unroll_loop",
  		"		for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {",
  		"		 	pointLight = pointLights[ i ];",
  		"		 	getPointDirectLightIrradiance( pointLight, geometry, directLight );",

  		"			#ifdef USE_SHADOWMAP",
  		"			directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;",
  		"			#endif",

  		"			RE_Direct( directLight, geometry, material, reflectedLight );",

  		"			#if defined( TRANSLUCENT ) && defined( USE_MAP )",
  		"			RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);",
  		"			#endif",
  		"		}",

  		"		#endif",

  		"	#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )",

  		"		DirectionalLight directionalLight;",

  		"		#pragma unroll_loop",
  		"		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
  		"			directionalLight = directionalLights[ i ];",
  		"			getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );",

  		"			#ifdef USE_SHADOWMAP",
  		"			directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;",
  		"			#endif",

  		"			RE_Direct( directLight, geometry, material, reflectedLight );",

  		"			#if defined( TRANSLUCENT ) && defined( USE_MAP )",
  		"			RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);",
  		"			#endif",
  		"		}",

  		"	#endif",

  		"	#if defined( RE_IndirectDiffuse )",

  		"		vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );",

  		"		#if ( NUM_HEMI_LIGHTS > 0 )",

  		"			#pragma unroll_loop",
  		"			for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {",

  		"				irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );",

  		"			}",

  		"		#endif",

  		"	#endif",

  		"	#if defined( RE_IndirectSpecular )",

  		"		vec3 radiance = vec3( 0.0 );",
  		"		vec3 clearCoatRadiance = vec3( 0.0 );",

  		"	#endif",
  			ShaderChunk["lights_fragment_end"],

  		"	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
  		"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",	// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

  			ShaderChunk["encodings_fragment"],

  		"}"

  	].join( "\n" ),

  	this.vertexShader = [

  		"varying vec3 vNormal;",
  		"varying vec2 vUv;",

  		"varying vec3 vViewPosition;",

  		ShaderChunk[ "common" ],

  		"void main() {",

  		"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

  		"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

  		"	vViewPosition = -mvPosition.xyz;",

  		"	vNormal = normalize( normalMatrix * normal );",

  		"	vUv = uv;",

  		"	gl_Position = projectionMatrix * mvPosition;",

  		"}" ].join( "\n" );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TimelinerController = function TimelinerController( scene, trackInfo, onUpdate ) {

  	this._scene = scene;
  	this._trackInfo = trackInfo;

  	this._onUpdate = onUpdate;

  	this._mixer = new AnimationMixer( scene );
  	this._clip = null;
  	this._action = null;

  	this._tracks = {};
  	this._propRefs = {};
  	this._channelNames = [];

  };

  TimelinerController.prototype = {

  	constructor: TimelinerController,

  	init: function( timeliner ) {
  		var this$1 = this;


  		var tracks = [],
  			trackInfo = this._trackInfo;

  		for ( var i = 0, n = trackInfo.length; i !== n; ++ i ) {

  			var spec = trackInfo[ i ];

  			tracks.push( this$1._addTrack(
  					spec.type, spec.propertyPath,
  					spec.initialValue, spec.interpolation ) );
  		}

  		this._clip = new AnimationClip( 'editclip', 0, tracks );
  		this._action = this._mixer.clipAction( this._clip ).play();

  	},

  	setDisplayTime: function( time ) {

  		this._action.time = time;
  		this._mixer.update( 0 );

  		this._onUpdate();

  	},

  	setDuration: function( duration ) {

  		this._clip.duration = duration;

  	},

  	getChannelNames: function() {

  		return this._channelNames;

  	},

  	getChannelKeyTimes: function( channelName ) {

  		return this._tracks[ channelName ].times;

  	},

  	setKeyframe: function( channelName, time ) {

  		var track = this._tracks[ channelName ],
  			times = track.times,
  			index = Timeliner.binarySearch( times, time ),
  			values = track.values,
  			stride = track.getValueSize(),
  			offset = index * stride;

  		if ( index < 0 ) {

  			// insert new keyframe

  			index = ~ index;
  			offset = index * stride;

  			var nTimes = times.length + 1,
  				nValues = values.length + stride;

  			for ( var i = nTimes - 1; i !== index; -- i ) {

  				times[ i ] = times[ i - 1 ];

  			}

  			for ( var i = nValues - 1,
  					e = offset + stride - 1; i !== e; -- i ) {

  				values[ i ] = values[ i - stride ];

  			}

  		}

  		times[ index ] = time;
  		this._propRefs[ channelName ].getValue( values, offset );

  	},

  	delKeyframe: function( channelName, time ) {

  		var track = this._tracks[ channelName ],
  			times = track.times,
  			index = Timeliner.binarySearch( times, time );

  		// we disallow to remove the keyframe when it is the last one we have,
  		// since the animation system is designed to always produce a defined
  		// state

  		if ( times.length > 1 && index >= 0 ) {

  			var nTimes = times.length - 1,
  				values = track.values,
  				stride = track.getValueSize(),
  				nValues = values.length - stride;

  			// note: no track.getValueSize when array sizes are out of sync

  			for ( var i = index; i !== nTimes; ++ i ) {

  				times[ i ] = times[ i + 1 ];

  			}

  			times.pop();

  			for ( var offset = index * stride; offset !== nValues; ++ offset ) {

  				values[ offset ] = values[ offset + stride ];

  			}

  			values.length = nValues;

  		}

  	},

  	moveKeyframe: function( channelName, time, delta, moveRemaining ) {

  		var track = this._tracks[ channelName ],
  			times = track.times,
  			index = Timeliner.binarySearch( times, time );

  		if ( index >= 0 ) {

  			var endAt = moveRemaining ? times.length : index + 1,
  				needsSort = times[ index - 1 ] <= time ||
  					! moveRemaining && time >= times[ index + 1 ];

  			while ( index !== endAt ) { times[ index ++ ] += delta; }

  			if ( needsSort ) { this._sort( track ); }

  		}

  	},

  	serialize: function() {

  		var result = {
  				duration: this._clip.duration,
  				channels: {}
  			},

  			names = this._channelNames,
  			tracks = this._tracks,

  			channels = result.channels;

  		for ( var i = 0, n = names.length; i !== n; ++ i ) {

  			var name = names[ i ],
  				track = tracks[ name ];

  			channels[ name ] = {

  				times: track.times,
  				values: track.values

  			};

  		}

  		return result;

  	},

  	deserialize: function( structs ) {
  		var this$1 = this;


  		var names = this._channelNames,
  			tracks = this._tracks,

  			channels = structs.channels;

  		this.setDuration( structs.duration );

  		for ( var i = 0, n = names.length; i !== n; ++ i ) {

  			var name = names[ i ],
  				track = tracks[ name ],
  				data = channels[ name ];

  			this$1._setArray( track.times, data.times );
  			this$1._setArray( track.values, data.values );

  		}

  		// update display
  		this.setDisplayTime( this._mixer.time );

  	},

  	_sort: function( track ) {

  		var times = track.times,
  			order = AnimationUtils.getKeyframeOrder( times );

  		this._setArray( times,
  				AnimationUtils.sortedArray( times, 1, order ) );

  		var values = track.values,
  			stride = track.getValueSize();

  		this._setArray( values,
  				AnimationUtils.sortedArray( values, stride, order ) );

  	},

  	_setArray: function( dst, src ) {

  		dst.length = 0;
  		dst.push.apply( dst, src );

  	},

  	_addTrack: function( type, prop, initialValue, interpolation ) {

  		var track = new type(
  				prop, [ 0 ], initialValue, interpolation );

  		// data must be in JS arrays so it can be resized
  		track.times = Array.prototype.slice.call( track.times );
  		track.values = Array.prototype.slice.call( track.values );

  		this._channelNames.push( prop );
  		this._tracks[ prop ] = track;

  		// for recording the state:
  		this._propRefs[ prop ] =
  				new PropertyBinding( this._scene, prop );

  		return track;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var TypedArrayUtils = {};
  TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {

  	var stack = [];
  	var sp = - 1;
  	var left = 0;
  	var right = arr.length / eleSize - 1;
  	var tmp = 0.0, x = 0, y = 0;

  	var swapF = function ( a, b ) {

  		a *= eleSize; b *= eleSize;

  		for ( y = 0; y < eleSize; y ++ ) {

  			tmp = arr[ a + y ];
  			arr[ a + y ] = arr[ b + y ];
  			arr[ b + y ] = tmp;

  		}

  	};
  	
  	var i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );

  	while ( true ) {

  		if ( right - left <= 25 ) {

  			for ( j = left + 1; j <= right; j ++ ) {

  				for ( x = 0; x < eleSize; x ++ ) {
  			
  					swap[ x ] = arr[ j * eleSize + x ];

  				}
  				
  				i = j - 1;
  				
  				while ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {

  					for ( x = 0; x < eleSize; x ++ ) {

  						arr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];

  					}

  					i --;

  				}

  				for ( x = 0; x < eleSize; x ++ ) {

  					arr[ ( i + 1 ) * eleSize + x ] = swap[ x ];

  				}

  			}
  			
  			if ( sp == - 1 ) { break; }

  			right = stack[ sp -- ]; //?
  			left = stack[ sp -- ];

  		} else {

  			var median = ( left + right ) >> 1;

  			i = left + 1;
  			j = right;
  	
  			swapF( median, i );

  			if ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {
  		
  				swapF( left, right );
  				
  			}

  			if ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {
  		
  				swapF( i, right );
  		
  			}

  			if ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {
  		
  				swapF( left, i );
  			
  			}

  			for ( x = 0; x < eleSize; x ++ ) {

  				temp[ x ] = arr[ i * eleSize + x ];

  			}
  			
  			while ( true ) {
  				
  				do { i ++; } while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );
  				do { j --; } while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );
  				
  				if ( j < i ) { break; }
  		
  				swapF( i, j );
  			
  			}

  			for ( x = 0; x < eleSize; x ++ ) {

  				arr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];
  				arr[ j * eleSize + x ] = temp[ x ];

  			}

  			if ( right - i + 1 >= j - left ) {

  				stack[ ++ sp ] = i;
  				stack[ ++ sp ] = right;
  				right = j - 1;

  			} else {

  				stack[ ++ sp ] = left;
  				stack[ ++ sp ] = j - 1;
  				left = i;

  			}

  		}

  	}

  	return arr;

  };
   TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {

  	var self = this;
  	
  	var maxDepth = 0;
  	
  	var getPointSet = function ( points, pos ) {

  		return points.subarray( pos * eleSize, pos * eleSize + eleSize );

  	};
  		
  	function buildTree( points, depth, parent, pos ) {

  		var dim = depth % eleSize,
  			median,
  			node,
  			plength = points.length / eleSize;

  		if ( depth > maxDepth ) { maxDepth = depth; }
  		
  		if ( plength === 0 ) { return null; }
  		if ( plength === 1 ) {

  			return new self.Node( getPointSet( points, 0 ), depth, parent, pos );

  		}

  		TypedArrayUtils.quicksortIP( points, eleSize, dim );
  		
  		median = Math.floor( plength / 2 );
  		
  		node = new self.Node( getPointSet( points, median ), depth, parent, median + pos );
  		node.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );
  		node.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );

  		return node;
  	
  	}

  	this.root = buildTree( points, 0, null, 0 );
  		
  	this.getMaxDepth = function () {

  		return maxDepth;

  	};
  	
  	this.nearest = function ( point, maxNodes, maxDistance ) {
  		var i,
  			result,
  			bestNodes;

  		bestNodes = new TypedArrayUtils.Kdtree.BinaryHeap(

  			function ( e ) {

  				return - e[ 1 ];

  			}

  					);

  		function nearestSearch( node ) {

  			var bestChild,
  				dimension = node.depth % eleSize,
  				ownDistance = metric( point, node.obj ),
  				linearDistance = 0,
  				otherChild,
  				i,
  				linearPoint = [];

  			function saveNode( node, distance ) {

  				bestNodes.push( [ node, distance ] );

  				if ( bestNodes.size() > maxNodes ) {

  					bestNodes.pop();

  				}

  			}

  			for ( i = 0; i < eleSize; i += 1 ) {

  				if ( i === node.depth % eleSize ) {

  					linearPoint[ i ] = point[ i ];

  				} else {

  					linearPoint[ i ] = node.obj[ i ];

  				}

  			}

  			linearDistance = metric( linearPoint, node.obj );

  			// if it's a leaf

  			if ( node.right === null && node.left === null ) {

  				if ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {

  					saveNode( node, ownDistance );

  				}

  				return;

  			}

  			if ( node.right === null ) {

  				bestChild = node.left;

  			} else if ( node.left === null ) {

  				bestChild = node.right;

  			} else {

  				if ( point[ dimension ] < node.obj[ dimension ] ) {

  					bestChild = node.left;

  				} else {

  					bestChild = node.right;

  				}

  			}

  			// recursive search

  			nearestSearch( bestChild );

  			if ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {

  				saveNode( node, ownDistance );

  			}

  			// if there's still room or the current distance is nearer than the best distance

  			if ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {

  				if ( bestChild === node.left ) {

  					otherChild = node.right;

  				} else {

  					otherChild = node.left;

  				}

  				if ( otherChild !== null ) {

  					nearestSearch( otherChild );

  				}

  			}

  		}

  		if ( maxDistance ) {

  			for ( i = 0; i < maxNodes; i += 1 ) {

  				bestNodes.push( [ null, maxDistance ] );

  			}

  		}

  		nearestSearch( self.root );

  		result = [];

  		for ( i = 0; i < maxNodes; i += 1 ) {

  			if ( bestNodes.content[ i ][ 0 ] ) {

  				result.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );

  			}

  		}
  		
  		return result;
  	
  	};
  	
  };
  TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {

  	this.obj = obj;
  	this.left = null;
  	this.right = null;
  	this.parent = parent;
  	this.depth = depth;
  	this.pos = pos;

  }; 
  TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {

  	this.content = [];
  	this.scoreFunction = scoreFunction;

  };

  TypedArrayUtils.Kdtree.BinaryHeap.prototype = {

  	push: function ( element ) {

  		// Add the new element to the end of the array.
  		this.content.push( element );

  		// Allow it to bubble up.
  		this.bubbleUp( this.content.length - 1 );

  	},

  	pop: function () {

  		// Store the first element so we can return it later.
  		var result = this.content[ 0 ];

  		// Get the element at the end of the array.
  		var end = this.content.pop();

  		// If there are any elements left, put the end element at the
  		// start, and let it sink down.
  		if ( this.content.length > 0 ) {

  			this.content[ 0 ] = end;
  			this.sinkDown( 0 );

  		}

  		return result;

  	},

  	peek: function () {

  		return this.content[ 0 ];

  	},

  	remove: function ( node ) {
  		var this$1 = this;


  		var len = this.content.length;

  		// To remove a value, we must search through the array to find it.
  		for ( var i = 0; i < len; i ++ ) {

  			if ( this$1.content[ i ] == node ) {

  				// When it is found, the process seen in 'pop' is repeated
  				// to fill up the hole.
  				var end = this$1.content.pop();

  				if ( i != len - 1 ) {

  					this$1.content[ i ] = end;

  					if ( this$1.scoreFunction( end ) < this$1.scoreFunction( node ) ) {

  						this$1.bubbleUp( i );

  					} else {

  						this$1.sinkDown( i );

  					}

  				}

  				return;

  			}

  		}

  		throw new Error( "Node not found." );

  	},

  	size: function () {

  		return this.content.length;

  	},

  	bubbleUp: function ( n ) {
  		var this$1 = this;


  		// Fetch the element that has to be moved.
  		var element = this.content[ n ];

  		// When at 0, an element can not go up any further.
  		while ( n > 0 ) {

  			// Compute the parent element's index, and fetch it.
  			var parentN = Math.floor( ( n + 1 ) / 2 ) - 1,
  				parent = this$1.content[ parentN ];

  			// Swap the elements if the parent is greater.
  			if ( this$1.scoreFunction( element ) < this$1.scoreFunction( parent ) ) {

  				this$1.content[ parentN ] = element;
  				this$1.content[ n ] = parent;

  				// Update 'n' to continue at the new position.
  				n = parentN;

  			} else {

  				// Found a parent that is less, no need to move it further.
  				break;

  			}

  		}

  	},

  	sinkDown: function ( n ) {
  		var this$1 = this;


  		// Look up the target element and its score.
  		var length = this.content.length,
  			element = this.content[ n ],
  			elemScore = this.scoreFunction( element );

  		while ( true ) {

  			// Compute the indices of the child elements.
  			var child2N = ( n + 1 ) * 2, child1N = child2N - 1;

  			// This is used to store the new position of the element, if any.
  			var swap = null;

  			// If the first child exists (is inside the array)...
  			if ( child1N < length ) {

  				// Look it up and compute its score.
  				var child1 = this$1.content[ child1N ],
  					child1Score = this$1.scoreFunction( child1 );

  				// If the score is less than our element's, we need to swap.
  				if ( child1Score < elemScore ) { swap = child1N; }

  			}

  			// Do the same checks for the other child.
  			if ( child2N < length ) {

  				var child2 = this$1.content[ child2N ],
  					child2Score = this$1.scoreFunction( child2 );

  				if ( child2Score < ( swap === null ? elemScore : child1Score ) ) { swap = child2N; }

  			}

  			// If the element needs to be moved, swap it, and continue.
  			if ( swap !== null ) {

  				this$1.content[ n ] = this$1.content[ swap ];
  				this$1.content[ swap ] = element;
  				n = swap;

  			} else {

  				// Otherwise, we are done.
  				break;

  			}

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GeometryUtils = {

  	// Merge two geometries or geometry and geometry from object (using object's transform)

  	merge: function ( geometry1, geometry2, materialIndexOffset ) {

  		console.warn( 'GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

  		var matrix;

  		if ( geometry2 instanceof Mesh ) {

  			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

  			matrix = geometry2.matrix;
  			geometry2 = geometry2.geometry;

  		}

  		geometry1.merge( geometry2, matrix, materialIndexOffset );

  	},

  	// Get random point in triangle (via barycentric coordinates)
  	// 	(uniform distribution)
  	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

  	randomPointInTriangle: function () {

  		var vector = new Vector3();

  		return function ( vectorA, vectorB, vectorC ) {

  			var point = new Vector3();

  			var a = Math.random();
  			var b = Math.random();

  			if ( ( a + b ) > 1 ) {

  				a = 1 - a;
  				b = 1 - b;

  			}

  			var c = 1 - a - b;

  			point.copy( vectorA );
  			point.multiplyScalar( a );

  			vector.copy( vectorB );
  			vector.multiplyScalar( b );

  			point.add( vector );

  			vector.copy( vectorC );
  			vector.multiplyScalar( c );

  			point.add( vector );

  			return point;

  		};

  	}(),

  	// Get random point in face (triangle)
  	// (uniform distribution)

  	randomPointInFace: function ( face, geometry ) {

  		var vA, vB, vC;

  		vA = geometry.vertices[ face.a ];
  		vB = geometry.vertices[ face.b ];
  		vC = geometry.vertices[ face.c ];

  		return GeometryUtils.randomPointInTriangle( vA, vB, vC );

  	},

  	// Get uniformly distributed random points in mesh
  	// 	- create array with cumulative sums of face areas
  	//  - pick random number from 0 to total area
  	//  - find corresponding place in area array by binary search
  	//	- get random point in face

  	randomPointsInGeometry: function ( geometry, n ) {

  		var face, i,
  			faces = geometry.faces,
  			vertices = geometry.vertices,
  			il = faces.length,
  			totalArea = 0,
  			cumulativeAreas = [],
  			vA, vB, vC;

  		// precompute face areas

  		for ( i = 0; i < il; i ++ ) {

  			face = faces[ i ];

  			vA = vertices[ face.a ];
  			vB = vertices[ face.b ];
  			vC = vertices[ face.c ];

  			face._area = GeometryUtils.triangleArea( vA, vB, vC );

  			totalArea += face._area;

  			cumulativeAreas[ i ] = totalArea;

  		}

  		// binary search cumulative areas array

  		function binarySearchIndices( value ) {

  			function binarySearch( start, end ) {

  				// return closest larger index
  				// if exact number is not found

  				if ( end < start )
  					{ return start; }

  				var mid = start + Math.floor( ( end - start ) / 2 );

  				if ( cumulativeAreas[ mid ] > value ) {

  					return binarySearch( start, mid - 1 );

  				} else if ( cumulativeAreas[ mid ] < value ) {

  					return binarySearch( mid + 1, end );

  				} else {

  					return mid;

  				}

  			}

  			var result = binarySearch( 0, cumulativeAreas.length - 1 );
  			return result;

  		}

  		// pick random face weighted by face area

  		var r, index,
  			result = [];

  		for ( i = 0; i < n; i ++ ) {

  			r = Math.random() * totalArea;

  			index = binarySearchIndices( r );

  			result[ i ] = GeometryUtils.randomPointInFace( faces[ index ], geometry );

  		}

  		return result;

  	},

  	randomPointsInBufferGeometry: function ( geometry, n ) {

  		var i,
  			vertices = geometry.attributes.position.array,
  			totalArea = 0,
  			cumulativeAreas = [],
  			vA, vB, vC;

  		// precompute face areas
  		vA = new Vector3();
  		vB = new Vector3();
  		vC = new Vector3();

  		// geometry._areas = [];
  		var il = vertices.length / 9;

  		for ( i = 0; i < il; i ++ ) {

  			vA.set( vertices[ i * 9 + 0 ], vertices[ i * 9 + 1 ], vertices[ i * 9 + 2 ] );
  			vB.set( vertices[ i * 9 + 3 ], vertices[ i * 9 + 4 ], vertices[ i * 9 + 5 ] );
  			vC.set( vertices[ i * 9 + 6 ], vertices[ i * 9 + 7 ], vertices[ i * 9 + 8 ] );

  			totalArea += GeometryUtils.triangleArea( vA, vB, vC );

  			cumulativeAreas.push( totalArea );

  		}

  		// binary search cumulative areas array

  		function binarySearchIndices( value ) {

  			function binarySearch( start, end ) {

  				// return closest larger index
  				// if exact number is not found

  				if ( end < start )
  					{ return start; }

  				var mid = start + Math.floor( ( end - start ) / 2 );

  				if ( cumulativeAreas[ mid ] > value ) {

  					return binarySearch( start, mid - 1 );

  				} else if ( cumulativeAreas[ mid ] < value ) {

  					return binarySearch( mid + 1, end );

  				} else {

  					return mid;

  				}

  			}

  			var result = binarySearch( 0, cumulativeAreas.length - 1 );
  			return result;

  		}

  		// pick random face weighted by face area

  		var r, index,
  			result = [];

  		for ( i = 0; i < n; i ++ ) {

  			r = Math.random() * totalArea;

  			index = binarySearchIndices( r );

  			// result[ i ] = GeometryUtils.randomPointInFace( faces[ index ], geometry, true );
  			vA.set( vertices[ index * 9 + 0 ], vertices[ index * 9 + 1 ], vertices[ index * 9 + 2 ] );
  			vB.set( vertices[ index * 9 + 3 ], vertices[ index * 9 + 4 ], vertices[ index * 9 + 5 ] );
  			vC.set( vertices[ index * 9 + 6 ], vertices[ index * 9 + 7 ], vertices[ index * 9 + 8 ] );
  			result[ i ] = GeometryUtils.randomPointInTriangle( vA, vB, vC );

  		}

  		return result;

  	},

  	// Get triangle area (half of parallelogram)
  	// http://mathworld.wolfram.com/TriangleArea.html

  	triangleArea: function () {

  		var vector1 = new Vector3();
  		var vector2 = new Vector3();

  		return function ( vectorA, vectorB, vectorC ) {

  			vector1.subVectors( vectorB, vectorA );
  			vector2.subVectors( vectorC, vectorA );
  			vector1.cross( vector2 );

  			return 0.5 * vector1.length();

  		};

  	}(),

  	center: function ( geometry ) {

  		console.warn( 'GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
  		return geometry.center();

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var MathUtils = {

      setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

          // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

          // rotations are applied to the axes in the order specified by 'order'
          // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
          // angles are in radians

          var cos = Math.cos;
          var sin = Math.sin;

          var c2 = cos( b / 2 );
          var s2 = sin( b / 2 );

          var c13 = cos( ( a + c ) / 2 );
          var s13 = sin( ( a + c ) / 2 );

          var c1_3 = cos( ( a - c ) / 2 );
          var s1_3 = sin( ( a - c ) / 2 );

          var c3_1 = cos( ( c - a ) / 2 );
          var s3_1 = sin( ( c - a ) / 2 );

          if ( order === 'XYX' ) {

              q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

          } else if ( order === 'YZY' ) {

              q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

          } else if ( order === 'ZXZ' ) {

              q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

          } else if ( order === 'XZX' ) {

              q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

          } else if ( order === 'YXY' ) {

              q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

          } else if ( order === 'ZYZ' ) {

              q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

          } else {

              console.warn( 'MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

          }

      }

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var SceneUtils = {

  	createMultiMaterialObject: function ( geometry, materials ) {

  		var group = new Group();

  		for ( var i = 0, l = materials.length; i < l; i ++ ) {

  			group.add( new Mesh( geometry, materials[ i ] ) );

  		}

  		return group;

  	},

  	detach: function ( child, parent, scene ) {

  		child.applyMatrix( parent.matrixWorld );
  		parent.remove( child );
  		scene.add( child );

  	},

  	attach: function ( child, scene, parent ) {

  		child.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );

  		scene.remove( child );
  		parent.add( child );

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ShadowMapViewer = function ( light ) {

  	//- Internals
  	var scope = this;
  	var doRenderLabel = ( light.name !== undefined && light.name !== '' );
  	var userAutoClearSetting;

  	//Holds the initial position and dimension of the HUD
  	var frame = {
  		x: 10,
  		y: 10,
  		width: 256,
  		height: 256
  	};

  	var camera = new OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );
  	camera.position.set( 0, 0, 2 );
  	var scene = new Scene();

  	//HUD for shadow map
  	var shader = UnpackDepthRGBAShader;

  	var uniforms = new UniformsUtils.clone( shader.uniforms );
  	var material = new ShaderMaterial( {
  		uniforms: uniforms,
  		vertexShader: shader.vertexShader,
  		fragmentShader: shader.fragmentShader
  	} );
  	var plane = new PlaneBufferGeometry( frame.width, frame.height );
  	var mesh = new Mesh( plane, material );

  	scene.add( mesh );
  	//Label for light's name
  	var labelCanvas, labelMesh;

  	if ( doRenderLabel ) {

  		labelCanvas = document.createElement( 'canvas' );

  		var context = labelCanvas.getContext( '2d' );
  		context.font = 'Bold 20px Arial';

  		var labelWidth = context.measureText( light.name ).width;
  		labelCanvas.width = labelWidth;
  		labelCanvas.height = 25;	//25 to account for g, p, etc.

  		context.font = 'Bold 20px Arial';
  		context.fillStyle = 'rgba( 255, 0, 0, 1 )';
  		context.fillText( light.name, 0, 20 );

  		var labelTexture = new Texture( labelCanvas );
  		labelTexture.magFilter = LinearFilter;
  		labelTexture.minFilter = LinearFilter;
  		labelTexture.needsUpdate = true;

  		var labelMaterial = new MeshBasicMaterial( { map: labelTexture, side: DoubleSide } );
  		labelMaterial.transparent = true;

  		var labelPlane = new PlaneBufferGeometry( labelCanvas.width, labelCanvas.height );
  		labelMesh = new Mesh( labelPlane, labelMaterial );

  		scene.add( labelMesh );

  	}
  	function resetPosition () {

  		scope.position.set( scope.position.x, scope.position.y );

  	}

  	//- API
  	// Set to false to disable displaying this shadow map
  	this.enabled = true;

  	// Set the size of the displayed shadow map on the HUD
  	this.size = {
  		width: frame.width,
  		height: frame.height,
  		set: function ( width, height ) {

  			this.width = width;
  			this.height = height;

  			mesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );

  			//Reset the position as it is off when we scale stuff
  			resetPosition();

  		}
  	};

  	// Set the position of the displayed shadow map on the HUD
  	this.position = {
  		x: frame.x,
  		y: frame.y,
  		set: function ( x, y ) {

  			this.x = x;
  			this.y = y;

  			var width = scope.size.width;
  			var height = scope.size.height;

  			mesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );

  			if ( doRenderLabel ) { labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 ); }

  		}
  	};

  	this.render = function ( renderer ) {

  		if ( this.enabled ) {

  			//Because a light's .shadowMap is only initialised after the first render pass
  			//we have to make sure the correct map is sent into the shader, otherwise we
  			//always end up with the scene's first added shadow casting light's shadowMap
  			//in the shader
  			//See: https://github.com/mrdoob/three.js/issues/5932
  			uniforms.tDiffuse.value = light.shadow.map.texture;

  			userAutoClearSetting = renderer.autoClear;
  			renderer.autoClear = false; // To allow render overlay
  			renderer.clearDepth();
  			renderer.render( scene, camera );
  			renderer.autoClear = userAutoClearSetting;	//Restore user's setting

  		}

  	};

  	this.updateForWindowResize = function () {

  		if ( this.enabled ) {

  			 camera.left = window.innerWidth / - 2;
  			 camera.right = window.innerWidth / 2;
  			 camera.top = window.innerHeight / 2;
  			 camera.bottom = window.innerHeight / - 2;
  			 camera.updateProjectionMatrix();

  			 this.update();
  		}

  	};

  	this.update = function () {

  		this.position.set( this.position.x, this.position.y );
  		this.size.set( this.size.width, this.size.height );

  	};

  	//Force an update to set position/size
  	this.update();

  };

  ShadowMapViewer.prototype.constructor = ShadowMapViewer;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function getBoneList( object ) {

  	var boneList = [];

  	if ( object && object.isBone ) {

  		boneList.push( object );

  	}

  	for ( var i = 0; i < object.children.length; i ++ ) {

  		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

  	}

  	return boneList;

  }

  function SkeletonHelper( object ) {

  	var bones = getBoneList( object );

  	var geometry = new BufferGeometry();

  	var vertices = [];
  	var colors = [];

  	var color1 = new Color( 0, 0, 1 );
  	var color2 = new Color( 0, 1, 0 );

  	for ( var i = 0; i < bones.length; i ++ ) {

  		var bone = bones[ i ];

  		if ( bone.parent && bone.parent.isBone ) {

  			vertices.push( 0, 0, 0 );
  			vertices.push( 0, 0, 0 );
  			colors.push( color1.r, color1.g, color1.b );
  			colors.push( color2.r, color2.g, color2.b );

  		}

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  	LineSegments.call( this, geometry, material );

  	this.root = object;
  	this.bones = bones;

  	this.matrix = object.matrixWorld;
  	this.matrixAutoUpdate = false;

  }

  SkeletonHelper.prototype = Object.create( LineSegments.prototype );
  SkeletonHelper.prototype.constructor = SkeletonHelper;

  SkeletonHelper.prototype.updateMatrixWorld = function () {

  	var vector = new Vector3();

  	var boneMatrix = new Matrix4();
  	var matrixWorldInv = new Matrix4();

  	return function updateMatrixWorld( force ) {

  		var bones = this.bones;

  		var geometry = this.geometry;
  		var position = geometry.getAttribute( 'position' );

  		matrixWorldInv.getInverse( this.root.matrixWorld );

  		for ( var i = 0, j = 0; i < bones.length; i ++ ) {

  			var bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j, vector.x, vector.y, vector.z );

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

  				j += 2;

  			}

  		}

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  var SkeletonUtils = {

  	retarget: function () {

  		var pos = new Vector3(),
  			quat = new Quaternion(),
  			scale = new Vector3(),
  			bindBoneMatrix = new Matrix4(),
  			relativeMatrix = new Matrix4(),
  			globalMatrix = new Matrix4();

  		return function ( target, source, options ) {
  			var this$1 = this;


  			options = options || {};
  			options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;
  			options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;
  			options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;
  			options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
  			options.hip = options.hip !== undefined ? options.hip : "hip";
  			options.names = options.names || {};

  			var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),
  				bones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),
  				bindBones,
  				bone, name, boneTo,
  				bonesPosition, i;

  			// reset bones

  			if ( target.isObject3D ) {

  				target.skeleton.pose();

  			} else {

  				options.useTargetMatrix = true;
  				options.preserveMatrix = false;

  			}

  			if ( options.preservePosition ) {

  				bonesPosition = [];

  				for ( i = 0; i < bones.length; i ++ ) {

  					bonesPosition.push( bones[ i ].position.clone() );

  				}

  			}

  			if ( options.preserveMatrix ) {

  				// reset matrix

  				target.updateMatrixWorld();

  				target.matrixWorld.identity();

  				// reset children matrix

  				for ( i = 0; i < target.children.length; ++ i ) {

  					target.children[ i ].updateMatrixWorld( true );

  				}

  			}

  			if ( options.offsets ) {

  				bindBones = [];

  				for ( i = 0; i < bones.length; ++ i ) {

  					bone = bones[ i ];
  					name = options.names[ bone.name ] || bone.name;

  					if ( options.offsets && options.offsets[ name ] ) {

  						bone.matrix.multiply( options.offsets[ name ] );

  						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  						bone.updateMatrixWorld();

  					}

  					bindBones.push( bone.matrixWorld.clone() );

  				}

  			}

  			for ( i = 0; i < bones.length; ++ i ) {

  				bone = bones[ i ];
  				name = options.names[ bone.name ] || bone.name;

  				boneTo = this$1.getBoneByName( name, sourceBones );

  				globalMatrix.copy( bone.matrixWorld );

  				if ( boneTo ) {

  					boneTo.updateMatrixWorld();

  					if ( options.useTargetMatrix ) {

  						relativeMatrix.copy( boneTo.matrixWorld );

  					} else {

  						relativeMatrix.getInverse( target.matrixWorld );
  						relativeMatrix.multiply( boneTo.matrixWorld );

  					}

  					// ignore scale to extract rotation

  					scale.setFromMatrixScale( relativeMatrix );
  					relativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );

  					// apply to global matrix

  					globalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );

  					if ( target.isObject3D ) {

  						var boneIndex = bones.indexOf( bone ),
  							wBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.getInverse( target.skeleton.boneInverses[ boneIndex ] );

  						globalMatrix.multiply( wBindMatrix );

  					}

  					globalMatrix.copyPosition( relativeMatrix );

  				}

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.getInverse( bone.parent.matrixWorld );
  					bone.matrix.multiply( globalMatrix );

  				} else {

  					bone.matrix.copy( globalMatrix );

  				}

  				if ( options.preserveHipPosition && name === options.hip ) {

  					bone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  				bone.updateMatrixWorld();

  			}

  			if ( options.preservePosition ) {

  				for ( i = 0; i < bones.length; ++ i ) {

  					bone = bones[ i ];
  					name = options.names[ bone.name ] || bone.name;

  					if ( name !== options.hip ) {

  						bone.position.copy( bonesPosition[ i ] );

  					}

  				}

  			}

  			if ( options.preserveMatrix ) {

  				// restore matrix

  				target.updateMatrixWorld( true );

  			}

  		};

  	}(),

  	retargetClip: function ( target, source, clip, options ) {
  		var this$1 = this;


  		options = options || {};
  		options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;
  		options.fps = options.fps !== undefined ? options.fps : 30;
  		options.names = options.names || [];

  		if ( ! source.isObject3D ) {

  			source = this.getHelperFromSkeleton( source );

  		}

  		var numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),
  			delta = 1 / options.fps,
  			convertedTracks = [],
  			mixer = new AnimationMixer( source ),
  			bones = this.getBones( target.skeleton ),
  			boneDatas = [],
  			positionOffset,
  			bone, boneTo, boneData,
  			name, i, j;

  		mixer.clipAction( clip ).play();
  		mixer.update( 0 );

  		source.updateMatrixWorld();

  		for ( i = 0; i < numFrames; ++ i ) {

  			var time = i * delta;

  			this$1.retarget( target, source, options );

  			for ( j = 0; j < bones.length; ++ j ) {

  				name = options.names[ bones[ j ].name ] || bones[ j ].name;

  				boneTo = this$1.getBoneByName( name, source.skeleton );

  				if ( boneTo ) {

  					bone = bones[ j ];
  					boneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };

  					if ( options.hip === name ) {

  						if ( ! boneData.pos ) {

  							boneData.pos = {
  								times: new Float32Array( numFrames ),
  								values: new Float32Array( numFrames * 3 )
  							};

  						}

  						if ( options.useFirstFramePosition ) {

  							if ( i === 0 ) {

  								positionOffset = bone.position.clone();

  							}

  							bone.position.sub( positionOffset );

  						}

  						boneData.pos.times[ i ] = time;

  						bone.position.toArray( boneData.pos.values, i * 3 );

  					}

  					if ( ! boneData.quat ) {

  						boneData.quat = {
  							times: new Float32Array( numFrames ),
  							values: new Float32Array( numFrames * 4 )
  						};

  					}

  					boneData.quat.times[ i ] = time;

  					bone.quaternion.toArray( boneData.quat.values, i * 4 );

  				}

  			}

  			mixer.update( delta );

  			source.updateMatrixWorld();

  		}

  		for ( i = 0; i < boneDatas.length; ++ i ) {

  			boneData = boneDatas[ i ];

  			if ( boneData ) {

  				if ( boneData.pos ) {

  					convertedTracks.push( new VectorKeyframeTrack(
  						".bones[" + boneData.bone.name + "].position",
  						boneData.pos.times,
  						boneData.pos.values
  					) );

  				}

  				convertedTracks.push( new QuaternionKeyframeTrack(
  					".bones[" + boneData.bone.name + "].quaternion",
  					boneData.quat.times,
  					boneData.quat.values
  				) );

  			}

  		}

  		mixer.uncacheAction( clip );

  		return new AnimationClip( clip.name, - 1, convertedTracks );

  	},

  	getHelperFromSkeleton: function ( skeleton ) {

  		var source = new SkeletonHelper( skeleton.bones[ 0 ] );
  		source.skeleton = skeleton;

  		return source;

  	},

  	getSkeletonOffsets: function () {

  		var targetParentPos = new Vector3(),
  			targetPos = new Vector3(),
  			sourceParentPos = new Vector3(),
  			sourcePos = new Vector3(),
  			targetDir = new Vector2(),
  			sourceDir = new Vector2();

  		return function ( target, source, options ) {
  			var this$1 = this;


  			options = options || {};
  			options.hip = options.hip !== undefined ? options.hip : "hip";
  			options.names = options.names || {};

  			if ( ! source.isObject3D ) {

  				source = this.getHelperFromSkeleton( source );

  			}

  			var nameKeys = Object.keys( options.names ),
  				nameValues = Object.values( options.names ),
  				sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),
  				bones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),
  				offsets = [],
  				bone, boneTo,
  				name, i;

  			target.skeleton.pose();

  			for ( i = 0; i < bones.length; ++ i ) {

  				bone = bones[ i ];
  				name = options.names[ bone.name ] || bone.name;

  				boneTo = this$1.getBoneByName( name, sourceBones );

  				if ( boneTo && name !== options.hip ) {

  					var boneParent = this$1.getNearestBone( bone.parent, nameKeys ),
  						boneToParent = this$1.getNearestBone( boneTo.parent, nameValues );

  					boneParent.updateMatrixWorld();
  					boneToParent.updateMatrixWorld();

  					targetParentPos.setFromMatrixPosition( boneParent.matrixWorld );
  					targetPos.setFromMatrixPosition( bone.matrixWorld );

  					sourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );
  					sourcePos.setFromMatrixPosition( boneTo.matrixWorld );

  					targetDir.subVectors(
  						new Vector2( targetPos.x, targetPos.y ),
  						new Vector2( targetParentPos.x, targetParentPos.y )
  					).normalize();

  					sourceDir.subVectors(
  						new Vector2( sourcePos.x, sourcePos.y ),
  						new Vector2( sourceParentPos.x, sourceParentPos.y )
  					).normalize();

  					var laterialAngle = targetDir.angle() - sourceDir.angle();

  					var offset = new Matrix4().makeRotationFromEuler(
  						new Euler(
  							0,
  							0,
  							laterialAngle
  						)
  					);

  					bone.matrix.multiply( offset );

  					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  					bone.updateMatrixWorld();

  					offsets[ name ] = offset;

  				}

  			}

  			return offsets;

  		};

  	}(),

  	renameBones: function ( skeleton, names ) {

  		var bones = this.getBones( skeleton );

  		for ( var i = 0; i < bones.length; ++ i ) {

  			var bone = bones[ i ];

  			if ( names[ bone.name ] ) {

  				bone.name = names[ bone.name ];

  			}

  		}

  		return this;

  	},

  	getBones: function ( skeleton ) {

  		return Array.isArray( skeleton ) ? skeleton : skeleton.bones;

  	},

  	getBoneByName: function ( name, skeleton ) {

  		for ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {

  			if ( name === bones[ i ].name )

  				{ return bones[ i ]; }

  		}

  	},

  	getNearestBone: function ( bone, names ) {

  		while ( bone.isBone ) {

  			if ( names.indexOf( bone.name ) !== - 1 ) {

  				return bone;

  			}

  			bone = bone.parent;

  		}

  	},

  	findBoneTrackData: function ( name, tracks ) {

  		var regexp = /\[(.*)\]\.(.*)/,
  			result = { name: name };

  		for ( var i = 0; i < tracks.length; ++ i ) {

  			// 1 is track name
  			// 2 is track type
  			var trackData = regexp.exec( tracks[ i ].name );

  			if ( trackData && name === trackData[ 1 ] ) {

  				result[ trackData[ 2 ] ] = i;

  			}

  		}

  		return result;

  	},

  	getEqualsBonesNames: function ( skeleton, targetSkeleton ) {

  		var sourceBones = this.getBones( skeleton ),
  			targetBones = this.getBones( targetSkeleton ),
  			bones = [];

  		search : for ( var i = 0; i < sourceBones.length; i ++ ) {

  			var boneName = sourceBones[ i ].name;

  			for ( var j = 0; j < targetBones.length; j ++ ) {

  				if ( boneName === targetBones[ j ].name ) {

  					bones.push( boneName );

  					continue search;

  				}

  			}

  		}

  		return bones;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var UVsDebug = function ( geometry, size ) {

  	// handles wrapping of uv.x > 1 only

  	var abc = 'abc';
  	var a = new Vector2();
  	var b = new Vector2();

  	var uvs = [
  		new Vector2(),
  		new Vector2(),
  		new Vector2()
  	];

  	var face = [];

  	var canvas = document.createElement( 'canvas' );
  	var width = size || 1024; // power of 2 required for wrapping
  	var height = size || 1024;
  	canvas.width = width;
  	canvas.height = height;

  	var ctx = canvas.getContext( '2d' );
  	ctx.lineWidth = 2;
  	ctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';
  	ctx.textAlign = 'center';

  	// paint background white

  	ctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';
  	ctx.fillRect( 0, 0, width, height );

  	if ( geometry.isGeometry ) {

  		var faces = geometry.faces;
  		var uvSet = geometry.faceVertexUvs[ 0 ];

  		for ( var i = 0, il = uvSet.length; i < il; i ++ ) {

  			var face = faces[ i ];
  			var uv = uvSet[ i ];

  			face[ 0 ] = face.a;
  			face[ 1 ] = face.b;
  			face[ 2 ] = face.c;

  			uvs[ 0 ].copy( uv[ 0 ] );
  			uvs[ 1 ].copy( uv[ 1 ] );
  			uvs[ 2 ].copy( uv[ 2 ] );

  			processFace( face, uvs, i );

  		}

  	} else {

  		var index = geometry.index;
  		var uvAttribute = geometry.attributes.uv;

  		if ( index ) {

  			// indexed geometry

  			for ( var i = 0, il = index.count; i < il; i += 3 ) {

  				face[ 0 ] = index.getX( i );
  				face[ 1 ] = index.getX( i + 1 );
  				face[ 2 ] = index.getX( i + 2 );

  				uvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );
  				uvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );
  				uvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );

  				processFace( face, uvs, i );

  			}

  		} else {

  			// non-indexed geometry

  			for ( var i = 0, il = uvAttribute.count; i < il; i += 3 ) {

  				face[ 0 ] = i;
  				face[ 1 ] = i + 1;
  				face[ 2 ] = i + 2;

  				uvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );
  				uvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );
  				uvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );

  				processFace( face, uvs, i );

  			}

  		}

  	}

  	return canvas;

  	function processFace( face, uvs, index ) {

  		// draw contour of face

  		ctx.beginPath();

  		a.set( 0, 0 );

  		for ( var j = 0, jl = uvs.length; j < jl; j ++ ) {

  			var uv = uvs[ j ];

  			a.x += uv.x;
  			a.y += uv.y;

  			if ( j === 0 ) {

  				ctx.moveTo( uv.x * width, ( 1 - uv.y ) * height );

  			} else {

  				ctx.lineTo( uv.x * width, ( 1 - uv.y ) * height );

  			}

  		}

  		ctx.closePath();
  		ctx.stroke();

  		// calculate center of face

  		a.divideScalar( uvs.length );

  		// label the face number

  		ctx.font = '12pt Arial bold';
  		ctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';
  		ctx.fillText( index, a.x * width, ( 1 - a.y ) * height );

  		if ( a.x > 0.95 ) {

  			// wrap x // 0.95 is arbitrary

  			ctx.fillText( index, ( a.x % 1 ) * width, ( 1 - a.y ) * height );

  		}

  		//

  		ctx.font = '8pt Arial bold';
  		ctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';

  		// label uv edge orders

  		for ( j = 0, jl = uvs.length; j < jl; j ++ ) {

  			var uv = uvs[ j ];
  			b.addVectors( a, uv ).divideScalar( 2 );

  			var vnum = face[ j ];
  			ctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );

  			if ( b.x > 0.95 ) {

  				// wrap x

  				ctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );

  			}

  		}

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var VolumeSlice = function ( volume, index, axis ) {

  	var slice = this;
  	
  	this.volume = volume;
  	
  	index = index || 0;
  	Object.defineProperty( this, 'index', {
  		get: function () {

  			return index;

  		},
  		set: function ( value ) {

  			index = value;
  			slice.geometryNeedsUpdate = true;
  			return index;

  		}
  	} );
  	
  	this.axis = axis || 'z';
  	this.canvas = document.createElement( 'canvas' );
  	this.canvasBuffer = document.createElement( 'canvas' );
  	this.updateGeometry();
  	var canvasMap = new Texture( this.canvas );
  	canvasMap.minFilter = LinearFilter;
  	canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;
  	var material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );
  	
  	this.mesh = new Mesh( this.geometry, material );
  	
  	this.geometryNeedsUpdate = true;
  	this.repaint();
  };

  VolumeSlice.prototype = {

  	constructor: VolumeSlice,
  	repaint: function () {
  		var this$1 = this;


  		if ( this.geometryNeedsUpdate ) {

  			this.updateGeometry();

  		}

  		var iLength = this.iLength,
  			jLength = this.jLength,
  			sliceAccess = this.sliceAccess,
  			volume = this.volume,
  			canvas = this.canvasBuffer,
  			ctx = this.ctxBuffer;
  		// get the imageData and pixel array from the canvas
  		var imgData = ctx.getImageData( 0, 0, iLength, jLength );
  		var data = imgData.data;
  		var volumeData = volume.data;
  		var upperThreshold = volume.upperThreshold;
  		var lowerThreshold = volume.lowerThreshold;
  		var windowLow = volume.windowLow;
  		var windowHigh = volume.windowHigh;

  		// manipulate some pixel elements
  		var pixelCount = 0;

  		if ( volume.dataType === 'label' ) {

  			//this part is currently useless but will be used when colortables will be handled
  			for ( var j = 0; j < jLength; j ++ ) {

  				for ( var i = 0; i < iLength; i ++ ) {

  					var label = volumeData[ sliceAccess( i, j ) ];
  					label = label >= this$1.colorMap.length ? ( label % this$1.colorMap.length ) + 1 : label;
  					var color = this$1.colorMap[ label ];
  					data[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;
  					data[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;
  					data[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;
  					data[ 4 * pixelCount + 3 ] = color & 0xff;
  					pixelCount ++;

  				}

  			}

  		} else {

  			for ( var j = 0; j < jLength; j ++ ) {

  				for ( var i = 0; i < iLength; i ++ ) {

  					var value = volumeData[ sliceAccess( i, j ) ];
  					var alpha = 0xff;
  					//apply threshold
  					alpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;
  					//apply window level
  					value = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );
  					value = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );

  					data[ 4 * pixelCount ] = value;
  					data[ 4 * pixelCount + 1 ] = value;
  					data[ 4 * pixelCount + 2 ] = value;
  					data[ 4 * pixelCount + 3 ] = alpha;
  					pixelCount ++;

  				}

  			}

  		}
  		ctx.putImageData( imgData, 0, 0 );
  		this.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );
  		this.mesh.material.map.needsUpdate = true;

  	},
  	updateGeometry: function () {

  		var extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );
  		this.sliceAccess = extracted.sliceAccess;
  		this.jLength = extracted.jLength;
  		this.iLength = extracted.iLength;
  		this.matrix = extracted.matrix;

  		this.canvas.width = extracted.planeWidth;
  		this.canvas.height = extracted.planeHeight;
  		this.canvasBuffer.width = this.iLength;
  		this.canvasBuffer.height = this.jLength;
  		this.ctx = this.canvas.getContext( '2d' );
  		this.ctxBuffer = this.canvasBuffer.getContext( '2d' );

  		if ( this.geometry ) { this.geometry.dispose(); } // dispose existing geometry

  		this.geometry = new PlaneBufferGeometry( extracted.planeWidth, extracted.planeHeight );

  		if ( this.mesh ) {

  			this.mesh.geometry = this.geometry;
  			//reset mesh matrix
  			this.mesh.matrix.identity();
  			this.mesh.applyMatrix( this.matrix );

  		}

  		this.geometryNeedsUpdate = false;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var DaydreamController = function () {

  	Object3D.call( this );

  	var scope = this;
  	var gamepad;

  	var axes = [ 0, 0 ];
  	var touchpadIsPressed = false;
  	var angularVelocity = new Vector3();

  	this.matrixAutoUpdate = false;

  	function findGamepad() {

  		// iterate across gamepads as the Daydream Controller may not be
  		// in position 0

  		var gamepads = navigator.getGamepads && navigator.getGamepads();

  		for ( var i = 0; i < 4; i ++ ) {

  			var gamepad = gamepads[ i ];

  			if ( gamepad && ( gamepad.id === 'Daydream Controller' ) ) {

  				return gamepad;

  			}

  		}

  	}

  	this.getGamepad = function () {

  		return gamepad;

  	};

  	this.getTouchpadState = function () {

  		return touchpadIsPressed;

  	};

  	this.update = function () {

  		gamepad = findGamepad();

  		if ( gamepad !== undefined && gamepad.pose !== undefined ) {

  			var pose = gamepad.pose;

  			if ( pose === null ) { return; } // no user action yet

  			//  orientation

  			if ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }

  			scope.updateMatrix();
  			scope.visible = true;

  			// angular velocity

  			if ( pose.angularVelocity !== null && ! angularVelocity.equals( pose.angularVelocity ) ) {

  				angularVelocity.fromArray( pose.angularVelocity );
  				scope.dispatchEvent( { type: 'angularvelocitychanged', angularVelocity: angularVelocity } );

  			}

  			// axes (touchpad)

  			if ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {

  				axes[ 0 ] = gamepad.axes[ 0 ];
  				axes[ 1 ] = gamepad.axes[ 1 ];
  				scope.dispatchEvent( { type: 'axischanged', axes: axes } );

  			}

  			// button (touchpad)

  			if ( touchpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {

  				touchpadIsPressed = gamepad.buttons[ 0 ].pressed;
  				scope.dispatchEvent( { type: touchpadIsPressed ? 'touchpaddown' : 'touchpadup' } );

  			}

  			// app button not available, reserved for use by the browser

  		} else {

  			scope.visible = false;

  		}

  	};

  	// DEPRECATED

  	this.getTouchPadState = function () {

  		console.warn( 'DaydreamController: getTouchPadState() is now getTouchpadState()' );
  		return touchpadIsPressed;

  	};

  };

  DaydreamController.prototype = Object.create( Object3D.prototype );
  DaydreamController.prototype.constructor = DaydreamController;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var GearVRController = function () {

  	Object3D.call( this );

  	var scope = this;
  	var gamepad;

  	var axes = [ 0, 0 ];
  	var touchpadIsPressed = false;
  	var triggerIsPressed = false;
  	var angularVelocity = new Vector3();

  	this.matrixAutoUpdate = true;

  	function findGamepad() {

  		var gamepads = navigator.getGamepads && navigator.getGamepads();

  		for ( var i = 0; i < 4; i ++ ) {

  			var gamepad = gamepads[ i ];

  			if ( gamepad && ( gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ) ) {

  				return gamepad;

  			}

  		}

  	}

  	this.getGamepad = function () {

  		return gamepad;

  	};

  	this.getTouchpadState = function () {

  		return touchpadIsPressed;

  	};

  	this.update = function () {

  		gamepad = findGamepad();

  		if ( gamepad !== undefined && gamepad.pose !== undefined ) {

  			var pose = gamepad.pose;

  			if ( pose === null ) { return; } // no user action yet

  			//  orientation

  			if ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }

  			scope.updateMatrix();
  			scope.visible = true;

  			// angular velocity

  			if ( pose.angularVelocity !== null && ! angularVelocity.equals( pose.angularVelocity ) ) {

  				angularVelocity.fromArray( pose.angularVelocity );
  				scope.dispatchEvent( { type: 'angularvelocitychanged', angularVelocity: angularVelocity } );

  			}

  			// axes (touchpad)

  			if ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {

  				axes[ 0 ] = gamepad.axes[ 0 ];
  				axes[ 1 ] = gamepad.axes[ 1 ];
  				scope.dispatchEvent( { type: 'axischanged', axes: axes } );

  			}

  			// button (touchpad)

  			if ( touchpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {

  				touchpadIsPressed = gamepad.buttons[ 0 ].pressed;
  				scope.dispatchEvent( { type: touchpadIsPressed ? 'touchpaddown' : 'touchpadup', axes: axes } );

  			}
  			// trigger

  			if ( triggerIsPressed !== gamepad.buttons[ 1 ].pressed ) {

  				triggerIsPressed = gamepad.buttons[ 1 ].pressed;
  				scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );

  			}

  		// app button not available, reserved for use by the browser

  		} else {

  			scope.visible = false;

  		}

  	};

  	// DEPRECATED

  	this.getTouchPadState = function () {

  		console.warn( 'GearVRController: getTouchPadState() is now getTouchpadState()' );
  		return touchpadIsPressed;

  	};

  	this.setHand = function () {

  		console.warn( 'GearVRController: setHand() has been removed.' );

  	};

  };

  GearVRController.prototype = Object.create( Object3D.prototype );
  GearVRController.prototype.constructor = GearVRController;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var ViveController = function ( id ) {

  	Object3D.call( this );

  	var scope = this;
  	var gamepad;

  	var axes = [ 0, 0 ];
  	var thumbpadIsPressed = false;
  	var triggerIsPressed = false;
  	var gripsArePressed = false;
  	var menuIsPressed = false;

  	function findGamepad( id ) {

  		// Iterate across gamepads as Vive Controllers may not be
  		// in position 0 and 1.

  		var gamepads = navigator.getGamepads && navigator.getGamepads();

  		for ( var i = 0, j = 0; i < gamepads.length; i ++ ) {

  			var gamepad = gamepads[ i ];

  			if ( gamepad && ( gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) || gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

  				if ( j === id ) { return gamepad; }

  				j ++;

  			}

  		}

  	}

  	this.matrixAutoUpdate = false;
  	this.standingMatrix = new Matrix4();

  	this.getGamepad = function () {

  		return gamepad;

  	};

  	this.getButtonState = function ( button ) {

  		if ( button === 'thumbpad' ) { return thumbpadIsPressed; }
  		if ( button === 'trigger' ) { return triggerIsPressed; }
  		if ( button === 'grips' ) { return gripsArePressed; }
  		if ( button === 'menu' ) { return menuIsPressed; }

  	};

  	this.update = function () {

  		gamepad = findGamepad( id );

  		if ( gamepad !== undefined && gamepad.pose !== undefined ) {

  			if ( gamepad.pose === null ) { return; } // No user action yet

  			//  Position and orientation.

  			var pose = gamepad.pose;

  			if ( pose.position !== null ) { scope.position.fromArray( pose.position ); }
  			if ( pose.orientation !== null ) { scope.quaternion.fromArray( pose.orientation ); }
  			scope.matrix.compose( scope.position, scope.quaternion, scope.scale );
  			scope.matrix.premultiply( scope.standingMatrix );	
  			scope.matrixWorldNeedsUpdate = true;
  			scope.visible = true;

  			//  Thumbpad and Buttons.

  			if ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {

  				axes[ 0 ] = gamepad.axes[ 0 ]; //  X axis: -1 = Left, +1 = Right.
  				axes[ 1 ] = gamepad.axes[ 1 ]; //  Y axis: -1 = Bottom, +1 = Top.
  				scope.dispatchEvent( { type: 'axischanged', axes: axes } );

  			}

  			if ( thumbpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {

  				thumbpadIsPressed = gamepad.buttons[ 0 ].pressed;
  				scope.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup', axes: axes } );

  			}

  			if ( triggerIsPressed !== gamepad.buttons[ 1 ].pressed ) {

  				triggerIsPressed = gamepad.buttons[ 1 ].pressed;
  				scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );

  			}

  			if ( gripsArePressed !== gamepad.buttons[ 2 ].pressed ) {

  				gripsArePressed = gamepad.buttons[ 2 ].pressed;
  				scope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );

  			}

  			if ( menuIsPressed !== gamepad.buttons[ 3 ].pressed ) {

  				menuIsPressed = gamepad.buttons[ 3 ].pressed;
  				scope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );

  			}

  		} else {

  			scope.visible = false;

  		}

  	};

  };

  ViveController.prototype = Object.create( Object3D.prototype );
  ViveController.prototype.constructor = ViveController;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // CircleGeometry

  function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'CircleGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CircleGeometry.prototype = Object.create( Geometry.prototype );
  CircleGeometry.prototype.constructor = CircleGeometry;

  // CircleBufferGeometry

  function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'CircleBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 1;
  	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, s;
  	var vertex = new Vector3();
  	var uv = new Vector2();

  	// center point

  	vertices.push( 0, 0, 0 );
  	normals.push( 0, 0, 1 );
  	uvs.push( 0.5, 0.5 );

  	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  		var segment = thetaStart + s / segments * thetaLength;

  		// vertex

  		vertex.x = radius * Math.cos( segment );
  		vertex.y = radius * Math.sin( segment );

  		vertices.push( vertex.x, vertex.y, vertex.z );

  		// normal

  		normals.push( 0, 0, 1 );

  		// uvs

  		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  		uvs.push( uv.x, uv.y );

  	}

  	// indices

  	for ( i = 1; i <= segments; i ++ ) {

  		indices.push( i, i + 1, 0 );

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // IcosahedronGeometry

  function IcosahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'IcosahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  	var vertices = [
  		- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
  		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
  		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
  	];

  	var indices = [
  		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
  		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
  		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
  		 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'IcosahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // ShapeGeometry

  function ShapeGeometry( shapes, curveSegments ) {

  	Geometry.call( this );

  	this.type = 'ShapeGeometry';

  	if ( typeof curveSegments === 'object' ) {

  		console.warn( 'ShapeGeometry: Options parameter has been removed.' );

  		curveSegments = curveSegments.curveSegments;

  	}

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
  	this.mergeVertices();

  }

  ShapeGeometry.prototype = Object.create( Geometry.prototype );
  ShapeGeometry.prototype.constructor = ShapeGeometry;

  ShapeGeometry.prototype.toJSON = function () {

  	var data = Geometry.prototype.toJSON.call( this );

  	var shapes = this.parameters.shapes;

  	return toJSON( shapes, data );

  };

  // ShapeBufferGeometry

  function ShapeBufferGeometry( shapes, curveSegments ) {
  	var this$1 = this;


  	BufferGeometry.call( this );

  	this.type = 'ShapeBufferGeometry';

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	curveSegments = curveSegments || 12;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var groupStart = 0;
  	var groupCount = 0;

  	// allow single and array values for "shapes" parameter

  	if ( Array.isArray( shapes ) === false ) {

  		addShape( shapes );

  	} else {

  		for ( var i = 0; i < shapes.length; i ++ ) {

  			addShape( shapes[ i ] );

  			this$1.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  			groupStart += groupCount;
  			groupCount = 0;

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
  	// helper functions

  	function addShape( shape ) {

  		var i, l, shapeHole;

  		var indexOffset = vertices.length / 3;
  		var points = shape.extractPoints( curveSegments );

  		var shapeVertices = points.shape;
  		var shapeHoles = points.holes;

  		// check direction of vertices

  		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

  			shapeVertices = shapeVertices.reverse();

  		}

  		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  			shapeHole = shapeHoles[ i ];

  			if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

  				shapeHoles[ i ] = shapeHole.reverse();

  			}

  		}

  		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

  		// join vertices of inner and outer paths to a single array

  		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  			shapeHole = shapeHoles[ i ];
  			shapeVertices = shapeVertices.concat( shapeHole );

  		}

  		// vertices, normals, uvs

  		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

  			var vertex = shapeVertices[ i ];

  			vertices.push( vertex.x, vertex.y, 0 );
  			normals.push( 0, 0, 1 );
  			uvs.push( vertex.x, vertex.y ); // world uvs

  		}

  		// incides

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var a = face[ 0 ] + indexOffset;
  			var b = face[ 1 ] + indexOffset;
  			var c = face[ 2 ] + indexOffset;

  			indices.push( a, b, c );
  			groupCount += 3;

  		}

  	}

  }

  ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  ShapeBufferGeometry.prototype.toJSON = function () {

  	var data = BufferGeometry.prototype.toJSON.call( this );

  	var shapes = this.parameters.shapes;

  	return toJSON( shapes, data );

  };

  //

  function toJSON( shapes, data ) {

  	data.shapes = [];

  	if ( Array.isArray( shapes ) ) {

  		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  			var shape = shapes[ i ];

  			data.shapes.push( shape.uuid );

  		}

  	} else {

  		data.shapes.push( shapes.uuid );

  	}

  	return data;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var PaintViveController = function ( id ) {

  	ViveController.call( this, id );

  	var PI2 = Math.PI * 2;

  	var MODES = { COLOR: 0, SIZE: 1 };
  	var mode = MODES.COLOR;

  	var color = new Color( 1, 1, 1 );
  	var size = 1.0;

  	//

  	function generateHueTexture() {

  		var canvas = document.createElement( 'canvas' );
  		canvas.width = 256;
  		canvas.height = 256;

  		var context = canvas.getContext( '2d' );
  		var imageData = context.getImageData( 0, 0, 256, 256 );
  		var data = imageData.data;
  		var swatchColor = new Color();

  		for ( var i = 0, j = 0; i < data.length; i += 4, j ++ ) {

  			var x = ( ( j % 256 ) / 256 ) - 0.5;
  			var y = ( Math.floor( j / 256 ) / 256 ) - 0.5;

  			swatchColor.setHSL( Math.atan2( y, x ) / PI2, 1, ( 0.5 - Math.sqrt( x * x + y * y ) ) * 2.0 );

  			data[ i + 0 ] = swatchColor.r * 256;
  			data[ i + 1 ] = swatchColor.g * 256;
  			data[ i + 2 ] = swatchColor.b * 256;
  			data[ i + 3 ] = 256;

  		}

  		context.putImageData( imageData, 0, 0 );

  		return new CanvasTexture( canvas );

  	}

  	// COLOR UI

  	var geometry = new CircleBufferGeometry( 1, 32 );
  	var material = new MeshBasicMaterial( { map: generateHueTexture() } );
  	var colorUI = new Mesh( geometry, material );
  	colorUI.position.set( 0, 0.005, 0.0495 );
  	colorUI.rotation.x = - 1.45;
  	colorUI.scale.setScalar( 0.02 );
  	this.add( colorUI );

  	var geometry = new IcosahedronBufferGeometry( 0.1, 2 );
  	var material = new MeshBasicMaterial();
  	material.color = color;
  	var ball = new Mesh( geometry, material );
  	colorUI.add( ball );
  	// SIZE UI
  	var sizeUI = new Group();
  	sizeUI.position.set( 0, 0.005, 0.0495 );
  	sizeUI.rotation.x = - 1.45;
  	sizeUI.scale.setScalar( 0.02 );
  	this.add( sizeUI );

  	var triangleShape = new Shape();
  	triangleShape.moveTo( 0, - 1 );
  	triangleShape.lineTo( 1, 1 );
  	triangleShape.lineTo( - 1, 1 );

  	var geometry = new ShapeBufferGeometry( triangleShape );
  	var material = new MeshBasicMaterial( { color: 0x222222, wireframe: true } );
  	var sizeUIOutline = new Mesh( geometry, material );
  	sizeUIOutline.position.z = 0.001;
  	resizeTriangleGeometry( sizeUIOutline.geometry, 1.0 );
  	sizeUI.add( sizeUIOutline );

  	var geometry = new ShapeBufferGeometry( triangleShape );
  	var material = new MeshBasicMaterial( { side: DoubleSide } );
  	material.color = color;
  	var sizeUIFill = new Mesh( geometry, material );
  	sizeUIFill.position.z = 0.0011;
  	resizeTriangleGeometry( sizeUIFill.geometry, 0.5 );
  	sizeUI.add( sizeUIFill );

  	sizeUI.visible = false;
  	function onAxisChanged( event ) {

  		if ( this.getButtonState( 'thumbpad' ) === false ) { return; }

  		var x = event.axes[ 0 ] / 2.0;
  		var y = - event.axes[ 1 ] / 2.0;

  		if ( mode === MODES.COLOR ) {

  			color.setHSL( Math.atan2( y, x ) / PI2, 1, ( 0.5 - Math.sqrt( x * x + y * y ) ) * 2.0 );

  			ball.position.set( event.axes[ 0 ], event.axes[ 1 ], 0 );

  		}

  		if ( mode === MODES.SIZE ) {

  			var ratio = 0.5 - y;
  			size = ratio * 2;

  			resizeTriangleGeometry( sizeUIFill.geometry, ratio );

  		}

  	}

  	function resizeTriangleGeometry( geometry, ratio ) {

  		var x = 0, y = 0;
  		var fullWidth = 0.75, fullHeight = 1.5;
  		var angle = Math.atan( ( fullWidth / 2 ) / fullHeight );

  		var bottomY = y - fullHeight / 2;
  		var height = fullHeight * ratio;
  		var width = ( Math.tan( angle ) * height ) * 2;

  		var position = geometry.attributes.position;

  		position.setXYZ( 0, x, bottomY, 0 );
  		position.setXYZ( 1, x + width / 2, bottomY + height, 0 );
  		position.setXYZ( 2, x - width / 2, bottomY + height, 0 );

  		position.needsUpdate = true;

  	}

  	function onGripsDown() {

  		if ( mode === MODES.COLOR ) {

  			mode = MODES.SIZE;
  			colorUI.visible = false;
  			sizeUI.visible = true;
  			return;

  		}

  		if ( mode === MODES.SIZE ) {

  			mode = MODES.COLOR;
  			colorUI.visible = true;
  			sizeUI.visible = false;
  			return;

  		}

  	}

  	this.getColor = function () {

  		return color;

  	};

  	this.getSize = function () {

  		return size;

  	 };

  	this.addEventListener( 'axischanged', onAxisChanged );
  	this.addEventListener( 'gripsdown', onGripsDown );

  };

  PaintViveController.prototype = Object.create( ViveController.prototype );
  PaintViveController.prototype.constructor = PaintViveController;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var WebVR = {

  	createButton: function ( renderer, options ) {

  		if ( options && options.frameOfReferenceType ) {

  			renderer.vr.setFrameOfReferenceType( options.frameOfReferenceType );

  		}

  		function showEnterVR( device ) {

  			button.style.display = '';

  			button.style.cursor = 'pointer';
  			button.style.left = 'calc(50% - 50px)';
  			button.style.width = '100px';

  			button.textContent = 'ENTER VR';

  			button.onmouseenter = function () { button.style.opacity = '1.0'; };
  			button.onmouseleave = function () { button.style.opacity = '0.5'; };

  			button.onclick = function () {

  				device.isPresenting ? device.exitPresent() : device.requestPresent( [ { source: renderer.domElement } ] );

  			};

  			renderer.vr.setDevice( device );

  		}

  		function showEnterXR( device ) {

  			var currentSession = null;

  			function onSessionStarted( session ) {

  				session.addEventListener( 'end', onSessionEnded );

  				renderer.vr.setSession( session );
  				button.textContent = 'EXIT VR';

  				currentSession = session;

  			}

  			function onSessionEnded( event ) {

  				currentSession.removeEventListener( 'end', onSessionEnded );

  				renderer.vr.setSession( null );
  				button.textContent = 'ENTER VR';

  				currentSession = null;

  			}

  			//

  			button.style.display = '';

  			button.style.cursor = 'pointer';
  			button.style.left = 'calc(50% - 50px)';
  			button.style.width = '100px';

  			button.textContent = 'ENTER VR';

  			button.onmouseenter = function () { button.style.opacity = '1.0'; };
  			button.onmouseleave = function () { button.style.opacity = '0.5'; };

  			button.onclick = function () {

  				if ( currentSession === null ) {

  					device.requestSession( { immersive: true, exclusive: true  } ).then( onSessionStarted );

  				} else {

  					currentSession.end();

  				}

  			};

  			renderer.vr.setDevice( device );

  		}

  		function showVRNotFound() {

  			button.style.display = '';

  			button.style.cursor = 'auto';
  			button.style.left = 'calc(50% - 75px)';
  			button.style.width = '150px';

  			button.textContent = 'VR NOT FOUND';

  			button.onmouseenter = null;
  			button.onmouseleave = null;

  			button.onclick = null;

  			renderer.vr.setDevice( null );

  		}

  		function stylizeElement( element ) {

  			element.style.position = 'absolute';
  			element.style.bottom = '20px';
  			element.style.padding = '12px 6px';
  			element.style.border = '1px solid #fff';
  			element.style.borderRadius = '4px';
  			element.style.background = 'rgba(0,0,0,0.1)';
  			element.style.color = '#fff';
  			element.style.font = 'normal 13px sans-serif';
  			element.style.textAlign = 'center';
  			element.style.opacity = '0.5';
  			element.style.outline = 'none';
  			element.style.zIndex = '999';

  		}

  		if ( 'xr' in navigator ) {

  			var button = document.createElement( 'button' );
  			button.style.display = 'none';

  			stylizeElement( button );

  			navigator.xr.requestDevice().then( function ( device ) {

  				device.supportsSession( { immersive: true, exclusive: true  } )
  					.then( function () { showEnterXR( device ); } )
  					.catch( showVRNotFound );

  			} ).catch( showVRNotFound );

  			return button;

  		} else if ( 'getVRDisplays' in navigator ) {

  			var button = document.createElement( 'button' );
  			button.style.display = 'none';

  			stylizeElement( button );

  			window.addEventListener( 'vrdisplayconnect', function ( event ) {

  				showEnterVR( event.display );

  			}, false );

  			window.addEventListener( 'vrdisplaydisconnect', function ( event ) {

  				showVRNotFound();

  			}, false );

  			window.addEventListener( 'vrdisplaypresentchange', function ( event ) {

  				button.textContent = event.display.isPresenting ? 'EXIT VR' : 'ENTER VR';

  			}, false );

  			window.addEventListener( 'vrdisplayactivate', function ( event ) {

  				event.display.requestPresent( [ { source: renderer.domElement } ] );

  			}, false );

  			navigator.getVRDisplays()
  				.then( function ( displays ) {

  					if ( displays.length > 0 ) {

  						showEnterVR( displays[ 0 ] );

  					} else {

  						showVRNotFound();

  					}

  				} ).catch( showVRNotFound );

  			return button;

  		} else {

  			var message = document.createElement( 'a' );
  			message.href = 'https://webvr.info';
  			message.innerHTML = 'WEBVR NOT SUPPORTED';

  			message.style.left = 'calc(50% - 90px)';
  			message.style.width = '180px';
  			message.style.textDecoration = 'none';

  			stylizeElement( message );

  			return message;

  		}

  	},

  	// DEPRECATED

  	checkAvailability: function () {
  		console.warn( 'WEBVR.checkAvailability has been deprecated.' );
  		return new Promise( function () {} );
  	},

  	getMessageContainer: function () {
  		console.warn( 'WEBVR.getMessageContainer has been deprecated.' );
  		return document.createElement( 'div' );
  	},

  	getButton: function () {
  		console.warn( 'WEBVR.getButton has been deprecated.' );
  		return document.createElement( 'div' );
  	},

  	getVRDisplay: function () {
  		console.warn( 'WEBVR.getVRDisplay has been deprecated.' );
  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var WebGL = {

  	isWebGLAvailable: function () {

  		try {

  			var canvas = document.createElement( 'canvas' );
  			return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );

  		} catch ( e ) {

  			return false;

  		}

  	},

  	isWebGL2Available: function () {

  		try {

  			var canvas = document.createElement( 'canvas' );
  			return !! ( window.WebGL2RenderingContext && canvas.getContext( 'webgl2' ) );

  		} catch ( e ) {

  			return false;

  		}

  	},

  	getWebGLErrorMessage: function () {

  		return this.getErrorMessage( 1 );

  	},

  	getWebGL2ErrorMessage: function () {

  		return this.getErrorMessage( 2 );

  	},

  	getErrorMessage: function ( version ) {

  		var names = {
  			1: 'WebGL',
  			2: 'WebGL 2'
  		};

  		var contexts = {
  			1: window.WebGLRenderingContext,
  			2: window.WebGL2RenderingContext
  		};

  		var message = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';

  		var element = document.createElement( 'div' );
  		element.id = 'webglmessage';
  		element.style.fontFamily = 'monospace';
  		element.style.fontSize = '13px';
  		element.style.fontWeight = 'normal';
  		element.style.textAlign = 'center';
  		element.style.background = '#fff';
  		element.style.color = '#000';
  		element.style.padding = '1.5em';
  		element.style.width = '400px';
  		element.style.margin = '5em auto 0';

  		if ( contexts[ version ] ) {

  			message = message.replace( '$0', 'graphics card' );

  		} else {

  			message = message.replace( '$0', 'browser' );

  		}

  		message = message.replace( '$1', names[ version ] );

  		element.innerHTML = message;

  		return element;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AnimationObjectGroup() {
  	var arguments$1 = arguments;


  	this.uuid = _Math.generateUUID();

  	// cached objects followed by the active ones
  	this._objects = Array.prototype.slice.call( arguments );

  	this.nCachedObjects_ = 0; // threshold
  	// note: read by PropertyBinding.Composite

  	var indices = {};
  	this._indicesByUUID = indices; // for bookkeeping

  	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  		indices[ arguments$1[ i ].uuid ] = i;

  	}

  	this._paths = []; // inside: string
  	this._parsedPaths = []; // inside: { we don't care, here }
  	this._bindings = []; // inside: Array< PropertyBinding >
  	this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  	var scope = this;

  	this.stats = {

  		objects: {
  			get total() {

  				return scope._objects.length;

  			},
  			get inUse() {

  				return this.total - scope.nCachedObjects_;

  			}
  		},
  		get bindingsPerObject() {

  			return scope._bindings.length;

  		}

  	};

  }

  Object.assign( AnimationObjectGroup.prototype, {

  	isAnimationObjectGroup: true,

  	add: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			bindings = this._bindings,
  			nBindings = bindings.length,
  			knownObject = undefined;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index === undefined ) {

  				// unknown object -> add it to the ACTIVE region

  				index = nObjects ++;
  				indicesByUUID[ uuid ] = index;
  				objects.push( object );

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

  				}

  			} else if ( index < nCachedObjects ) {

  				knownObject = objects[ index ];

  				// move existing object to the ACTIVE region

  				var firstActiveIndex = -- nCachedObjects,
  					lastCachedObject = objects[ firstActiveIndex ];

  				indicesByUUID[ lastCachedObject.uuid ] = index;
  				objects[ index ] = lastCachedObject;

  				indicesByUUID[ uuid ] = firstActiveIndex;
  				objects[ firstActiveIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						lastCached = bindingsForPath[ firstActiveIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = lastCached;

  					if ( binding === undefined ) {

  						// since we do not bother to create new bindings
  						// for objects that are cached, the binding may
  						// or may not exist

  						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

  					}

  					bindingsForPath[ firstActiveIndex ] = binding;

  				}

  			} else if ( objects[ index ] !== knownObject ) {

  				console.error( 'AnimationObjectGroup: Different objects with the same UUID ' +
  					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

  			} // else the object is already where we want it to be

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	remove: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined && index >= nCachedObjects ) {

  				// move existing object into the CACHED region

  				var lastCachedIndex = nCachedObjects ++,
  					firstActiveObject = objects[ lastCachedIndex ];

  				indicesByUUID[ firstActiveObject.uuid ] = index;
  				objects[ index ] = firstActiveObject;

  				indicesByUUID[ uuid ] = lastCachedIndex;
  				objects[ lastCachedIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						firstActive = bindingsForPath[ lastCachedIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = firstActive;
  					bindingsForPath[ lastCachedIndex ] = binding;

  				}

  			}

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// remove & forget
  	uncache: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined ) {

  				delete indicesByUUID[ uuid ];

  				if ( index < nCachedObjects ) {

  					// object is cached, shrink the CACHED region

  					var firstActiveIndex = -- nCachedObjects,
  						lastCachedObject = objects[ firstActiveIndex ],
  						lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					// last cached object takes this object's place
  					indicesByUUID[ lastCachedObject.uuid ] = index;
  					objects[ index ] = lastCachedObject;

  					// last object goes to the activated slot and pop
  					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
  					objects[ firstActiveIndex ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ],
  							lastCached = bindingsForPath[ firstActiveIndex ],
  							last = bindingsForPath[ lastIndex ];

  						bindingsForPath[ index ] = lastCached;
  						bindingsForPath[ firstActiveIndex ] = last;
  						bindingsForPath.pop();

  					}

  				} else {

  					// object is active, just swap with the last and pop

  					var lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					indicesByUUID[ lastObject.uuid ] = index;
  					objects[ index ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ];

  						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
  						bindingsForPath.pop();

  					}

  				} // cached or active

  			} // if object is known

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// Internal interface used by befriended PropertyBinding.Composite:

  	subscribe_: function ( path, parsedPath ) {

  		// returns an array of bindings for the given path that is changed
  		// according to the contained objects in the group

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ],
  			bindings = this._bindings;

  		if ( index !== undefined ) { return bindings[ index ]; }

  		var paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			bindingsForPath = new Array( nObjects );

  		index = bindings.length;

  		indicesByPath[ path ] = index;

  		paths.push( path );
  		parsedPaths.push( parsedPath );
  		bindings.push( bindingsForPath );

  		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

  			var object = objects[ i ];
  			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

  		}

  		return bindingsForPath;

  	},

  	unsubscribe_: function ( path ) {

  		// tells the group to forget about a property path and no longer
  		// update the array previously obtained with 'subscribe_'

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ];

  		if ( index !== undefined ) {

  			var paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				bindings = this._bindings,
  				lastBindingsIndex = bindings.length - 1,
  				lastBindings = bindings[ lastBindingsIndex ],
  				lastBindingsPath = path[ lastBindingsIndex ];

  			indicesByPath[ lastBindingsPath ] = index;

  			bindings[ index ] = lastBindings;
  			bindings.pop();

  			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
  			parsedPaths.pop();

  			paths[ index ] = paths[ lastBindingsIndex ];
  			paths.pop();

  		}

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Audio( listener ) {

  	Object3D.call( this );

  	this.type = 'Audio';

  	this.listener = listener;
  	this.context = listener.context;

  	this.gain = this.context.createGain();
  	this.gain.connect( listener.getInput() );

  	this.autoplay = false;

  	this.buffer = null;
  	this.detune = 0;
  	this.loop = false;
  	this.startTime = 0;
  	this.offset = 0;
  	this.playbackRate = 1;
  	this.isPlaying = false;
  	this.hasPlaybackControl = true;
  	this.sourceType = 'empty';

  	this.filters = [];

  }

  Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Audio,

  	getOutput: function () {

  		return this.gain;

  	},

  	setNodeSource: function ( audioNode ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'audioNode';
  		this.source = audioNode;
  		this.connect();

  		return this;

  	},

  	setMediaElementSource: function ( mediaElement ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'mediaNode';
  		this.source = this.context.createMediaElementSource( mediaElement );
  		this.connect();

  		return this;

  	},

  	setBuffer: function ( audioBuffer ) {

  		this.buffer = audioBuffer;
  		this.sourceType = 'buffer';

  		if ( this.autoplay ) { this.play(); }

  		return this;

  	},

  	play: function () {

  		if ( this.isPlaying === true ) {

  			console.warn( 'Audio: Audio is already playing.' );
  			return;

  		}

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return;

  		}

  		var source = this.context.createBufferSource();

  		source.buffer = this.buffer;
  		source.loop = this.loop;
  		source.onended = this.onEnded.bind( this );
  		this.startTime = this.context.currentTime;
  		source.start( this.startTime, this.offset );

  		this.isPlaying = true;

  		this.source = source;

  		this.setDetune( this.detune );
  		this.setPlaybackRate( this.playbackRate );

  		return this.connect();

  	},

  	pause: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return;

  		}

  		if ( this.isPlaying === true ) {

  			this.source.stop();
  			this.source.onended = null;
  			this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
  			this.isPlaying = false;

  		}

  		return this;

  	},

  	stop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.source.stop();
  		this.source.onended = null;
  		this.offset = 0;
  		this.isPlaying = false;

  		return this;

  	},

  	connect: function () {
  		var this$1 = this;


  		if ( this.filters.length > 0 ) {

  			this.source.connect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this$1.filters[ i - 1 ].connect( this$1.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

  		} else {

  			this.source.connect( this.getOutput() );

  		}

  		return this;

  	},

  	disconnect: function () {
  		var this$1 = this;


  		if ( this.filters.length > 0 ) {

  			this.source.disconnect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this$1.filters[ i - 1 ].disconnect( this$1.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

  		} else {

  			this.source.disconnect( this.getOutput() );

  		}

  		return this;

  	},

  	getFilters: function () {

  		return this.filters;

  	},

  	setFilters: function ( value ) {

  		if ( ! value ) { value = []; }

  		if ( this.isPlaying === true ) {

  			this.disconnect();
  			this.filters = value;
  			this.connect();

  		} else {

  			this.filters = value;

  		}

  		return this;

  	},

  	setDetune: function ( value ) {

  		this.detune = value;

  		if ( this.source.detune === undefined ) { return; } // only set detune when available

  		if ( this.isPlaying === true ) {

  			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

  		}

  		return this;

  	},

  	getDetune: function () {

  		return this.detune;

  	},

  	getFilter: function () {

  		return this.getFilters()[ 0 ];

  	},

  	setFilter: function ( filter ) {

  		return this.setFilters( filter ? [ filter ] : [] );

  	},

  	setPlaybackRate: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.playbackRate = value;

  		if ( this.isPlaying === true ) {

  			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

  		}

  		return this;

  	},

  	getPlaybackRate: function () {

  		return this.playbackRate;

  	},

  	onEnded: function () {

  		this.isPlaying = false;

  	},

  	getLoop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return false;

  		}

  		return this.loop;

  	},

  	setLoop: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.loop = value;

  		if ( this.isPlaying === true ) {

  			this.source.loop = this.loop;

  		}

  		return this;

  	},

  	getVolume: function () {

  		return this.gain.gain.value;

  	},

  	setVolume: function ( value ) {

  		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AudioAnalyser( audio, fftSize ) {

  	this.analyser = audio.context.createAnalyser();
  	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

  	this.data = new Uint8Array( this.analyser.frequencyBinCount );

  	audio.getOutput().connect( this.analyser );

  }

  Object.assign( AudioAnalyser.prototype, {

  	getFrequencyData: function () {

  		this.analyser.getByteFrequencyData( this.data );

  		return this.data;

  	},

  	getAverageFrequency: function () {

  		var value = 0, data = this.getFrequencyData();

  		for ( var i = 0; i < data.length; i ++ ) {

  			value += data[ i ];

  		}

  		return value / data.length;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var context;

  var AudioContext = {

  	getContext: function () {

  		if ( context === undefined ) {

  			context = new ( window.AudioContext || window.webkitAudioContext )();

  		}

  		return context;

  	},

  	setContext: function ( value ) {

  		context = value;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AudioListener() {

  	Object3D.call( this );

  	this.type = 'AudioListener';

  	this.context = AudioContext.getContext();

  	this.gain = this.context.createGain();
  	this.gain.connect( this.context.destination );

  	this.filter = null;

  	this.timeDelta = 0;

  }

  AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: AudioListener,

  	getInput: function () {

  		return this.gain;

  	},

  	removeFilter: function ( ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );
  			this.gain.connect( this.context.destination );
  			this.filter = null;

  		}

  		return this;

  	},

  	getFilter: function () {

  		return this.filter;

  	},

  	setFilter: function ( value ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );

  		} else {

  			this.gain.disconnect( this.context.destination );

  		}

  		this.filter = value;
  		this.gain.connect( this.filter );
  		this.filter.connect( this.context.destination );

  		return this;

  	},

  	getMasterVolume: function () {

  		return this.gain.gain.value;

  	},

  	setMasterVolume: function ( value ) {

  		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  		return this;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3();
  		var quaternion = new Quaternion();
  		var scale = new Vector3();

  		var orientation = new Vector3();
  		var clock = new Clock();

  		return function updateMatrixWorld( force ) {

  			Object3D.prototype.updateMatrixWorld.call( this, force );

  			var listener = this.context.listener;
  			var up = this.up;

  			this.timeDelta = clock.getDelta();

  			this.matrixWorld.decompose( position, quaternion, scale );

  			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  			if ( listener.positionX ) {

  				// code path for Chrome (see #14393)

  				var endTime = this.context.currentTime + this.timeDelta;

  				listener.positionX.linearRampToValueAtTime( position.x, endTime );
  				listener.positionY.linearRampToValueAtTime( position.y, endTime );
  				listener.positionZ.linearRampToValueAtTime( position.z, endTime );
  				listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
  				listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
  				listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
  				listener.upX.linearRampToValueAtTime( up.x, endTime );
  				listener.upY.linearRampToValueAtTime( up.y, endTime );
  				listener.upZ.linearRampToValueAtTime( up.z, endTime );

  			} else {

  				listener.setPosition( position.x, position.y, position.z );
  				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  			}

  		};

  	} )()

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PositionalAudio( listener ) {

  	Audio.call( this, listener );

  	this.panner = this.context.createPanner();
  	this.panner.connect( this.gain );

  }

  PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

  	constructor: PositionalAudio,

  	getOutput: function () {

  		return this.panner;

  	},

  	getRefDistance: function () {

  		return this.panner.refDistance;

  	},

  	setRefDistance: function ( value ) {

  		this.panner.refDistance = value;

  		return this;

  	},

  	getRolloffFactor: function () {

  		return this.panner.rolloffFactor;

  	},

  	setRolloffFactor: function ( value ) {

  		this.panner.rolloffFactor = value;

  		return this;

  	},

  	getDistanceModel: function () {

  		return this.panner.distanceModel;

  	},

  	setDistanceModel: function ( value ) {

  		this.panner.distanceModel = value;

  		return this;

  	},

  	getMaxDistance: function () {

  		return this.panner.maxDistance;

  	},

  	setMaxDistance: function ( value ) {

  		this.panner.maxDistance = value;

  		return this;

  	},

  	setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

  		this.panner.coneInnerAngle = coneInnerAngle;
  		this.panner.coneOuterAngle = coneOuterAngle;
  		this.panner.coneOuterGain = coneOuterGain;

  		return this;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3();
  		var quaternion = new Quaternion();
  		var scale = new Vector3();

  		var orientation = new Vector3();

  		return function updateMatrixWorld( force ) {

  			Object3D.prototype.updateMatrixWorld.call( this, force );

  			if ( this.hasPlaybackControl === true && this.isPlaying === false ) { return; }

  			this.matrixWorld.decompose( position, quaternion, scale );

  			orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

  			var panner = this.panner;

  			if ( panner.positionX ) {

  				// code path for Chrome and Firefox (see #14393)

  				var endTime = this.context.currentTime + this.listener.timeDelta;

  				panner.positionX.linearRampToValueAtTime( position.x, endTime );
  				panner.positionY.linearRampToValueAtTime( position.y, endTime );
  				panner.positionZ.linearRampToValueAtTime( position.z, endTime );
  				panner.orientationX.linearRampToValueAtTime( orientation.x, endTime );
  				panner.orientationY.linearRampToValueAtTime( orientation.y, endTime );
  				panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );

  			} else {

  				panner.setPosition( position.x, position.y, position.z );
  				panner.setOrientation( orientation.x, orientation.y, orientation.z );

  			}

  		};

  	} )()
  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

  	if ( typeof ( normalized ) === 'number' ) {

  		meshPerAttribute = normalized;

  		normalized = false;

  		console.error( 'InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

  	}

  	BufferAttribute.call( this, array, itemSize, normalized );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

  	constructor: InstancedBufferAttribute,

  	isInstancedBufferAttribute: true,

  	copy: function ( source ) {

  		BufferAttribute.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Font( data ) {

  	this.type = 'Font';

  	this.data = data;

  }

  Object.assign( Font.prototype, {

  	isFont: true,

  	generateShapes: function ( text, size ) {

  		if ( size === undefined ) { size = 100; }

  		var shapes = [];
  		var paths = createPaths( text, size, this.data );

  		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

  			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  		}

  		return shapes;

  	}

  } );

  function createPaths( text, size, data ) {

  	var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
  	var scale = size / data.resolution;
  	var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

  	var paths = [];

  	var offsetX = 0, offsetY = 0;

  	for ( var i = 0; i < chars.length; i ++ ) {

  		var char = chars[ i ];

  		if ( char === '\n' ) {

  			offsetX = 0;
  			offsetY -= line_height;

  		} else {

  			var ret = createPath( char, scale, offsetX, offsetY, data );
  			offsetX += ret.offsetX;
  			paths.push( ret.path );

  		}

  	}

  	return paths;

  }

  function createPath( char, scale, offsetX, offsetY, data ) {

  	var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

  	if ( ! glyph ) { return; }

  	var path = new ShapePath();

  	var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  	if ( glyph.o ) {

  		var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

  		for ( var i = 0, l = outline.length; i < l; ) {

  			var action = outline[ i ++ ];

  			switch ( action ) {

  				case 'm': // moveTo

  					x = outline[ i ++ ] * scale + offsetX;
  					y = outline[ i ++ ] * scale + offsetY;

  					path.moveTo( x, y );

  					break;

  				case 'l': // lineTo

  					x = outline[ i ++ ] * scale + offsetX;
  					y = outline[ i ++ ] * scale + offsetY;

  					path.lineTo( x, y );

  					break;

  				case 'q': // quadraticCurveTo

  					cpx = outline[ i ++ ] * scale + offsetX;
  					cpy = outline[ i ++ ] * scale + offsetY;
  					cpx1 = outline[ i ++ ] * scale + offsetX;
  					cpy1 = outline[ i ++ ] * scale + offsetY;

  					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

  					break;

  				case 'b': // bezierCurveTo

  					cpx = outline[ i ++ ] * scale + offsetX;
  					cpy = outline[ i ++ ] * scale + offsetY;
  					cpx1 = outline[ i ++ ] * scale + offsetX;
  					cpy1 = outline[ i ++ ] * scale + offsetY;
  					cpx2 = outline[ i ++ ] * scale + offsetX;
  					cpy2 = outline[ i ++ ] * scale + offsetY;

  					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

  					break;

  			}

  		}

  	}

  	return { offsetX: glyph.ha * scale, path: path };

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // ConeGeometry

  function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
  ConeGeometry.prototype.constructor = ConeGeometry;

  // ConeBufferGeometry

  function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // DodecahedronGeometry

  function DodecahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'DodecahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  	var r = 1 / t;

  	var vertices = [

  		// (1, 1, 1)
  		- 1, - 1, - 1,	- 1, - 1, 1,
  		- 1, 1, - 1, - 1, 1, 1,
  		1, - 1, - 1, 1, - 1, 1,
  		1, 1, - 1, 1, 1, 1,

  		// (0, 1/, )
  		 0, - r, - t, 0, - r, t,
  		 0, r, - t, 0, r, t,

  		// (1/, , 0)
  		- r, - t, 0, - r, t, 0,
  		 r, - t, 0, r, t, 0,

  		// (, 0, 1/)
  		- t, 0, - r, t, 0, - r,
  		- t, 0, r, t, 0, r
  	];

  	var indices = [
  		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
  		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
  		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
  		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
  		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
  		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
  		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
  		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
  		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
  		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
  		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
  		1, 12, 14, 	1, 14, 5, 	1, 5, 9
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'DodecahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function EdgesGeometry( geometry, thresholdAngle ) {

  	BufferGeometry.call( this );

  	this.type = 'EdgesGeometry';

  	this.parameters = {
  		thresholdAngle: thresholdAngle
  	};

  	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  	// buffer

  	var vertices = [];

  	// helper variables

  	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
  	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];

  	// prepare source geometry

  	var geometry2;

  	if ( geometry.isBufferGeometry ) {

  		geometry2 = new Geometry();
  		geometry2.fromBufferGeometry( geometry );

  	} else {

  		geometry2 = geometry.clone();

  	}

  	geometry2.mergeVertices();
  	geometry2.computeFaceNormals();

  	var sourceVertices = geometry2.vertices;
  	var faces = geometry2.faces;

  	// now create a data structure where each entry represents an edge with its adjoining faces

  	for ( var i = 0, l = faces.length; i < l; i ++ ) {

  		var face = faces[ i ];

  		for ( var j = 0; j < 3; j ++ ) {

  			edge1 = face[ keys[ j ] ];
  			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  			edge[ 0 ] = Math.min( edge1, edge2 );
  			edge[ 1 ] = Math.max( edge1, edge2 );

  			key = edge[ 0 ] + ',' + edge[ 1 ];

  			if ( edges[ key ] === undefined ) {

  				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

  			} else {

  				edges[ key ].face2 = i;

  			}

  		}

  	}

  	// generate vertices

  	for ( key in edges ) {

  		var e = edges[ key ];

  		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

  		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

  			var vertex = sourceVertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = sourceVertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
  EdgesGeometry.prototype.constructor = EdgesGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // ExtrudeGeometry

  function ExtrudeGeometry( shapes, options ) {

  	Geometry.call( this );

  	this.type = 'ExtrudeGeometry';

  	this.parameters = {
  		shapes: shapes,
  		options: options
  	};

  	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
  	this.mergeVertices();

  }

  ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  ExtrudeGeometry.prototype.toJSON = function () {

  	var data = Geometry.prototype.toJSON.call( this );

  	var shapes = this.parameters.shapes;
  	var options = this.parameters.options;

  	return toJSON$1( shapes, options, data );

  };

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry( shapes, options ) {

  	BufferGeometry.call( this );

  	this.type = 'ExtrudeBufferGeometry';

  	this.parameters = {
  		shapes: shapes,
  		options: options
  	};

  	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  	var scope = this;

  	var verticesArray = [];
  	var uvArray = [];

  	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  		var shape = shapes[ i ];
  		addShape( shape );

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

  	this.computeVertexNormals();

  	// functions

  	function addShape( shape ) {

  		var placeholder = [];

  		// options

  		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  		var steps = options.steps !== undefined ? options.steps : 1;
  		var depth = options.depth !== undefined ? options.depth : 100;

  		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
  		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
  		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
  		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  		var extrudePath = options.extrudePath;

  		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

  		// deprecated options

  		if ( options.amount !== undefined ) {

  			console.warn( 'ExtrudeBufferGeometry: amount has been renamed to depth.' );
  			depth = options.amount;

  		}

  		//

  		var extrudePts, extrudeByPath = false;
  		var splineTube, binormal, normal, position2;

  		if ( extrudePath ) {

  			extrudePts = extrudePath.getSpacedPoints( steps );

  			extrudeByPath = true;
  			bevelEnabled = false; // bevels not supported for path extrusion

  			// SETUP TNB variables

  			// TODO1 - have a .isClosed in spline?

  			splineTube = extrudePath.computeFrenetFrames( steps, false );

  			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  			binormal = new Vector3();
  			normal = new Vector3();
  			position2 = new Vector3();

  		}

  		// Safeguards if bevels are not enabled

  		if ( ! bevelEnabled ) {

  			bevelSegments = 0;
  			bevelThickness = 0;
  			bevelSize = 0;

  		}

  		// Variables initialization

  		var ahole, h, hl; // looping of holes

  		var shapePoints = shape.extractPoints( curveSegments );

  		var vertices = shapePoints.shape;
  		var holes = shapePoints.holes;

  		var reverse = ! ShapeUtils.isClockWise( vertices );

  		if ( reverse ) {

  			vertices = vertices.reverse();

  			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];

  				if ( ShapeUtils.isClockWise( ahole ) ) {

  					holes[ h ] = ahole.reverse();

  				}

  			}

  		}
  		var faces = ShapeUtils.triangulateShape( vertices, holes );
  		var contour = vertices; // vertices has all points but contour has only points of circumference

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];

  			vertices = vertices.concat( ahole );

  		}
  		function scalePt2( pt, vec, size ) {

  			if ( ! vec ) { console.error( "ExtrudeGeometry: vec does not exist" ); }

  			return vec.clone().multiplyScalar( size ).add( pt );

  		}

  		var b, bs, t, z,
  			vert, vlen = vertices.length,
  			face, flen = faces.length;
  		// Find directions for point movement
  		function getBevelVec( inPt, inPrev, inNext ) {

  			// computes for inPt the corresponding point inPt' on a new contour
  			//   shifted by 1 unit (length of normalized vector) to the left
  			// if we walk along contour clockwise, this new contour is outside the old one
  			//
  			// inPt' is the intersection of the two lines parallel to the two
  			//  adjacent edges of inPt at a distance of 1 unit on the left side.

  			var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

  			// good reading for geometry algorithms (here: line-line intersection)
  			// http://geomalgorithms.com/a05-_intersect-1.html

  			var v_prev_x = inPt.x - inPrev.x,
  				v_prev_y = inPt.y - inPrev.y;
  			var v_next_x = inNext.x - inPt.x,
  				v_next_y = inNext.y - inPt.y;

  			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  			// check for collinear edges
  			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  				// not collinear

  				// length of vectors for normalizing

  				var v_prev_len = Math.sqrt( v_prev_lensq );
  				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  				// shift adjacent points by unit vectors to the left

  				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  				// scaling factor for v_prev to intersection point

  				var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  						( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  					( v_prev_x * v_next_y - v_prev_y * v_next_x );

  				// vector from inPt to intersection point

  				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  				// Don't normalize!, otherwise sharp corners become ugly
  				//  but prevent crazy spikes
  				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  				if ( v_trans_lensq <= 2 ) {

  					return new Vector2( v_trans_x, v_trans_y );

  				} else {

  					shrink_by = Math.sqrt( v_trans_lensq / 2 );

  				}

  			} else {

  				// handle special case of collinear edges

  				var direction_eq = false; // assumes: opposite
  				if ( v_prev_x > Number.EPSILON ) {

  					if ( v_next_x > Number.EPSILON ) {

  						direction_eq = true;

  					}

  				} else {

  					if ( v_prev_x < - Number.EPSILON ) {

  						if ( v_next_x < - Number.EPSILON ) {

  							direction_eq = true;

  						}

  					} else {

  						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  							direction_eq = true;

  						}

  					}

  				}

  				if ( direction_eq ) {

  					// console.log("Warning: lines are a straight sequence");
  					v_trans_x = - v_prev_y;
  					v_trans_y = v_prev_x;
  					shrink_by = Math.sqrt( v_prev_lensq );

  				} else {

  					// console.log("Warning: lines are a straight spike");
  					v_trans_x = v_prev_x;
  					v_trans_y = v_prev_y;
  					shrink_by = Math.sqrt( v_prev_lensq / 2 );

  				}

  			}

  			return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  		}
  		var contourMovements = [];

  		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  			if ( j === il ) { j = 0; }
  			if ( k === il ) { k = 0; }

  			//  (j)---(i)---(k)
  			// console.log('i,j,k', i, j , k)

  			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  		}

  		var holesMovements = [],
  			oneHoleMovements, verticesMovements = contourMovements.concat();

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];

  			oneHoleMovements = [];

  			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  				if ( j === il ) { j = 0; }
  				if ( k === il ) { k = 0; }

  				//  (j)---(i)---(k)
  				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  			}

  			holesMovements.push( oneHoleMovements );
  			verticesMovements = verticesMovements.concat( oneHoleMovements );

  		}
  		// Loop bevelSegments, 1 for the front, 1 for the back

  		for ( b = 0; b < bevelSegments; b ++ ) {

  			//for ( b = bevelSegments; b > 0; b -- ) {

  			t = b / bevelSegments;
  			z = bevelThickness * Math.cos( t * Math.PI / 2 );
  			bs = bevelSize * Math.sin( t * Math.PI / 2 );

  			// contract shape

  			for ( i = 0, il = contour.length; i < il; i ++ ) {

  				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  				v( vert.x, vert.y, - z );

  			}

  			// expand holes

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];
  				oneHoleMovements = holesMovements[ h ];

  				for ( i = 0, il = ahole.length; i < il; i ++ ) {

  					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  					v( vert.x, vert.y, - z );

  				}

  			}

  		}

  		bs = bevelSize;

  		// Back facing vertices

  		for ( i = 0; i < vlen; i ++ ) {

  			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  			if ( ! extrudeByPath ) {

  				v( vert.x, vert.y, 0 );

  			} else {

  				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  				v( position2.x, position2.y, position2.z );

  			}

  		}

  		// Add stepped vertices...
  		// Including front facing vertices

  		var s;

  		for ( s = 1; s <= steps; s ++ ) {

  			for ( i = 0; i < vlen; i ++ ) {

  				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, depth / steps * s );

  				} else {

  					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  					v( position2.x, position2.y, position2.z );

  				}

  			}

  		}
  		// Add bevel segments planes

  		//for ( b = 1; b <= bevelSegments; b ++ ) {
  		for ( b = bevelSegments - 1; b >= 0; b -- ) {

  			t = b / bevelSegments;
  			z = bevelThickness * Math.cos( t * Math.PI / 2 );
  			bs = bevelSize * Math.sin( t * Math.PI / 2 );

  			// contract shape

  			for ( i = 0, il = contour.length; i < il; i ++ ) {

  				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  				v( vert.x, vert.y, depth + z );

  			}

  			// expand holes

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];
  				oneHoleMovements = holesMovements[ h ];

  				for ( i = 0, il = ahole.length; i < il; i ++ ) {

  					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  					if ( ! extrudeByPath ) {

  						v( vert.x, vert.y, depth + z );

  					} else {

  						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  					}

  				}

  			}

  		}
  		// Top and bottom faces

  		buildLidFaces();

  		// Sides faces

  		buildSideFaces();
  		/////  Internal functions

  		function buildLidFaces() {

  			var start = verticesArray.length / 3;

  			if ( bevelEnabled ) {

  				var layer = 0; // steps + 1
  				var offset = vlen * layer;

  				// Bottom faces

  				for ( i = 0; i < flen; i ++ ) {

  					face = faces[ i ];
  					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  				}

  				layer = steps + bevelSegments * 2;
  				offset = vlen * layer;

  				// Top faces

  				for ( i = 0; i < flen; i ++ ) {

  					face = faces[ i ];
  					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  				}

  			} else {

  				// Bottom faces

  				for ( i = 0; i < flen; i ++ ) {

  					face = faces[ i ];
  					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  				}

  				// Top faces

  				for ( i = 0; i < flen; i ++ ) {

  					face = faces[ i ];
  					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  				}

  			}

  			scope.addGroup( start, verticesArray.length / 3 - start, 0 );

  		}

  		// Create faces for the z-sides of the shape

  		function buildSideFaces() {

  			var start = verticesArray.length / 3;
  			var layeroffset = 0;
  			sidewalls( contour, layeroffset );
  			layeroffset += contour.length;

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];
  				sidewalls( ahole, layeroffset );

  				//, true
  				layeroffset += ahole.length;

  			}
  			scope.addGroup( start, verticesArray.length / 3 - start, 1 );
  		}

  		function sidewalls( contour, layeroffset ) {

  			var j, k;
  			i = contour.length;

  			while ( -- i >= 0 ) {

  				j = i;
  				k = i - 1;
  				if ( k < 0 ) { k = contour.length - 1; }

  				//console.log('b', i,j, i-1, k,vertices.length);

  				var s = 0,
  					sl = steps + bevelSegments * 2;

  				for ( s = 0; s < sl; s ++ ) {

  					var slen1 = vlen * s;
  					var slen2 = vlen * ( s + 1 );

  					var a = layeroffset + j + slen1,
  						b = layeroffset + k + slen1,
  						c = layeroffset + k + slen2,
  						d = layeroffset + j + slen2;

  					f4( a, b, c, d );

  				}

  			}

  		}

  		function v( x, y, z ) {

  			placeholder.push( x );
  			placeholder.push( y );
  			placeholder.push( z );

  		}
  		function f3( a, b, c ) {

  			addVertex( a );
  			addVertex( b );
  			addVertex( c );

  			var nextIndex = verticesArray.length / 3;
  			var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  			addUV( uvs[ 0 ] );
  			addUV( uvs[ 1 ] );
  			addUV( uvs[ 2 ] );

  		}

  		function f4( a, b, c, d ) {

  			addVertex( a );
  			addVertex( b );
  			addVertex( d );

  			addVertex( b );
  			addVertex( c );
  			addVertex( d );
  			var nextIndex = verticesArray.length / 3;
  			var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  			addUV( uvs[ 0 ] );
  			addUV( uvs[ 1 ] );
  			addUV( uvs[ 3 ] );

  			addUV( uvs[ 1 ] );
  			addUV( uvs[ 2 ] );
  			addUV( uvs[ 3 ] );

  		}

  		function addVertex( index ) {

  			verticesArray.push( placeholder[ index * 3 + 0 ] );
  			verticesArray.push( placeholder[ index * 3 + 1 ] );
  			verticesArray.push( placeholder[ index * 3 + 2 ] );

  		}
  		function addUV( vector2 ) {

  			uvArray.push( vector2.x );
  			uvArray.push( vector2.y );

  		}

  	}

  }

  ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  ExtrudeBufferGeometry.prototype.toJSON = function () {

  	var data = BufferGeometry.prototype.toJSON.call( this );

  	var shapes = this.parameters.shapes;
  	var options = this.parameters.options;

  	return toJSON$1( shapes, options, data );

  };

  //

  var WorldUVGenerator = {

  	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];

  		return [
  			new Vector2( a_x, a_y ),
  			new Vector2( b_x, b_y ),
  			new Vector2( c_x, c_y )
  		];

  	},

  	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var a_z = vertices[ indexA * 3 + 2 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var b_z = vertices[ indexB * 3 + 2 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];
  		var c_z = vertices[ indexC * 3 + 2 ];
  		var d_x = vertices[ indexD * 3 ];
  		var d_y = vertices[ indexD * 3 + 1 ];
  		var d_z = vertices[ indexD * 3 + 2 ];

  		if ( Math.abs( a_y - b_y ) < 0.01 ) {

  			return [
  				new Vector2( a_x, 1 - a_z ),
  				new Vector2( b_x, 1 - b_z ),
  				new Vector2( c_x, 1 - c_z ),
  				new Vector2( d_x, 1 - d_z )
  			];

  		} else {

  			return [
  				new Vector2( a_y, 1 - a_z ),
  				new Vector2( b_y, 1 - b_z ),
  				new Vector2( c_y, 1 - c_z ),
  				new Vector2( d_y, 1 - d_z )
  			];

  		}

  	}
  };

  function toJSON$1( shapes, options, data ) {

  	//

  	data.shapes = [];

  	if ( Array.isArray( shapes ) ) {

  		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  			var shape = shapes[ i ];

  			data.shapes.push( shape.uuid );

  		}

  	} else {

  		data.shapes.push( shapes.uuid );

  	}

  	//

  	if ( options.extrudePath !== undefined ) { data.options.extrudePath = options.extrudePath.toJSON(); }

  	return data;

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // LatheGeometry

  function LatheGeometry( points, segments, phiStart, phiLength ) {

  	Geometry.call( this );

  	this.type = 'LatheGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
  	this.mergeVertices();

  }

  LatheGeometry.prototype = Object.create( Geometry.prototype );
  LatheGeometry.prototype.constructor = LatheGeometry;

  // LatheBufferGeometry

  function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

  	BufferGeometry.call( this );

  	this.type = 'LatheBufferGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	segments = Math.floor( segments ) || 12;
  	phiStart = phiStart || 0;
  	phiLength = phiLength || Math.PI * 2;

  	// clamp phiLength so it's in range of [ 0, 2PI ]

  	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
  	// buffers

  	var indices = [];
  	var vertices = [];
  	var uvs = [];

  	// helper variables

  	var base;
  	var inverseSegments = 1.0 / segments;
  	var vertex = new Vector3();
  	var uv = new Vector2();
  	var i, j;

  	// generate vertices and uvs

  	for ( i = 0; i <= segments; i ++ ) {

  		var phi = phiStart + i * inverseSegments * phiLength;

  		var sin = Math.sin( phi );
  		var cos = Math.cos( phi );

  		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

  			// vertex

  			vertex.x = points[ j ].x * sin;
  			vertex.y = points[ j ].y;
  			vertex.z = points[ j ].x * cos;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// uv

  			uv.x = i / segments;
  			uv.y = j / ( points.length - 1 );

  			uvs.push( uv.x, uv.y );
  		}

  	}

  	// indices

  	for ( i = 0; i < segments; i ++ ) {

  		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

  			base = j + i * points.length;

  			var a = base;
  			var b = base + points.length;
  			var c = base + points.length + 1;
  			var d = base + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// generate normals

  	this.computeVertexNormals();

  	// if the geometry is closed, we need to average the normals along the seam.
  	// because the corresponding vertices are identical (but still have different UVs).

  	if ( phiLength === Math.PI * 2 ) {

  		var normals = this.attributes.normal.array;
  		var n1 = new Vector3();
  		var n2 = new Vector3();
  		var n = new Vector3();

  		// this is the buffer offset for the last line of vertices

  		base = segments * points.length * 3;

  		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  			// select the normal of the vertex in the first line

  			n1.x = normals[ j + 0 ];
  			n1.y = normals[ j + 1 ];
  			n1.z = normals[ j + 2 ];

  			// select the normal of the vertex in the last line

  			n2.x = normals[ base + j + 0 ];
  			n2.y = normals[ base + j + 1 ];
  			n2.z = normals[ base + j + 2 ];

  			// average normals

  			n.addVectors( n1, n2 ).normalize();

  			// assign the new values to both normals

  			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  		}

  	}

  }

  LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // ParametricGeometry

  function ParametricGeometry( func, slices, stacks ) {

  	Geometry.call( this );

  	this.type = 'ParametricGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
  	this.mergeVertices();

  }

  ParametricGeometry.prototype = Object.create( Geometry.prototype );
  ParametricGeometry.prototype.constructor = ParametricGeometry;

  // ParametricBufferGeometry

  function ParametricBufferGeometry( func, slices, stacks ) {

  	BufferGeometry.call( this );

  	this.type = 'ParametricBufferGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	var EPS = 0.00001;

  	var normal = new Vector3();

  	var p0 = new Vector3(), p1 = new Vector3();
  	var pu = new Vector3(), pv = new Vector3();

  	var i, j;

  	if ( func.length < 3 ) {

  		console.error( 'ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

  	}

  	// generate vertices, normals and uvs

  	var sliceCount = slices + 1;

  	for ( i = 0; i <= stacks; i ++ ) {

  		var v = i / stacks;

  		for ( j = 0; j <= slices; j ++ ) {

  			var u = j / slices;

  			// vertex

  			func( u, v, p0 );
  			vertices.push( p0.x, p0.y, p0.z );

  			// normal

  			// approximate tangent vectors via finite differences

  			if ( u - EPS >= 0 ) {

  				func( u - EPS, v, p1 );
  				pu.subVectors( p0, p1 );

  			} else {

  				func( u + EPS, v, p1 );
  				pu.subVectors( p1, p0 );

  			}

  			if ( v - EPS >= 0 ) {

  				func( u, v - EPS, p1 );
  				pv.subVectors( p0, p1 );

  			} else {

  				func( u, v + EPS, p1 );
  				pv.subVectors( p1, p0 );

  			}

  			// cross product of tangent vectors returns surface normal

  			normal.crossVectors( pu, pv ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, v );

  		}

  	}

  	// generate indices

  	for ( i = 0; i < stacks; i ++ ) {

  		for ( j = 0; j < slices; j ++ ) {

  			var a = i * sliceCount + j;
  			var b = i * sliceCount + j + 1;
  			var c = ( i + 1 ) * sliceCount + j + 1;
  			var d = ( i + 1 ) * sliceCount + j;

  			// faces one and two

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // RingGeometry

  function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'RingGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  RingGeometry.prototype = Object.create( Geometry.prototype );
  RingGeometry.prototype.constructor = RingGeometry;

  // RingBufferGeometry

  function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'RingBufferGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	innerRadius = innerRadius || 0.5;
  	outerRadius = outerRadius || 1;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// some helper variables

  	var segment;
  	var radius = innerRadius;
  	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  	var vertex = new Vector3();
  	var uv = new Vector2();
  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= phiSegments; j ++ ) {

  		for ( i = 0; i <= thetaSegments; i ++ ) {

  			// values are generate from the inside of the ring to the outside

  			segment = thetaStart + i / thetaSegments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uv

  			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// increase the radius for next row of vertices

  		radius += radiusStep;

  	}

  	// indices

  	for ( j = 0; j < phiSegments; j ++ ) {

  		var thetaSegmentLevel = j * ( thetaSegments + 1 );

  		for ( i = 0; i < thetaSegments; i ++ ) {

  			segment = i + thetaSegmentLevel;

  			var a = segment;
  			var b = segment + thetaSegments + 1;
  			var c = segment + thetaSegments + 2;
  			var d = segment + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // TetrahedronGeometry

  function TetrahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'TetrahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry( radius, detail ) {

  	var vertices = [
  		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
  	];

  	var indices = [
  		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'TetrahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // TextGeometry

  function TextGeometry( text, parameters ) {

  	Geometry.call( this );

  	this.type = 'TextGeometry';

  	this.parameters = {
  		text: text,
  		parameters: parameters
  	};

  	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
  	this.mergeVertices();

  }

  TextGeometry.prototype = Object.create( Geometry.prototype );
  TextGeometry.prototype.constructor = TextGeometry;

  // TextBufferGeometry

  function TextBufferGeometry( text, parameters ) {

  	parameters = parameters || {};

  	var font = parameters.font;

  	if ( ! ( font && font.isFont ) ) {

  		console.error( 'TextGeometry: font parameter is not an instance of Font.' );
  		return new Geometry();

  	}

  	var shapes = font.generateShapes( text, parameters.size );

  	// translate parameters to ExtrudeGeometry API

  	parameters.depth = parameters.height !== undefined ? parameters.height : 50;

  	// defaults

  	if ( parameters.bevelThickness === undefined ) { parameters.bevelThickness = 10; }
  	if ( parameters.bevelSize === undefined ) { parameters.bevelSize = 8; }
  	if ( parameters.bevelEnabled === undefined ) { parameters.bevelEnabled = false; }

  	ExtrudeBufferGeometry.call( this, shapes, parameters );

  	this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // TorusKnotGeometry

  function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

  	Geometry.call( this );

  	this.type = 'TorusKnotGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	if ( heightScale !== undefined ) { console.warn( 'TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ); }

  	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
  	this.mergeVertices();

  }

  TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

  	BufferGeometry.call( this );

  	this.type = 'TorusKnotBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	radius = radius || 1;
  	tube = tube || 0.4;
  	tubularSegments = Math.floor( tubularSegments ) || 64;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	p = p || 2;
  	q = q || 3;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, j;

  	var vertex = new Vector3();
  	var normal = new Vector3();

  	var P1 = new Vector3();
  	var P2 = new Vector3();

  	var B = new Vector3();
  	var T = new Vector3();
  	var N = new Vector3();

  	// generate vertices, normals and uvs

  	for ( i = 0; i <= tubularSegments; ++ i ) {

  		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  		var u = i / tubularSegments * p * Math.PI * 2;

  		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  		calculatePositionOnCurve( u, p, q, radius, P1 );
  		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  		// calculate orthonormal basis

  		T.subVectors( P2, P1 );
  		N.addVectors( P2, P1 );
  		B.crossVectors( T, N );
  		N.crossVectors( B, T );

  		// normalize B, N. T can be ignored, we don't use it

  		B.normalize();
  		N.normalize();

  		for ( j = 0; j <= radialSegments; ++ j ) {

  			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  			var v = j / radialSegments * Math.PI * 2;
  			var cx = - tube * Math.cos( v );
  			var cy = tube * Math.sin( v );

  			// now calculate the final vertex position.
  			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  			vertex.x = P1.x + ( cx * N.x + cy * B.x );
  			vertex.y = P1.y + ( cx * N.y + cy * B.y );
  			vertex.z = P1.z + ( cx * N.z + cy * B.z );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  			normal.subVectors( vertex, P1 ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= tubularSegments; j ++ ) {

  		for ( i = 1; i <= radialSegments; i ++ ) {

  			// indices

  			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  			var b = ( radialSegments + 1 ) * j + ( i - 1 );
  			var c = ( radialSegments + 1 ) * j + i;
  			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// this function calculates the current position on the torus curve

  	function calculatePositionOnCurve( u, p, q, radius, position ) {

  		var cu = Math.cos( u );
  		var su = Math.sin( u );
  		var quOverP = q / p * u;
  		var cs = Math.cos( quOverP );

  		position.x = radius * ( 2 + cs ) * 0.5 * cu;
  		position.y = radius * ( 2 + cs ) * su * 0.5;
  		position.z = radius * Math.sin( quOverP ) * 0.5;

  	}

  }

  TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // TubeGeometry

  function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

  	Geometry.call( this );

  	this.type = 'TubeGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	if ( taper !== undefined ) { console.warn( 'TubeGeometry: taper has been removed.' ); }

  	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

  	// expose internals

  	this.tangents = bufferGeometry.tangents;
  	this.normals = bufferGeometry.normals;
  	this.binormals = bufferGeometry.binormals;

  	// create geometry

  	this.fromBufferGeometry( bufferGeometry );
  	this.mergeVertices();

  }

  TubeGeometry.prototype = Object.create( Geometry.prototype );
  TubeGeometry.prototype.constructor = TubeGeometry;

  // TubeBufferGeometry

  function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

  	BufferGeometry.call( this );

  	this.type = 'TubeBufferGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	tubularSegments = tubularSegments || 64;
  	radius = radius || 1;
  	radialSegments = radialSegments || 8;
  	closed = closed || false;

  	var frames = path.computeFrenetFrames( tubularSegments, closed );

  	// expose internals

  	this.tangents = frames.tangents;
  	this.normals = frames.normals;
  	this.binormals = frames.binormals;

  	// helper variables

  	var vertex = new Vector3();
  	var normal = new Vector3();
  	var uv = new Vector2();
  	var P = new Vector3();

  	var i, j;

  	// buffer

  	var vertices = [];
  	var normals = [];
  	var uvs = [];
  	var indices = [];

  	// create buffer data

  	generateBufferData();

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// functions

  	function generateBufferData() {

  		for ( i = 0; i < tubularSegments; i ++ ) {

  			generateSegment( i );

  		}

  		// if the geometry is not closed, generate the last row of vertices and normals
  		// at the regular position on the given path
  		//
  		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  		generateSegment( ( closed === false ) ? tubularSegments : 0 );

  		// uvs are generated in a separate function.
  		// this makes it easy compute correct values for closed geometries

  		generateUVs();

  		// finally create faces

  		generateIndices();

  	}

  	function generateSegment( i ) {

  		// we use getPointAt to sample evenly distributed points from the given path

  		P = path.getPointAt( i / tubularSegments, P );

  		// retrieve corresponding normal and binormal

  		var N = frames.normals[ i ];
  		var B = frames.binormals[ i ];

  		// generate normals and vertices for the current segment

  		for ( j = 0; j <= radialSegments; j ++ ) {

  			var v = j / radialSegments * Math.PI * 2;

  			var sin = Math.sin( v );
  			var cos = - Math.cos( v );

  			// normal

  			normal.x = ( cos * N.x + sin * B.x );
  			normal.y = ( cos * N.y + sin * B.y );
  			normal.z = ( cos * N.z + sin * B.z );
  			normal.normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// vertex

  			vertex.x = P.x + radius * normal.x;
  			vertex.y = P.y + radius * normal.y;
  			vertex.z = P.z + radius * normal.z;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	function generateIndices() {

  		for ( j = 1; j <= tubularSegments; j ++ ) {

  			for ( i = 1; i <= radialSegments; i ++ ) {

  				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				var b = ( radialSegments + 1 ) * j + ( i - 1 );
  				var c = ( radialSegments + 1 ) * j + i;
  				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  	}

  	function generateUVs() {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			for ( j = 0; j <= radialSegments; j ++ ) {

  				uv.x = i / tubularSegments;
  				uv.y = j / radialSegments;

  				uvs.push( uv.x, uv.y );

  			}

  		}

  	}

  }

  TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  TubeBufferGeometry.prototype.toJSON = function () {

  	var data = BufferGeometry.prototype.toJSON.call( this );

  	data.path = this.parameters.path.toJSON();

  	return data;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var lineGeometry, coneGeometry;

  function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

  	// dir is assumed to be normalized

  	Object3D.call( this );

  	if ( dir === undefined ) { dir = new Vector3( 0, 0, 1 ); }
  	if ( origin === undefined ) { origin = new Vector3( 0, 0, 0 ); }
  	if ( length === undefined ) { length = 1; }
  	if ( color === undefined ) { color = 0xffff00; }
  	if ( headLength === undefined ) { headLength = 0.2 * length; }
  	if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

  	if ( lineGeometry === undefined ) {

  		lineGeometry = new BufferGeometry();
  		lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

  		coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
  		coneGeometry.translate( 0, - 0.5, 0 );

  	}

  	this.position.copy( origin );

  	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
  	this.line.matrixAutoUpdate = false;
  	this.add( this.line );

  	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
  	this.cone.matrixAutoUpdate = false;
  	this.add( this.cone );

  	this.setDirection( dir );
  	this.setLength( length, headLength, headWidth );

  }

  ArrowHelper.prototype = Object.create( Object3D.prototype );
  ArrowHelper.prototype.constructor = ArrowHelper;

  ArrowHelper.prototype.setDirection = ( function () {

  	var axis = new Vector3();
  	var radians;

  	return function setDirection( dir ) {

  		// dir is assumed to be normalized

  		if ( dir.y > 0.99999 ) {

  			this.quaternion.set( 0, 0, 0, 1 );

  		} else if ( dir.y < - 0.99999 ) {

  			this.quaternion.set( 1, 0, 0, 0 );

  		} else {

  			axis.set( dir.z, 0, - dir.x ).normalize();

  			radians = Math.acos( dir.y );

  			this.quaternion.setFromAxisAngle( axis, radians );

  		}

  	};

  }() );

  ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  	if ( headLength === undefined ) { headLength = 0.2 * length; }
  	if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

  	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
  	this.line.updateMatrix();

  	this.cone.scale.set( headWidth, headLength, headWidth );
  	this.cone.position.y = length;
  	this.cone.updateMatrix();

  };

  ArrowHelper.prototype.setColor = function ( color ) {

  	this.line.material.color.copy( color );
  	this.cone.material.color.copy( color );

  };

  ArrowHelper.prototype.copy = function ( source ) {

  	Object3D.prototype.copy.call( this, source, false );

  	this.line.copy( source.line );
  	this.cone.copy( source.cone );

  	return this;

  };

  ArrowHelper.prototype.clone = function () {

  	return new this.constructor().copy( this );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AxesHelper( size ) {

  	size = size || 1;

  	var vertices = [
  		0, 0, 0,	size, 0, 0,
  		0, 0, 0,	0, size, 0,
  		0, 0, 0,	0, 0, size
  	];

  	var colors = [
  		1, 0, 0,	1, 0.6, 0,
  		0, 1, 0,	0.6, 1, 0,
  		0, 0, 1,	0, 0.6, 1
  	];

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  	LineSegments.call( this, geometry, material );

  }

  AxesHelper.prototype = Object.create( LineSegments.prototype );
  AxesHelper.prototype.constructor = AxesHelper;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Box3Helper( box, hex ) {

  	this.type = 'Box3Helper';

  	this.box = box;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

  	var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

  	var geometry = new BufferGeometry();

  	geometry.setIndex( new BufferAttribute( indices, 1 ) );

  	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  	this.geometry.computeBoundingSphere();

  }

  Box3Helper.prototype = Object.create( LineSegments.prototype );
  Box3Helper.prototype.constructor = Box3Helper;

  Box3Helper.prototype.updateMatrixWorld = function ( force ) {

  	var box = this.box;

  	if ( box.isEmpty() ) { return; }

  	box.getCenter( this.position );

  	box.getSize( this.scale );

  	this.scale.multiplyScalar( 0.5 );

  	Object3D.prototype.updateMatrixWorld.call( this, force );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BoxHelper( object, color ) {

  	this.object = object;

  	if ( color === undefined ) { color = 0xffff00; }

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  	var positions = new Float32Array( 8 * 3 );

  	var geometry = new BufferGeometry();
  	geometry.setIndex( new BufferAttribute( indices, 1 ) );
  	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  BoxHelper.prototype = Object.create( LineSegments.prototype );
  BoxHelper.prototype.constructor = BoxHelper;

  BoxHelper.prototype.update = ( function () {

  	var box = new Box3();

  	return function update( object ) {

  		if ( object !== undefined ) {

  			console.warn( 'BoxHelper: .update() has no longer arguments.' );

  		}

  		if ( this.object !== undefined ) {

  			box.setFromObject( this.object );

  		}

  		if ( box.isEmpty() ) { return; }

  		var min = box.min;
  		var max = box.max;
  		var position = this.geometry.attributes.position;
  		var array = position.array;

  		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
  		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
  		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
  		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  		position.needsUpdate = true;

  		this.geometry.computeBoundingSphere();

  	};

  } )();

  BoxHelper.prototype.setFromObject = function ( object ) {

  	this.object = object;
  	this.update();

  	return this;

  };

  BoxHelper.prototype.copy = function ( source ) {

  	LineSegments.prototype.copy.call( this, source );

  	this.object = source.object;

  	return this;

  };

  BoxHelper.prototype.clone = function () {

  	return new this.constructor().copy( this );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CameraHelper( camera ) {

  	var geometry = new BufferGeometry();
  	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

  	var vertices = [];
  	var colors = [];

  	var pointMap = {};

  	// colors

  	var colorFrustum = new Color( 0xffaa00 );
  	var colorCone = new Color( 0xff0000 );
  	var colorUp = new Color( 0x00aaff );
  	var colorTarget = new Color( 0xffffff );
  	var colorCross = new Color( 0x333333 );

  	// near

  	addLine( 'n1', 'n2', colorFrustum );
  	addLine( 'n2', 'n4', colorFrustum );
  	addLine( 'n4', 'n3', colorFrustum );
  	addLine( 'n3', 'n1', colorFrustum );

  	// far

  	addLine( 'f1', 'f2', colorFrustum );
  	addLine( 'f2', 'f4', colorFrustum );
  	addLine( 'f4', 'f3', colorFrustum );
  	addLine( 'f3', 'f1', colorFrustum );

  	// sides

  	addLine( 'n1', 'f1', colorFrustum );
  	addLine( 'n2', 'f2', colorFrustum );
  	addLine( 'n3', 'f3', colorFrustum );
  	addLine( 'n4', 'f4', colorFrustum );

  	// cone

  	addLine( 'p', 'n1', colorCone );
  	addLine( 'p', 'n2', colorCone );
  	addLine( 'p', 'n3', colorCone );
  	addLine( 'p', 'n4', colorCone );

  	// up

  	addLine( 'u1', 'u2', colorUp );
  	addLine( 'u2', 'u3', colorUp );
  	addLine( 'u3', 'u1', colorUp );

  	// target

  	addLine( 'c', 't', colorTarget );
  	addLine( 'p', 'c', colorCross );

  	// cross

  	addLine( 'cn1', 'cn2', colorCross );
  	addLine( 'cn3', 'cn4', colorCross );

  	addLine( 'cf1', 'cf2', colorCross );
  	addLine( 'cf3', 'cf4', colorCross );

  	function addLine( a, b, color ) {

  		addPoint( a, color );
  		addPoint( b, color );

  	}

  	function addPoint( id, color ) {

  		vertices.push( 0, 0, 0 );
  		colors.push( color.r, color.g, color.b );

  		if ( pointMap[ id ] === undefined ) {

  			pointMap[ id ] = [];

  		}

  		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	LineSegments.call( this, geometry, material );

  	this.camera = camera;
  	if ( this.camera.updateProjectionMatrix ) { this.camera.updateProjectionMatrix(); }

  	this.matrix = camera.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.pointMap = pointMap;

  	this.update();

  }

  CameraHelper.prototype = Object.create( LineSegments.prototype );
  CameraHelper.prototype.constructor = CameraHelper;

  CameraHelper.prototype.update = function () {

  	var geometry, pointMap;

  	var vector = new Vector3();
  	var camera = new Camera();

  	function setPoint( point, x, y, z ) {

  		vector.set( x, y, z ).unproject( camera );

  		var points = pointMap[ point ];

  		if ( points !== undefined ) {

  			var position = geometry.getAttribute( 'position' );

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

  			}

  		}

  	}

  	return function update() {

  		geometry = this.geometry;
  		pointMap = this.pointMap;

  		var w = 1, h = 1;

  		// we need just camera projection matrix
  		// world matrix must be identity

  		camera.projectionMatrix.copy( this.camera.projectionMatrix );

  		// center / target

  		setPoint( 'c', 0, 0, - 1 );
  		setPoint( 't', 0, 0, 1 );

  		// near

  		setPoint( 'n1', - w, - h, - 1 );
  		setPoint( 'n2', w, - h, - 1 );
  		setPoint( 'n3', - w, h, - 1 );
  		setPoint( 'n4', w, h, - 1 );

  		// far

  		setPoint( 'f1', - w, - h, 1 );
  		setPoint( 'f2', w, - h, 1 );
  		setPoint( 'f3', - w, h, 1 );
  		setPoint( 'f4', w, h, 1 );

  		// up

  		setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u3', 0, h * 2, - 1 );

  		// cross

  		setPoint( 'cf1', - w, 0, 1 );
  		setPoint( 'cf2', w, 0, 1 );
  		setPoint( 'cf3', 0, - h, 1 );
  		setPoint( 'cf4', 0, h, 1 );

  		setPoint( 'cn1', - w, 0, - 1 );
  		setPoint( 'cn2', w, 0, - 1 );
  		setPoint( 'cn3', 0, - h, - 1 );
  		setPoint( 'cn4', 0, h, - 1 );

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function DirectionalLightHelper( light, size, color ) {

  	Object3D.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	if ( size === undefined ) { size = 1; }

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( [
  		- size, size, 0,
  		size, size, 0,
  		size, - size, 0,
  		- size, - size, 0,
  		- size, size, 0
  	], 3 ) );

  	var material = new LineBasicMaterial( { fog: false } );

  	this.lightPlane = new Line( geometry, material );
  	this.add( this.lightPlane );

  	geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

  	this.targetLine = new Line( geometry, material );
  	this.add( this.targetLine );

  	this.update();

  }

  DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  DirectionalLightHelper.prototype.dispose = function () {

  	this.lightPlane.geometry.dispose();
  	this.lightPlane.material.dispose();
  	this.targetLine.geometry.dispose();
  	this.targetLine.material.dispose();

  };

  DirectionalLightHelper.prototype.update = function () {

  	var v1 = new Vector3();
  	var v2 = new Vector3();
  	var v3 = new Vector3();

  	return function update() {

  		v1.setFromMatrixPosition( this.light.matrixWorld );
  		v2.setFromMatrixPosition( this.light.target.matrixWorld );
  		v3.subVectors( v2, v1 );

  		this.lightPlane.lookAt( v2 );

  		if ( this.color !== undefined ) {

  			this.lightPlane.material.color.set( this.color );
  			this.targetLine.material.color.set( this.color );

  		} else {

  			this.lightPlane.material.color.copy( this.light.color );
  			this.targetLine.material.color.copy( this.light.color );

  		}

  		this.targetLine.lookAt( v2 );
  		this.targetLine.scale.z = v3.length();

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function FaceNormalsHelper( object, size, hex, linewidth ) {

  	// FaceNormalsHelper only supports Geometry

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length;

  	} else {

  		console.warn( 'FaceNormalsHelper: only Geometry is supported. Use VertexNormalsHelper, instead.' );

  	}

  	//

  	var geometry = new BufferGeometry();

  	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;
  	this.update();

  }

  FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
  FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

  FaceNormalsHelper.prototype.update = ( function () {

  	var v1 = new Vector3();
  	var v2 = new Vector3();
  	var normalMatrix = new Matrix3();

  	return function update() {
  		var this$1 = this;


  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		var vertices = objGeometry.vertices;

  		var faces = objGeometry.faces;

  		var idx = 0;

  		for ( var i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var normal = face.normal;

  			v1.copy( vertices[ face.a ] )
  				.add( vertices[ face.b ] )
  				.add( vertices[ face.c ] )
  				.divideScalar( 3 )
  				.applyMatrix4( matrixWorld );

  			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  			position.setXYZ( idx, v1.x, v1.y, v1.z );

  			idx = idx + 1;

  			position.setXYZ( idx, v2.x, v2.y, v2.z );

  			idx = idx + 1;

  		}

  		position.needsUpdate = true;

  	};

  }() );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function GridHelper( size, divisions, color1, color2 ) {

  	size = size || 10;
  	divisions = divisions || 10;
  	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

  	var center = divisions / 2;
  	var step = size / divisions;
  	var halfSize = size / 2;

  	var vertices = [], colors = [];

  	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

  		vertices.push( - halfSize, 0, k, halfSize, 0, k );
  		vertices.push( k, 0, - halfSize, k, 0, halfSize );

  		var color = i === center ? color1 : color2;

  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;

  	}

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  	LineSegments.call( this, geometry, material );

  }

  GridHelper.prototype = Object.create( LineSegments.prototype );
  GridHelper.prototype.constructor = GridHelper;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function HemisphereLightHelper( light, size, color ) {

  	Object3D.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	var geometry = new OctahedronBufferGeometry( size );
  	geometry.rotateY( Math.PI * 0.5 );

  	this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
  	if ( this.color === undefined ) { this.material.vertexColors = VertexColors; }

  	var position = geometry.getAttribute( 'position' );
  	var colors = new Float32Array( position.count * 3 );

  	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

  	this.add( new Mesh( geometry, this.material ) );

  	this.update();

  }

  HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  HemisphereLightHelper.prototype.dispose = function () {

  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  HemisphereLightHelper.prototype.update = function () {

  	var vector = new Vector3();

  	var color1 = new Color();
  	var color2 = new Color();

  	return function update() {

  		var mesh = this.children[ 0 ];

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );

  		} else {

  			var colors = mesh.geometry.getAttribute( 'color' );

  			color1.copy( this.light.color );
  			color2.copy( this.light.groundColor );

  			for ( var i = 0, l = colors.count; i < l; i ++ ) {

  				var color = ( i < ( l / 2 ) ) ? color1 : color2;

  				colors.setXYZ( i, color.r, color.g, color.b );

  			}

  			colors.needsUpdate = true;

  		}

  		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PlaneHelper( plane, size, hex ) {

  	this.type = 'PlaneHelper';

  	this.plane = plane;

  	this.size = ( size === undefined ) ? 1 : size;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  	geometry.computeBoundingSphere();

  	Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  	//

  	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

  	var geometry2 = new BufferGeometry();
  	geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
  	geometry2.computeBoundingSphere();

  	this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

  }

  PlaneHelper.prototype = Object.create( Line.prototype );
  PlaneHelper.prototype.constructor = PlaneHelper;

  PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

  	var scale = - this.plane.constant;

  	if ( Math.abs( scale ) < 1e-8 ) { scale = 1e-8; } // sign does not matter

  	this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

  	this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  	this.lookAt( this.plane.normal );

  	Object3D.prototype.updateMatrixWorld.call( this, force );

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PointLightHelper( light, sphereSize, color ) {

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.color = color;

  	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
  	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

  	Mesh.call( this, geometry, material );

  	this.matrix = this.light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.update();
  }

  PointLightHelper.prototype = Object.create( Mesh.prototype );
  PointLightHelper.prototype.constructor = PointLightHelper;

  PointLightHelper.prototype.dispose = function () {

  	this.geometry.dispose();
  	this.material.dispose();

  };

  PointLightHelper.prototype.update = function () {

  	if ( this.color !== undefined ) {

  		this.material.color.set( this.color );

  	} else {

  		this.material.color.copy( this.light.color );

  	}
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

  	radius = radius || 10;
  	radials = radials || 16;
  	circles = circles || 8;
  	divisions = divisions || 64;
  	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

  	var vertices = [];
  	var colors = [];

  	var x, z;
  	var v, i, j, r, color;

  	// create the radials

  	for ( i = 0; i <= radials; i ++ ) {

  		v = ( i / radials ) * ( Math.PI * 2 );

  		x = Math.sin( v ) * radius;
  		z = Math.cos( v ) * radius;

  		vertices.push( 0, 0, 0 );
  		vertices.push( x, 0, z );

  		color = ( i & 1 ) ? color1 : color2;

  		colors.push( color.r, color.g, color.b );
  		colors.push( color.r, color.g, color.b );

  	}

  	// create the circles

  	for ( i = 0; i <= circles; i ++ ) {

  		color = ( i & 1 ) ? color1 : color2;

  		r = radius - ( radius / circles * i );

  		for ( j = 0; j < divisions; j ++ ) {

  			// first vertex

  			v = ( j / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  			// second vertex

  			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  		}

  	}

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  	LineSegments.call( this, geometry, material );

  }

  PolarGridHelper.prototype = Object.create( LineSegments.prototype );
  PolarGridHelper.prototype.constructor = PolarGridHelper;

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {

  	this.audio = audio;
  	this.range = range || 1;
  	this.divisionsInnerAngle = divisionsInnerAngle || 16;
  	this.divisionsOuterAngle = divisionsOuterAngle || 2;

  	var geometry = new BufferGeometry();
  	var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
  	var positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );
  	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  	var materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );
  	var materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );

  	Line.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );

  	this.update();

  }

  PositionalAudioHelper.prototype = Object.create( Line.prototype );
  PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

  PositionalAudioHelper.prototype.update = function () {

  	var audio = this.audio;
  	var range = this.range;
  	var divisionsInnerAngle = this.divisionsInnerAngle;
  	var divisionsOuterAngle = this.divisionsOuterAngle;

  	var coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );
  	var coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );

  	var halfConeInnerAngle = coneInnerAngle / 2;
  	var halfConeOuterAngle = coneOuterAngle / 2;

  	var start = 0;
  	var count = 0;
  	var i, stride;

  	var geometry = this.geometry;
  	var positionAttribute = geometry.attributes.position;

  	geometry.clearGroups();

  	//

  	function generateSegment( from, to, divisions, materialIndex ) {

  		var step = ( to - from ) / divisions;

  		positionAttribute.setXYZ( start, 0, 0, 0 );
  		count ++;

  		for ( i = from; i < to; i += step ) {

  			stride = start + count;

  			positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );
  			positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );
  			positionAttribute.setXYZ( stride + 2, 0, 0, 0 );

  			count += 3;

  		}

  		geometry.addGroup( start, count, materialIndex );

  		start += count;
  		count = 0;

  	}

  	//

  	generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );
  	generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );
  	generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );

  	//

  	positionAttribute.needsUpdate = true;

  	if ( coneInnerAngle === coneOuterAngle ) { this.material[ 0 ].visible = false; }

  };

  PositionalAudioHelper.prototype.dispose = function () {

  	this.geometry.dispose();
  	this.material[ 0 ].dispose();
  	this.material[ 1 ].dispose();

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RectAreaLightHelper( light, color ) {

  	this.type = 'RectAreaLightHelper';

  	this.light = light;

  	this.color = color; // optional hardwired color for the helper

  	var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  	geometry.computeBoundingSphere();

  	var material = new LineBasicMaterial( { fog: false } );

  	Line.call( this, geometry, material );

  	//

  	var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

  	var geometry2 = new BufferGeometry();
  	geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
  	geometry2.computeBoundingSphere();

  	this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

  	this.update();

  }

  RectAreaLightHelper.prototype = Object.create( Line.prototype );
  RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

  RectAreaLightHelper.prototype.update = function () {

  	this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

  	if ( this.color !== undefined ) {

  		this.material.color.set( this.color );
  		this.children[ 0 ].material.color.set( this.color );

  	} else {

  		this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  		// prevent hue shift
  		var c = this.material.color;
  		var max = Math.max( c.r, c.g, c.b );
  		if ( max > 1 ) { c.multiplyScalar( 1 / max ); }

  		this.children[ 0 ].material.color.copy( this.material.color );

  	}

  };

  RectAreaLightHelper.prototype.dispose = function () {

  	this.geometry.dispose();
  	this.material.dispose();
  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function SpotLightHelper( light, color ) {

  	Object3D.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	var geometry = new BufferGeometry();

  	var positions = [
  		0, 0, 0, 	0, 0, 1,
  		0, 0, 0, 	1, 0, 1,
  		0, 0, 0,	- 1, 0, 1,
  		0, 0, 0, 	0, 1, 1,
  		0, 0, 0, 	0, - 1, 1
  	];

  	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

  		var p1 = ( i / l ) * Math.PI * 2;
  		var p2 = ( j / l ) * Math.PI * 2;

  		positions.push(
  			Math.cos( p1 ), Math.sin( p1 ), 1,
  			Math.cos( p2 ), Math.sin( p2 ), 1
  		);

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  	var material = new LineBasicMaterial( { fog: false } );

  	this.cone = new LineSegments( geometry, material );
  	this.add( this.cone );

  	this.update();

  }

  SpotLightHelper.prototype = Object.create( Object3D.prototype );
  SpotLightHelper.prototype.constructor = SpotLightHelper;

  SpotLightHelper.prototype.dispose = function () {

  	this.cone.geometry.dispose();
  	this.cone.material.dispose();

  };

  SpotLightHelper.prototype.update = function () {

  	var vector = new Vector3();

  	return function update() {

  		this.light.updateMatrixWorld();

  		var coneLength = this.light.distance ? this.light.distance : 1000;
  		var coneWidth = coneLength * Math.tan( this.light.angle );

  		this.cone.scale.set( coneWidth, coneWidth, coneLength );

  		vector.setFromMatrixPosition( this.light.target.matrixWorld );

  		this.cone.lookAt( vector );

  		if ( this.color !== undefined ) {

  			this.cone.material.color.set( this.color );

  		} else {

  			this.cone.material.color.copy( this.light.color );

  		}

  	};

  }();

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function VertexNormalsHelper( object, size, hex, linewidth ) {

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xff0000;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length * 3;

  	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  		nNormals = objGeometry.attributes.normal.count;

  	}

  	//

  	var geometry = new BufferGeometry();

  	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
  VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

  VertexNormalsHelper.prototype.update = ( function () {

  	var v1 = new Vector3();
  	var v2 = new Vector3();
  	var normalMatrix = new Matrix3();

  	return function update() {
  		var this$1 = this;


  		var keys = [ 'a', 'b', 'c' ];

  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		if ( objGeometry && objGeometry.isGeometry ) {

  			var vertices = objGeometry.vertices;

  			var faces = objGeometry.faces;

  			var idx = 0;

  			for ( var i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  					var vertex = vertices[ face[ keys[ j ] ] ];

  					var normal = face.vertexNormals[ j ];

  					v1.copy( vertex ).applyMatrix4( matrixWorld );

  					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  					position.setXYZ( idx, v1.x, v1.y, v1.z );

  					idx = idx + 1;

  					position.setXYZ( idx, v2.x, v2.y, v2.z );

  					idx = idx + 1;

  				}

  			}

  		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  			var objPos = objGeometry.attributes.position;

  			var objNorm = objGeometry.attributes.normal;

  			var idx = 0;

  			// for simplicity, ignore index and drawcalls, and render every normal

  			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

  				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

  				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

  				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  				position.setXYZ( idx, v1.x, v1.y, v1.z );

  				idx = idx + 1;

  				position.setXYZ( idx, v2.x, v2.y, v2.z );

  				idx = idx + 1;

  			}

  		}

  		position.needsUpdate = true;

  	};

  }() );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function RectAreaLight( color, intensity, width, height ) {

  	Light.call( this, color, intensity );

  	this.type = 'RectAreaLight';

  	this.width = ( width !== undefined ) ? width : 10;
  	this.height = ( height !== undefined ) ? height : 10;

  }

  RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: RectAreaLight,

  	isRectAreaLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Light.prototype.toJSON.call( this, meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AnimationLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( AnimationLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json, onLoad ) {

  		var animations = [];

  		for ( var i = 0; i < json.length; i ++ ) {

  			var clip = AnimationClip.parse( json[ i ] );

  			animations.push( clip );

  		}

  		onLoad( animations );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function AudioLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( AudioLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new FileLoader( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.setPath( this.path );
  		loader.load( url, function ( buffer ) {

  			// Create a copy of the buffer. The `decodeAudioData` method
  			// detaches the buffer when complete, preventing reuse.
  			var bufferCopy = buffer.slice( 0 );

  			var context = AudioContext.getContext();
  			context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

  				onLoad( audioBuffer );

  			} );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function BufferGeometryLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( BufferGeometryLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( scope.path );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		var geometry = new BufferGeometry();

  		var index = json.data.index;

  		if ( index !== undefined ) {

  			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
  			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

  		}

  		var attributes = json.data.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];
  			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

  			var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
  			if ( attribute.name !== undefined ) { bufferAttribute.name = attribute.name; }
  			geometry.addAttribute( key, bufferAttribute );

  		}

  		var morphAttributes = json.data.morphAttributes;

  		if ( morphAttributes ) {

  			for ( var key in morphAttributes ) {

  				var attributeArray = morphAttributes[ key ];

  				var array = [];

  				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

  					var attribute = attributeArray[ i ];
  					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

  					var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
  					if ( attribute.name !== undefined ) { bufferAttribute.name = attribute.name; }
  					array.push( bufferAttribute );

  				}

  				geometry.morphAttributes[ key ] = array;

  			}

  		}

  		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  		if ( groups !== undefined ) {

  			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

  				var group = groups[ i ];

  				geometry.addGroup( group.start, group.count, group.materialIndex );

  			}

  		}

  		var boundingSphere = json.data.boundingSphere;

  		if ( boundingSphere !== undefined ) {

  			var center = new Vector3();

  			if ( boundingSphere.center !== undefined ) {

  				center.fromArray( boundingSphere.center );

  			}

  			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

  		}

  		if ( json.name ) { geometry.name = json.name; }
  		if ( json.userData ) { geometry.userData = json.userData; }

  		return geometry;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  var TYPED_ARRAYS = {
  	Int8Array: Int8Array,
  	Uint8Array: Uint8Array,
  	// Workaround for IE11 pre KB2929437. See #11440
  	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  	Int16Array: Int16Array,
  	Uint16Array: Uint16Array,
  	Int32Array: Int32Array,
  	Uint32Array: Uint32Array,
  	Float32Array: Float32Array,
  	Float64Array: Float64Array
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function CubeTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( CubeTextureLoader.prototype, {

  	crossOrigin: 'anonymous',

  	load: function ( urls, onLoad, onProgress, onError ) {

  		var texture = new CubeTexture();

  		var loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var loaded = 0;

  		function loadTexture( i ) {

  			loader.load( urls[ i ], function ( image ) {

  				texture.images[ i ] = image;

  				loaded ++;

  				if ( loaded === 6 ) {

  					texture.needsUpdate = true;

  					if ( onLoad ) { onLoad( texture ); }

  				}

  			}, undefined, onError );

  		}

  		for ( var i = 0; i < urls.length; ++ i ) {

  			loadTexture( i );

  		}

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function FontLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( FontLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( this.manager );
  		loader.setPath( this.path );
  		loader.load( url, function ( text ) {

  			var json;

  			try {

  				json = JSON.parse( text );

  			} catch ( e ) {

  				console.warn( 'FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
  				json = JSON.parse( text.substring( 65, text.length - 2 ) );

  			}

  			var font = scope.parse( json );

  			if ( onLoad ) { onLoad( font ); }

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		return new Font( json );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function ImageBitmapLoader( manager ) {

  	if ( typeof createImageBitmap === 'undefined' ) {

  		console.warn( 'ImageBitmapLoader: createImageBitmap() not supported.' );

  	}

  	if ( typeof fetch === 'undefined' ) {

  		console.warn( 'ImageBitmapLoader: fetch() not supported.' );

  	}

  	this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  	this.options = undefined;

  }

  ImageBitmapLoader.prototype = {

  	constructor: ImageBitmapLoader,

  	setOptions: function setOptions( options ) {

  		this.options = options;

  		return this;

  	},

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		url = this.manager.resolveURL( url );

  		var scope = this;

  		var cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		fetch( url ).then( function ( res ) {

  			return res.blob();

  		} ).then( function ( blob ) {

  			return createImageBitmap( blob, scope.options );

  		} ).then( function ( imageBitmap ) {

  			Cache.add( url, imageBitmap );

  			if ( onLoad ) { onLoad( imageBitmap ); }

  			scope.manager.itemEnd( url );

  		} ).catch( function ( e ) {

  			if ( onError ) { onError( e ); }

  			scope.manager.itemError( url );
  			scope.manager.itemEnd( url );

  		} );

  		scope.manager.itemStart( url );

  	},

  	setCrossOrigin: function (  ) {

  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function LOD() {

  	Object3D.call( this );

  	this.type = 'LOD';

  	Object.defineProperties( this, {
  		levels: {
  			enumerable: true,
  			value: []
  		}
  	} );

  }

  LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: LOD,

  	copy: function ( source ) {
  		var this$1 = this;


  		Object3D.prototype.copy.call( this, source, false );

  		var levels = source.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			this$1.addLevel( level.object.clone(), level.distance );

  		}

  		return this;

  	},

  	addLevel: function ( object, distance ) {

  		if ( distance === undefined ) { distance = 0; }

  		distance = Math.abs( distance );

  		var levels = this.levels;

  		for ( var l = 0; l < levels.length; l ++ ) {

  			if ( distance < levels[ l ].distance ) {

  				break;

  			}

  		}

  		levels.splice( l, 0, { distance: distance, object: object } );

  		this.add( object );

  	},

  	getObjectForDistance: function ( distance ) {

  		var levels = this.levels;

  		for ( var i = 1, l = levels.length; i < l; i ++ ) {

  			if ( distance < levels[ i ].distance ) {

  				break;

  			}

  		}

  		return levels[ i - 1 ].object;

  	},

  	raycast: ( function () {

  		var matrixPosition = new Vector3();

  		return function raycast( raycaster, intersects ) {

  			matrixPosition.setFromMatrixPosition( this.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

  			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  		};

  	}() ),

  	update: function () {

  		var v1 = new Vector3();
  		var v2 = new Vector3();

  		return function update( camera ) {

  			var levels = this.levels;

  			if ( levels.length > 1 ) {

  				v1.setFromMatrixPosition( camera.matrixWorld );
  				v2.setFromMatrixPosition( this.matrixWorld );

  				var distance = v1.distanceTo( v2 );

  				levels[ 0 ].object.visible = true;

  				for ( var i = 1, l = levels.length; i < l; i ++ ) {

  					if ( distance >= levels[ i ].distance ) {

  						levels[ i - 1 ].object.visible = false;
  						levels[ i ].object.visible = true;

  					} else {

  						break;

  					}

  				}

  				for ( ; i < l; i ++ ) {

  					levels[ i ].object.visible = false;

  				}

  			}

  		};

  	}(),

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.levels = [];

  		var levels = this.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			data.object.levels.push( {
  				object: level.object.uuid,
  				distance: level.distance
  			} );

  		}

  		return data;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Fog( color, near, far ) {

  	this.name = '';

  	this.color = new Color( color );

  	this.near = ( near !== undefined ) ? near : 1;
  	this.far = ( far !== undefined ) ? far : 1000;

  }

  Object.assign( Fog.prototype, {

  	isFog: true,

  	clone: function () {

  		return new Fog( this.color, this.near, this.far );

  	},

  	toJSON: function (  ) {

  		return {
  			type: 'Fog',
  			color: this.color.getHex(),
  			near: this.near,
  			far: this.far
  		};

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function FogExp2( color, density ) {

  	this.name = '';

  	this.color = new Color( color );
  	this.density = ( density !== undefined ) ? density : 0.00025;

  }

  Object.assign( FogExp2.prototype, {

  	isFogExp2: true,

  	clone: function () {

  		return new FogExp2( this.color, this.density );

  	},

  	toJSON: function (  ) {

  		return {
  			type: 'FogExp2',
  			color: this.color.getHex(),
  			density: this.density
  		};

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var Geometries = {
      WireframeGeometry: WireframeGeometry,
      TetrahedronGeometry: TetrahedronGeometry,
      TetrahedronBufferGeometry: TetrahedronBufferGeometry,
      OctahedronGeometry: OctahedronGeometry,
      OctahedronBufferGeometry: OctahedronBufferGeometry,
      IcosahedronGeometry: IcosahedronGeometry,
      IcosahedronBufferGeometry: IcosahedronBufferGeometry,
      DodecahedronGeometry: DodecahedronGeometry,
      DodecahedronBufferGeometry: DodecahedronBufferGeometry,
      PolyhedronGeometry: PolyhedronGeometry,
      PolyhedronBufferGeometry: PolyhedronBufferGeometry,
      TubeGeometry: TubeGeometry,
      TubeBufferGeometry: TubeBufferGeometry,
      TorusKnotGeometry: TorusKnotGeometry,
      TorusGeometry: TorusGeometry,
      TorusBufferGeometry: TorusBufferGeometry,
      TextGeometry: TextGeometry,
      TextBufferGeometry: TextBufferGeometry,
      SphereGeometry: SphereGeometry,
      SphereBufferGeometry: SphereBufferGeometry,
      RingGeometry: RingGeometry,
      RingBufferGeometry: RingBufferGeometry,
      PlaneGeometry: PlaneGeometry,
      PlaneBufferGeometry: PlaneBufferGeometry,
      LatheGeometry: LatheGeometry,
      LatheBufferGeometry: LatheBufferGeometry,
      ShapeGeometry: ShapeGeometry,
      ShapeBufferGeometry: ShapeBufferGeometry,
      ExtrudeGeometry: ExtrudeGeometry,
      ExtrudeBufferGeometry: ExtrudeBufferGeometry,
      EdgesGeometry: EdgesGeometry,
      ConeGeometry: ConeGeometry,
      ConeBufferGeometry: ConeBufferGeometry,
      CylinderGeometry: CylinderGeometry,
      CylinderBufferGeometry: CylinderBufferGeometry,
      CircleGeometry: CircleGeometry,
      CircleBufferGeometry: CircleBufferGeometry,
      BoxGeometry: BoxGeometry,
      BoxBufferGeometry: BoxBufferGeometry
  };
  function ObjectLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.resourcePath = '';

  }

  Object.assign( ObjectLoader.prototype, {

  	crossOrigin: 'anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
  		this.resourcePath = this.resourcePath || path;

  		var loader = new FileLoader( scope.manager );
  		loader.setPath( this.path );
  		loader.load( url, function ( text ) {

  			var json = null;

  			try {

  				json = JSON.parse( text );

  			} catch ( error ) {

  				if ( onError !== undefined ) { onError( error ); }

  				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  				return;

  			}

  			var metadata = json.metadata;

  			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  				console.error( 'ObjectLoader: Can\'t load ' + url );
  				return;

  			}

  			scope.parse( json, onLoad );

  		}, onProgress, onError );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResourcePath: function ( value ) {

  		this.resourcePath = value;
  		return this;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	parse: function ( json, onLoad ) {

  		var shapes = this.parseShape( json.shapes );
  		var geometries = this.parseGeometries( json.geometries, shapes );

  		var images = this.parseImages( json.images, function () {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		} );

  		var textures = this.parseTextures( json.textures, images );
  		var materials = this.parseMaterials( json.materials, textures );

  		var object = this.parseObject( json.object, geometries, materials );

  		if ( json.animations ) {

  			object.animations = this.parseAnimations( json.animations );

  		}

  		if ( json.images === undefined || json.images.length === 0 ) {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		}

  		return object;

  	},

  	parseShape: function ( json ) {

  		var shapes = {};

  		if ( json !== undefined ) {

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var shape = new Shape().fromJSON( json[ i ] );

  				shapes[ shape.uuid ] = shape;

  			}

  		}

  		return shapes;

  	},

  	parseGeometries: function ( json, shapes ) {
  		var this$1 = this;


  		var geometries = {};

  		if ( json !== undefined ) {

  			var bufferGeometryLoader = new BufferGeometryLoader();

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var geometry;
  				var data = json[ i ];

  				switch ( data.type ) {

  					case 'PlaneGeometry':
  					case 'PlaneBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.widthSegments,
  							data.heightSegments
  						);

  						break;

  					case 'BoxGeometry':
  					case 'BoxBufferGeometry':
  					case 'CubeGeometry': // backwards compatible

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.depth,
  							data.widthSegments,
  							data.heightSegments,
  							data.depthSegments
  						);

  						break;

  					case 'CircleGeometry':
  					case 'CircleBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.segments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'CylinderGeometry':
  					case 'CylinderBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radiusTop,
  							data.radiusBottom,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'ConeGeometry':
  					case 'ConeBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'SphereGeometry':
  					case 'SphereBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.widthSegments,
  							data.heightSegments,
  							data.phiStart,
  							data.phiLength,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'DodecahedronGeometry':
  					case 'DodecahedronBufferGeometry':
  					case 'IcosahedronGeometry':
  					case 'IcosahedronBufferGeometry':
  					case 'OctahedronGeometry':
  					case 'OctahedronBufferGeometry':
  					case 'TetrahedronGeometry':
  					case 'TetrahedronBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.detail
  						);

  						break;

  					case 'RingGeometry':
  					case 'RingBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.innerRadius,
  							data.outerRadius,
  							data.thetaSegments,
  							data.phiSegments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'TorusGeometry':
  					case 'TorusBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.radialSegments,
  							data.tubularSegments,
  							data.arc
  						);

  						break;

  					case 'TorusKnotGeometry':
  					case 'TorusKnotBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.tubularSegments,
  							data.radialSegments,
  							data.p,
  							data.q
  						);

  						break;

  					case 'TubeGeometry':
  					case 'TubeBufferGeometry':

  						// This only works for built-in curves (e.g. CatmullRomCurve3).
  						// User defined curves or instances of CurvePath will not be deserialized.
  						geometry = new Geometries[ data.type ](
  							new Curves[ data.path.type ]().fromJSON( data.path ),
  							data.tubularSegments,
  							data.radius,
  							data.radialSegments,
  							data.closed
  						);

  						break;

  					case 'LatheGeometry':
  					case 'LatheBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.points,
  							data.segments,
  							data.phiStart,
  							data.phiLength
  						);

  						break;

  					case 'PolyhedronGeometry':
  					case 'PolyhedronBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.vertices,
  							data.indices,
  							data.radius,
  							data.details
  						);

  						break;

  					case 'ShapeGeometry':
  					case 'ShapeBufferGeometry':

  						var geometryShapes = [];

  						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  							var shape = shapes[ data.shapes[ j ] ];

  							geometryShapes.push( shape );

  						}

  						geometry = new Geometries[ data.type ](
  							geometryShapes,
  							data.curveSegments
  						);

  						break;
  					case 'ExtrudeGeometry':
  					case 'ExtrudeBufferGeometry':

  						var geometryShapes = [];

  						for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  							var shape = shapes[ data.shapes[ j ] ];

  							geometryShapes.push( shape );

  						}

  						var extrudePath = data.options.extrudePath;

  						if ( extrudePath !== undefined ) {

  							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

  						}

  						geometry = new Geometries[ data.type ](
  							geometryShapes,
  							data.options
  						);

  						break;

  					case 'BufferGeometry':

  						geometry = bufferGeometryLoader.parse( data );

  						break;

  					case 'Geometry':

  						if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {

  							var geometryLoader = new LegacyJSONLoader();
  							geometry = geometryLoader.parse( data, this$1.resourcePath ).geometry;
  						} else {

  							console.error( 'ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );

  						}

  						break;

  					default:

  						console.warn( 'ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  						continue;

  				}

  				geometry.uuid = data.uuid;

  				if ( data.name !== undefined ) { geometry.name = data.name; }
  				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) { geometry.userData = data.userData; }

  				geometries[ data.uuid ] = geometry;

  			}

  		}

  		return geometries;

  	},

  	parseMaterials: function ( json, textures ) {

  		var cache = {}; // MultiMaterial
  		var materials = {};

  		if ( json !== undefined ) {

  			var loader = new MaterialLoader();
  			loader.setTextures( textures );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.type === 'MultiMaterial' ) {

  					// Deprecated

  					var array = [];

  					for ( var j = 0; j < data.materials.length; j ++ ) {

  						var material = data.materials[ j ];

  						if ( cache[ material.uuid ] === undefined ) {

  							cache[ material.uuid ] = loader.parse( material );

  						}

  						array.push( cache[ material.uuid ] );

  					}

  					materials[ data.uuid ] = array;

  				} else {

  					if ( cache[ data.uuid ] === undefined ) {

  						cache[ data.uuid ] = loader.parse( data );

  					}

  					materials[ data.uuid ] = cache[ data.uuid ];

  				}

  			}

  		}

  		return materials;

  	},

  	parseAnimations: function ( json ) {

  		var animations = [];

  		for ( var i = 0; i < json.length; i ++ ) {

  			var data = json[ i ];

  			var clip = AnimationClip.parse( data );

  			if ( data.uuid !== undefined ) { clip.uuid = data.uuid; }

  			animations.push( clip );

  		}

  		return animations;

  	},

  	parseImages: function ( json, onLoad ) {

  		var scope = this;
  		var images = {};

  		function loadImage( url ) {

  			scope.manager.itemStart( url );

  			return loader.load( url, function () {

  				scope.manager.itemEnd( url );

  			}, undefined, function () {

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			} );

  		}

  		if ( json !== undefined && json.length > 0 ) {

  			var manager = new LoadingManager( onLoad );

  			var loader = new ImageLoader( manager );
  			loader.setCrossOrigin( this.crossOrigin );

  			for ( var i = 0, il = json.length; i < il; i ++ ) {

  				var image = json[ i ];
  				var url = image.url;

  				if ( Array.isArray( url ) ) {

  					// load array of images e.g CubeTexture

  					images[ image.uuid ] = [];

  					for ( var j = 0, jl = url.length; j < jl; j ++ ) {

  						var currentUrl = url[ j ];

  						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

  						images[ image.uuid ].push( loadImage( path ) );

  					}

  				} else {

  					// load single image

  					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

  					images[ image.uuid ] = loadImage( path );

  				}

  			}

  		}

  		return images;

  	},

  	parseTextures: function ( json, images ) {

  		function parseConstant( value, type ) {

  			if ( typeof value === 'number' ) { return value; }

  			console.warn( 'ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  			return type[ value ];

  		}

  		var textures = {};

  		if ( json !== undefined ) {

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.image === undefined ) {

  					console.warn( 'ObjectLoader: No "image" specified for', data.uuid );

  				}

  				if ( images[ data.image ] === undefined ) {

  					console.warn( 'ObjectLoader: Undefined image', data.image );

  				}

  				var texture;

  				if ( Array.isArray( images[ data.image ] ) ) {

  					texture = new CubeTexture( images[ data.image ] );

  				} else {

  					texture = new Texture( images[ data.image ] );

  				}

  				texture.needsUpdate = true;

  				texture.uuid = data.uuid;

  				if ( data.name !== undefined ) { texture.name = data.name; }

  				if ( data.mapping !== undefined ) { texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); }

  				if ( data.offset !== undefined ) { texture.offset.fromArray( data.offset ); }
  				if ( data.repeat !== undefined ) { texture.repeat.fromArray( data.repeat ); }
  				if ( data.center !== undefined ) { texture.center.fromArray( data.center ); }
  				if ( data.rotation !== undefined ) { texture.rotation = data.rotation; }

  				if ( data.wrap !== undefined ) {

  					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
  					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

  				}

  				if ( data.format !== undefined ) { texture.format = data.format; }
  				if ( data.type !== undefined ) { texture.type = data.type; }
  				if ( data.encoding !== undefined ) { texture.encoding = data.encoding; }

  				if ( data.minFilter !== undefined ) { texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); }
  				if ( data.magFilter !== undefined ) { texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); }
  				if ( data.anisotropy !== undefined ) { texture.anisotropy = data.anisotropy; }

  				if ( data.flipY !== undefined ) { texture.flipY = data.flipY; }

  				if ( data.premultiplyAlpha !== undefined ) { texture.premultiplyAlpha = data.premultiplyAlpha; }
  				if ( data.unpackAlignment !== undefined ) { texture.unpackAlignment = data.unpackAlignment; }

  				textures[ data.uuid ] = texture;

  			}

  		}

  		return textures;

  	},

  	parseObject: function ( data, geometries, materials ) {
  		var this$1 = this;


  		var object;

  		function getGeometry( name ) {

  			if ( geometries[ name ] === undefined ) {

  				console.warn( 'ObjectLoader: Undefined geometry', name );

  			}

  			return geometries[ name ];

  		}

  		function getMaterial( name ) {

  			if ( name === undefined ) { return undefined; }

  			if ( Array.isArray( name ) ) {

  				var array = [];

  				for ( var i = 0, l = name.length; i < l; i ++ ) {

  					var uuid = name[ i ];

  					if ( materials[ uuid ] === undefined ) {

  						console.warn( 'ObjectLoader: Undefined material', uuid );

  					}

  					array.push( materials[ uuid ] );

  				}

  				return array;

  			}

  			if ( materials[ name ] === undefined ) {

  				console.warn( 'ObjectLoader: Undefined material', name );

  			}

  			return materials[ name ];

  		}

  		switch ( data.type ) {

  			case 'Scene':

  				object = new Scene();

  				if ( data.background !== undefined ) {

  					if ( Number.isInteger( data.background ) ) {

  						object.background = new Color( data.background );

  					}

  				}

  				if ( data.fog !== undefined ) {

  					if ( data.fog.type === 'Fog' ) {

  						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

  					} else if ( data.fog.type === 'FogExp2' ) {

  						object.fog = new FogExp2( data.fog.color, data.fog.density );

  					}

  				}

  				break;

  			case 'PerspectiveCamera':

  				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

  				if ( data.focus !== undefined ) { object.focus = data.focus; }
  				if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
  				if ( data.filmGauge !== undefined ) { object.filmGauge = data.filmGauge; }
  				if ( data.filmOffset !== undefined ) { object.filmOffset = data.filmOffset; }
  				if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

  				break;

  			case 'OrthographicCamera':

  				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

  				if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
  				if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

  				break;

  			case 'AmbientLight':

  				object = new AmbientLight( data.color, data.intensity );

  				break;

  			case 'DirectionalLight':

  				object = new DirectionalLight( data.color, data.intensity );

  				break;

  			case 'PointLight':

  				object = new PointLight( data.color, data.intensity, data.distance, data.decay );

  				break;

  			case 'RectAreaLight':

  				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

  				break;

  			case 'SpotLight':

  				object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  				break;

  			case 'HemisphereLight':

  				object = new HemisphereLight( data.color, data.groundColor, data.intensity );

  				break;

  			case 'SkinnedMesh':

  				console.warn( 'ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

  			case 'Mesh':

  				var geometry = getGeometry( data.geometry );
  				var material = getMaterial( data.material );

  				if ( geometry.bones && geometry.bones.length > 0 ) {

  					object = new SkinnedMesh( geometry, material );

  				} else {

  					object = new Mesh( geometry, material );

  				}

  				if ( data.drawMode !== undefined ) { object.setDrawMode( data.drawMode ); }

  				break;

  			case 'LOD':

  				object = new LOD();

  				break;

  			case 'Line':

  				object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

  				break;

  			case 'LineLoop':

  				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'LineSegments':

  				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'PointCloud':
  			case 'Points':

  				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

  				break;

  			case 'Sprite':

  				object = new Sprite( getMaterial( data.material ) );

  				break;

  			case 'Group':

  				object = new Group();

  				break;

  			default:

  				object = new Object3D();

  		}

  		object.uuid = data.uuid;

  		if ( data.name !== undefined ) { object.name = data.name; }

  		if ( data.matrix !== undefined ) {

  			object.matrix.fromArray( data.matrix );

  			if ( data.matrixAutoUpdate !== undefined ) { object.matrixAutoUpdate = data.matrixAutoUpdate; }
  			if ( object.matrixAutoUpdate ) { object.matrix.decompose( object.position, object.quaternion, object.scale ); }

  		} else {

  			if ( data.position !== undefined ) { object.position.fromArray( data.position ); }
  			if ( data.rotation !== undefined ) { object.rotation.fromArray( data.rotation ); }
  			if ( data.quaternion !== undefined ) { object.quaternion.fromArray( data.quaternion ); }
  			if ( data.scale !== undefined ) { object.scale.fromArray( data.scale ); }

  		}

  		if ( data.castShadow !== undefined ) { object.castShadow = data.castShadow; }
  		if ( data.receiveShadow !== undefined ) { object.receiveShadow = data.receiveShadow; }

  		if ( data.shadow ) {

  			if ( data.shadow.bias !== undefined ) { object.shadow.bias = data.shadow.bias; }
  			if ( data.shadow.radius !== undefined ) { object.shadow.radius = data.shadow.radius; }
  			if ( data.shadow.mapSize !== undefined ) { object.shadow.mapSize.fromArray( data.shadow.mapSize ); }
  			if ( data.shadow.camera !== undefined ) { object.shadow.camera = this.parseObject( data.shadow.camera ); }

  		}

  		if ( data.visible !== undefined ) { object.visible = data.visible; }
  		if ( data.frustumCulled !== undefined ) { object.frustumCulled = data.frustumCulled; }
  		if ( data.renderOrder !== undefined ) { object.renderOrder = data.renderOrder; }
  		if ( data.userData !== undefined ) { object.userData = data.userData; }
  		if ( data.layers !== undefined ) { object.layers.mask = data.layers; }

  		if ( data.children !== undefined ) {

  			var children = data.children;

  			for ( var i = 0; i < children.length; i ++ ) {

  				object.add( this$1.parseObject( children[ i ], geometries, materials ) );

  			}

  		}

  		if ( data.type === 'LOD' ) {

  			var levels = data.levels;

  			for ( var l = 0; l < levels.length; l ++ ) {

  				var level = levels[ l ];
  				var child = object.getObjectByProperty( 'uuid', level.object );

  				if ( child !== undefined ) {

  					object.addLevel( child, level.distance );

  				}

  			}

  		}

  		return object;

  	}

  } );

  var TEXTURE_MAPPING = {
  	UVMapping: UVMapping,
  	CubeReflectionMapping: CubeReflectionMapping,
  	CubeRefractionMapping: CubeRefractionMapping,
  	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  	SphericalReflectionMapping: SphericalReflectionMapping,
  	CubeUVReflectionMapping: CubeUVReflectionMapping,
  	CubeUVRefractionMapping: CubeUVRefractionMapping
  };

  var TEXTURE_WRAPPING = {
  	RepeatWrapping: RepeatWrapping,
  	ClampToEdgeWrapping: ClampToEdgeWrapping,
  	MirroredRepeatWrapping: MirroredRepeatWrapping
  };

  var TEXTURE_FILTER = {
  	NearestFilter: NearestFilter,
  	NearestMipMapNearestFilter: NearestMipMapNearestFilter,
  	NearestMipMapLinearFilter: NearestMipMapLinearFilter,
  	LinearFilter: LinearFilter,
  	LinearMipMapNearestFilter: LinearMipMapNearestFilter,
  	LinearMipMapLinearFilter: LinearMipMapLinearFilter
  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function MeshMatcapMaterial( parameters ) {

  	Material$1.call( this );

  	this.defines = { 'MATCAP': '' };

  	this.type = 'MeshMatcapMaterial';

  	this.color = new Color( 0xffffff ); // diffuse

  	this.matcap = null;

  	this.map = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalMapType = TangentSpaceNormalMap;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.alphaMap = null;

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshMatcapMaterial.prototype = Object.create( Material$1.prototype );
  MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

  MeshMatcapMaterial.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.defines = { 'MATCAP': '' };

  	this.color.copy( source.color );

  	this.matcap = source.matcap;

  	this.map = source.map;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalMapType = source.normalMapType;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.alphaMap = source.alphaMap;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // WARNING: This file was auto-generated, any change will be overridden in next release. Please use configs/es6.conf.js then run "npm run convert". //
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function Cylindrical( radius, theta, y ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
  	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

  	return this;

  }

  Object.assign( Cylindrical.prototype, {

  	set: function ( radius, theta, y ) {

  		this.radius = radius;
  		this.theta = theta;
  		this.y = y;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.theta = other.theta;
  		this.y = other.y;

  		return this;

  	},

  	setFromVector3: function ( v ) {

  		return this.setFromCartesianCoords( v.x, v.y, v.z );

  	},

  	setFromCartesianCoords: function ( x, y, z ) {

  		this.radius = Math.sqrt( x * x + z * z );
  		this.theta = Math.atan2( x, z );
  		this.y = y;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGL2Renderer( parameters ) {

  	console.log( 'WebGL2Renderer', REVISION );

  	parameters = parameters || {};

  	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
  		_context = parameters.context !== undefined ? parameters.context : null,

  		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  		_depth = parameters.depth !== undefined ? parameters.depth : true,
  		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

  	// initialize

  	var gl;

  	try {

  		var attributes = {
  			alpha: _alpha,
  			depth: _depth,
  			stencil: _stencil,
  			antialias: _antialias,
  			premultipliedAlpha: _premultipliedAlpha,
  			preserveDrawingBuffer: _preserveDrawingBuffer,
  			powerPreference: _powerPreference
  		};

  		// event listeners must be registered before WebGL context is created, see #12753

  		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.addEventListener( 'webglcontextrestored', function () { } );

  		gl = _context || _canvas.getContext( 'webgl2', attributes );

  		if ( gl === null ) {

  			if ( _canvas.getContext( 'webgl2' ) !== null ) {

  				throw new Error( 'Error creating WebGL2 context with your selected attributes.' );

  			} else {

  				throw new Error( 'Error creating WebGL2 context.' );

  			}

  		}

  	} catch ( error ) {

  		console.error( 'WebGL2Renderer: ' + error.message );

  	}

  	//

  	var _autoClearColor = true,
  		_autoClearDepth = true,
  		_autoClearStencil = true,

  		_clearColor = new Color( 0x000000 ),
  		_clearAlpha = 0,

  		_width = _canvas.width,
  		_height = _canvas.height,

  		_pixelRatio = 1,

  		_viewport = new Vector4( 0, 0, _width, _height );

  	var extensions = new WebGLExtensions( gl );
  	var state = new WebGLState( gl, extensions, function () {} );

  	//

  	function clear( color, depth, stencil ) {

  		var bits = 0;

  		if ( color === undefined || color ) { bits |= gl.COLOR_BUFFER_BIT; }
  		if ( depth === undefined || depth ) { bits |= gl.DEPTH_BUFFER_BIT; }
  		if ( stencil === undefined || stencil ) { bits |= gl.STENCIL_BUFFER_BIT; }

  		gl.clear( bits );

  	}

  	function setPixelRatio( value ) {

  		if ( value === undefined ) { return; }

  		_pixelRatio = value;

  		setSize( _viewport.z, _viewport.w, false );

  	}

  	function setSize( width, height, updateStyle ) {

  		_width = width;
  		_height = height;

  		_canvas.width = width * _pixelRatio;
  		_canvas.height = height * _pixelRatio;

  		if ( updateStyle !== false ) {

  			_canvas.style.width = width + 'px';
  			_canvas.style.height = height + 'px';

  		}

  		setViewport( 0, 0, width, height );

  	}

  	function setViewport( x, y, width, height ) {

  		state.viewport( _viewport.set( x, y, width, height ) );

  	}

  	function render( scene, camera ) {

  		if ( camera !== undefined && camera.isCamera !== true ) {

  			console.error( 'WebGL2Renderer.render: camera is not an instance of Camera.' );
  			return;

  		}

  		var background = scene.background;

  		if ( background === null ) {

  			state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

  		} else if ( background && background.isColor ) {

  			state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );

  		}

  		{

  			this.clear( _autoClearColor, _autoClearDepth, _autoClearStencil );

  		}

  	}

  	function onContextLost( event ) {

  		event.preventDefault();

  	}

  	return {
  		domElement: _canvas,

  		clear: clear,
  		setPixelRatio: setPixelRatio,
  		setSize: setSize,
  		render: render
  	};

  }

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function WebGLMultisampleRenderTarget( width, height, options ) {

  	WebGLRenderTarget.call( this, width, height, options );

  	this.samples = 4;

  }

  WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

  	constructor: WebGLMultisampleRenderTarget,

  	isWebGLMultisampleRenderTarget: true,

  	copy: function ( source ) {

  		WebGLRenderTarget.prototype.copy.call( this, source );

  		this.samples = source.samples;

  		return this;

  	}

  } );

  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.format = format !== undefined ? format : RGBFormat;

  	this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

  	this.generateMipmaps = false;

  }

  VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

  	constructor: VideoTexture,

  	isVideoTexture: true,

  	update: function () {

  		var video = this.image;

  		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

  			this.needsUpdate = true;

  		}

  	}

  } );

  exports.CCDIKSolver = CCDIKSolver;
  exports.MMDAnimationHelper = MMDAnimationHelper;
  exports.MMDPhysics = MMDPhysics;
  exports.AnimationClipCreator = AnimationClipCreator;
  exports.CinematicCamera = CinematicCamera;
  exports.Car = Car;
  exports.DeviceOrientationControls = DeviceOrientationControls;
  exports.DragControls = DragControls;
  exports.EditorControls = EditorControls;
  exports.FirstPersonControls = FirstPersonControls;
  exports.FlyControls = FlyControls;
  exports.MapControls = MapControls;
  exports.OrbitControls = OrbitControls;
  exports.OrthographicTrackballControls = OrthographicTrackballControls;
  exports.PointerLockControls = PointerLockControls;
  exports.TrackballControls = TrackballControls;
  exports.TransformControls = TransformControls;
  exports.TransformControlsGizmo = TransformControlsGizmo;
  exports.TransformControlsPlane = TransformControlsPlane;
  exports.ConvexObjectBreaker = ConvexObjectBreaker;
  exports.GrannyKnot = GrannyKnot;
  exports.HeartCurve = HeartCurve;
  exports.VivianiCurve = VivianiCurve;
  exports.KnotCurve = KnotCurve;
  exports.HelixCurve = HelixCurve;
  exports.TrefoilKnot = TrefoilKnot;
  exports.TorusKnot = TorusKnot;
  exports.CinquefoilKnot = CinquefoilKnot;
  exports.TrefoilPolynomialKnot = TrefoilPolynomialKnot;
  exports.FigureEightPolynomialKnot = FigureEightPolynomialKnot;
  exports.DecoratedTorusKnot4a = DecoratedTorusKnot4a;
  exports.DecoratedTorusKnot4b = DecoratedTorusKnot4b;
  exports.DecoratedTorusKnot5a = DecoratedTorusKnot5a;
  exports.DecoratedTorusKnot5c = DecoratedTorusKnot5c;
  exports.NURBSCurve = NURBSCurve;
  exports.NURBSSurface = NURBSSurface;
  exports.NURBSUtils = NURBSUtils;
  exports.AnaglyphEffect = AnaglyphEffect;
  exports.AsciiEffect = AsciiEffect;
  exports.OutlineEffect = OutlineEffect;
  exports.ParallaxBarrierEffect = ParallaxBarrierEffect;
  exports.PeppersGhostEffect = PeppersGhostEffect;
  exports.StereoEffect = StereoEffect;
  exports.ColladaExporter = ColladaExporter;
  exports.GLTFExporter = GLTFExporter;
  exports.MMDExporter = MMDExporter;
  exports.OBJExporter = OBJExporter;
  exports.PLYExporter = PLYExporter;
  exports.STLExporter = STLExporter;
  exports.TypedGeometryExporter = TypedGeometryExporter;
  exports.BoxLineGeometry = BoxLineGeometry;
  exports.ConvexGeometry = ConvexGeometry;
  exports.ConvexBufferGeometry = ConvexBufferGeometry;
  exports.DecalGeometry = DecalGeometry;
  exports.hilbert2D = hilbert2D;
  exports.hilbert3D = hilbert3D;
  exports.LightningStrike = LightningStrike;
  exports.TeapotBufferGeometry = TeapotBufferGeometry;
  exports.GPUComputationRenderer = GPUComputationRenderer;
  exports.GPUParticleSystem = GPUParticleSystem;
  exports.GPUParticleContainer = GPUParticleContainer;
  exports.Gyroscope = Gyroscope;
  exports.ImprovedNoise = ImprovedNoise;
  exports.SelectionBox = SelectionBox;
  exports.SelectionHelper = SelectionHelper;
  exports.Line2 = Line2;
  exports.LineGeometry = LineGeometry;
  exports.LineMaterial = LineMaterial;
  exports.LineSegments2 = LineSegments2;
  exports.LineSegmentsGeometry = LineSegmentsGeometry;
  exports.Wireframe = Wireframe;
  exports.WireframeGeometry2 = WireframeGeometry2;
  exports.ThreeMFLoader = ThreeMFLoader;
  exports.AMFLoader = AMFLoader;
  exports.AssimpJSONLoader = AssimpJSONLoader;
  exports.AssimpLoader = AssimpLoader;
  exports.AWDLoader = AWDLoader;
  exports.BabylonLoader = BabylonLoader;
  exports.BVHLoader = BVHLoader;
  exports.ColladaLoader = ColladaLoader;
  exports.DDSLoader = DDSLoader;
  exports.LegacyGLTFLoader = LegacyGLTFLoader;
  exports.LegacyJSONLoader = LegacyJSONLoader;
  exports.DRACOLoader = DRACOLoader$1;
  exports.CubemapGenerator = CubemapGenerator;
  exports.EXRLoader = EXRLoader;
  exports.FBXLoader = FBXLoader;
  exports.GCodeLoader = GCodeLoader;
  exports.GLTFLoader = GLTFLoader;
  exports.HDRCubeTextureLoader = HDRCubeTextureLoader;
  exports.KMZLoader = KMZLoader;
  exports.KTXLoader = KTXLoader;
  exports.LDrawLoader = LDrawLoader;
  exports.LoaderSupport = LoaderSupport;
  exports.MD2Loader = MD2Loader;
  exports.MMDLoader = MMDLoader;
  exports.MTLLoader = MTLLoader;
  exports.NodeMaterialLoader = NodeMaterialLoader;
  exports.OBJLoader = OBJLoader;
  exports.OBJLoader2 = OBJLoader2;
  exports.PCDLoader = PCDLoader;
  exports.PDBLoader = PDBLoader;
  exports.PlayCanvasLoader = PlayCanvasLoader;
  exports.PLYLoader = PLYLoader;
  exports.PRWMLoader = PRWMLoader;
  exports.PVRLoader = PVRLoader;
  exports.HDRLoader = HDRLoader;
  exports.RGBELoader = RGBELoader;
  exports.STLLoader = STLLoader;
  exports.SVGLoader = SVGLoader;
  exports.TDSLoader = TDSLoader;
  exports.TGALoader = TGALoader;
  exports.TTFLoader = TTFLoader;
  exports.VRMLLoader = VRMLLoader;
  exports.VRMLoader = VRMLoader;
  exports.VTKLoader = VTKLoader;
  exports.MarchingCubes = MarchingCubes;
  exports.ColorConverter = ColorConverter;
  exports.Lut = Lut;
  exports.MD2Character = MD2Character;
  exports.MD2CharacterComplex = MD2CharacterComplex;
  exports.ExplodeModifier = ExplodeModifier;
  exports.SimplifyModifier = SimplifyModifier;
  exports.SubdivisionModifier = SubdivisionModifier;
  exports.TessellateModifier = TessellateModifier;
  exports.MorphAnimMesh = MorphAnimMesh;
  exports.MorphBlendMesh = MorphBlendMesh;
  exports.CameraNode = CameraNode;
  exports.ColorsNode = ColorsNode;
  exports.LightNode = LightNode;
  exports.NormalNode = NormalNode$1;
  exports.PositionNode = PositionNode;
  exports.ReflectNode = ReflectNode;
  exports.ResolutionNode = ResolutionNode;
  exports.ScreenUVNode = ScreenUVNode;
  exports.UVNode = UVNode;
  exports.BlinnExponentToRoughnessNode = BlinnExponentToRoughnessNode;
  exports.BlinnShininessExponentNode = BlinnShininessExponentNode;
  exports.RoughnessToBlinnExponentNode = RoughnessToBlinnExponentNode;
  exports.AttributeNode = AttributeNode;
  exports.ConstNode = ConstNode;
  exports.ExpressionNode = ExpressionNode;
  exports.FunctionCallNode = FunctionCallNode;
  exports.FunctionNode = FunctionNode;
  exports.InputNode = InputNode;
  exports.Node = Node$1;
  exports.NodeBuilder = NodeBuilder;
  exports.NodeFrame = NodeFrame;
  exports.NodeLib = NodeLib;
  exports.NodeUniform = NodeUniform;
  exports.NodeUtils = NodeUtils;
  exports.StructNode = StructNode;
  exports.TempNode = TempNode;
  exports.VarNode = VarNode;
  exports.BlurNode = BlurNode;
  exports.ColorAdjustmentNode = ColorAdjustmentNode;
  exports.LuminanceNode = LuminanceNode;
  exports.BoolNode = BoolNode;
  exports.ColorNode = ColorNode;
  exports.CubeTextureNode = CubeTextureNode;
  exports.FloatNode = FloatNode;
  exports.IntNode = IntNode;
  exports.Matrix3Node = Matrix3Node;
  exports.Matrix4Node = Matrix4Node;
  exports.PropertyNode = PropertyNode;
  exports.ReflectorNode = ReflectorNode;
  exports.RTTNode = RTTNode;
  exports.ScreenNode = ScreenNode;
  exports.TextureNode = TextureNode;
  exports.Vector2Node = Vector2Node;
  exports.Vector3Node = Vector3Node;
  exports.Vector4Node = Vector4Node;
  exports.MeshStandardNodeMaterial = MeshStandardNodeMaterial;
  exports.NodeMaterial = NodeMaterial;
  exports.MeshStandardNode = MeshStandardNode;
  exports.PhongNode = PhongNode;
  exports.RawNode = RawNode;
  exports.SpriteNode = SpriteNode;
  exports.StandardNode = StandardNode;
  exports.PhongNodeMaterial = PhongNodeMaterial;
  exports.SpriteNodeMaterial = SpriteNodeMaterial;
  exports.StandardNodeMaterial = StandardNodeMaterial;
  exports.CondNode = CondNode;
  exports.Math1Node = Math1Node;
  exports.Math2Node = Math2Node;
  exports.Math3Node = Math3Node;
  exports.OperatorNode = OperatorNode;
  exports.BumpMapNode = BumpMapNode;
  exports.NormalMapNode = NormalMapNode;
  exports.TextureCubeNode = TextureCubeNode;
  exports.TextureCubeUVNode = TextureCubeUVNode;
  exports.NodePass = NodePass;
  exports.NodePostProcessing = NodePostProcessing;
  exports.CheckerNode = CheckerNode;
  exports.NoiseNode = NoiseNode;
  exports.BypassNode = BypassNode;
  exports.ColorSpaceNode = ColorSpaceNode;
  exports.JoinNode = JoinNode;
  exports.MaxMIPLevelNode = MaxMIPLevelNode;
  exports.SwitchNode = SwitchNode;
  exports.TimerNode = TimerNode;
  exports.UVTransformNode = UVTransformNode;
  exports.VelocityNode = VelocityNode;
  exports.Fire = Fire;
  exports.Lensflare = Lensflare;
  exports.LensflareElement = LensflareElement;
  exports.LightningStorm = LightningStorm;
  exports.Reflector = Reflector;
  exports.ReflectorRTT = ReflectorRTT;
  exports.Refractor = Refractor;
  exports.ShadowMesh = ShadowMesh;
  exports.Sky = Sky;
  exports.Water = Water;
  exports.Water2 = Water2;
  exports.Ocean = Ocean;
  exports.PMREMCubeUVPacker = PMREMCubeUVPacker;
  exports.PMREMGenerator = PMREMGenerator;
  exports.AdaptiveToneMappingPass = AdaptiveToneMappingPass;
  exports.AfterimagePass = AfterimagePass;
  exports.BloomPass = BloomPass;
  exports.BokehPass = BokehPass;
  exports.ClearPass = ClearPass;
  exports.CubeTexturePass = CubeTexturePass;
  exports.DotScreenPass = DotScreenPass;
  exports.EffectComposer = EffectComposer;
  exports.FilmPass = FilmPass;
  exports.GlitchPass = GlitchPass;
  exports.HalftonePass = HalftonePass;
  exports.MaskPass = MaskPass;
  exports.ClearMaskPass = ClearMaskPass;
  exports.OutlinePass = OutlinePass;
  exports.Pass = Pass;
  exports.RenderPass = RenderPass;
  exports.SAOPass = SAOPass;
  exports.SavePass = SavePass;
  exports.ShaderPass = ShaderPass;
  exports.SMAAPass = SMAAPass;
  exports.SSAARenderPass = SSAARenderPass;
  exports.SSAOPass = SSAOPass;
  exports.TAARenderPass = TAARenderPass;
  exports.TexturePass = TexturePass;
  exports.UnrealBloomPass = UnrealBloomPass;
  exports.PRNG = PRNG;
  exports.QuickHull = QuickHull;
  exports.CSS2DObject = CSS2DObject;
  exports.CSS2DRenderer = CSS2DRenderer;
  exports.CSS3DObject = CSS3DObject;
  exports.CSS3DSprite = CSS3DSprite;
  exports.CSS3DRenderer = CSS3DRenderer;
  exports.RenderableObject = RenderableObject;
  exports.RenderableFace = RenderableFace;
  exports.RenderableVertex = RenderableVertex;
  exports.RenderableLine = RenderableLine;
  exports.RenderableSprite = RenderableSprite;
  exports.Projector = Projector;
  exports.RaytracingRenderer = RaytracingRenderer;
  exports.SoftwareRenderer = SoftwareRenderer;
  exports.SVGObject = SVGObject;
  exports.SVGRenderer = SVGRenderer;
  exports.WebGLDeferredRenderer = WebGLDeferredRenderer;
  exports.RollerCoasterGeometry = RollerCoasterGeometry;
  exports.RollerCoasterLiftersGeometry = RollerCoasterLiftersGeometry;
  exports.RollerCoasterShadowGeometry = RollerCoasterShadowGeometry;
  exports.SkyGeometry = SkyGeometry;
  exports.TreesGeometry = TreesGeometry;
  exports.ShaderGodRays = ShaderGodRays;
  exports.AfterimageShader = AfterimageShader;
  exports.BasicShader = BasicShader;
  exports.BleachBypassShader = BleachBypassShader;
  exports.BlendShader = BlendShader;
  exports.BokehShader = BokehShader;
  exports.BokehShader2 = BokehShader2;
  exports.BokehDepthShader = BokehDepthShader;
  exports.BrightnessContrastShader = BrightnessContrastShader;
  exports.ColorCorrectionShader = ColorCorrectionShader;
  exports.ColorifyShader = ColorifyShader;
  exports.ConvolutionShader = ConvolutionShader;
  exports.CopyShader = CopyShader;
  exports.DepthLimitedBlurShader = DepthLimitedBlurShader;
  exports.BlurShaderUtils = BlurShaderUtils;
  exports.DigitalGlitch = DigitalGlitch;
  exports.DOFMipMapShader = DOFMipMapShader;
  exports.DotScreenShader = DotScreenShader;
  exports.FilmShader = FilmShader;
  exports.FocusShader = FocusShader;
  exports.FreiChenShader = FreiChenShader;
  exports.FresnelShader = FresnelShader;
  exports.FXAAShader = FXAAShader;
  exports.GammaCorrectionShader = GammaCorrectionShader;
  exports.HalftoneShader = HalftoneShader;
  exports.HorizontalBlurShader = HorizontalBlurShader;
  exports.HorizontalTiltShiftShader = HorizontalTiltShiftShader;
  exports.HueSaturationShader = HueSaturationShader;
  exports.KaleidoShader = KaleidoShader;
  exports.LuminosityHighPassShader = LuminosityHighPassShader;
  exports.LuminosityShader = LuminosityShader;
  exports.MirrorShader = MirrorShader;
  exports.NormalMapShader = NormalMapShader;
  exports.ParallaxShader = ParallaxShader;
  exports.PixelShader = PixelShader;
  exports.RGBShiftShader = RGBShiftShader;
  exports.SAOShader = SAOShader;
  exports.SepiaShader = SepiaShader;
  exports.SMAAShader = SMAAShader;
  exports.SobelOperatorShader = SobelOperatorShader;
  exports.SSAOShader = SSAOShader;
  exports.SSAODepthShader = SSAODepthShader;
  exports.SSAOBlurShader = SSAOBlurShader;
  exports.TechnicolorShader = TechnicolorShader;
  exports.ToneMapShader = ToneMapShader;
  exports.TriangleBlurShader = TriangleBlurShader;
  exports.UnpackDepthRGBAShader = UnpackDepthRGBAShader;
  exports.VerticalBlurShader = VerticalBlurShader;
  exports.VerticalTiltShiftShader = VerticalTiltShiftShader;
  exports.VignetteShader = VignetteShader;
  exports.VolumeRenderShader1 = VolumeRenderShader1;
  exports.WaterRefractionShader = WaterRefractionShader;
  exports.ShaderSkin = ShaderSkin;
  exports.ShaderTerrain = ShaderTerrain;
  exports.ShaderToon = ShaderToon;
  exports.TranslucentShader = TranslucentShader;
  exports.SimplexNoise = SimplexNoise;
  exports.TimelinerController = TimelinerController;
  exports.TypedArrayUtils = TypedArrayUtils;
  exports.BufferGeometryUtils = BufferGeometryUtils;
  exports.GeometryUtils = GeometryUtils;
  exports.MathUtils = MathUtils;
  exports.SceneUtils = SceneUtils;
  exports.ShadowMapViewer = ShadowMapViewer;
  exports.SkeletonUtils = SkeletonUtils;
  exports.UVsDebug = UVsDebug;
  exports.VolumeSlice = VolumeSlice;
  exports.DaydreamController = DaydreamController;
  exports.GearVRController = GearVRController;
  exports.PaintViveController = PaintViveController;
  exports.ViveController = ViveController;
  exports.WebVR = WebVR;
  exports.WebGL = WebGL;
  exports.AnimationAction = AnimationAction;
  exports.AnimationClip = AnimationClip;
  exports.AnimationMixer = AnimationMixer;
  exports.AnimationObjectGroup = AnimationObjectGroup;
  exports.AnimationUtils = AnimationUtils;
  exports.KeyframeTrack = KeyframeTrack;
  exports.PropertyBinding = PropertyBinding;
  exports.PropertyMixer = PropertyMixer;
  exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
  exports.ColorKeyframeTrack = ColorKeyframeTrack;
  exports.NumberKeyframeTrack = NumberKeyframeTrack;
  exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
  exports.StringKeyframeTrack = StringKeyframeTrack;
  exports.VectorKeyframeTrack = VectorKeyframeTrack;
  exports.Audio = Audio;
  exports.AudioAnalyser = AudioAnalyser;
  exports.AudioContext = AudioContext;
  exports.AudioListener = AudioListener;
  exports.PositionalAudio = PositionalAudio;
  exports.ArrayCamera = ArrayCamera;
  exports.Camera = Camera;
  exports.CubeCamera = CubeCamera;
  exports.OrthographicCamera = OrthographicCamera;
  exports.PerspectiveCamera = PerspectiveCamera;
  exports.StereoCamera = StereoCamera;
  exports.REVISION = REVISION;
  exports.MOUSE = MOUSE;
  exports.CullFaceNone = CullFaceNone;
  exports.CullFaceBack = CullFaceBack;
  exports.CullFaceFront = CullFaceFront;
  exports.CullFaceFrontBack = CullFaceFrontBack;
  exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
  exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
  exports.BasicShadowMap = BasicShadowMap;
  exports.PCFShadowMap = PCFShadowMap;
  exports.PCFSoftShadowMap = PCFSoftShadowMap;
  exports.FrontSide = FrontSide;
  exports.BackSide = BackSide;
  exports.DoubleSide = DoubleSide;
  exports.FlatShading = FlatShading;
  exports.SmoothShading = SmoothShading;
  exports.NoColors = NoColors;
  exports.FaceColors = FaceColors;
  exports.VertexColors = VertexColors;
  exports.NoBlending = NoBlending;
  exports.NormalBlending = NormalBlending;
  exports.AdditiveBlending = AdditiveBlending;
  exports.SubtractiveBlending = SubtractiveBlending;
  exports.MultiplyBlending = MultiplyBlending;
  exports.CustomBlending = CustomBlending;
  exports.AddEquation = AddEquation;
  exports.SubtractEquation = SubtractEquation;
  exports.ReverseSubtractEquation = ReverseSubtractEquation;
  exports.MinEquation = MinEquation;
  exports.MaxEquation = MaxEquation;
  exports.ZeroFactor = ZeroFactor;
  exports.OneFactor = OneFactor;
  exports.SrcColorFactor = SrcColorFactor;
  exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
  exports.SrcAlphaFactor = SrcAlphaFactor;
  exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
  exports.DstAlphaFactor = DstAlphaFactor;
  exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
  exports.DstColorFactor = DstColorFactor;
  exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
  exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
  exports.NeverDepth = NeverDepth;
  exports.AlwaysDepth = AlwaysDepth;
  exports.LessDepth = LessDepth;
  exports.LessEqualDepth = LessEqualDepth;
  exports.EqualDepth = EqualDepth;
  exports.GreaterEqualDepth = GreaterEqualDepth;
  exports.GreaterDepth = GreaterDepth;
  exports.NotEqualDepth = NotEqualDepth;
  exports.MultiplyOperation = MultiplyOperation;
  exports.MixOperation = MixOperation;
  exports.AddOperation = AddOperation;
  exports.NoToneMapping = NoToneMapping;
  exports.LinearToneMapping = LinearToneMapping;
  exports.ReinhardToneMapping = ReinhardToneMapping;
  exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
  exports.CineonToneMapping = CineonToneMapping;
  exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
  exports.UVMapping = UVMapping;
  exports.CubeReflectionMapping = CubeReflectionMapping;
  exports.CubeRefractionMapping = CubeRefractionMapping;
  exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
  exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
  exports.SphericalReflectionMapping = SphericalReflectionMapping;
  exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
  exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
  exports.RepeatWrapping = RepeatWrapping;
  exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
  exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
  exports.NearestFilter = NearestFilter;
  exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
  exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
  exports.LinearFilter = LinearFilter;
  exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
  exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
  exports.UnsignedByteType = UnsignedByteType;
  exports.ByteType = ByteType;
  exports.ShortType = ShortType;
  exports.UnsignedShortType = UnsignedShortType;
  exports.IntType = IntType;
  exports.UnsignedIntType = UnsignedIntType;
  exports.FloatType = FloatType;
  exports.HalfFloatType = HalfFloatType;
  exports.UnsignedShort4444Type = UnsignedShort4444Type;
  exports.UnsignedShort5551Type = UnsignedShort5551Type;
  exports.UnsignedShort565Type = UnsignedShort565Type;
  exports.UnsignedInt248Type = UnsignedInt248Type;
  exports.AlphaFormat = AlphaFormat;
  exports.RGBFormat = RGBFormat;
  exports.RGBAFormat = RGBAFormat;
  exports.LuminanceFormat = LuminanceFormat;
  exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
  exports.RGBEFormat = RGBEFormat;
  exports.DepthFormat = DepthFormat;
  exports.DepthStencilFormat = DepthStencilFormat;
  exports.RedFormat = RedFormat;
  exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
  exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
  exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
  exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
  exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
  exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
  exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
  exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
  exports.RGB_ETC1_Format = RGB_ETC1_Format;
  exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
  exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
  exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
  exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
  exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
  exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
  exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
  exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
  exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
  exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
  exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
  exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
  exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
  exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
  exports.LoopOnce = LoopOnce;
  exports.LoopRepeat = LoopRepeat;
  exports.LoopPingPong = LoopPingPong;
  exports.InterpolateDiscrete = InterpolateDiscrete;
  exports.InterpolateLinear = InterpolateLinear;
  exports.InterpolateSmooth = InterpolateSmooth;
  exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
  exports.ZeroSlopeEnding = ZeroSlopeEnding;
  exports.WrapAroundEnding = WrapAroundEnding;
  exports.TrianglesDrawMode = TrianglesDrawMode;
  exports.TriangleStripDrawMode = TriangleStripDrawMode;
  exports.TriangleFanDrawMode = TriangleFanDrawMode;
  exports.LinearEncoding = LinearEncoding;
  exports.sRGBEncoding = sRGBEncoding;
  exports.GammaEncoding = GammaEncoding;
  exports.RGBEEncoding = RGBEEncoding;
  exports.LogLuvEncoding = LogLuvEncoding;
  exports.RGBM7Encoding = RGBM7Encoding;
  exports.RGBM16Encoding = RGBM16Encoding;
  exports.RGBDEncoding = RGBDEncoding;
  exports.BasicDepthPacking = BasicDepthPacking;
  exports.RGBADepthPacking = RGBADepthPacking;
  exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
  exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
  exports.Float64BufferAttribute = Float64BufferAttribute;
  exports.Float32BufferAttribute = Float32BufferAttribute;
  exports.Uint32BufferAttribute = Uint32BufferAttribute;
  exports.Int32BufferAttribute = Int32BufferAttribute;
  exports.Uint16BufferAttribute = Uint16BufferAttribute;
  exports.Int16BufferAttribute = Int16BufferAttribute;
  exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
  exports.Uint8BufferAttribute = Uint8BufferAttribute;
  exports.Int8BufferAttribute = Int8BufferAttribute;
  exports.BufferAttribute = BufferAttribute;
  exports.BufferGeometry = BufferGeometry;
  exports.Clock = Clock;
  exports.DirectGeometry = DirectGeometry;
  exports.EventDispatcher = EventDispatcher;
  exports.Face3 = Face3;
  exports.Geometry = Geometry;
  exports.InstancedBufferAttribute = InstancedBufferAttribute;
  exports.InstancedBufferGeometry = InstancedBufferGeometry;
  exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
  exports.InterleavedBuffer = InterleavedBuffer;
  exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
  exports.Layers = Layers;
  exports.Object3D = Object3D;
  exports.Raycaster = Raycaster;
  exports.Uniform = Uniform;
  exports.Curve = Curve;
  exports.CurvePath = CurvePath;
  exports.Font = Font;
  exports.CatmullRom = CatmullRom;
  exports.QuadraticBezier = QuadraticBezier;
  exports.CubicBezier = CubicBezier;
  exports.Path = Path;
  exports.Shape = Shape;
  exports.ShapePath = ShapePath;
  exports.ArcCurve = ArcCurve;
  exports.CatmullRomCurve3 = CatmullRomCurve3;
  exports.CubicBezierCurve = CubicBezierCurve;
  exports.CubicBezierCurve3 = CubicBezierCurve3;
  exports.EllipseCurve = EllipseCurve;
  exports.LineCurve = LineCurve;
  exports.LineCurve3 = LineCurve3;
  exports.QuadraticBezierCurve = QuadraticBezierCurve;
  exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
  exports.SplineCurve = SplineCurve;
  exports.Earcut = Earcut;
  exports.ImageUtils = ImageUtils;
  exports.ImmediateRenderObject = ImmediateRenderObject;
  exports.ShapeUtils = ShapeUtils;
  exports.BoxGeometry = BoxGeometry;
  exports.BoxBufferGeometry = BoxBufferGeometry;
  exports.CircleGeometry = CircleGeometry;
  exports.CircleBufferGeometry = CircleBufferGeometry;
  exports.ConeGeometry = ConeGeometry;
  exports.ConeBufferGeometry = ConeBufferGeometry;
  exports.CylinderGeometry = CylinderGeometry;
  exports.CylinderBufferGeometry = CylinderBufferGeometry;
  exports.DodecahedronGeometry = DodecahedronGeometry;
  exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
  exports.EdgesGeometry = EdgesGeometry;
  exports.ExtrudeGeometry = ExtrudeGeometry;
  exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
  exports.IcosahedronGeometry = IcosahedronGeometry;
  exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
  exports.LatheGeometry = LatheGeometry;
  exports.LatheBufferGeometry = LatheBufferGeometry;
  exports.OctahedronGeometry = OctahedronGeometry;
  exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
  exports.ParametricGeometry = ParametricGeometry;
  exports.ParametricBufferGeometry = ParametricBufferGeometry;
  exports.PlaneGeometry = PlaneGeometry;
  exports.PlaneBufferGeometry = PlaneBufferGeometry;
  exports.PolyhedronGeometry = PolyhedronGeometry;
  exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
  exports.RingGeometry = RingGeometry;
  exports.RingBufferGeometry = RingBufferGeometry;
  exports.ShapeGeometry = ShapeGeometry;
  exports.ShapeBufferGeometry = ShapeBufferGeometry;
  exports.SphereGeometry = SphereGeometry;
  exports.SphereBufferGeometry = SphereBufferGeometry;
  exports.TetrahedronGeometry = TetrahedronGeometry;
  exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
  exports.TextGeometry = TextGeometry;
  exports.TextBufferGeometry = TextBufferGeometry;
  exports.TorusGeometry = TorusGeometry;
  exports.TorusBufferGeometry = TorusBufferGeometry;
  exports.TorusKnotGeometry = TorusKnotGeometry;
  exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
  exports.TubeGeometry = TubeGeometry;
  exports.TubeBufferGeometry = TubeBufferGeometry;
  exports.WireframeGeometry = WireframeGeometry;
  exports.ArrowHelper = ArrowHelper;
  exports.AxesHelper = AxesHelper;
  exports.Box3Helper = Box3Helper;
  exports.BoxHelper = BoxHelper;
  exports.CameraHelper = CameraHelper;
  exports.DirectionalLightHelper = DirectionalLightHelper;
  exports.FaceNormalsHelper = FaceNormalsHelper;
  exports.GridHelper = GridHelper;
  exports.HemisphereLightHelper = HemisphereLightHelper;
  exports.PlaneHelper = PlaneHelper;
  exports.PointLightHelper = PointLightHelper;
  exports.PolarGridHelper = PolarGridHelper;
  exports.PositionalAudioHelper = PositionalAudioHelper;
  exports.RectAreaLightHelper = RectAreaLightHelper;
  exports.SkeletonHelper = SkeletonHelper;
  exports.SpotLightHelper = SpotLightHelper;
  exports.VertexNormalsHelper = VertexNormalsHelper;
  exports.AmbientLight = AmbientLight;
  exports.DirectionalLight = DirectionalLight;
  exports.DirectionalLightShadow = DirectionalLightShadow;
  exports.HemisphereLight = HemisphereLight;
  exports.Light = Light;
  exports.LightShadow = LightShadow;
  exports.PointLight = PointLight;
  exports.RectAreaLight = RectAreaLight;
  exports.SpotLight = SpotLight;
  exports.SpotLightShadow = SpotLightShadow;
  exports.AnimationLoader = AnimationLoader;
  exports.AudioLoader = AudioLoader;
  exports.BufferGeometryLoader = BufferGeometryLoader;
  exports.Cache = Cache;
  exports.CompressedTextureLoader = CompressedTextureLoader;
  exports.CubeTextureLoader = CubeTextureLoader;
  exports.DataTextureLoader = DataTextureLoader;
  exports.FileLoader = FileLoader;
  exports.FontLoader = FontLoader;
  exports.ImageBitmapLoader = ImageBitmapLoader;
  exports.ImageLoader = ImageLoader;
  exports.Loader = Loader$1;
  exports.LoaderUtils = LoaderUtils;
  exports.DefaultLoadingManager = DefaultLoadingManager;
  exports.LoadingManager = LoadingManager;
  exports.MaterialLoader = MaterialLoader;
  exports.ObjectLoader = ObjectLoader;
  exports.TextureLoader = TextureLoader;
  exports.LineBasicMaterial = LineBasicMaterial;
  exports.LineDashedMaterial = LineDashedMaterial;
  exports.Material = Material$1;
  exports.MeshBasicMaterial = MeshBasicMaterial;
  exports.MeshDepthMaterial = MeshDepthMaterial;
  exports.MeshDistanceMaterial = MeshDistanceMaterial;
  exports.MeshLambertMaterial = MeshLambertMaterial;
  exports.MeshMatcapMaterial = MeshMatcapMaterial;
  exports.MeshNormalMaterial = MeshNormalMaterial;
  exports.MeshPhongMaterial = MeshPhongMaterial;
  exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
  exports.MeshStandardMaterial = MeshStandardMaterial;
  exports.MeshToonMaterial = MeshToonMaterial;
  exports.PointsMaterial = PointsMaterial;
  exports.RawShaderMaterial = RawShaderMaterial;
  exports.ShaderMaterial = ShaderMaterial;
  exports.ShadowMaterial = ShadowMaterial;
  exports.SpriteMaterial = SpriteMaterial;
  exports.Box2 = Box2;
  exports.Box3 = Box3;
  exports.Color = Color;
  exports.Cylindrical = Cylindrical;
  exports.Euler = Euler;
  exports.Frustum = Frustum;
  exports.Interpolant = Interpolant;
  exports.CubicInterpolant = CubicInterpolant;
  exports.DiscreteInterpolant = DiscreteInterpolant;
  exports.LinearInterpolant = LinearInterpolant;
  exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
  exports.Line3 = Line3;
  exports._Math = _Math;
  exports.Matrix3 = Matrix3;
  exports.Matrix4 = Matrix4;
  exports.Plane = Plane;
  exports.Quaternion = Quaternion;
  exports.Ray = Ray;
  exports.Sphere = Sphere;
  exports.Spherical = Spherical;
  exports.Triangle = Triangle;
  exports.Vector2 = Vector2;
  exports.Vector3 = Vector3;
  exports.Vector4 = Vector4;
  exports.Bone = Bone;
  exports.Group = Group;
  exports.Line = Line;
  exports.LineLoop = LineLoop;
  exports.LineSegments = LineSegments;
  exports.LOD = LOD;
  exports.Mesh = Mesh;
  exports.Points = Points;
  exports.Skeleton = Skeleton;
  exports.SkinnedMesh = SkinnedMesh;
  exports.Sprite = Sprite;
  exports.ShaderChunk = ShaderChunk;
  exports.ShaderLib = ShaderLib;
  exports.UniformsLib = UniformsLib;
  exports.UniformsUtils = UniformsUtils;
  exports.WebGLAnimation = WebGLAnimation;
  exports.WebGLAttributes = WebGLAttributes;
  exports.WebGLBackground = WebGLBackground;
  exports.WebGLBufferRenderer = WebGLBufferRenderer;
  exports.WebGLCapabilities = WebGLCapabilities;
  exports.WebGLClipping = WebGLClipping;
  exports.WebGLExtensions = WebGLExtensions;
  exports.WebGLGeometries = WebGLGeometries;
  exports.WebGLIndexedBufferRenderer = WebGLIndexedBufferRenderer;
  exports.WebGLInfo = WebGLInfo;
  exports.WebGLLights = WebGLLights;
  exports.WebGLMorphtargets = WebGLMorphtargets;
  exports.WebGLObjects = WebGLObjects;
  exports.WebGLProgram = WebGLProgram;
  exports.WebGLPrograms = WebGLPrograms;
  exports.WebGLProperties = WebGLProperties;
  exports.WebGLRenderLists = WebGLRenderLists;
  exports.WebGLRenderStates = WebGLRenderStates;
  exports.WebGLShader = WebGLShader;
  exports.WebGLShadowMap = WebGLShadowMap;
  exports.WebGLState = WebGLState;
  exports.WebGLTextures = WebGLTextures;
  exports.WebGLUniforms = WebGLUniforms;
  exports.WebGLUtils = WebGLUtils;
  exports.WebGL2Renderer = WebGL2Renderer;
  exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
  exports.WebGLRenderer = WebGLRenderer;
  exports.WebGLRenderTarget = WebGLRenderTarget;
  exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
  exports.WebVRManager = WebVRManager;
  exports.setProjectionFromUnion = setProjectionFromUnion;
  exports.WebXRManager = WebXRManager;
  exports.Fog = Fog;
  exports.FogExp2 = FogExp2;
  exports.Scene = Scene;
  exports.CanvasTexture = CanvasTexture;
  exports.CompressedTexture = CompressedTexture;
  exports.CubeTexture = CubeTexture;
  exports.DataTexture = DataTexture;
  exports.DataTexture3D = DataTexture3D;
  exports.DepthTexture = DepthTexture;
  exports.Texture = Texture;
  exports.VideoTexture = VideoTexture;
  exports.arrayMin = arrayMin;
  exports.arrayMax = arrayMax;

  return exports;

}({}));
